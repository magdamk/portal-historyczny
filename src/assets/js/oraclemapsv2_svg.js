/*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */
!function (e, t) {
	"use strict";
	"object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function (e) {
		if (!e.document)
			throw new Error("jQuery requires a window with a document");
		return t(e)
	}
	 : t(e)
}
("undefined" != typeof window ? window : this, function (C, e) {
	"use strict";
	var t = [],
	r = Object.getPrototypeOf,
	s = t.slice,
	g = t.flat ? function (e) {
		return t.flat.call(e)
	}
	 : function (e) {
		return t.concat.apply([], e)
	},
	u = t.push,
	i = t.indexOf,
	n = {},
	o = n.toString,
	v = n.hasOwnProperty,
	a = v.toString,
	l = a.call(Object),
	y = {},
	m = function (e) {
		return "function" == typeof e && "number" != typeof e.nodeType && "function" != typeof e.item
	},
	x = function (e) {
		return null != e && e === e.window
	},
	E = C.document,
	c = {
		type: !0,
		src: !0,
		nonce: !0,
		noModule: !0
	};
	function b(e, t, n) {
		var r,
		i,
		o = (n = n || E).createElement("script");
		if (o.text = e, t)
			for (r in c)
				(i = t[r] || t.getAttribute && t.getAttribute(r)) && o.setAttribute(r, i);
		n.head.appendChild(o).parentNode.removeChild(o)
	}
	function w(e) {
		return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? n[o.call(e)] || "object" : typeof e
	}
	var f = "3.6.0",
	S = function (e, t) {
		return new S.fn.init(e, t)
	};
	function p(e) {
		var t = !!e && "length" in e && e.length,
		n = w(e);
		return !m(e) && !x(e) && ("array" === n || 0 === t || "number" == typeof t && 0 < t && t - 1 in e)
	}
	S.fn = S.prototype = {
		jquery: f,
		constructor: S,
		length: 0,
		toArray: function () {
			return s.call(this)
		},
		get: function (e) {
			return null == e ? s.call(this) : e < 0 ? this[e + this.length] : this[e]
		},
		pushStack: function (e) {
			var t = S.merge(this.constructor(), e);
			return t.prevObject = this,
			t
		},
		each: function (e) {
			return S.each(this, e)
		},
		map: function (n) {
			return this.pushStack(S.map(this, function (e, t) {
					return n.call(e, t, e)
				}))
		},
		slice: function () {
			return this.pushStack(s.apply(this, arguments))
		},
		first: function () {
			return this.eq(0)
		},
		last: function () {
			return this.eq(-1)
		},
		even: function () {
			return this.pushStack(S.grep(this, function (e, t) {
					return (t + 1) % 2
				}))
		},
		odd: function () {
			return this.pushStack(S.grep(this, function (e, t) {
					return t % 2
				}))
		},
		eq: function (e) {
			var t = this.length,
			n = +e + (e < 0 ? t : 0);
			return this.pushStack(0 <= n && n < t ? [this[n]] : [])
		},
		end: function () {
			return this.prevObject || this.constructor()
		},
		push: u,
		sort: t.sort,
		splice: t.splice
	},
	S.extend = S.fn.extend = function () {
		var e,
		t,
		n,
		r,
		i,
		o,
		a = arguments[0] || {},
		s = 1,
		u = arguments.length,
		l = !1;
		for ("boolean" == typeof a && (l = a, a = arguments[s] || {}, s++), "object" == typeof a || m(a) || (a = {}), s === u && (a = this, s--); s < u; s++)
			if (null != (e = arguments[s]))
				for (t in e)
					r = e[t], "__proto__" !== t && a !== r && (l && r && (S.isPlainObject(r) || (i = Array.isArray(r))) ? (n = a[t], o = i && !Array.isArray(n) ? [] : i || S.isPlainObject(n) ? n : {}, i = !1, a[t] = S.extend(l, o, r)) : void 0 !== r && (a[t] = r));
		return a
	},
	S.extend({
		expando: "jQuery" + (f + Math.random()).replace(/\D/g, ""),
		isReady: !0,
		error: function (e) {
			throw new Error(e)
		},
		noop: function () {},
		isPlainObject: function (e) {
			var t,
			n;
			return !(!e || "[object Object]" !== o.call(e)) && (!(t = r(e)) || "function" == typeof(n = v.call(t, "constructor") && t.constructor) && a.call(n) === l)
		},
		isEmptyObject: function (e) {
			var t;
			for (t in e)
				return !1;
			return !0
		},
		globalEval: function (e, t, n) {
			b(e, {
				nonce: t && t.nonce
			}, n)
		},
		each: function (e, t) {
			var n,
			r = 0;
			if (p(e)) {
				for (n = e.length; r < n; r++)
					if (!1 === t.call(e[r], r, e[r]))
						break
			} else
				for (r in e)
					if (!1 === t.call(e[r], r, e[r]))
						break;
			return e
		},
		makeArray: function (e, t) {
			var n = t || [];
			return null != e && (p(Object(e)) ? S.merge(n, "string" == typeof e ? [e] : e) : u.call(n, e)),
			n
		},
		inArray: function (e, t, n) {
			return null == t ? -1 : i.call(t, e, n)
		},
		merge: function (e, t) {
			for (var n = +t.length, r = 0, i = e.length; r < n; r++)
				e[i++] = t[r];
			return e.length = i,
			e
		},
		grep: function (e, t, n) {
			for (var r = [], i = 0, o = e.length, a = !n; i < o; i++)
				!t(e[i], i) !== a && r.push(e[i]);
			return r
		},
		map: function (e, t, n) {
			var r,
			i,
			o = 0,
			a = [];
			if (p(e))
				for (r = e.length; o < r; o++)
					null != (i = t(e[o], o, n)) && a.push(i);
			else
				for (o in e)
					null != (i = t(e[o], o, n)) && a.push(i);
			return g(a)
		},
		guid: 1,
		support: y
	}),
	"function" == typeof Symbol && (S.fn[Symbol.iterator] = t[Symbol.iterator]),
	S.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (e, t) {
		n["[object " + t + "]"] = t.toLowerCase()
	});
	var d = function (n) {
		var e,
		d,
		b,
		o,
		i,
		h,
		f,
		g,
		w,
		u,
		l,
		T,
		C,
		a,
		E,
		v,
		s,
		c,
		y,
		S = "sizzle" + 1 * new Date,
		p = n.document,
		k = 0,
		r = 0,
		m = ue(),
		x = ue(),
		A = ue(),
		N = ue(),
		j = function (e, t) {
			return e === t && (l = !0),
			0
		},
		D = {}
		.hasOwnProperty,
		t = [],
		q = t.pop,
		L = t.push,
		H = t.push,
		O = t.slice,
		P = function (e, t) {
			for (var n = 0, r = e.length; n < r; n++)
				if (e[n] === t)
					return n;
			return -1
		},
		R = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
		M = "[\\x20\\t\\r\\n\\f]",
		I = "(?:\\\\[\\da-fA-F]{1,6}" + M + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
		W = "\\[" + M + "*(" + I + ")(?:" + M + "*([*^$|!~]?=)" + M + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + I + "))|)" + M + "*\\]",
		F = ":(" + I + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + W + ")*)|.*)\\)|)",
		B = new RegExp(M + "+", "g"),
		$ = new RegExp("^" + M + "+|((?:^|[^\\\\])(?:\\\\.)*)" + M + "+$", "g"),
		_ = new RegExp("^" + M + "*," + M + "*"),
		z = new RegExp("^" + M + "*([>+~]|" + M + ")" + M + "*"),
		U = new RegExp(M + "|>"),
		X = new RegExp(F),
		V = new RegExp("^" + I + "$"),
		G = {
			ID: new RegExp("^#(" + I + ")"),
			CLASS: new RegExp("^\\.(" + I + ")"),
			TAG: new RegExp("^(" + I + "|[*])"),
			ATTR: new RegExp("^" + W),
			PSEUDO: new RegExp("^" + F),
			CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + M + "*(even|odd|(([+-]|)(\\d*)n|)" + M + "*(?:([+-]|)" + M + "*(\\d+)|))" + M + "*\\)|)", "i"),
			bool: new RegExp("^(?:" + R + ")$", "i"),
			needsContext: new RegExp("^" + M + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + M + "*((?:-\\d)?\\d*)" + M + "*\\)|)(?=[^-]|$)", "i")
		},
		Y = /HTML$/i,
		Q = /^(?:input|select|textarea|button)$/i,
		J = /^h\d$/i,
		K = /^[^{]+\{\s*\[native \w/,
		Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
		ee = /[+~]/,
		te = new RegExp("\\\\[\\da-fA-F]{1,6}" + M + "?|\\\\([^\\r\\n\\f])", "g"),
		ne = function (e, t) {
			var n = "0x" + e.slice(1) - 65536;
			return t || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320))
		},
		re = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
		ie = function (e, t) {
			return t ? "\0" === e ? "\ufffd" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e
		},
		oe = function () {
			T()
		},
		ae = be(function (e) {
			return !0 === e.disabled && "fieldset" === e.nodeName.toLowerCase()
		}, {
			dir: "parentNode",
			next: "legend"
		});
		try {
			H.apply(t = O.call(p.childNodes), p.childNodes),
			t[p.childNodes.length].nodeType
		} catch (e) {
			H = {
				apply: t.length ? function (e, t) {
					L.apply(e, O.call(t))
				}
				 : function (e, t) {
					var n = e.length,
					r = 0;
					while (e[n++] = t[r++]);
					e.length = n - 1
				}
			}
		}
		function se(t, e, n, r) {
			var i,
			o,
			a,
			s,
			u,
			l,
			c,
			f = e && e.ownerDocument,
			p = e ? e.nodeType : 9;
			if (n = n || [], "string" != typeof t || !t || 1 !== p && 9 !== p && 11 !== p)
				return n;
			if (!r && (T(e), e = e || C, E)) {
				if (11 !== p && (u = Z.exec(t)))
					if (i = u[1]) {
						if (9 === p) {
							if (!(a = e.getElementById(i)))
								return n;
							if (a.id === i)
								return n.push(a), n
						} else if (f && (a = f.getElementById(i)) && y(e, a) && a.id === i)
							return n.push(a), n
					} else {
						if (u[2])
							return H.apply(n, e.getElementsByTagName(t)), n;
						if ((i = u[3]) && d.getElementsByClassName && e.getElementsByClassName)
							return H.apply(n, e.getElementsByClassName(i)), n
					}
				if (d.qsa && !N[t + " "] && (!v || !v.test(t)) && (1 !== p || "object" !== e.nodeName.toLowerCase())) {
					if (c = t, f = e, 1 === p && (U.test(t) || z.test(t))) {
						(f = ee.test(t) && ye(e.parentNode) || e) === e && d.scope || ((s = e.getAttribute("id")) ? s = s.replace(re, ie) : e.setAttribute("id", s = S)),
						o = (l = h(t)).length;
						while (o--)
							l[o] = (s ? "#" + s : ":scope") + " " + xe(l[o]);
						c = l.join(",")
					}
					try {
						return H.apply(n, f.querySelectorAll(c)),
						n
					} catch (e) {
						N(t, !0)
					} finally {
						s === S && e.removeAttribute("id")
					}
				}
			}
			return g(t.replace($, "$1"), e, n, r)
		}
		function ue() {
			var r = [];
			return function e(t, n) {
				return r.push(t + " ") > b.cacheLength && delete e[r.shift()],
				e[t + " "] = n
			}
		}
		function le(e) {
			return e[S] = !0,
			e
		}
		function ce(e) {
			var t = C.createElement("fieldset");
			try {
				return !!e(t)
			} catch (e) {
				return !1
			} finally {
				t.parentNode && t.parentNode.removeChild(t),
				t = null
			}
		}
		function fe(e, t) {
			var n = e.split("|"),
			r = n.length;
			while (r--)
				b.attrHandle[n[r]] = t
		}
		function pe(e, t) {
			var n = t && e,
			r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex;
			if (r)
				return r;
			if (n)
				while (n = n.nextSibling)
					if (n === t)
						return -1;
			return e ? 1 : -1
		}
		function de(t) {
			return function (e) {
				return "input" === e.nodeName.toLowerCase() && e.type === t
			}
		}
		function he(n) {
			return function (e) {
				var t = e.nodeName.toLowerCase();
				return ("input" === t || "button" === t) && e.type === n
			}
		}
		function ge(t) {
			return function (e) {
				return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && ae(e) === t : e.disabled === t : "label" in e && e.disabled === t
			}
		}
		function ve(a) {
			return le(function (o) {
				return o = +o,
				le(function (e, t) {
					var n,
					r = a([], e.length, o),
					i = r.length;
					while (i--)
						e[n = r[i]] && (e[n] = !(t[n] = e[n]))
				})
			})
		}
		function ye(e) {
			return e && "undefined" != typeof e.getElementsByTagName && e
		}
		for (e in d = se.support = {}, i = se.isXML = function (e) {
			var t = e && e.namespaceURI,
			n = e && (e.ownerDocument || e).documentElement;
			return !Y.test(t || n && n.nodeName || "HTML")
		}, T = se.setDocument = function (e) {
			var t,
			n,
			r = e ? e.ownerDocument || e : p;
			return r != C && 9 === r.nodeType && r.documentElement && (a = (C = r).documentElement, E = !i(C), p != C && (n = C.defaultView) && n.top !== n && (n.addEventListener ? n.addEventListener("unload", oe, !1) : n.attachEvent && n.attachEvent("onunload", oe)), d.scope = ce(function (e) {
					return a.appendChild(e).appendChild(C.createElement("div")),
					"undefined" != typeof e.querySelectorAll && !e.querySelectorAll(":scope fieldset div").length
				}), d.attributes = ce(function (e) {
					return e.className = "i",
					!e.getAttribute("className")
				}), d.getElementsByTagName = ce(function (e) {
					return e.appendChild(C.createComment("")),
					!e.getElementsByTagName("*").length
				}), d.getElementsByClassName = K.test(C.getElementsByClassName), d.getById = ce(function (e) {
					return a.appendChild(e).id = S,
					!C.getElementsByName || !C.getElementsByName(S).length
				}), d.getById ? (b.filter.ID = function (e) {
					var t = e.replace(te, ne);
					return function (e) {
						return e.getAttribute("id") === t
					}
				}, b.find.ID = function (e, t) {
					if ("undefined" != typeof t.getElementById && E) {
						var n = t.getElementById(e);
						return n ? [n] : []
					}
				}) : (b.filter.ID = function (e) {
					var n = e.replace(te, ne);
					return function (e) {
						var t = "undefined" != typeof e.getAttributeNode && e.getAttributeNode("id");
						return t && t.value === n
					}
				}, b.find.ID = function (e, t) {
					if ("undefined" != typeof t.getElementById && E) {
						var n,
						r,
						i,
						o = t.getElementById(e);
						if (o) {
							if ((n = o.getAttributeNode("id")) && n.value === e)
								return [o];
							i = t.getElementsByName(e),
							r = 0;
							while (o = i[r++])
								if ((n = o.getAttributeNode("id")) && n.value === e)
									return [o]
						}
						return []
					}
				}), b.find.TAG = d.getElementsByTagName ? function (e, t) {
				return "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e) : d.qsa ? t.querySelectorAll(e) : void 0
			}
				 : function (e, t) {
				var n,
				r = [],
				i = 0,
				o = t.getElementsByTagName(e);
				if ("*" === e) {
					while (n = o[i++])
						1 === n.nodeType && r.push(n);
						return r
					}
					return o
				}, b.find.CLASS = d.getElementsByClassName && function (e, t) {
					if ("undefined" != typeof t.getElementsByClassName && E)
						return t.getElementsByClassName(e)
				}, s = [], v = [], (d.qsa = K.test(C.querySelectorAll)) && (ce(function (e) {
							var t;
							a.appendChild(e).innerHTML = "<a id='" + S + "'></a><select id='" + S + "-\r\\' msallowcapture=''><option selected=''></option></select>",
							e.querySelectorAll("[msallowcapture^='']").length && v.push("[*^$]=" + M + "*(?:''|\"\")"),
							e.querySelectorAll("[selected]").length || v.push("\\[" + M + "*(?:value|" + R + ")"),
							e.querySelectorAll("[id~=" + S + "-]").length || v.push("~="),
							(t = C.createElement("input")).setAttribute("name", ""),
							e.appendChild(t),
							e.querySelectorAll("[name='']").length || v.push("\\[" + M + "*name" + M + "*=" + M + "*(?:''|\"\")"),
							e.querySelectorAll(":checked").length || v.push(":checked"),
							e.querySelectorAll("a#" + S + "+*").length || v.push(".#.+[+~]"),
							e.querySelectorAll("\\\f"),
							v.push("[\\r\\n\\f]")
						}), ce(function (e) {
							e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
							var t = C.createElement("input");
							t.setAttribute("type", "hidden"),
							e.appendChild(t).setAttribute("name", "D"),
							e.querySelectorAll("[name=d]").length && v.push("name" + M + "*[*^$|!~]?="),
							2 !== e.querySelectorAll(":enabled").length && v.push(":enabled", ":disabled"),
							a.appendChild(e).disabled = !0,
							2 !== e.querySelectorAll(":disabled").length && v.push(":enabled", ":disabled"),
							e.querySelectorAll("*,:x"),
							v.push(",.*:")
						})), (d.matchesSelector = K.test(c = a.matches || a.webkitMatchesSelector || a.mozMatchesSelector || a.oMatchesSelector || a.msMatchesSelector)) && ce(function (e) {
						d.disconnectedMatch = c.call(e, "*"),
						c.call(e, "[s!='']:x"),
						s.push("!=", F)
					}), v = v.length && new RegExp(v.join("|")), s = s.length && new RegExp(s.join("|")), t = K.test(a.compareDocumentPosition), y = t || K.test(a.contains) ? function (e, t) {
					var n = 9 === e.nodeType ? e.documentElement : e,
					r = t && t.parentNode;
					return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)))
				}
					 : function (e, t) {
					if (t)
						while (t = t.parentNode)
							if (t === e)
								return !0;
					return !1
				}, j = t ? function (e, t) {
					if (e === t)
						return l = !0, 0;
					var n = !e.compareDocumentPosition - !t.compareDocumentPosition;
					return n || (1 & (n = (e.ownerDocument || e) == (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !d.sortDetached && t.compareDocumentPosition(e) === n ? e == C || e.ownerDocument == p && y(p, e) ? -1 : t == C || t.ownerDocument == p && y(p, t) ? 1 : u ? P(u, e) - P(u, t) : 0 : 4 & n ? -1 : 1)
				}
					 : function (e, t) {
					if (e === t)
						return l = !0, 0;
					var n,
					r = 0,
					i = e.parentNode,
					o = t.parentNode,
					a = [e],
					s = [t];
					if (!i || !o)
						return e == C ? -1 : t == C ? 1 : i ? -1 : o ? 1 : u ? P(u, e) - P(u, t) : 0;
					if (i === o)
						return pe(e, t);
					n = e;
					while (n = n.parentNode)
						a.unshift(n);
					n = t;
					while (n = n.parentNode)
						s.unshift(n);
					while (a[r] === s[r])
						r++;
					return r ? pe(a[r], s[r]) : a[r] == p ? -1 : s[r] == p ? 1 : 0
				}),
				C
			}, se.matches = function (e, t) {
				return se(e, null, null, t)
			}, se.matchesSelector = function (e, t) {
				if (T(e), d.matchesSelector && E && !N[t + " "] && (!s || !s.test(t)) && (!v || !v.test(t)))
					try {
						var n = c.call(e, t);
						if (n || d.disconnectedMatch || e.document && 11 !== e.document.nodeType)
							return n
					} catch (e) {
						N(t, !0)
					}
				return 0 < se(t, C, null, [e]).length
			}, se.contains = function (e, t) {
				return (e.ownerDocument || e) != C && T(e),
				y(e, t)
			}, se.attr = function (e, t) {
				(e.ownerDocument || e) != C && T(e);
				var n = b.attrHandle[t.toLowerCase()],
				r = n && D.call(b.attrHandle, t.toLowerCase()) ? n(e, t, !E) : void 0;
				return void 0 !== r ? r : d.attributes || !E ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ? r.value : null
			}, se.escape = function (e) {
				return (e + "").replace(re, ie)
			}, se.error = function (e) {
				throw new Error("Syntax error, unrecognized expression: " + e)
			}, se.uniqueSort = function (e) {
				var t,
				n = [],
				r = 0,
				i = 0;
				if (l = !d.detectDuplicates, u = !d.sortStable && e.slice(0), e.sort(j), l) {
					while (t = e[i++])
						t === e[i] && (r = n.push(i));
					while (r--)
						e.splice(n[r], 1)
				}
				return u = null,
				e
			}, o = se.getText = function (e) {
				var t,
				n = "",
				r = 0,
				i = e.nodeType;
				if (i) {
					if (1 === i || 9 === i || 11 === i) {
						if ("string" == typeof e.textContent)
							return e.textContent;
						for (e = e.firstChild; e; e = e.nextSibling)
							n += o(e)
					} else if (3 === i || 4 === i)
						return e.nodeValue
				} else
					while (t = e[r++])
						n += o(t);
				return n
			}, (b = se.selectors = {
						cacheLength: 50,
						createPseudo: le,
						match: G,
						attrHandle: {},
						find: {},
						relative: {
							">": {
								dir: "parentNode",
								first: !0
							},
							" ": {
								dir: "parentNode"
							},
							"+": {
								dir: "previousSibling",
								first: !0
							},
							"~": {
								dir: "previousSibling"
							}
						},
						preFilter: {
							ATTR: function (e) {
								return e[1] = e[1].replace(te, ne),
								e[3] = (e[3] || e[4] || e[5] || "").replace(te, ne),
								"~=" === e[2] && (e[3] = " " + e[3] + " "),
								e.slice(0, 4)
							},
							CHILD: function (e) {
								return e[1] = e[1].toLowerCase(),
								"nth" === e[1].slice(0, 3) ? (e[3] || se.error(e[0]), e[4] =  + (e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] =  + (e[7] + e[8] || "odd" === e[3])) : e[3] && se.error(e[0]),
								e
							},
							PSEUDO: function (e) {
								var t,
								n = !e[6] && e[2];
								return G.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && X.test(n) && (t = h(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3))
							}
						},
						filter: {
							TAG: function (e) {
								var t = e.replace(te, ne).toLowerCase();
								return "*" === e ? function () {
									return !0
								}
								 : function (e) {
									return e.nodeName && e.nodeName.toLowerCase() === t
								}
							},
							CLASS: function (e) {
								var t = m[e + " "];
								return t || (t = new RegExp("(^|" + M + ")" + e + "(" + M + "|$)")) && m(e, function (e) {
									return t.test("string" == typeof e.className && e.className || "undefined" != typeof e.getAttribute && e.getAttribute("class") || "")
								})
							},
							ATTR: function (n, r, i) {
								return function (e) {
									var t = se.attr(e, n);
									return null == t ? "!=" === r : !r || (t += "", "=" === r ? t === i : "!=" === r ? t !== i : "^=" === r ? i && 0 === t.indexOf(i) : "*=" === r ? i && -1 < t.indexOf(i) : "$=" === r ? i && t.slice(-i.length) === i : "~=" === r ? -1 < (" " + t.replace(B, " ") + " ").indexOf(i) : "|=" === r && (t === i || t.slice(0, i.length + 1) === i + "-"))
								}
							},
							CHILD: function (h, e, t, g, v) {
								var y = "nth" !== h.slice(0, 3),
								m = "last" !== h.slice(-4),
								x = "of-type" === e;
								return 1 === g && 0 === v ? function (e) {
									return !!e.parentNode
								}
								 : function (e, t, n) {
									var r,
									i,
									o,
									a,
									s,
									u,
									l = y !== m ? "nextSibling" : "previousSibling",
									c = e.parentNode,
									f = x && e.nodeName.toLowerCase(),
									p = !n && !x,
									d = !1;
									if (c) {
										if (y) {
											while (l) {
												a = e;
												while (a = a[l])
													if (x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType)
														return !1;
												u = l = "only" === h && !u && "nextSibling"
											}
											return !0
										}
										if (u = [m ? c.firstChild : c.lastChild], m && p) {
											d = (s = (r = (i = (o = (a = c)[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === k && r[1]) && r[2],
											a = s && c.childNodes[s];
											while (a = ++s && a && a[l] || (d = s = 0) || u.pop())
												if (1 === a.nodeType && ++d && a === e) {
													i[h] = [k, s, d];
													break
												}
										} else if (p && (d = s = (r = (i = (o = (a = e)[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] || [])[0] === k && r[1]), !1 === d)
											while (a = ++s && a && a[l] || (d = s = 0) || u.pop())
												if ((x ? a.nodeName.toLowerCase() === f : 1 === a.nodeType) && ++d && (p && ((i = (o = a[S] || (a[S] = {}))[a.uniqueID] || (o[a.uniqueID] = {}))[h] = [k, d]), a === e))
													break;
										return (d -= v) === g || d % g == 0 && 0 <= d / g
									}
								}
							},
							PSEUDO: function (e, o) {
								var t,
								a = b.pseudos[e] || b.setFilters[e.toLowerCase()] || se.error("unsupported pseudo: " + e);
								return a[S] ? a(o) : 1 < a.length ? (t = [e, e, "", o], b.setFilters.hasOwnProperty(e.toLowerCase()) ? le(function (e, t) {
										var n,
										r = a(e, o),
										i = r.length;
										while (i--)
											e[n = P(e, r[i])] = !(t[n] = r[i])
									}) : function (e) {
									return a(e, 0, t)
								}) : a
							}
						},
						pseudos: {
							not: le(function (e) {
								var r = [],
								i = [],
								s = f(e.replace($, "$1"));
								return s[S] ? le(function (e, t, n, r) {
									var i,
									o = s(e, null, r, []),
									a = e.length;
									while (a--)
										(i = o[a]) && (e[a] = !(t[a] = i))
								}) : function (e, t, n) {
									return r[0] = e,
									s(r, null, n, i),
									r[0] = null,
									!i.pop()
								}
							}),
							has: le(function (t) {
								return function (e) {
									return 0 < se(t, e).length
								}
							}),
							contains: le(function (t) {
								return t = t.replace(te, ne),
								function (e) {
									return -1 < (e.textContent || o(e)).indexOf(t)
								}
							}),
							lang: le(function (n) {
								return V.test(n || "") || se.error("unsupported lang: " + n),
								n = n.replace(te, ne).toLowerCase(),
								function (e) {
									var t;
									do {
										if (t = E ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang"))
											return (t = t.toLowerCase()) === n || 0 === t.indexOf(n + "-")
									} while ((e = e.parentNode) && 1 === e.nodeType);
									return !1
								}
							}),
							target: function (e) {
								var t = n.location && n.location.hash;
								return t && t.slice(1) === e.id
							},
							root: function (e) {
								return e === a
							},
							focus: function (e) {
								return e === C.activeElement && (!C.hasFocus || C.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)
							},
							enabled: ge(!1),
							disabled: ge(!0),
							checked: function (e) {
								var t = e.nodeName.toLowerCase();
								return "input" === t && !!e.checked || "option" === t && !!e.selected
							},
							selected: function (e) {
								return e.parentNode && e.parentNode.selectedIndex,
								!0 === e.selected
							},
							empty: function (e) {
								for (e = e.firstChild; e; e = e.nextSibling)
									if (e.nodeType < 6)
										return !1;
								return !0
							},
							parent: function (e) {
								return !b.pseudos.empty(e)
							},
							header: function (e) {
								return J.test(e.nodeName)
							},
							input: function (e) {
								return Q.test(e.nodeName)
							},
							button: function (e) {
								var t = e.nodeName.toLowerCase();
								return "input" === t && "button" === e.type || "button" === t
							},
							text: function (e) {
								var t;
								return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase())
							},
							first: ve(function () {
								return [0]
							}),
							last: ve(function (e, t) {
								return [t - 1]
							}),
							eq: ve(function (e, t, n) {
								return [n < 0 ? n + t : n]
							}),
							even: ve(function (e, t) {
								for (var n = 0; n < t; n += 2)
									e.push(n);
								return e
							}),
							odd: ve(function (e, t) {
								for (var n = 1; n < t; n += 2)
									e.push(n);
								return e
							}),
							lt: ve(function (e, t, n) {
								for (var r = n < 0 ? n + t : t < n ? t : n; 0 <= --r; )
									e.push(r);
								return e
							}),
							gt: ve(function (e, t, n) {
								for (var r = n < 0 ? n + t : n; ++r < t; )
									e.push(r);
								return e
							})
						}
					}).pseudos.nth = b.pseudos.eq, {
				radio: !0,
				checkbox: !0,
				file: !0,
				password: !0,
				image: !0
			})b.pseudos[e] = de(e);
		for (e in {
			submit: !0,
			reset: !0
		})
			b.pseudos[e] = he(e);
		function me() {}
		function xe(e) {
			for (var t = 0, n = e.length, r = ""; t < n; t++)
				r += e[t].value;
			return r
		}
		function be(s, e, t) {
			var u = e.dir,
			l = e.next,
			c = l || u,
			f = t && "parentNode" === c,
			p = r++;
			return e.first ? function (e, t, n) {
				while (e = e[u])
					if (1 === e.nodeType || f)
						return s(e, t, n);
				return !1
			}
			 : function (e, t, n) {
				var r,
				i,
				o,
				a = [k, p];
				if (n) {
					while (e = e[u])
						if ((1 === e.nodeType || f) && s(e, t, n))
							return !0
				} else
					while (e = e[u])
						if (1 === e.nodeType || f)
							if (i = (o = e[S] || (e[S] = {}))[e.uniqueID] || (o[e.uniqueID] = {}), l && l === e.nodeName.toLowerCase())
								e = e[u] || e;
							else {
								if ((r = i[c]) && r[0] === k && r[1] === p)
									return a[2] = r[2];
								if ((i[c] = a)[2] = s(e, t, n))
									return !0
							}
				return !1
			}
		}
		function we(i) {
			return 1 < i.length ? function (e, t, n) {
				var r = i.length;
				while (r--)
					if (!i[r](e, t, n))
						return !1;
				return !0
			}
			 : i[0]
		}
		function Te(e, t, n, r, i) {
			for (var o, a = [], s = 0, u = e.length, l = null != t; s < u; s++)
				(o = e[s]) && (n && !n(o, r, i) || (a.push(o), l && t.push(s)));
			return a
		}
		function Ce(d, h, g, v, y, e) {
			return v && !v[S] && (v = Ce(v)),
			y && !y[S] && (y = Ce(y, e)),
			le(function (e, t, n, r) {
				var i,
				o,
				a,
				s = [],
				u = [],
				l = t.length,
				c = e || function (e, t, n) {
					for (var r = 0, i = t.length; r < i; r++)
						se(e, t[r], n);
					return n
				}
				(h || "*", n.nodeType ? [n] : n, []),
				f = !d || !e && h ? c : Te(c, s, d, n, r),
				p = g ? y || (e ? d : l || v) ? [] : t : f;
				if (g && g(f, p, n, r), v) {
					i = Te(p, u),
					v(i, [], n, r),
					o = i.length;
					while (o--)
						(a = i[o]) && (p[u[o]] = !(f[u[o]] = a))
				}
				if (e) {
					if (y || d) {
						if (y) {
							i = [],
							o = p.length;
							while (o--)
								(a = p[o]) && i.push(f[o] = a);
							y(null, p = [], i, r)
						}
						o = p.length;
						while (o--)
							(a = p[o]) && -1 < (i = y ? P(e, a) : s[o]) && (e[i] = !(t[i] = a))
					}
				} else
					p = Te(p === t ? p.splice(l, p.length) : p), y ? y(null, t, p, r) : H.apply(t, p)
			})
		}
		function Ee(e) {
			for (var i, t, n, r = e.length, o = b.relative[e[0].type], a = o || b.relative[" "], s = o ? 1 : 0, u = be(function (e) {
					return e === i
				}, a, !0), l = be(function (e) {
					return -1 < P(i, e)
				}, a, !0), c = [function (e, t, n) {
						var r = !o && (n || t !== w) || ((i = t).nodeType ? u(e, t, n) : l(e, t, n));
						return i = null,
						r
					}
				]; s < r; s++)
				if (t = b.relative[e[s].type])
					c = [be(we(c), t)];
				else {
					if ((t = b.filter[e[s].type].apply(null, e[s].matches))[S]) {
						for (n = ++s; n < r; n++)
							if (b.relative[e[n].type])
								break;
						return Ce(1 < s && we(c), 1 < s && xe(e.slice(0, s - 1).concat({
									value: " " === e[s - 2].type ? "*" : ""
								})).replace($, "$1"), t, s < n && Ee(e.slice(s, n)), n < r && Ee(e = e.slice(n)), n < r && xe(e))
					}
					c.push(t)
				}
			return we(c)
		}
		return me.prototype = b.filters = b.pseudos,
		b.setFilters = new me,
		h = se.tokenize = function (e, t) {
			var n,
			r,
			i,
			o,
			a,
			s,
			u,
			l = x[e + " "];
			if (l)
				return t ? 0 : l.slice(0);
			a = e,
			s = [],
			u = b.preFilter;
			while (a) {
				for (o in n && !(r = _.exec(a)) || (r && (a = a.slice(r[0].length) || a), s.push(i = [])), n = !1, (r = z.exec(a)) && (n = r.shift(), i.push({
							value: n,
							type: r[0].replace($, " ")
						}), a = a.slice(n.length)), b.filter)
					!(r = G[o].exec(a)) || u[o] && !(r = u[o](r)) || (n = r.shift(), i.push({
							value: n,
							type: o,
							matches: r
						}), a = a.slice(n.length));
				if (!n)
					break
			}
			return t ? a.length : a ? se.error(e) : x(e, s).slice(0)
		},
		f = se.compile = function (e, t) {
			var n,
			v,
			y,
			m,
			x,
			r,
			i = [],
			o = [],
			a = A[e + " "];
			if (!a) {
				t || (t = h(e)),
				n = t.length;
				while (n--)
					(a = Ee(t[n]))[S] ? i.push(a) : o.push(a);
				(a = A(e, (v = o, m = 0 < (y = i).length, x = 0 < v.length, r = function (e, t, n, r, i) {
								var o,
								a,
								s,
								u = 0,
								l = "0",
								c = e && [],
								f = [],
								p = w,
								d = e || x && b.find.TAG("*", i),
								h = k += null == p ? 1 : Math.random() || .1,
								g = d.length;
								for (i && (w = t == C || t || i); l !== g && null != (o = d[l]); l++) {
									if (x && o) {
										a = 0,
										t || o.ownerDocument == C || (T(o), n = !E);
										while (s = v[a++])
											if (s(o, t || C, n)) {
												r.push(o);
												break
											}
										i && (k = h)
									}
									m && ((o = !s && o) && u--, e && c.push(o))
								}
								if (u += l, m && l !== u) {
									a = 0;
									while (s = y[a++])
										s(c, f, t, n);
									if (e) {
										if (0 < u)
											while (l--)
												c[l] || f[l] || (f[l] = q.call(r));
										f = Te(f)
									}
									H.apply(r, f),
									i && !e && 0 < f.length && 1 < u + y.length && se.uniqueSort(r)
								}
								return i && (k = h, w = p),
								c
							}, m ? le(r) : r))).selector = e
			}
			return a
		},
		g = se.select = function (e, t, n, r) {
			var i,
			o,
			a,
			s,
			u,
			l = "function" == typeof e && e,
			c = !r && h(e = l.selector || e);
			if (n = n || [], 1 === c.length) {
				if (2 < (o = c[0] = c[0].slice(0)).length && "ID" === (a = o[0]).type && 9 === t.nodeType && E && b.relative[o[1].type]) {
					if (!(t = (b.find.ID(a.matches[0].replace(te, ne), t) || [])[0]))
						return n;
					l && (t = t.parentNode),
					e = e.slice(o.shift().value.length)
				}
				i = G.needsContext.test(e) ? 0 : o.length;
				while (i--) {
					if (a = o[i], b.relative[s = a.type])
						break;
					if ((u = b.find[s]) && (r = u(a.matches[0].replace(te, ne), ee.test(o[0].type) && ye(t.parentNode) || t))) {
						if (o.splice(i, 1), !(e = r.length && xe(o)))
							return H.apply(n, r), n;
						break
					}
				}
			}
			return (l || f(e, c))(r, t, !E, n, !t || ee.test(e) && ye(t.parentNode) || t),
			n
		},
		d.sortStable = S.split("").sort(j).join("") === S,
		d.detectDuplicates = !!l,
		T(),
		d.sortDetached = ce(function (e) {
			return 1 & e.compareDocumentPosition(C.createElement("fieldset"))
		}),
		ce(function (e) {
			return e.innerHTML = "<a href='#'></a>",
			"#" === e.firstChild.getAttribute("href")
		}) || fe("type|href|height|width", function (e, t, n) {
			if (!n)
				return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2)
		}),
		d.attributes && ce(function (e) {
			return e.innerHTML = "<input/>",
			e.firstChild.setAttribute("value", ""),
			"" === e.firstChild.getAttribute("value")
		}) || fe("value", function (e, t, n) {
			if (!n && "input" === e.nodeName.toLowerCase())
				return e.defaultValue
		}),
		ce(function (e) {
			return null == e.getAttribute("disabled")
		}) || fe(R, function (e, t, n) {
			var r;
			if (!n)
				return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null
		}),
		se
	}
	(C);
	S.find = d,
	S.expr = d.selectors,
	S.expr[":"] = S.expr.pseudos,
	S.uniqueSort = S.unique = d.uniqueSort,
	S.text = d.getText,
	S.isXMLDoc = d.isXML,
	S.contains = d.contains,
	S.escapeSelector = d.escape;
	var h = function (e, t, n) {
		var r = [],
		i = void 0 !== n;
		while ((e = e[t]) && 9 !== e.nodeType)
			if (1 === e.nodeType) {
				if (i && S(e).is(n))
					break;
				r.push(e)
			}
		return r
	},
	T = function (e, t) {
		for (var n = []; e; e = e.nextSibling)
			1 === e.nodeType && e !== t && n.push(e);
		return n
	},
	k = S.expr.match.needsContext;
	function A(e, t) {
		return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
	}
	var N = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
	function j(e, n, r) {
		return m(n) ? S.grep(e, function (e, t) {
			return !!n.call(e, t, e) !== r
		}) : n.nodeType ? S.grep(e, function (e) {
			return e === n !== r
		}) : "string" != typeof n ? S.grep(e, function (e) {
			return -1 < i.call(n, e) !== r
		}) : S.filter(n, e, r)
	}
	S.filter = function (e, t, n) {
		var r = t[0];
		return n && (e = ":not(" + e + ")"),
		1 === t.length && 1 === r.nodeType ? S.find.matchesSelector(r, e) ? [r] : [] : S.find.matches(e, S.grep(t, function (e) {
				return 1 === e.nodeType
			}))
	},
	S.fn.extend({
		find: function (e) {
			var t,
			n,
			r = this.length,
			i = this;
			if ("string" != typeof e)
				return this.pushStack(S(e).filter(function () {
						for (t = 0; t < r; t++)
							if (S.contains(i[t], this))
								return !0
					}));
			for (n = this.pushStack([]), t = 0; t < r; t++)
				S.find(e, i[t], n);
			return 1 < r ? S.uniqueSort(n) : n
		},
		filter: function (e) {
			return this.pushStack(j(this, e || [], !1))
		},
		not: function (e) {
			return this.pushStack(j(this, e || [], !0))
		},
		is: function (e) {
			return !!j(this, "string" == typeof e && k.test(e) ? S(e) : e || [], !1).length
		}
	});
	var D,
	q = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
	(S.fn.init = function (e, t, n) {
		var r,
		i;
		if (!e)
			return this;
		if (n = n || D, "string" == typeof e) {
			if (!(r = "<" === e[0] && ">" === e[e.length - 1] && 3 <= e.length ? [null, e, null] : q.exec(e)) || !r[1] && t)
				return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e);
			if (r[1]) {
				if (t = t instanceof S ? t[0] : t, S.merge(this, S.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : E, !0)), N.test(r[1]) && S.isPlainObject(t))
					for (r in t)
						m(this[r]) ? this[r](t[r]) : this.attr(r, t[r]);
				return this
			}
			return (i = E.getElementById(r[2])) && (this[0] = i, this.length = 1),
			this
		}
		return e.nodeType ? (this[0] = e, this.length = 1, this) : m(e) ? void 0 !== n.ready ? n.ready(e) : e(S) : S.makeArray(e, this)
	}).prototype = S.fn,
	D = S(E);
	var L = /^(?:parents|prev(?:Until|All))/,
	H = {
		children: !0,
		contents: !0,
		next: !0,
		prev: !0
	};
	function O(e, t) {
		while ((e = e[t]) && 1 !== e.nodeType);
		return e
	}
	S.fn.extend({
		has: function (e) {
			var t = S(e, this),
			n = t.length;
			return this.filter(function () {
				for (var e = 0; e < n; e++)
					if (S.contains(this, t[e]))
						return !0
			})
		},
		closest: function (e, t) {
			var n,
			r = 0,
			i = this.length,
			o = [],
			a = "string" != typeof e && S(e);
			if (!k.test(e))
				for (; r < i; r++)
					for (n = this[r]; n && n !== t; n = n.parentNode)
						if (n.nodeType < 11 && (a ? -1 < a.index(n) : 1 === n.nodeType && S.find.matchesSelector(n, e))) {
							o.push(n);
							break
						}
			return this.pushStack(1 < o.length ? S.uniqueSort(o) : o)
		},
		index: function (e) {
			return e ? "string" == typeof e ? i.call(S(e), this[0]) : i.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
		},
		add: function (e, t) {
			return this.pushStack(S.uniqueSort(S.merge(this.get(), S(e, t))))
		},
		addBack: function (e) {
			return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
		}
	}),
	S.each({
		parent: function (e) {
			var t = e.parentNode;
			return t && 11 !== t.nodeType ? t : null
		},
		parents: function (e) {
			return h(e, "parentNode")
		},
		parentsUntil: function (e, t, n) {
			return h(e, "parentNode", n)
		},
		next: function (e) {
			return O(e, "nextSibling")
		},
		prev: function (e) {
			return O(e, "previousSibling")
		},
		nextAll: function (e) {
			return h(e, "nextSibling")
		},
		prevAll: function (e) {
			return h(e, "previousSibling")
		},
		nextUntil: function (e, t, n) {
			return h(e, "nextSibling", n)
		},
		prevUntil: function (e, t, n) {
			return h(e, "previousSibling", n)
		},
		siblings: function (e) {
			return T((e.parentNode || {}).firstChild, e)
		},
		children: function (e) {
			return T(e.firstChild)
		},
		contents: function (e) {
			return null != e.contentDocument && r(e.contentDocument) ? e.contentDocument : (A(e, "template") && (e = e.content || e), S.merge([], e.childNodes))
		}
	}, function (r, i) {
		S.fn[r] = function (e, t) {
			var n = S.map(this, i, e);
			return "Until" !== r.slice(-5) && (t = e),
			t && "string" == typeof t && (n = S.filter(t, n)),
			1 < this.length && (H[r] || S.uniqueSort(n), L.test(r) && n.reverse()),
			this.pushStack(n)
		}
	});
	var P = /[^\x20\t\r\n\f]+/g;
	function R(e) {
		return e
	}
	function M(e) {
		throw e
	}
	function I(e, t, n, r) {
		var i;
		try {
			e && m(i = e.promise) ? i.call(e).done(t).fail(n) : e && m(i = e.then) ? i.call(e, t, n) : t.apply(void 0, [e].slice(r))
		} catch (e) {
			n.apply(void 0, [e])
		}
	}
	S.Callbacks = function (r) {
		var e,
		n;
		r = "string" == typeof r ? (e = r, n = {}, S.each(e.match(P) || [], function (e, t) {
					n[t] = !0
				}), n) : S.extend({}, r);
		var i,
		t,
		o,
		a,
		s = [],
		u = [],
		l = -1,
		c = function () {
			for (a = a || r.once, o = i = !0; u.length; l = -1) {
				t = u.shift();
				while (++l < s.length)
					!1 === s[l].apply(t[0], t[1]) && r.stopOnFalse && (l = s.length, t = !1)
			}
			r.memory || (t = !1),
			i = !1,
			a && (s = t ? [] : "")
		},
		f = {
			add: function () {
				return s && (t && !i && (l = s.length - 1, u.push(t)), function n(e) {
					S.each(e, function (e, t) {
						m(t) ? r.unique && f.has(t) || s.push(t) : t && t.length && "string" !== w(t) && n(t)
					})
				}
					(arguments), t && !i && c()),
				this
			},
			remove: function () {
				return S.each(arguments, function (e, t) {
					var n;
					while (-1 < (n = S.inArray(t, s, n)))
						s.splice(n, 1), n <= l && l--
				}),
				this
			},
			has: function (e) {
				return e ? -1 < S.inArray(e, s) : 0 < s.length
			},
			empty: function () {
				return s && (s = []),
				this
			},
			disable: function () {
				return a = u = [],
				s = t = "",
				this
			},
			disabled: function () {
				return !s
			},
			lock: function () {
				return a = u = [],
				t || i || (s = t = ""),
				this
			},
			locked: function () {
				return !!a
			},
			fireWith: function (e, t) {
				return a || (t = [e, (t = t || []).slice ? t.slice() : t], u.push(t), i || c()),
				this
			},
			fire: function () {
				return f.fireWith(this, arguments),
				this
			},
			fired: function () {
				return !!o
			}
		};
		return f
	},
	S.extend({
		Deferred: function (e) {
			var o = [["notify", "progress", S.Callbacks("memory"), S.Callbacks("memory"), 2], ["resolve", "done", S.Callbacks("once memory"), S.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", S.Callbacks("once memory"), S.Callbacks("once memory"), 1, "rejected"]],
			i = "pending",
			a = {
				state: function () {
					return i
				},
				always: function () {
					return s.done(arguments).fail(arguments),
					this
				},
				"catch": function (e) {
					return a.then(null, e)
				},
				pipe: function () {
					var i = arguments;
					return S.Deferred(function (r) {
						S.each(o, function (e, t) {
							var n = m(i[t[4]]) && i[t[4]];
							s[t[1]](function () {
								var e = n && n.apply(this, arguments);
								e && m(e.promise) ? e.promise().progress(r.notify).done(r.resolve).fail(r.reject) : r[t[0] + "With"](this, n ? [e] : arguments)
							})
						}),
						i = null
					}).promise()
				},
				then: function (t, n, r) {
					var u = 0;
					function l(i, o, a, s) {
						return function () {
							var n = this,
							r = arguments,
							e = function () {
								var e,
								t;
								if (!(i < u)) {
									if ((e = a.apply(n, r)) === o.promise())
										throw new TypeError("Thenable self-resolution");
									t = e && ("object" == typeof e || "function" == typeof e) && e.then,
									m(t) ? s ? t.call(e, l(u, o, R, s), l(u, o, M, s)) : (u++, t.call(e, l(u, o, R, s), l(u, o, M, s), l(u, o, R, o.notifyWith))) : (a !== R && (n = void 0, r = [e]), (s || o.resolveWith)(n, r))
								}
							},
							t = s ? e : function () {
								try {
									e()
								} catch (e) {
									S.Deferred.exceptionHook && S.Deferred.exceptionHook(e, t.stackTrace),
									u <= i + 1 && (a !== M && (n = void 0, r = [e]), o.rejectWith(n, r))
								}
							};
							i ? t() : (S.Deferred.getStackHook && (t.stackTrace = S.Deferred.getStackHook()), C.setTimeout(t))
						}
					}
					return S.Deferred(function (e) {
						o[0][3].add(l(0, e, m(r) ? r : R, e.notifyWith)),
						o[1][3].add(l(0, e, m(t) ? t : R)),
						o[2][3].add(l(0, e, m(n) ? n : M))
					}).promise()
				},
				promise: function (e) {
					return null != e ? S.extend(e, a) : a
				}
			},
			s = {};
			return S.each(o, function (e, t) {
				var n = t[2],
				r = t[5];
				a[t[1]] = n.add,
				r && n.add(function () {
					i = r
				}, o[3 - e][2].disable, o[3 - e][3].disable, o[0][2].lock, o[0][3].lock),
				n.add(t[3].fire),
				s[t[0]] = function () {
					return s[t[0] + "With"](this === s ? void 0 : this, arguments),
					this
				},
				s[t[0] + "With"] = n.fireWith
			}),
			a.promise(s),
			e && e.call(s, s),
			s
		},
		when: function (e) {
			var n = arguments.length,
			t = n,
			r = Array(t),
			i = s.call(arguments),
			o = S.Deferred(),
			a = function (t) {
				return function (e) {
					r[t] = this,
					i[t] = 1 < arguments.length ? s.call(arguments) : e,
					--n || o.resolveWith(r, i)
				}
			};
			if (n <= 1 && (I(e, o.done(a(t)).resolve, o.reject, !n), "pending" === o.state() || m(i[t] && i[t].then)))
				return o.then();
			while (t--)
				I(i[t], a(t), o.reject);
			return o.promise()
		}
	});
	var W = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
	S.Deferred.exceptionHook = function (e, t) {
		C.console && C.console.warn && e && W.test(e.name) && C.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t)
	},
	S.readyException = function (e) {
		C.setTimeout(function () {
			throw e
		})
	};
	var F = S.Deferred();
	function B() {
		E.removeEventListener("DOMContentLoaded", B),
		C.removeEventListener("load", B),
		S.ready()
	}
	S.fn.ready = function (e) {
		return F.then(e)["catch"](function (e) {
			S.readyException(e)
		}),
		this
	},
	S.extend({
		isReady: !1,
		readyWait: 1,
		ready: function (e) {
			(!0 === e ? --S.readyWait : S.isReady) || (S.isReady = !0) !== e && 0 < --S.readyWait || F.resolveWith(E, [S])
		}
	}),
	S.ready.then = F.then,
	"complete" === E.readyState || "loading" !== E.readyState && !E.documentElement.doScroll ? C.setTimeout(S.ready) : (E.addEventListener("DOMContentLoaded", B), C.addEventListener("load", B));
	var $ = function (e, t, n, r, i, o, a) {
		var s = 0,
		u = e.length,
		l = null == n;
		if ("object" === w(n))
			for (s in i = !0, n)
				$(e, t, s, n[s], !0, o, a);
		else if (void 0 !== r && (i = !0, m(r) || (a = !0), l && (a ? (t.call(e, r), t = null) : (l = t, t = function (e, t, n) {
						return l.call(S(e), n)
					})), t))
			for (; s < u; s++)
				t(e[s], n, a ? r : r.call(e[s], s, t(e[s], n)));
		return i ? e : l ? t.call(e) : u ? t(e[0], n) : o
	},
	_ = /^-ms-/,
	z = /-([a-z])/g;
	function U(e, t) {
		return t.toUpperCase()
	}
	function X(e) {
		return e.replace(_, "ms-").replace(z, U)
	}
	var V = function (e) {
		return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType
	};
	function G() {
		this.expando = S.expando + G.uid++
	}
	G.uid = 1,
	G.prototype = {
		cache: function (e) {
			var t = e[this.expando];
			return t || (t = {}, V(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, {
						value: t,
						configurable: !0
					}))),
			t
		},
		set: function (e, t, n) {
			var r,
			i = this.cache(e);
			if ("string" == typeof t)
				i[X(t)] = n;
			else
				for (r in t)
					i[X(r)] = t[r];
			return i
		},
		get: function (e, t) {
			return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][X(t)]
		},
		access: function (e, t, n) {
			return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t)
		},
		remove: function (e, t) {
			var n,
			r = e[this.expando];
			if (void 0 !== r) {
				if (void 0 !== t) {
					n = (t = Array.isArray(t) ? t.map(X) : (t = X(t))in r ? [t] : t.match(P) || []).length;
					while (n--)
						delete r[t[n]]
				}
				(void 0 === t || S.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando])
			}
		},
		hasData: function (e) {
			var t = e[this.expando];
			return void 0 !== t && !S.isEmptyObject(t)
		}
	};
	var Y = new G,
	Q = new G,
	J = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	K = /[A-Z]/g;
	function Z(e, t, n) {
		var r,
		i;
		if (void 0 === n && 1 === e.nodeType)
			if (r = "data-" + t.replace(K, "-$&").toLowerCase(), "string" == typeof(n = e.getAttribute(r))) {
				try {
					n = "true" === (i = n) || "false" !== i && ("null" === i ? null : i === +i + "" ? +i : J.test(i) ? JSON.parse(i) : i)
				} catch (e) {}
				Q.set(e, t, n)
			} else
				n = void 0;
		return n
	}
	S.extend({
		hasData: function (e) {
			return Q.hasData(e) || Y.hasData(e)
		},
		data: function (e, t, n) {
			return Q.access(e, t, n)
		},
		removeData: function (e, t) {
			Q.remove(e, t)
		},
		_data: function (e, t, n) {
			return Y.access(e, t, n)
		},
		_removeData: function (e, t) {
			Y.remove(e, t)
		}
	}),
	S.fn.extend({
		data: function (n, e) {
			var t,
			r,
			i,
			o = this[0],
			a = o && o.attributes;
			if (void 0 === n) {
				if (this.length && (i = Q.get(o), 1 === o.nodeType && !Y.get(o, "hasDataAttrs"))) {
					t = a.length;
					while (t--)
						a[t] && 0 === (r = a[t].name).indexOf("data-") && (r = X(r.slice(5)), Z(o, r, i[r]));
					Y.set(o, "hasDataAttrs", !0)
				}
				return i
			}
			return "object" == typeof n ? this.each(function () {
				Q.set(this, n)
			}) : $(this, function (e) {
				var t;
				if (o && void 0 === e)
					return void 0 !== (t = Q.get(o, n)) ? t : void 0 !== (t = Z(o, n)) ? t : void 0;
				this.each(function () {
					Q.set(this, n, e)
				})
			}, null, e, 1 < arguments.length, null, !0)
		},
		removeData: function (e) {
			return this.each(function () {
				Q.remove(this, e)
			})
		}
	}),
	S.extend({
		queue: function (e, t, n) {
			var r;
			if (e)
				return t = (t || "fx") + "queue", r = Y.get(e, t), n && (!r || Array.isArray(n) ? r = Y.access(e, t, S.makeArray(n)) : r.push(n)), r || []
		},
		dequeue: function (e, t) {
			t = t || "fx";
			var n = S.queue(e, t),
			r = n.length,
			i = n.shift(),
			o = S._queueHooks(e, t);
			"inprogress" === i && (i = n.shift(), r--),
			i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, function () {
					S.dequeue(e, t)
				}, o)),
			!r && o && o.empty.fire()
		},
		_queueHooks: function (e, t) {
			var n = t + "queueHooks";
			return Y.get(e, n) || Y.access(e, n, {
				empty: S.Callbacks("once memory").add(function () {
					Y.remove(e, [t + "queue", n])
				})
			})
		}
	}),
	S.fn.extend({
		queue: function (t, n) {
			var e = 2;
			return "string" != typeof t && (n = t, t = "fx", e--),
			arguments.length < e ? S.queue(this[0], t) : void 0 === n ? this : this.each(function () {
				var e = S.queue(this, t, n);
				S._queueHooks(this, t),
				"fx" === t && "inprogress" !== e[0] && S.dequeue(this, t)
			})
		},
		dequeue: function (e) {
			return this.each(function () {
				S.dequeue(this, e)
			})
		},
		clearQueue: function (e) {
			return this.queue(e || "fx", [])
		},
		promise: function (e, t) {
			var n,
			r = 1,
			i = S.Deferred(),
			o = this,
			a = this.length,
			s = function () {
				--r || i.resolveWith(o, [o])
			};
			"string" != typeof e && (t = e, e = void 0),
			e = e || "fx";
			while (a--)
				(n = Y.get(o[a], e + "queueHooks")) && n.empty && (r++, n.empty.add(s));
			return s(),
			i.promise(t)
		}
	});
	var ee = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
	te = new RegExp("^(?:([+-])=|)(" + ee + ")([a-z%]*)$", "i"),
	ne = ["Top", "Right", "Bottom", "Left"],
	re = E.documentElement,
	ie = function (e) {
		return S.contains(e.ownerDocument, e)
	},
	oe = {
		composed: !0
	};
	re.getRootNode && (ie = function (e) {
		return S.contains(e.ownerDocument, e) || e.getRootNode(oe) === e.ownerDocument
	});
	var ae = function (e, t) {
		return "none" === (e = t || e).style.display || "" === e.style.display && ie(e) && "none" === S.css(e, "display")
	};
	function se(e, t, n, r) {
		var i,
		o,
		a = 20,
		s = r ? function () {
			return r.cur()
		}
		 : function () {
			return S.css(e, t, "")
		},
		u = s(),
		l = n && n[3] || (S.cssNumber[t] ? "" : "px"),
		c = e.nodeType && (S.cssNumber[t] || "px" !== l && +u) && te.exec(S.css(e, t));
		if (c && c[3] !== l) {
			u /= 2,
			l = l || c[3],
			c = +u || 1;
			while (a--)
				S.style(e, t, c + l), (1 - o) * (1 - (o = s() / u || .5)) <= 0 && (a = 0), c /= o;
			c *= 2,
			S.style(e, t, c + l),
			n = n || []
		}
		return n && (c = +c || +u || 0, i = n[1] ? c + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, r.start = c, r.end = i)),
		i
	}
	var ue = {};
	function le(e, t) {
		for (var n, r, i, o, a, s, u, l = [], c = 0, f = e.length; c < f; c++)
			(r = e[c]).style && (n = r.style.display, t ? ("none" === n && (l[c] = Y.get(r, "display") || null, l[c] || (r.style.display = "")), "" === r.style.display && ae(r) && (l[c] = (u = a = o = void 0, a = (i = r).ownerDocument, s = i.nodeName, (u = ue[s]) || (o = a.body.appendChild(a.createElement(s)), u = S.css(o, "display"), o.parentNode.removeChild(o), "none" === u && (u = "block"), ue[s] = u)))) : "none" !== n && (l[c] = "none", Y.set(r, "display", n)));
		for (c = 0; c < f; c++)
			null != l[c] && (e[c].style.display = l[c]);
		return e
	}
	S.fn.extend({
		show: function () {
			return le(this, !0)
		},
		hide: function () {
			return le(this)
		},
		toggle: function (e) {
			return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function () {
				ae(this) ? S(this).show() : S(this).hide()
			})
		}
	});
	var ce,
	fe,
	pe = /^(?:checkbox|radio)$/i,
	de = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
	he = /^$|^module$|\/(?:java|ecma)script/i;
	ce = E.createDocumentFragment().appendChild(E.createElement("div")),
	(fe = E.createElement("input")).setAttribute("type", "radio"),
	fe.setAttribute("checked", "checked"),
	fe.setAttribute("name", "t"),
	ce.appendChild(fe),
	y.checkClone = ce.cloneNode(!0).cloneNode(!0).lastChild.checked,
	ce.innerHTML = "<textarea>x</textarea>",
	y.noCloneChecked = !!ce.cloneNode(!0).lastChild.defaultValue,
	ce.innerHTML = "<option></option>",
	y.option = !!ce.lastChild;
	var ge = {
		thead: [1, "<table>", "</table>"],
		col: [2, "<table><colgroup>", "</colgroup></table>"],
		tr: [2, "<table><tbody>", "</tbody></table>"],
		td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
		_default: [0, "", ""]
	};
	function ve(e, t) {
		var n;
		return n = "undefined" != typeof e.getElementsByTagName ? e.getElementsByTagName(t || "*") : "undefined" != typeof e.querySelectorAll ? e.querySelectorAll(t || "*") : [],
		void 0 === t || t && A(e, t) ? S.merge([e], n) : n
	}
	function ye(e, t) {
		for (var n = 0, r = e.length; n < r; n++)
			Y.set(e[n], "globalEval", !t || Y.get(t[n], "globalEval"))
	}
	ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead,
	ge.th = ge.td,
	y.option || (ge.optgroup = ge.option = [1, "<select multiple='multiple'>", "</select>"]);
	var me = /<|&#?\w+;/;
	function xe(e, t, n, r, i) {
		for (var o, a, s, u, l, c, f = t.createDocumentFragment(), p = [], d = 0, h = e.length; d < h; d++)
			if ((o = e[d]) || 0 === o)
				if ("object" === w(o))
					S.merge(p, o.nodeType ? [o] : o);
				else if (me.test(o)) {
					a = a || f.appendChild(t.createElement("div")),
					s = (de.exec(o) || ["", ""])[1].toLowerCase(),
					u = ge[s] || ge._default,
					a.innerHTML = u[1] + S.htmlPrefilter(o) + u[2],
					c = u[0];
					while (c--)
						a = a.lastChild;
					S.merge(p, a.childNodes),
					(a = f.firstChild).textContent = ""
				} else
					p.push(t.createTextNode(o));
		f.textContent = "",
		d = 0;
		while (o = p[d++])
			if (r && -1 < S.inArray(o, r))
				i && i.push(o);
			else if (l = ie(o), a = ve(f.appendChild(o), "script"), l && ye(a), n) {
				c = 0;
				while (o = a[c++])
					he.test(o.type || "") && n.push(o)
			}
		return f
	}
	var be = /^([^.]*)(?:\.(.+)|)/;
	function we() {
		return !0
	}
	function Te() {
		return !1
	}
	function Ce(e, t) {
		return e === function () {
			try {
				return E.activeElement
			} catch (e) {}
		}
		() == ("focus" === t)
	}
	function Ee(e, t, n, r, i, o) {
		var a,
		s;
		if ("object" == typeof t) {
			for (s in "string" != typeof n && (r = r || n, n = void 0), t)
				Ee(e, s, n, r, t[s], o);
			return e
		}
		if (null == r && null == i ? (i = n, r = n = void 0) : null == i && ("string" == typeof n ? (i = r, r = void 0) : (i = r, r = n, n = void 0)), !1 === i)
			i = Te;
		else if (!i)
			return e;
		return 1 === o && (a = i, (i = function (e) {
				return S().off(e),
				a.apply(this, arguments)
			}).guid = a.guid || (a.guid = S.guid++)),
		e.each(function () {
			S.event.add(this, t, i, r, n)
		})
	}
	function Se(e, i, o) {
		o ? (Y.set(e, i, !1), S.event.add(e, i, {
				namespace: !1,
				handler: function (e) {
					var t,
					n,
					r = Y.get(this, i);
					if (1 & e.isTrigger && this[i]) {
						if (r.length)
							(S.event.special[i] || {}).delegateType && e.stopPropagation();
						else if (r = s.call(arguments), Y.set(this, i, r), t = o(this, i), this[i](), r !== (n = Y.get(this, i)) || t ? Y.set(this, i, !1) : n = {}, r !== n)
							return e.stopImmediatePropagation(), e.preventDefault(), n && n.value
					} else
						r.length && (Y.set(this, i, {
								value: S.event.trigger(S.extend(r[0], S.Event.prototype), r.slice(1), this)
							}), e.stopImmediatePropagation())
				}
			})) : void 0 === Y.get(e, i) && S.event.add(e, i, we)
	}
	S.event = {
		global: {},
		add: function (t, e, n, r, i) {
			var o,
			a,
			s,
			u,
			l,
			c,
			f,
			p,
			d,
			h,
			g,
			v = Y.get(t);
			if (V(t)) {
				n.handler && (n = (o = n).handler, i = o.selector),
				i && S.find.matchesSelector(re, i),
				n.guid || (n.guid = S.guid++),
				(u = v.events) || (u = v.events = Object.create(null)),
				(a = v.handle) || (a = v.handle = function (e) {
					return "undefined" != typeof S && S.event.triggered !== e.type ? S.event.dispatch.apply(t, arguments) : void 0
				}),
				l = (e = (e || "").match(P) || [""]).length;
				while (l--)
					d = g = (s = be.exec(e[l]) || [])[1], h = (s[2] || "").split(".").sort(), d && (f = S.event.special[d] || {}, d = (i ? f.delegateType : f.bindType) || d, f = S.event.special[d] || {}, c = S.extend({
							type: d,
							origType: g,
							data: r,
							handler: n,
							guid: n.guid,
							selector: i,
							needsContext: i && S.expr.match.needsContext.test(i),
							namespace: h.join(".")
						}, o), (p = u[d]) || ((p = u[d] = []).delegateCount = 0, f.setup && !1 !== f.setup.call(t, r, h, a) || t.addEventListener && t.addEventListener(d, a)), f.add && (f.add.call(t, c), c.handler.guid || (c.handler.guid = n.guid)), i ? p.splice(p.delegateCount++, 0, c) : p.push(c), S.event.global[d] = !0)
			}
		},
		remove: function (e, t, n, r, i) {
			var o,
			a,
			s,
			u,
			l,
			c,
			f,
			p,
			d,
			h,
			g,
			v = Y.hasData(e) && Y.get(e);
			if (v && (u = v.events)) {
				l = (t = (t || "").match(P) || [""]).length;
				while (l--)
					if (d = g = (s = be.exec(t[l]) || [])[1], h = (s[2] || "").split(".").sort(), d) {
						f = S.event.special[d] || {},
						p = u[d = (r ? f.delegateType : f.bindType) || d] || [],
						s = s[2] && new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"),
						a = o = p.length;
						while (o--)
							c = p[o], !i && g !== c.origType || n && n.guid !== c.guid || s && !s.test(c.namespace) || r && r !== c.selector && ("**" !== r || !c.selector) || (p.splice(o, 1), c.selector && p.delegateCount--, f.remove && f.remove.call(e, c));
						a && !p.length && (f.teardown && !1 !== f.teardown.call(e, h, v.handle) || S.removeEvent(e, d, v.handle), delete u[d])
					} else
						for (d in u)
							S.event.remove(e, d + t[l], n, r, !0);
				S.isEmptyObject(u) && Y.remove(e, "handle events")
			}
		},
		dispatch: function (e) {
			var t,
			n,
			r,
			i,
			o,
			a,
			s = new Array(arguments.length),
			u = S.event.fix(e),
			l = (Y.get(this, "events") || Object.create(null))[u.type] || [],
			c = S.event.special[u.type] || {};
			for (s[0] = u, t = 1; t < arguments.length; t++)
				s[t] = arguments[t];
			if (u.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, u)) {
				a = S.event.handlers.call(this, u, l),
				t = 0;
				while ((i = a[t++]) && !u.isPropagationStopped()) {
					u.currentTarget = i.elem,
					n = 0;
					while ((o = i.handlers[n++]) && !u.isImmediatePropagationStopped())
						u.rnamespace && !1 !== o.namespace && !u.rnamespace.test(o.namespace) || (u.handleObj = o, u.data = o.data, void 0 !== (r = ((S.event.special[o.origType] || {}).handle || o.handler).apply(i.elem, s)) && !1 === (u.result = r) && (u.preventDefault(), u.stopPropagation()))
				}
				return c.postDispatch && c.postDispatch.call(this, u),
				u.result
			}
		},
		handlers: function (e, t) {
			var n,
			r,
			i,
			o,
			a,
			s = [],
			u = t.delegateCount,
			l = e.target;
			if (u && l.nodeType && !("click" === e.type && 1 <= e.button))
				for (; l !== this; l = l.parentNode || this)
					if (1 === l.nodeType && ("click" !== e.type || !0 !== l.disabled)) {
						for (o = [], a = {}, n = 0; n < u; n++)
							void 0 === a[i = (r = t[n]).selector + " "] && (a[i] = r.needsContext ? -1 < S(i, this).index(l) : S.find(i, this, null, [l]).length), a[i] && o.push(r);
						o.length && s.push({
							elem: l,
							handlers: o
						})
					}
			return l = this,
			u < t.length && s.push({
				elem: l,
				handlers: t.slice(u)
			}),
			s
		},
		addProp: function (t, e) {
			Object.defineProperty(S.Event.prototype, t, {
				enumerable: !0,
				configurable: !0,
				get: m(e) ? function () {
					if (this.originalEvent)
						return e(this.originalEvent)
				}
				 : function () {
					if (this.originalEvent)
						return this.originalEvent[t]
				},
				set: function (e) {
					Object.defineProperty(this, t, {
						enumerable: !0,
						configurable: !0,
						writable: !0,
						value: e
					})
				}
			})
		},
		fix: function (e) {
			return e[S.expando] ? e : new S.Event(e)
		},
		special: {
			load: {
				noBubble: !0
			},
			click: {
				setup: function (e) {
					var t = this || e;
					return pe.test(t.type) && t.click && A(t, "input") && Se(t, "click", we),
					!1
				},
				trigger: function (e) {
					var t = this || e;
					return pe.test(t.type) && t.click && A(t, "input") && Se(t, "click"),
					!0
				},
				_default: function (e) {
					var t = e.target;
					return pe.test(t.type) && t.click && A(t, "input") && Y.get(t, "click") || A(t, "a")
				}
			},
			beforeunload: {
				postDispatch: function (e) {
					void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)
				}
			}
		}
	},
	S.removeEvent = function (e, t, n) {
		e.removeEventListener && e.removeEventListener(t, n)
	},
	S.Event = function (e, t) {
		if (!(this instanceof S.Event))
			return new S.Event(e, t);
		e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? we : Te, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e,
		t && S.extend(this, t),
		this.timeStamp = e && e.timeStamp || Date.now(),
		this[S.expando] = !0
	},
	S.Event.prototype = {
		constructor: S.Event,
		isDefaultPrevented: Te,
		isPropagationStopped: Te,
		isImmediatePropagationStopped: Te,
		isSimulated: !1,
		preventDefault: function () {
			var e = this.originalEvent;
			this.isDefaultPrevented = we,
			e && !this.isSimulated && e.preventDefault()
		},
		stopPropagation: function () {
			var e = this.originalEvent;
			this.isPropagationStopped = we,
			e && !this.isSimulated && e.stopPropagation()
		},
		stopImmediatePropagation: function () {
			var e = this.originalEvent;
			this.isImmediatePropagationStopped = we,
			e && !this.isSimulated && e.stopImmediatePropagation(),
			this.stopPropagation()
		}
	},
	S.each({
		altKey: !0,
		bubbles: !0,
		cancelable: !0,
		changedTouches: !0,
		ctrlKey: !0,
		detail: !0,
		eventPhase: !0,
		metaKey: !0,
		pageX: !0,
		pageY: !0,
		shiftKey: !0,
		view: !0,
		"char": !0,
		code: !0,
		charCode: !0,
		key: !0,
		keyCode: !0,
		button: !0,
		buttons: !0,
		clientX: !0,
		clientY: !0,
		offsetX: !0,
		offsetY: !0,
		pointerId: !0,
		pointerType: !0,
		screenX: !0,
		screenY: !0,
		targetTouches: !0,
		toElement: !0,
		touches: !0,
		which: !0
	}, S.event.addProp),
	S.each({
		focus: "focusin",
		blur: "focusout"
	}, function (e, t) {
		S.event.special[e] = {
			setup: function () {
				return Se(this, e, Ce),
				!1
			},
			trigger: function () {
				return Se(this, e),
				!0
			},
			_default: function () {
				return !0
			},
			delegateType: t
		}
	}),
	S.each({
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function (e, i) {
		S.event.special[e] = {
			delegateType: i,
			bindType: i,
			handle: function (e) {
				var t,
				n = e.relatedTarget,
				r = e.handleObj;
				return n && (n === this || S.contains(this, n)) || (e.type = r.origType, t = r.handler.apply(this, arguments), e.type = i),
				t
			}
		}
	}),
	S.fn.extend({
		on: function (e, t, n, r) {
			return Ee(this, e, t, n, r)
		},
		one: function (e, t, n, r) {
			return Ee(this, e, t, n, r, 1)
		},
		off: function (e, t, n) {
			var r,
			i;
			if (e && e.preventDefault && e.handleObj)
				return r = e.handleObj, S(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this;
			if ("object" == typeof e) {
				for (i in e)
					this.off(i, t, e[i]);
				return this
			}
			return !1 !== t && "function" != typeof t || (n = t, t = void 0),
			!1 === n && (n = Te),
			this.each(function () {
				S.event.remove(this, e, n, t)
			})
		}
	});
	var ke = /<script|<style|<link/i,
	Ae = /checked\s*(?:[^=]|=\s*.checked.)/i,
	Ne = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
	function je(e, t) {
		return A(e, "table") && A(11 !== t.nodeType ? t : t.firstChild, "tr") && S(e).children("tbody")[0] || e
	}
	function De(e) {
		return e.type = (null !== e.getAttribute("type")) + "/" + e.type,
		e
	}
	function qe(e) {
		return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"),
		e
	}
	function Le(e, t) {
		var n,
		r,
		i,
		o,
		a,
		s;
		if (1 === t.nodeType) {
			if (Y.hasData(e) && (s = Y.get(e).events))
				for (i in Y.remove(t, "handle events"), s)
					for (n = 0, r = s[i].length; n < r; n++)
						S.event.add(t, i, s[i][n]);
			Q.hasData(e) && (o = Q.access(e), a = S.extend({}, o), Q.set(t, a))
		}
	}
	function He(n, r, i, o) {
		r = g(r);
		var e,
		t,
		a,
		s,
		u,
		l,
		c = 0,
		f = n.length,
		p = f - 1,
		d = r[0],
		h = m(d);
		if (h || 1 < f && "string" == typeof d && !y.checkClone && Ae.test(d))
			return n.each(function (e) {
				var t = n.eq(e);
				h && (r[0] = d.call(this, e, t.html())),
				He(t, r, i, o)
			});
		if (f && (t = (e = xe(r, n[0].ownerDocument, !1, n, o)).firstChild, 1 === e.childNodes.length && (e = t), t || o)) {
			for (s = (a = S.map(ve(e, "script"), De)).length; c < f; c++)
				u = e, c !== p && (u = S.clone(u, !0, !0), s && S.merge(a, ve(u, "script"))), i.call(n[c], u, c);
			if (s)
				for (l = a[a.length - 1].ownerDocument, S.map(a, qe), c = 0; c < s; c++)
					u = a[c], he.test(u.type || "") && !Y.access(u, "globalEval") && S.contains(l, u) && (u.src && "module" !== (u.type || "").toLowerCase() ? S._evalUrl && !u.noModule && S._evalUrl(u.src, {
							nonce: u.nonce || u.getAttribute("nonce")
						}, l) : b(u.textContent.replace(Ne, ""), u, l))
		}
		return n
	}
	function Oe(e, t, n) {
		for (var r, i = t ? S.filter(t, e) : e, o = 0; null != (r = i[o]); o++)
			n || 1 !== r.nodeType || S.cleanData(ve(r)), r.parentNode && (n && ie(r) && ye(ve(r, "script")), r.parentNode.removeChild(r));
		return e
	}
	S.extend({
		htmlPrefilter: function (e) {
			return e
		},
		clone: function (e, t, n) {
			var r,
			i,
			o,
			a,
			s,
			u,
			l,
			c = e.cloneNode(!0),
			f = ie(e);
			if (!(y.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || S.isXMLDoc(e)))
				for (a = ve(c), r = 0, i = (o = ve(e)).length; r < i; r++)
					s = o[r], u = a[r], void 0, "input" === (l = u.nodeName.toLowerCase()) && pe.test(s.type) ? u.checked = s.checked : "input" !== l && "textarea" !== l || (u.defaultValue = s.defaultValue);
			if (t)
				if (n)
					for (o = o || ve(e), a = a || ve(c), r = 0, i = o.length; r < i; r++)
						Le(o[r], a[r]);
				else
					Le(e, c);
			return 0 < (a = ve(c, "script")).length && ye(a, !f && ve(e, "script")),
			c
		},
		cleanData: function (e) {
			for (var t, n, r, i = S.event.special, o = 0; void 0 !== (n = e[o]); o++)
				if (V(n)) {
					if (t = n[Y.expando]) {
						if (t.events)
							for (r in t.events)
								i[r] ? S.event.remove(n, r) : S.removeEvent(n, r, t.handle);
						n[Y.expando] = void 0
					}
					n[Q.expando] && (n[Q.expando] = void 0)
				}
		}
	}),
	S.fn.extend({
		detach: function (e) {
			return Oe(this, e, !0)
		},
		remove: function (e) {
			return Oe(this, e)
		},
		text: function (e) {
			return $(this, function (e) {
				return void 0 === e ? S.text(this) : this.empty().each(function () {
					1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e)
				})
			}, null, e, arguments.length)
		},
		append: function () {
			return He(this, arguments, function (e) {
				1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || je(this, e).appendChild(e)
			})
		},
		prepend: function () {
			return He(this, arguments, function (e) {
				if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
					var t = je(this, e);
					t.insertBefore(e, t.firstChild)
				}
			})
		},
		before: function () {
			return He(this, arguments, function (e) {
				this.parentNode && this.parentNode.insertBefore(e, this)
			})
		},
		after: function () {
			return He(this, arguments, function (e) {
				this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)
			})
		},
		empty: function () {
			for (var e, t = 0; null != (e = this[t]); t++)
				1 === e.nodeType && (S.cleanData(ve(e, !1)), e.textContent = "");
			return this
		},
		clone: function (e, t) {
			return e = null != e && e,
			t = null == t ? e : t,
			this.map(function () {
				return S.clone(this, e, t)
			})
		},
		html: function (e) {
			return $(this, function (e) {
				var t = this[0] || {},
				n = 0,
				r = this.length;
				if (void 0 === e && 1 === t.nodeType)
					return t.innerHTML;
				if ("string" == typeof e && !ke.test(e) && !ge[(de.exec(e) || ["", ""])[1].toLowerCase()]) {
					e = S.htmlPrefilter(e);
					try {
						for (; n < r; n++)
							1 === (t = this[n] || {}).nodeType && (S.cleanData(ve(t, !1)), t.innerHTML = e);
						t = 0
					} catch (e) {}
				}
				t && this.empty().append(e)
			}, null, e, arguments.length)
		},
		replaceWith: function () {
			var n = [];
			return He(this, arguments, function (e) {
				var t = this.parentNode;
				S.inArray(this, n) < 0 && (S.cleanData(ve(this)), t && t.replaceChild(e, this))
			}, n)
		}
	}),
	S.each({
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function (e, a) {
		S.fn[e] = function (e) {
			for (var t, n = [], r = S(e), i = r.length - 1, o = 0; o <= i; o++)
				t = o === i ? this : this.clone(!0), S(r[o])[a](t), u.apply(n, t.get());
			return this.pushStack(n)
		}
	});
	var Pe = new RegExp("^(" + ee + ")(?!px)[a-z%]+$", "i"),
	Re = function (e) {
		var t = e.ownerDocument.defaultView;
		return t && t.opener || (t = C),
		t.getComputedStyle(e)
	},
	Me = function (e, t, n) {
		var r,
		i,
		o = {};
		for (i in t)
			o[i] = e.style[i], e.style[i] = t[i];
		for (i in r = n.call(e), t)
			e.style[i] = o[i];
		return r
	},
	Ie = new RegExp(ne.join("|"), "i");
	function We(e, t, n) {
		var r,
		i,
		o,
		a,
		s = e.style;
		return (n = n || Re(e)) && ("" !== (a = n.getPropertyValue(t) || n[t]) || ie(e) || (a = S.style(e, t)), !y.pixelBoxStyles() && Pe.test(a) && Ie.test(t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)),
		void 0 !== a ? a + "" : a
	}
	function Fe(e, t) {
		return {
			get: function () {
				if (!e())
					return (this.get = t).apply(this, arguments);
				delete this.get
			}
		}
	}
	!function () {
		function e() {
			if (l) {
				u.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",
				l.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",
				re.appendChild(u).appendChild(l);
				var e = C.getComputedStyle(l);
				n = "1%" !== e.top,
				s = 12 === t(e.marginLeft),
				l.style.right = "60%",
				o = 36 === t(e.right),
				r = 36 === t(e.width),
				l.style.position = "absolute",
				i = 12 === t(l.offsetWidth / 3),
				re.removeChild(u),
				l = null
			}
		}
		function t(e) {
			return Math.round(parseFloat(e))
		}
		var n,
		r,
		i,
		o,
		a,
		s,
		u = E.createElement("div"),
		l = E.createElement("div");
		l.style && (l.style.backgroundClip = "content-box", l.cloneNode(!0).style.backgroundClip = "", y.clearCloneStyle = "content-box" === l.style.backgroundClip, S.extend(y, {
				boxSizingReliable: function () {
					return e(),
					r
				},
				pixelBoxStyles: function () {
					return e(),
					o
				},
				pixelPosition: function () {
					return e(),
					n
				},
				reliableMarginLeft: function () {
					return e(),
					s
				},
				scrollboxSize: function () {
					return e(),
					i
				},
				reliableTrDimensions: function () {
					var e,
					t,
					n,
					r;
					return null == a && (e = E.createElement("table"), t = E.createElement("tr"), n = E.createElement("div"), e.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", t.style.cssText = "border:1px solid", t.style.height = "1px", n.style.height = "9px", n.style.display = "block", re.appendChild(e).appendChild(t).appendChild(n), r = C.getComputedStyle(t), a = parseInt(r.height, 10) + parseInt(r.borderTopWidth, 10) + parseInt(r.borderBottomWidth, 10) === t.offsetHeight, re.removeChild(e)),
					a
				}
			}))
	}
	();
	var Be = ["Webkit", "Moz", "ms"],
	$e = E.createElement("div").style,
	_e = {};
	function ze(e) {
		var t = S.cssProps[e] || _e[e];
		return t || (e in $e ? e : _e[e] = function (e) {
			var t = e[0].toUpperCase() + e.slice(1),
			n = Be.length;
			while (n--)
				if ((e = Be[n] + t)in $e)
					return e
		}
			(e) || e)
	}
	var Ue = /^(none|table(?!-c[ea]).+)/,
	Xe = /^--/,
	Ve = {
		position: "absolute",
		visibility: "hidden",
		display: "block"
	},
	Ge = {
		letterSpacing: "0",
		fontWeight: "400"
	};
	function Ye(e, t, n) {
		var r = te.exec(t);
		return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : t
	}
	function Qe(e, t, n, r, i, o) {
		var a = "width" === t ? 1 : 0,
		s = 0,
		u = 0;
		if (n === (r ? "border" : "content"))
			return 0;
		for (; a < 4; a += 2)
			"margin" === n && (u += S.css(e, n + ne[a], !0, i)), r ? ("content" === n && (u -= S.css(e, "padding" + ne[a], !0, i)), "margin" !== n && (u -= S.css(e, "border" + ne[a] + "Width", !0, i))) : (u += S.css(e, "padding" + ne[a], !0, i), "padding" !== n ? u += S.css(e, "border" + ne[a] + "Width", !0, i) : s += S.css(e, "border" + ne[a] + "Width", !0, i));
		return !r && 0 <= o && (u += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - o - u - s - .5)) || 0),
		u
	}
	function Je(e, t, n) {
		var r = Re(e),
		i = (!y.boxSizingReliable() || n) && "border-box" === S.css(e, "boxSizing", !1, r),
		o = i,
		a = We(e, t, r),
		s = "offset" + t[0].toUpperCase() + t.slice(1);
		if (Pe.test(a)) {
			if (!n)
				return a;
			a = "auto"
		}
		return (!y.boxSizingReliable() && i || !y.reliableTrDimensions() && A(e, "tr") || "auto" === a || !parseFloat(a) && "inline" === S.css(e, "display", !1, r)) && e.getClientRects().length && (i = "border-box" === S.css(e, "boxSizing", !1, r), (o = s in e) && (a = e[s])),
		(a = parseFloat(a) || 0) + Qe(e, t, n || (i ? "border" : "content"), o, r, a) + "px"
	}
	function Ke(e, t, n, r, i) {
		return new Ke.prototype.init(e, t, n, r, i)
	}
	S.extend({
		cssHooks: {
			opacity: {
				get: function (e, t) {
					if (t) {
						var n = We(e, "opacity");
						return "" === n ? "1" : n
					}
				}
			}
		},
		cssNumber: {
			animationIterationCount: !0,
			columnCount: !0,
			fillOpacity: !0,
			flexGrow: !0,
			flexShrink: !0,
			fontWeight: !0,
			gridArea: !0,
			gridColumn: !0,
			gridColumnEnd: !0,
			gridColumnStart: !0,
			gridRow: !0,
			gridRowEnd: !0,
			gridRowStart: !0,
			lineHeight: !0,
			opacity: !0,
			order: !0,
			orphans: !0,
			widows: !0,
			zIndex: !0,
			zoom: !0
		},
		cssProps: {},
		style: function (e, t, n, r) {
			if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
				var i,
				o,
				a,
				s = X(t),
				u = Xe.test(t),
				l = e.style;
				if (u || (t = ze(s)), a = S.cssHooks[t] || S.cssHooks[s], void 0 === n)
					return a && "get" in a && void 0 !== (i = a.get(e, !1, r)) ? i : l[t];
				"string" === (o = typeof n) && (i = te.exec(n)) && i[1] && (n = se(e, t, i), o = "number"),
				null != n && n == n && ("number" !== o || u || (n += i && i[3] || (S.cssNumber[s] ? "" : "px")), y.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (l[t] = "inherit"), a && "set" in a && void 0 === (n = a.set(e, n, r)) || (u ? l.setProperty(t, n) : l[t] = n))
			}
		},
		css: function (e, t, n, r) {
			var i,
			o,
			a,
			s = X(t);
			return Xe.test(t) || (t = ze(s)),
			(a = S.cssHooks[t] || S.cssHooks[s]) && "get" in a && (i = a.get(e, !0, n)),
			void 0 === i && (i = We(e, t, r)),
			"normal" === i && t in Ge && (i = Ge[t]),
			"" === n || n ? (o = parseFloat(i), !0 === n || isFinite(o) ? o || 0 : i) : i
		}
	}),
	S.each(["height", "width"], function (e, u) {
		S.cssHooks[u] = {
			get: function (e, t, n) {
				if (t)
					return !Ue.test(S.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? Je(e, u, n) : Me(e, Ve, function () {
						return Je(e, u, n)
					})
			},
			set: function (e, t, n) {
				var r,
				i = Re(e),
				o = !y.scrollboxSize() && "absolute" === i.position,
				a = (o || n) && "border-box" === S.css(e, "boxSizing", !1, i),
				s = n ? Qe(e, u, n, a, i) : 0;
				return a && o && (s -= Math.ceil(e["offset" + u[0].toUpperCase() + u.slice(1)] - parseFloat(i[u]) - Qe(e, u, "border", !1, i) - .5)),
				s && (r = te.exec(t)) && "px" !== (r[3] || "px") && (e.style[u] = t, t = S.css(e, u)),
				Ye(0, t, s)
			}
		}
	}),
	S.cssHooks.marginLeft = Fe(y.reliableMarginLeft, function (e, t) {
		if (t)
			return (parseFloat(We(e, "marginLeft")) || e.getBoundingClientRect().left - Me(e, {
					marginLeft: 0
				}, function () {
					return e.getBoundingClientRect().left
				})) + "px"
	}),
	S.each({
		margin: "",
		padding: "",
		border: "Width"
	}, function (i, o) {
		S.cssHooks[i + o] = {
			expand: function (e) {
				for (var t = 0, n = {}, r = "string" == typeof e ? e.split(" ") : [e]; t < 4; t++)
					n[i + ne[t] + o] = r[t] || r[t - 2] || r[0];
				return n
			}
		},
		"margin" !== i && (S.cssHooks[i + o].set = Ye)
	}),
	S.fn.extend({
		css: function (e, t) {
			return $(this, function (e, t, n) {
				var r,
				i,
				o = {},
				a = 0;
				if (Array.isArray(t)) {
					for (r = Re(e), i = t.length; a < i; a++)
						o[t[a]] = S.css(e, t[a], !1, r);
					return o
				}
				return void 0 !== n ? S.style(e, t, n) : S.css(e, t)
			}, e, t, 1 < arguments.length)
		}
	}),
	((S.Tween = Ke).prototype = {
			constructor: Ke,
			init: function (e, t, n, r, i, o) {
				this.elem = e,
				this.prop = n,
				this.easing = i || S.easing._default,
				this.options = t,
				this.start = this.now = this.cur(),
				this.end = r,
				this.unit = o || (S.cssNumber[n] ? "" : "px")
			},
			cur: function () {
				var e = Ke.propHooks[this.prop];
				return e && e.get ? e.get(this) : Ke.propHooks._default.get(this)
			},
			run: function (e) {
				var t,
				n = Ke.propHooks[this.prop];
				return this.options.duration ? this.pos = t = S.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e,
				this.now = (this.end - this.start) * t + this.start,
				this.options.step && this.options.step.call(this.elem, this.now, this),
				n && n.set ? n.set(this) : Ke.propHooks._default.set(this),
				this
			}
		}).init.prototype = Ke.prototype,
	(Ke.propHooks = {
			_default: {
				get: function (e) {
					var t;
					return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = S.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0
				},
				set: function (e) {
					S.fx.step[e.prop] ? S.fx.step[e.prop](e) : 1 !== e.elem.nodeType || !S.cssHooks[e.prop] && null == e.elem.style[ze(e.prop)] ? e.elem[e.prop] = e.now : S.style(e.elem, e.prop, e.now + e.unit)
				}
			}
		}).scrollTop = Ke.propHooks.scrollLeft = {
		set: function (e) {
			e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now)
		}
	},
	S.easing = {
		linear: function (e) {
			return e
		},
		swing: function (e) {
			return .5 - Math.cos(e * Math.PI) / 2
		},
		_default: "swing"
	},
	S.fx = Ke.prototype.init,
	S.fx.step = {};
	var Ze,
	et,
	tt,
	nt,
	rt = /^(?:toggle|show|hide)$/,
	it = /queueHooks$/;
	function ot() {
		et && (!1 === E.hidden && C.requestAnimationFrame ? C.requestAnimationFrame(ot) : C.setTimeout(ot, S.fx.interval), S.fx.tick())
	}
	function at() {
		return C.setTimeout(function () {
			Ze = void 0
		}),
		Ze = Date.now()
	}
	function st(e, t) {
		var n,
		r = 0,
		i = {
			height: e
		};
		for (t = t ? 1 : 0; r < 4; r += 2 - t)
			i["margin" + (n = ne[r])] = i["padding" + n] = e;
		return t && (i.opacity = i.width = e),
		i
	}
	function ut(e, t, n) {
		for (var r, i = (lt.tweeners[t] || []).concat(lt.tweeners["*"]), o = 0, a = i.length; o < a; o++)
			if (r = i[o].call(n, t, e))
				return r
	}
	function lt(o, e, t) {
		var n,
		a,
		r = 0,
		i = lt.prefilters.length,
		s = S.Deferred().always(function () {
			delete u.elem
		}),
		u = function () {
			if (a)
				return !1;
			for (var e = Ze || at(), t = Math.max(0, l.startTime + l.duration - e), n = 1 - (t / l.duration || 0), r = 0, i = l.tweens.length; r < i; r++)
				l.tweens[r].run(n);
			return s.notifyWith(o, [l, n, t]),
			n < 1 && i ? t : (i || s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l]), !1)
		},
		l = s.promise({
			elem: o,
			props: S.extend({}, e),
			opts: S.extend(!0, {
				specialEasing: {},
				easing: S.easing._default
			}, t),
			originalProperties: e,
			originalOptions: t,
			startTime: Ze || at(),
			duration: t.duration,
			tweens: [],
			createTween: function (e, t) {
				var n = S.Tween(o, l.opts, e, t, l.opts.specialEasing[e] || l.opts.easing);
				return l.tweens.push(n),
				n
			},
			stop: function (e) {
				var t = 0,
				n = e ? l.tweens.length : 0;
				if (a)
					return this;
				for (a = !0; t < n; t++)
					l.tweens[t].run(1);
				return e ? (s.notifyWith(o, [l, 1, 0]), s.resolveWith(o, [l, e])) : s.rejectWith(o, [l, e]),
				this
			}
		}),
		c = l.props;
		for (!function (e, t) {
			var n,
			r,
			i,
			o,
			a;
			for (n in e)
				if (i = t[r = X(n)], o = e[n], Array.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), (a = S.cssHooks[r]) && "expand" in a)
					for (n in o = a.expand(o), delete e[r], o)
						n in e || (e[n] = o[n], t[n] = i);
					else
						t[r] = i
			}
				(c, l.opts.specialEasing); r < i; r++)if (n = lt.prefilters[r].call(l, o, c, l.opts))
				return m(n.stop) && (S._queueHooks(l.elem, l.opts.queue).stop = n.stop.bind(n)), n;
		return S.map(c, ut, l),
		m(l.opts.start) && l.opts.start.call(o, l),
		l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always),
		S.fx.timer(S.extend(u, {
				elem: o,
				anim: l,
				queue: l.opts.queue
			})),
		l
	}
	S.Animation = S.extend(lt, {
		tweeners: {
			"*": [function (e, t) {
					var n = this.createTween(e, t);
					return se(n.elem, e, te.exec(t), n),
					n
				}
			]
		},
		tweener: function (e, t) {
			m(e) ? (t = e, e = ["*"]) : e = e.match(P);
			for (var n, r = 0, i = e.length; r < i; r++)
				n = e[r], lt.tweeners[n] = lt.tweeners[n] || [], lt.tweeners[n].unshift(t)
		},
		prefilters: [function (e, t, n) {
				var r,
				i,
				o,
				a,
				s,
				u,
				l,
				c,
				f = "width" in t || "height" in t,
				p = this,
				d = {},
				h = e.style,
				g = e.nodeType && ae(e),
				v = Y.get(e, "fxshow");
				for (r in n.queue || (null == (a = S._queueHooks(e, "fx")).unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = function () {
							a.unqueued || s()
						}), a.unqueued++, p.always(function () {
							p.always(function () {
								a.unqueued--,
								S.queue(e, "fx").length || a.empty.fire()
							})
						})), t)
					if (i = t[r], rt.test(i)) {
						if (delete t[r], o = o || "toggle" === i, i === (g ? "hide" : "show")) {
							if ("show" !== i || !v || void 0 === v[r])
								continue;
							g = !0
						}
						d[r] = v && v[r] || S.style(e, r)
					}
				if ((u = !S.isEmptyObject(t)) || !S.isEmptyObject(d))
					for (r in f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], null == (l = v && v.display) && (l = Y.get(e, "display")), "none" === (c = S.css(e, "display")) && (l ? c = l : (le([e], !0), l = e.style.display || l, c = S.css(e, "display"), le([e]))), ("inline" === c || "inline-block" === c && null != l) && "none" === S.css(e, "float") && (u || (p.done(function () {
										h.display = l
									}), null == l && (c = h.display, l = "none" === c ? "" : c)), h.display = "inline-block")), n.overflow && (h.overflow = "hidden", p.always(function () {
								h.overflow = n.overflow[0],
								h.overflowX = n.overflow[1],
								h.overflowY = n.overflow[2]
							})), u = !1, d)
						u || (v ? "hidden" in v && (g = v.hidden) : v = Y.access(e, "fxshow", {
								display: l
							}), o && (v.hidden = !g), g && le([e], !0), p.done(function () {
								for (r in g || le([e]), Y.remove(e, "fxshow"), d)
									S.style(e, r, d[r])
							})), u = ut(g ? v[r] : 0, r, p), r in v || (v[r] = u.start, g && (u.end = u.start, u.start = 0))
			}
		],
		prefilter: function (e, t) {
			t ? lt.prefilters.unshift(e) : lt.prefilters.push(e)
		}
	}),
	S.speed = function (e, t, n) {
		var r = e && "object" == typeof e ? S.extend({}, e) : {
			complete: n || !n && t || m(e) && e,
			duration: e,
			easing: n && t || t && !m(t) && t
		};
		return S.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in S.fx.speeds ? r.duration = S.fx.speeds[r.duration] : r.duration = S.fx.speeds._default),
		null != r.queue && !0 !== r.queue || (r.queue = "fx"),
		r.old = r.complete,
		r.complete = function () {
			m(r.old) && r.old.call(this),
			r.queue && S.dequeue(this, r.queue)
		},
		r
	},
	S.fn.extend({
		fadeTo: function (e, t, n, r) {
			return this.filter(ae).css("opacity", 0).show().end().animate({
				opacity: t
			}, e, n, r)
		},
		animate: function (t, e, n, r) {
			var i = S.isEmptyObject(t),
			o = S.speed(e, n, r),
			a = function () {
				var e = lt(this, S.extend({}, t), o);
				(i || Y.get(this, "finish")) && e.stop(!0)
			};
			return a.finish = a,
			i || !1 === o.queue ? this.each(a) : this.queue(o.queue, a)
		},
		stop: function (i, e, o) {
			var a = function (e) {
				var t = e.stop;
				delete e.stop,
				t(o)
			};
			return "string" != typeof i && (o = e, e = i, i = void 0),
			e && this.queue(i || "fx", []),
			this.each(function () {
				var e = !0,
				t = null != i && i + "queueHooks",
				n = S.timers,
				r = Y.get(this);
				if (t)
					r[t] && r[t].stop && a(r[t]);
				else
					for (t in r)
						r[t] && r[t].stop && it.test(t) && a(r[t]);
				for (t = n.length; t--; )
					n[t].elem !== this || null != i && n[t].queue !== i || (n[t].anim.stop(o), e = !1, n.splice(t, 1));
				!e && o || S.dequeue(this, i)
			})
		},
		finish: function (a) {
			return !1 !== a && (a = a || "fx"),
			this.each(function () {
				var e,
				t = Y.get(this),
				n = t[a + "queue"],
				r = t[a + "queueHooks"],
				i = S.timers,
				o = n ? n.length : 0;
				for (t.finish = !0, S.queue(this, a, []), r && r.stop && r.stop.call(this, !0), e = i.length; e--; )
					i[e].elem === this && i[e].queue === a && (i[e].anim.stop(!0), i.splice(e, 1));
				for (e = 0; e < o; e++)
					n[e] && n[e].finish && n[e].finish.call(this);
				delete t.finish
			})
		}
	}),
	S.each(["toggle", "show", "hide"], function (e, r) {
		var i = S.fn[r];
		S.fn[r] = function (e, t, n) {
			return null == e || "boolean" == typeof e ? i.apply(this, arguments) : this.animate(st(r, !0), e, t, n)
		}
	}),
	S.each({
		slideDown: st("show"),
		slideUp: st("hide"),
		slideToggle: st("toggle"),
		fadeIn: {
			opacity: "show"
		},
		fadeOut: {
			opacity: "hide"
		},
		fadeToggle: {
			opacity: "toggle"
		}
	}, function (e, r) {
		S.fn[e] = function (e, t, n) {
			return this.animate(r, e, t, n)
		}
	}),
	S.timers = [],
	S.fx.tick = function () {
		var e,
		t = 0,
		n = S.timers;
		for (Ze = Date.now(); t < n.length; t++)
			(e = n[t])() || n[t] !== e || n.splice(t--, 1);
		n.length || S.fx.stop(),
		Ze = void 0
	},
	S.fx.timer = function (e) {
		S.timers.push(e),
		S.fx.start()
	},
	S.fx.interval = 13,
	S.fx.start = function () {
		et || (et = !0, ot())
	},
	S.fx.stop = function () {
		et = null
	},
	S.fx.speeds = {
		slow: 600,
		fast: 200,
		_default: 400
	},
	S.fn.delay = function (r, e) {
		return r = S.fx && S.fx.speeds[r] || r,
		e = e || "fx",
		this.queue(e, function (e, t) {
			var n = C.setTimeout(e, r);
			t.stop = function () {
				C.clearTimeout(n)
			}
		})
	},
	tt = E.createElement("input"),
	nt = E.createElement("select").appendChild(E.createElement("option")),
	tt.type = "checkbox",
	y.checkOn = "" !== tt.value,
	y.optSelected = nt.selected,
	(tt = E.createElement("input")).value = "t",
	tt.type = "radio",
	y.radioValue = "t" === tt.value;
	var ct,
	ft = S.expr.attrHandle;
	S.fn.extend({
		attr: function (e, t) {
			return $(this, S.attr, e, t, 1 < arguments.length)
		},
		removeAttr: function (e) {
			return this.each(function () {
				S.removeAttr(this, e)
			})
		}
	}),
	S.extend({
		attr: function (e, t, n) {
			var r,
			i,
			o = e.nodeType;
			if (3 !== o && 8 !== o && 2 !== o)
				return "undefined" == typeof e.getAttribute ? S.prop(e, t, n) : (1 === o && S.isXMLDoc(e) || (i = S.attrHooks[t.toLowerCase()] || (S.expr.match.bool.test(t) ? ct : void 0)), void 0 !== n ? null === n ? void S.removeAttr(e, t) : i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : (e.setAttribute(t, n + ""), n) : i && "get" in i && null !== (r = i.get(e, t)) ? r : null == (r = S.find.attr(e, t)) ? void 0 : r)
		},
		attrHooks: {
			type: {
				set: function (e, t) {
					if (!y.radioValue && "radio" === t && A(e, "input")) {
						var n = e.value;
						return e.setAttribute("type", t),
						n && (e.value = n),
						t
					}
				}
			}
		},
		removeAttr: function (e, t) {
			var n,
			r = 0,
			i = t && t.match(P);
			if (i && 1 === e.nodeType)
				while (n = i[r++])
					e.removeAttribute(n)
		}
	}),
	ct = {
		set: function (e, t, n) {
			return !1 === t ? S.removeAttr(e, n) : e.setAttribute(n, n),
			n
		}
	},
	S.each(S.expr.match.bool.source.match(/\w+/g), function (e, t) {
		var a = ft[t] || S.find.attr;
		ft[t] = function (e, t, n) {
			var r,
			i,
			o = t.toLowerCase();
			return n || (i = ft[o], ft[o] = r, r = null != a(e, t, n) ? o : null, ft[o] = i),
			r
		}
	});
	var pt = /^(?:input|select|textarea|button)$/i,
	dt = /^(?:a|area)$/i;
	function ht(e) {
		return (e.match(P) || []).join(" ")
	}
	function gt(e) {
		return e.getAttribute && e.getAttribute("class") || ""
	}
	function vt(e) {
		return Array.isArray(e) ? e : "string" == typeof e && e.match(P) || []
	}
	S.fn.extend({
		prop: function (e, t) {
			return $(this, S.prop, e, t, 1 < arguments.length)
		},
		removeProp: function (e) {
			return this.each(function () {
				delete this[S.propFix[e] || e]
			})
		}
	}),
	S.extend({
		prop: function (e, t, n) {
			var r,
			i,
			o = e.nodeType;
			if (3 !== o && 8 !== o && 2 !== o)
				return 1 === o && S.isXMLDoc(e) || (t = S.propFix[t] || t, i = S.propHooks[t]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get" in i && null !== (r = i.get(e, t)) ? r : e[t]
		},
		propHooks: {
			tabIndex: {
				get: function (e) {
					var t = S.find.attr(e, "tabindex");
					return t ? parseInt(t, 10) : pt.test(e.nodeName) || dt.test(e.nodeName) && e.href ? 0 : -1
				}
			}
		},
		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	}),
	y.optSelected || (S.propHooks.selected = {
			get: function (e) {
				var t = e.parentNode;
				return t && t.parentNode && t.parentNode.selectedIndex,
				null
			},
			set: function (e) {
				var t = e.parentNode;
				t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex)
			}
		}),
	S.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
		S.propFix[this.toLowerCase()] = this
	}),
	S.fn.extend({
		addClass: function (t) {
			var e,
			n,
			r,
			i,
			o,
			a,
			s,
			u = 0;
			if (m(t))
				return this.each(function (e) {
					S(this).addClass(t.call(this, e, gt(this)))
				});
			if ((e = vt(t)).length)
				while (n = this[u++])
					if (i = gt(n), r = 1 === n.nodeType && " " + ht(i) + " ") {
						a = 0;
						while (o = e[a++])
							r.indexOf(" " + o + " ") < 0 && (r += o + " ");
						i !== (s = ht(r)) && n.setAttribute("class", s)
					}
			return this
		},
		removeClass: function (t) {
			var e,
			n,
			r,
			i,
			o,
			a,
			s,
			u = 0;
			if (m(t))
				return this.each(function (e) {
					S(this).removeClass(t.call(this, e, gt(this)))
				});
			if (!arguments.length)
				return this.attr("class", "");
			if ((e = vt(t)).length)
				while (n = this[u++])
					if (i = gt(n), r = 1 === n.nodeType && " " + ht(i) + " ") {
						a = 0;
						while (o = e[a++])
							while (-1 < r.indexOf(" " + o + " "))
								r = r.replace(" " + o + " ", " ");
						i !== (s = ht(r)) && n.setAttribute("class", s)
					}
			return this
		},
		toggleClass: function (i, t) {
			var o = typeof i,
			a = "string" === o || Array.isArray(i);
			return "boolean" == typeof t && a ? t ? this.addClass(i) : this.removeClass(i) : m(i) ? this.each(function (e) {
				S(this).toggleClass(i.call(this, e, gt(this), t), t)
			}) : this.each(function () {
				var e,
				t,
				n,
				r;
				if (a) {
					t = 0,
					n = S(this),
					r = vt(i);
					while (e = r[t++])
						n.hasClass(e) ? n.removeClass(e) : n.addClass(e)
				} else
					void 0 !== i && "boolean" !== o || ((e = gt(this)) && Y.set(this, "__className__", e), this.setAttribute && this.setAttribute("class", e || !1 === i ? "" : Y.get(this, "__className__") || ""))
			})
		},
		hasClass: function (e) {
			var t,
			n,
			r = 0;
			t = " " + e + " ";
			while (n = this[r++])
				if (1 === n.nodeType && -1 < (" " + ht(gt(n)) + " ").indexOf(t))
					return !0;
			return !1
		}
	});
	var yt = /\r/g;
	S.fn.extend({
		val: function (n) {
			var r,
			e,
			i,
			t = this[0];
			return arguments.length ? (i = m(n), this.each(function (e) {
					var t;
					1 === this.nodeType && (null == (t = i ? n.call(this, e, S(this).val()) : n) ? t = "" : "number" == typeof t ? t += "" : Array.isArray(t) && (t = S.map(t, function (e) {
									return null == e ? "" : e + ""
								})), (r = S.valHooks[this.type] || S.valHooks[this.nodeName.toLowerCase()]) && "set" in r && void 0 !== r.set(this, t, "value") || (this.value = t))
				})) : t ? (r = S.valHooks[t.type] || S.valHooks[t.nodeName.toLowerCase()]) && "get" in r && void 0 !== (e = r.get(t, "value")) ? e : "string" == typeof(e = t.value) ? e.replace(yt, "") : null == e ? "" : e : void 0
		}
	}),
	S.extend({
		valHooks: {
			option: {
				get: function (e) {
					var t = S.find.attr(e, "value");
					return null != t ? t : ht(S.text(e))
				}
			},
			select: {
				get: function (e) {
					var t,
					n,
					r,
					i = e.options,
					o = e.selectedIndex,
					a = "select-one" === e.type,
					s = a ? null : [],
					u = a ? o + 1 : i.length;
					for (r = o < 0 ? u : a ? o : 0; r < u; r++)
						if (((n = i[r]).selected || r === o) && !n.disabled && (!n.parentNode.disabled || !A(n.parentNode, "optgroup"))) {
							if (t = S(n).val(), a)
								return t;
							s.push(t)
						}
					return s
				},
				set: function (e, t) {
					var n,
					r,
					i = e.options,
					o = S.makeArray(t),
					a = i.length;
					while (a--)
						((r = i[a]).selected = -1 < S.inArray(S.valHooks.option.get(r), o)) && (n = !0);
					return n || (e.selectedIndex = -1),
					o
				}
			}
		}
	}),
	S.each(["radio", "checkbox"], function () {
		S.valHooks[this] = {
			set: function (e, t) {
				if (Array.isArray(t))
					return e.checked = -1 < S.inArray(S(e).val(), t)
			}
		},
		y.checkOn || (S.valHooks[this].get = function (e) {
			return null === e.getAttribute("value") ? "on" : e.value
		})
	}),
	y.focusin = "onfocusin" in C;
	var mt = /^(?:focusinfocus|focusoutblur)$/,
	xt = function (e) {
		e.stopPropagation()
	};
	S.extend(S.event, {
		trigger: function (e, t, n, r) {
			var i,
			o,
			a,
			s,
			u,
			l,
			c,
			f,
			p = [n || E],
			d = v.call(e, "type") ? e.type : e,
			h = v.call(e, "namespace") ? e.namespace.split(".") : [];
			if (o = f = a = n = n || E, 3 !== n.nodeType && 8 !== n.nodeType && !mt.test(d + S.event.triggered) && (-1 < d.indexOf(".") && (d = (h = d.split(".")).shift(), h.sort()), u = d.indexOf(":") < 0 && "on" + d, (e = e[S.expando] ? e : new S.Event(d, "object" == typeof e && e)).isTrigger = r ? 2 : 3, e.namespace = h.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = n), t = null == t ? [e] : S.makeArray(t, [e]), c = S.event.special[d] || {}, r || !c.trigger || !1 !== c.trigger.apply(n, t))) {
				if (!r && !c.noBubble && !x(n)) {
					for (s = c.delegateType || d, mt.test(s + d) || (o = o.parentNode); o; o = o.parentNode)
						p.push(o), a = o;
					a === (n.ownerDocument || E) && p.push(a.defaultView || a.parentWindow || C)
				}
				i = 0;
				while ((o = p[i++]) && !e.isPropagationStopped())
					f = o, e.type = 1 < i ? s : c.bindType || d, (l = (Y.get(o, "events") || Object.create(null))[e.type] && Y.get(o, "handle")) && l.apply(o, t), (l = u && o[u]) && l.apply && V(o) && (e.result = l.apply(o, t), !1 === e.result && e.preventDefault());
				return e.type = d,
				r || e.isDefaultPrevented() || c._default && !1 !== c._default.apply(p.pop(), t) || !V(n) || u && m(n[d]) && !x(n) && ((a = n[u]) && (n[u] = null), S.event.triggered = d, e.isPropagationStopped() && f.addEventListener(d, xt), n[d](), e.isPropagationStopped() && f.removeEventListener(d, xt), S.event.triggered = void 0, a && (n[u] = a)),
				e.result
			}
		},
		simulate: function (e, t, n) {
			var r = S.extend(new S.Event, n, {
				type: e,
				isSimulated: !0
			});
			S.event.trigger(r, null, t)
		}
	}),
	S.fn.extend({
		trigger: function (e, t) {
			return this.each(function () {
				S.event.trigger(e, t, this)
			})
		},
		triggerHandler: function (e, t) {
			var n = this[0];
			if (n)
				return S.event.trigger(e, t, n, !0)
		}
	}),
	y.focusin || S.each({
		focus: "focusin",
		blur: "focusout"
	}, function (n, r) {
		var i = function (e) {
			S.event.simulate(r, e.target, S.event.fix(e))
		};
		S.event.special[r] = {
			setup: function () {
				var e = this.ownerDocument || this.document || this,
				t = Y.access(e, r);
				t || e.addEventListener(n, i, !0),
				Y.access(e, r, (t || 0) + 1)
			},
			teardown: function () {
				var e = this.ownerDocument || this.document || this,
				t = Y.access(e, r) - 1;
				t ? Y.access(e, r, t) : (e.removeEventListener(n, i, !0), Y.remove(e, r))
			}
		}
	});
	var bt = C.location,
	wt = {
		guid: Date.now()
	},
	Tt = /\?/;
	S.parseXML = function (e) {
		var t,
		n;
		if (!e || "string" != typeof e)
			return null;
		try {
			t = (new C.DOMParser).parseFromString(e, "text/xml")
		} catch (e) {}
		return n = t && t.getElementsByTagName("parsererror")[0],
		t && !n || S.error("Invalid XML: " + (n ? S.map(n.childNodes, function (e) {
					return e.textContent
				}).join("\n") : e)),
		t
	};
	var Ct = /\[\]$/,
	Et = /\r?\n/g,
	St = /^(?:submit|button|image|reset|file)$/i,
	kt = /^(?:input|select|textarea|keygen)/i;
	function At(n, e, r, i) {
		var t;
		if (Array.isArray(e))
			S.each(e, function (e, t) {
				r || Ct.test(n) ? i(n, t) : At(n + "[" + ("object" == typeof t && null != t ? e : "") + "]", t, r, i)
			});
		else if (r || "object" !== w(e))
			i(n, e);
		else
			for (t in e)
				At(n + "[" + t + "]", e[t], r, i)
	}
	S.param = function (e, t) {
		var n,
		r = [],
		i = function (e, t) {
			var n = m(t) ? t() : t;
			r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n)
		};
		if (null == e)
			return "";
		if (Array.isArray(e) || e.jquery && !S.isPlainObject(e))
			S.each(e, function () {
				i(this.name, this.value)
			});
		else
			for (n in e)
				At(n, e[n], t, i);
		return r.join("&")
	},
	S.fn.extend({
		serialize: function () {
			return S.param(this.serializeArray())
		},
		serializeArray: function () {
			return this.map(function () {
				var e = S.prop(this, "elements");
				return e ? S.makeArray(e) : this
			}).filter(function () {
				var e = this.type;
				return this.name && !S(this).is(":disabled") && kt.test(this.nodeName) && !St.test(e) && (this.checked || !pe.test(e))
			}).map(function (e, t) {
				var n = S(this).val();
				return null == n ? null : Array.isArray(n) ? S.map(n, function (e) {
					return {
						name: t.name,
						value: e.replace(Et, "\r\n")
					}
				}) : {
					name: t.name,
					value: n.replace(Et, "\r\n")
				}
			}).get()
		}
	});
	var Nt = /%20/g,
	jt = /#.*$/,
	Dt = /([?&])_=[^&]*/,
	qt = /^(.*?):[ \t]*([^\r\n]*)$/gm,
	Lt = /^(?:GET|HEAD)$/,
	Ht = /^\/\//,
	Ot = {},
	Pt = {},
	Rt = "*/".concat("*"),
	Mt = E.createElement("a");
	function It(o) {
		return function (e, t) {
			"string" != typeof e && (t = e, e = "*");
			var n,
			r = 0,
			i = e.toLowerCase().match(P) || [];
			if (m(t))
				while (n = i[r++])
					"+" === n[0] ? (n = n.slice(1) || "*", (o[n] = o[n] || []).unshift(t)) : (o[n] = o[n] || []).push(t)
		}
	}
	function Wt(t, i, o, a) {
		var s = {},
		u = t === Pt;
		function l(e) {
			var r;
			return s[e] = !0,
			S.each(t[e] || [], function (e, t) {
				var n = t(i, o, a);
				return "string" != typeof n || u || s[n] ? u ? !(r = n) : void 0 : (i.dataTypes.unshift(n), l(n), !1)
			}),
			r
		}
		return l(i.dataTypes[0]) || !s["*"] && l("*")
	}
	function Ft(e, t) {
		var n,
		r,
		i = S.ajaxSettings.flatOptions || {};
		for (n in t)
			void 0 !== t[n] && ((i[n] ? e : r || (r = {}))[n] = t[n]);
		return r && S.extend(!0, e, r),
		e
	}
	Mt.href = bt.href,
	S.extend({
		active: 0,
		lastModified: {},
		etag: {},
		ajaxSettings: {
			url: bt.href,
			type: "GET",
			isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(bt.protocol),
			global: !0,
			processData: !0,
			async: !0,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
			accepts: {
				"*": Rt,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},
			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},
			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},
			converters: {
				"* text": String,
				"text html": !0,
				"text json": JSON.parse,
				"text xml": S.parseXML
			},
			flatOptions: {
				url: !0,
				context: !0
			}
		},
		ajaxSetup: function (e, t) {
			return t ? Ft(Ft(e, S.ajaxSettings), t) : Ft(S.ajaxSettings, e)
		},
		ajaxPrefilter: It(Ot),
		ajaxTransport: It(Pt),
		ajax: function (e, t) {
			"object" == typeof e && (t = e, e = void 0),
			t = t || {};
			var c,
			f,
			p,
			n,
			d,
			r,
			h,
			g,
			i,
			o,
			v = S.ajaxSetup({}, t),
			y = v.context || v,
			m = v.context && (y.nodeType || y.jquery) ? S(y) : S.event,
			x = S.Deferred(),
			b = S.Callbacks("once memory"),
			w = v.statusCode || {},
			a = {},
			s = {},
			u = "canceled",
			T = {
				readyState: 0,
				getResponseHeader: function (e) {
					var t;
					if (h) {
						if (!n) {
							n = {};
							while (t = qt.exec(p))
								n[t[1].toLowerCase() + " "] = (n[t[1].toLowerCase() + " "] || []).concat(t[2])
						}
						t = n[e.toLowerCase() + " "]
					}
					return null == t ? null : t.join(", ")
				},
				getAllResponseHeaders: function () {
					return h ? p : null
				},
				setRequestHeader: function (e, t) {
					return null == h && (e = s[e.toLowerCase()] = s[e.toLowerCase()] || e, a[e] = t),
					this
				},
				overrideMimeType: function (e) {
					return null == h && (v.mimeType = e),
					this
				},
				statusCode: function (e) {
					var t;
					if (e)
						if (h)
							T.always(e[T.status]);
						else
							for (t in e)
								w[t] = [w[t], e[t]];
					return this
				},
				abort: function (e) {
					var t = e || u;
					return c && c.abort(t),
					l(0, t),
					this
				}
			};
			if (x.promise(T), v.url = ((e || v.url || bt.href) + "").replace(Ht, bt.protocol + "//"), v.type = t.method || t.type || v.method || v.type, v.dataTypes = (v.dataType || "*").toLowerCase().match(P) || [""], null == v.crossDomain) {
				r = E.createElement("a");
				try {
					r.href = v.url,
					r.href = r.href,
					v.crossDomain = Mt.protocol + "//" + Mt.host != r.protocol + "//" + r.host
				} catch (e) {
					v.crossDomain = !0
				}
			}
			if (v.data && v.processData && "string" != typeof v.data && (v.data = S.param(v.data, v.traditional)), Wt(Ot, v, t, T), h)
				return T;
			for (i in(g = S.event && v.global) && 0 == S.active++ && S.event.trigger("ajaxStart"), v.type = v.type.toUpperCase(), v.hasContent = !Lt.test(v.type), f = v.url.replace(jt, ""), v.hasContent ? v.data && v.processData && 0 === (v.contentType || "").indexOf("application/x-www-form-urlencoded") && (v.data = v.data.replace(Nt, "+")) : (o = v.url.slice(f.length), v.data && (v.processData || "string" == typeof v.data) && (f += (Tt.test(f) ? "&" : "?") + v.data, delete v.data), !1 === v.cache && (f = f.replace(Dt, "$1"), o = (Tt.test(f) ? "&" : "?") + "_=" + wt.guid++ + o), v.url = f + o), v.ifModified && (S.lastModified[f] && T.setRequestHeader("If-Modified-Since", S.lastModified[f]), S.etag[f] && T.setRequestHeader("If-None-Match", S.etag[f])), (v.data && v.hasContent && !1 !== v.contentType || t.contentType) && T.setRequestHeader("Content-Type", v.contentType), T.setRequestHeader("Accept", v.dataTypes[0] && v.accepts[v.dataTypes[0]] ? v.accepts[v.dataTypes[0]] + ("*" !== v.dataTypes[0] ? ", " + Rt + "; q=0.01" : "") : v.accepts["*"]), v.headers)
				T.setRequestHeader(i, v.headers[i]);
			if (v.beforeSend && (!1 === v.beforeSend.call(y, T, v) || h))
				return T.abort();
			if (u = "abort", b.add(v.complete), T.done(v.success), T.fail(v.error), c = Wt(Pt, v, t, T)) {
				if (T.readyState = 1, g && m.trigger("ajaxSend", [T, v]), h)
					return T;
				v.async && 0 < v.timeout && (d = C.setTimeout(function () {
						T.abort("timeout")
					}, v.timeout));
				try {
					h = !1,
					c.send(a, l)
				} catch (e) {
					if (h)
						throw e;
					l(-1, e)
				}
			} else
				l(-1, "No Transport");
			function l(e, t, n, r) {
				var i,
				o,
				a,
				s,
				u,
				l = t;
				h || (h = !0, d && C.clearTimeout(d), c = void 0, p = r || "", T.readyState = 0 < e ? 4 : 0, i = 200 <= e && e < 300 || 304 === e, n && (s = function (e, t, n) {
						var r,
						i,
						o,
						a,
						s = e.contents,
						u = e.dataTypes;
						while ("*" === u[0])
							u.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type"));
						if (r)
							for (i in s)
								if (s[i] && s[i].test(r)) {
									u.unshift(i);
									break
								}
						if (u[0]in n)
							o = u[0];
						else {
							for (i in n) {
								if (!u[0] || e.converters[i + " " + u[0]]) {
									o = i;
									break
								}
								a || (a = i)
							}
							o = o || a
						}
						if (o)
							return o !== u[0] && u.unshift(o), n[o]
					}
						(v, T, n)), !i && -1 < S.inArray("script", v.dataTypes) && S.inArray("json", v.dataTypes) < 0 && (v.converters["text script"] = function () {}), s = function (e, t, n, r) {
					var i,
					o,
					a,
					s,
					u,
					l = {},
					c = e.dataTypes.slice();
					if (c[1])
						for (a in e.converters)
							l[a.toLowerCase()] = e.converters[a];
					o = c.shift();
					while (o)
						if (e.responseFields[o] && (n[e.responseFields[o]] = t), !u && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), u = o, o = c.shift())
							if ("*" === o)
								o = u;
							else if ("*" !== u && u !== o) {
								if (!(a = l[u + " " + o] || l["* " + o]))
									for (i in l)
										if ((s = i.split(" "))[1] === o && (a = l[u + " " + s[0]] || l["* " + s[0]])) {
											!0 === a ? a = l[i] : !0 !== l[i] && (o = s[0], c.unshift(s[1]));
											break
										}
								if (!0 !== a)
									if (a && e["throws"])
										t = a(t);
									else
										try {
											t = a(t)
										} catch (e) {
											return {
												state: "parsererror",
												error: a ? e : "No conversion from " + u + " to " + o
											}
										}
							}
					return {
						state: "success",
						data: t
					}
				}
					(v, s, T, i), i ? (v.ifModified && ((u = T.getResponseHeader("Last-Modified")) && (S.lastModified[f] = u), (u = T.getResponseHeader("etag")) && (S.etag[f] = u)), 204 === e || "HEAD" === v.type ? l = "nocontent" : 304 === e ? l = "notmodified" : (l = s.state, o = s.data, i = !(a = s.error))) : (a = l, !e && l || (l = "error", e < 0 && (e = 0))), T.status = e, T.statusText = (t || l) + "", i ? x.resolveWith(y, [o, l, T]) : x.rejectWith(y, [T, l, a]), T.statusCode(w), w = void 0, g && m.trigger(i ? "ajaxSuccess" : "ajaxError", [T, v, i ? o : a]), b.fireWith(y, [T, l]), g && (m.trigger("ajaxComplete", [T, v]), --S.active || S.event.trigger("ajaxStop")))
			}
			return T
		},
		getJSON: function (e, t, n) {
			return S.get(e, t, n, "json")
		},
		getScript: function (e, t) {
			return S.get(e, void 0, t, "script")
		}
	}),
	S.each(["get", "post"], function (e, i) {
		S[i] = function (e, t, n, r) {
			return m(t) && (r = r || n, n = t, t = void 0),
			S.ajax(S.extend({
					url: e,
					type: i,
					dataType: r,
					data: t,
					success: n
				}, S.isPlainObject(e) && e))
		}
	}),
	S.ajaxPrefilter(function (e) {
		var t;
		for (t in e.headers)
			"content-type" === t.toLowerCase() && (e.contentType = e.headers[t] || "")
	}),
	S._evalUrl = function (e, t, n) {
		return S.ajax({
			url: e,
			type: "GET",
			dataType: "script",
			cache: !0,
			async: !1,
			global: !1,
			converters: {
				"text script": function () {}
			},
			dataFilter: function (e) {
				S.globalEval(e, t, n)
			}
		})
	},
	S.fn.extend({
		wrapAll: function (e) {
			var t;
			return this[0] && (m(e) && (e = e.call(this[0])), t = S(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function () {
					var e = this;
					while (e.firstElementChild)
						e = e.firstElementChild;
					return e
				}).append(this)),
			this
		},
		wrapInner: function (n) {
			return m(n) ? this.each(function (e) {
				S(this).wrapInner(n.call(this, e))
			}) : this.each(function () {
				var e = S(this),
				t = e.contents();
				t.length ? t.wrapAll(n) : e.append(n)
			})
		},
		wrap: function (t) {
			var n = m(t);
			return this.each(function (e) {
				S(this).wrapAll(n ? t.call(this, e) : t)
			})
		},
		unwrap: function (e) {
			return this.parent(e).not("body").each(function () {
				S(this).replaceWith(this.childNodes)
			}),
			this
		}
	}),
	S.expr.pseudos.hidden = function (e) {
		return !S.expr.pseudos.visible(e)
	},
	S.expr.pseudos.visible = function (e) {
		return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length)
	},
	S.ajaxSettings.xhr = function () {
		try {
			return new C.XMLHttpRequest
		} catch (e) {}
	};
	var Bt = {
		0: 200,
		1223: 204
	},
	$t = S.ajaxSettings.xhr();
	y.cors = !!$t && "withCredentials" in $t,
	y.ajax = $t = !!$t,
	S.ajaxTransport(function (i) {
		var o,
		a;
		if (y.cors || $t && !i.crossDomain)
			return {
				send: function (e, t) {
					var n,
					r = i.xhr();
					if (r.open(i.type, i.url, i.async, i.username, i.password), i.xhrFields)
						for (n in i.xhrFields)
							r[n] = i.xhrFields[n];
					for (n in i.mimeType && r.overrideMimeType && r.overrideMimeType(i.mimeType), i.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest"), e)
						r.setRequestHeader(n, e[n]);
					o = function (e) {
						return function () {
							o && (o = a = r.onload = r.onerror = r.onabort = r.ontimeout = r.onreadystatechange = null, "abort" === e ? r.abort() : "error" === e ? "number" != typeof r.status ? t(0, "error") : t(r.status, r.statusText) : t(Bt[r.status] || r.status, r.statusText, "text" !== (r.responseType || "text") || "string" != typeof r.responseText ? {
									binary: r.response
								}
									 : {
									text: r.responseText
								}, r.getAllResponseHeaders()))
						}
					},
					r.onload = o(),
					a = r.onerror = r.ontimeout = o("error"),
					void 0 !== r.onabort ? r.onabort = a : r.onreadystatechange = function () {
						4 === r.readyState && C.setTimeout(function () {
							o && a()
						})
					},
					o = o("abort");
					try {
						r.send(i.hasContent && i.data || null)
					} catch (e) {
						if (o)
							throw e
					}
				},
				abort: function () {
					o && o()
				}
			}
	}),
	S.ajaxPrefilter(function (e) {
		e.crossDomain && (e.contents.script = !1)
	}),
	S.ajaxSetup({
		accepts: {
			script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function (e) {
				return S.globalEval(e),
				e
			}
		}
	}),
	S.ajaxPrefilter("script", function (e) {
		void 0 === e.cache && (e.cache = !1),
		e.crossDomain && (e.type = "GET")
	}),
	S.ajaxTransport("script", function (n) {
		var r,
		i;
		if (n.crossDomain || n.scriptAttrs)
			return {
				send: function (e, t) {
					r = S("<script>").attr(n.scriptAttrs || {}).prop({
						charset: n.scriptCharset,
						src: n.url
					}).on("load error", i = function (e) {
							r.remove(),
							i = null,
							e && t("error" === e.type ? 404 : 200, e.type)
						}),
					E.head.appendChild(r[0])
				},
				abort: function () {
					i && i()
				}
			}
	});
	var _t,
	zt = [],
	Ut = /(=)\?(?=&|$)|\?\?/;
	S.ajaxSetup({
		jsonp: "callback",
		jsonpCallback: function () {
			var e = zt.pop() || S.expando + "_" + wt.guid++;
			return this[e] = !0,
			e
		}
	}),
	S.ajaxPrefilter("json jsonp", function (e, t, n) {
		var r,
		i,
		o,
		a = !1 !== e.jsonp && (Ut.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && Ut.test(e.data) && "data");
		if (a || "jsonp" === e.dataTypes[0])
			return r = e.jsonpCallback = m(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, a ? e[a] = e[a].replace(Ut, "$1" + r) : !1 !== e.jsonp && (e.url += (Tt.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function () {
				return o || S.error(r + " was not called"),
				o[0]
			},
		e.dataTypes[0] = "json",
		i = C[r],
		C[r] = function () {
			o = arguments
		},
		n.always(function () {
			void 0 === i ? S(C).removeProp(r) : C[r] = i,
			e[r] && (e.jsonpCallback = t.jsonpCallback, zt.push(r)),
			o && m(i) && i(o[0]),
			o = i = void 0
		}),
		"script"
	}),
	y.createHTMLDocument = ((_t = E.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === _t.childNodes.length),
	S.parseHTML = function (e, t, n) {
		return "string" != typeof e ? [] : ("boolean" == typeof t && (n = t, t = !1), t || (y.createHTMLDocument ? ((r = (t = E.implementation.createHTMLDocument("")).createElement("base")).href = E.location.href, t.head.appendChild(r)) : t = E), o = !n && [], (i = N.exec(e)) ? [t.createElement(i[1])] : (i = xe([e], t, o), o && o.length && S(o).remove(), S.merge([], i.childNodes)));
		var r,
		i,
		o
	},
	S.fn.load = function (e, t, n) {
		var r,
		i,
		o,
		a = this,
		s = e.indexOf(" ");
		return -1 < s && (r = ht(e.slice(s)), e = e.slice(0, s)),
		m(t) ? (n = t, t = void 0) : t && "object" == typeof t && (i = "POST"),
		0 < a.length && S.ajax({
			url: e,
			type: i || "GET",
			dataType: "html",
			data: t
		}).done(function (e) {
			o = arguments,
			a.html(r ? S("<div>").append(S.parseHTML(e)).find(r) : e)
		}).always(n && function (e, t) {
			a.each(function () {
				n.apply(this, o || [e.responseText, t, e])
			})
		}),
		this
	},
	S.expr.pseudos.animated = function (t) {
		return S.grep(S.timers, function (e) {
			return t === e.elem
		}).length
	},
	S.offset = {
		setOffset: function (e, t, n) {
			var r,
			i,
			o,
			a,
			s,
			u,
			l = S.css(e, "position"),
			c = S(e),
			f = {};
			"static" === l && (e.style.position = "relative"),
			s = c.offset(),
			o = S.css(e, "top"),
			u = S.css(e, "left"),
			("absolute" === l || "fixed" === l) && -1 < (o + u).indexOf("auto") ? (a = (r = c.position()).top, i = r.left) : (a = parseFloat(o) || 0, i = parseFloat(u) || 0),
			m(t) && (t = t.call(e, n, S.extend({}, s))),
			null != t.top && (f.top = t.top - s.top + a),
			null != t.left && (f.left = t.left - s.left + i),
			"using" in t ? t.using.call(e, f) : c.css(f)
		}
	},
	S.fn.extend({
		offset: function (t) {
			if (arguments.length)
				return void 0 === t ? this : this.each(function (e) {
					S.offset.setOffset(this, t, e)
				});
			var e,
			n,
			r = this[0];
			return r ? r.getClientRects().length ? (e = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, {
				top: e.top + n.pageYOffset,
				left: e.left + n.pageXOffset
			}) : {
				top: 0,
				left: 0
			}
			 : void 0
		},
		position: function () {
			if (this[0]) {
				var e,
				t,
				n,
				r = this[0],
				i = {
					top: 0,
					left: 0
				};
				if ("fixed" === S.css(r, "position"))
					t = r.getBoundingClientRect();
				else {
					t = this.offset(),
					n = r.ownerDocument,
					e = r.offsetParent || n.documentElement;
					while (e && (e === n.body || e === n.documentElement) && "static" === S.css(e, "position"))
						e = e.parentNode;
					e && e !== r && 1 === e.nodeType && ((i = S(e).offset()).top += S.css(e, "borderTopWidth", !0), i.left += S.css(e, "borderLeftWidth", !0))
				}
				return {
					top: t.top - i.top - S.css(r, "marginTop", !0),
					left: t.left - i.left - S.css(r, "marginLeft", !0)
				}
			}
		},
		offsetParent: function () {
			return this.map(function () {
				var e = this.offsetParent;
				while (e && "static" === S.css(e, "position"))
					e = e.offsetParent;
				return e || re
			})
		}
	}),
	S.each({
		scrollLeft: "pageXOffset",
		scrollTop: "pageYOffset"
	}, function (t, i) {
		var o = "pageYOffset" === i;
		S.fn[t] = function (e) {
			return $(this, function (e, t, n) {
				var r;
				if (x(e) ? r = e : 9 === e.nodeType && (r = e.defaultView), void 0 === n)
					return r ? r[i] : e[t];
				r ? r.scrollTo(o ? r.pageXOffset : n, o ? n : r.pageYOffset) : e[t] = n
			}, t, e, arguments.length)
		}
	}),
	S.each(["top", "left"], function (e, n) {
		S.cssHooks[n] = Fe(y.pixelPosition, function (e, t) {
			if (t)
				return t = We(e, n), Pe.test(t) ? S(e).position()[n] + "px" : t
		})
	}),
	S.each({
		Height: "height",
		Width: "width"
	}, function (a, s) {
		S.each({
			padding: "inner" + a,
			content: s,
			"": "outer" + a
		}, function (r, o) {
			S.fn[o] = function (e, t) {
				var n = arguments.length && (r || "boolean" != typeof e),
				i = r || (!0 === e || !0 === t ? "margin" : "border");
				return $(this, function (e, t, n) {
					var r;
					return x(e) ? 0 === o.indexOf("outer") ? e["inner" + a] : e.document.documentElement["client" + a] : 9 === e.nodeType ? (r = e.documentElement, Math.max(e.body["scroll" + a], r["scroll" + a], e.body["offset" + a], r["offset" + a], r["client" + a])) : void 0 === n ? S.css(e, t, i) : S.style(e, t, n, i)
				}, s, n ? e : void 0, n)
			}
		})
	}),
	S.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (e, t) {
		S.fn[t] = function (e) {
			return this.on(t, e)
		}
	}),
	S.fn.extend({
		bind: function (e, t, n) {
			return this.on(e, null, t, n)
		},
		unbind: function (e, t) {
			return this.off(e, null, t)
		},
		delegate: function (e, t, n, r) {
			return this.on(t, e, n, r)
		},
		undelegate: function (e, t, n) {
			return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n)
		},
		hover: function (e, t) {
			return this.mouseenter(e).mouseleave(t || e)
		}
	}),
	S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function (e, n) {
		S.fn[n] = function (e, t) {
			return 0 < arguments.length ? this.on(n, null, e, t) : this.trigger(n)
		}
	});
	var Xt = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
	S.proxy = function (e, t) {
		var n,
		r,
		i;
		if ("string" == typeof t && (n = e[t], t = e, e = n), m(e))
			return r = s.call(arguments, 2), (i = function () {
				return e.apply(t || this, r.concat(s.call(arguments)))
			}).guid = e.guid = e.guid || S.guid++, i
	},
	S.holdReady = function (e) {
		e ? S.readyWait++ : S.ready(!0)
	},
	S.isArray = Array.isArray,
	S.parseJSON = JSON.parse,
	S.nodeName = A,
	S.isFunction = m,
	S.isWindow = x,
	S.camelCase = X,
	S.type = w,
	S.now = Date.now,
	S.isNumeric = function (e) {
		var t = S.type(e);
		return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e))
	},
	S.trim = function (e) {
		return null == e ? "" : (e + "").replace(Xt, "")
	},
	"function" == typeof define && define.amd && define("jquery", [], function () {
		return S
	});
	var Vt = C.jQuery,
	Gt = C.$;
	return S.noConflict = function (e) {
		return C.$ === S && (C.$ = Gt),
		e && C.jQuery === S && (C.jQuery = Vt),
		S
	},
	"undefined" == typeof e && (C.jQuery = C.$ = S),
	S
});
/*!
 * jQuery Mousewheel 3.1.13
 *
 * Copyright 2015 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */
!function (a) {
	"function" == typeof define && define.amd ? define(["jquery"], a) : "object" == typeof exports ? module.exports = a : a(jQuery)
}
(function (a) {
	function b(b) {
		var g = b || window.event,
		h = i.call(arguments, 1),
		j = 0,
		l = 0,
		m = 0,
		n = 0,
		o = 0,
		p = 0;
		if (b = a.event.fix(g), b.type = "mousewheel", "detail" in g && (m = -1 * g.detail), "wheelDelta" in g && (m = g.wheelDelta), "wheelDeltaY" in g && (m = g.wheelDeltaY), "wheelDeltaX" in g && (l = -1 * g.wheelDeltaX), "axis" in g && g.axis === g.HORIZONTAL_AXIS && (l = -1 * m, m = 0), j = 0 === m ? l : m, "deltaY" in g && (m = -1 * g.deltaY, j = m), "deltaX" in g && (l = g.deltaX, 0 === m && (j = -1 * l)), 0 !== m || 0 !== l) {
			if (1 === g.deltaMode) {
				var q = a.data(this, "mousewheel-line-height");
				j *= q,
				m *= q,
				l *= q
			} else if (2 === g.deltaMode) {
				var r = a.data(this, "mousewheel-page-height");
				j *= r,
				m *= r,
				l *= r
			}
			if (n = Math.max(Math.abs(m), Math.abs(l)), (!f || f > n) && (f = n, d(g, n) && (f /= 40)), d(g, n) && (j /= 40, l /= 40, m /= 40), j = Math[j >= 1 ? "floor" : "ceil"](j / f), l = Math[l >= 1 ? "floor" : "ceil"](l / f), m = Math[m >= 1 ? "floor" : "ceil"](m / f), k.settings.normalizeOffset && this.getBoundingClientRect) {
				var s = this.getBoundingClientRect();
				o = b.clientX - s.left,
				p = b.clientY - s.top
			}
			return b.deltaX = l,
			b.deltaY = m,
			b.deltaFactor = f,
			b.offsetX = o,
			b.offsetY = p,
			b.deltaMode = 0,
			h.unshift(b, j, l, m),
			e && clearTimeout(e),
			e = setTimeout(c, 200),
			(a.event.dispatch || a.event.handle).apply(this, h)
		}
	}
	function c() {
		f = null
	}
	function d(a, b) {
		return k.settings.adjustOldDeltas && "mousewheel" === a.type && b % 120 === 0
	}
	var e,
	f,
	g = ["wheel", "mousewheel", "DOMMouseScroll", "MozMousePixelScroll"],
	h = "onwheel" in document || document.documentMode >= 9 ? ["wheel"] : ["mousewheel", "DomMouseScroll", "MozMousePixelScroll"],
	i = Array.prototype.slice;
	if (a.event.fixHooks)
		for (var j = g.length; j; )
			a.event.fixHooks[g[--j]] = a.event.mouseHooks;
	var k = a.event.special.mousewheel = {
		version: "3.1.12",
		setup: function () {
			if (this.addEventListener)
				for (var c = h.length; c; )
					this.addEventListener(h[--c], b, !1);
			else
				this.onmousewheel = b;
			a.data(this, "mousewheel-line-height", k.getLineHeight(this)),
			a.data(this, "mousewheel-page-height", k.getPageHeight(this))
		},
		teardown: function () {
			if (this.removeEventListener)
				for (var c = h.length; c; )
					this.removeEventListener(h[--c], b, !1);
			else
				this.onmousewheel = null;
			a.removeData(this, "mousewheel-line-height"),
			a.removeData(this, "mousewheel-page-height")
		},
		getLineHeight: function (b) {
			var c = a(b),
			d = c["offsetParent" in a.fn ? "offsetParent" : "parent"]();
			return d.length || (d = a("body")),
			parseInt(d.css("fontSize"), 10) || parseInt(c.css("fontSize"), 10) || 16
		},
		getPageHeight: function (b) {
			return a(b).height()
		},
		settings: {
			adjustOldDeltas: !0,
			normalizeOffset: !0
		}
	};
	a.fn.extend({
		mousewheel: function (a) {
			return a ? this.bind("mousewheel", a) : this.trigger("mousewheel")
		},
		unmousewheel: function (a) {
			return this.unbind("mousewheel", a)
		}
	})
});
/*! Hammer.JS - v2.0.8 - 2016-04-23
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
!function (a, b, c, d) {
	"use strict";
	function e(a, b, c) {
		return setTimeout(j(a, c), b)
	}
	function f(a, b, c) {
		return Array.isArray(a) ? (g(a, c[b], c), !0) : !1
	}
	function g(a, b, c) {
		var e;
		if (a)
			if (a.forEach)
				a.forEach(b, c);
			else if (a.length !== d)
				for (e = 0; e < a.length; )
					b.call(c, a[e], e, a), e++;
			else
				for (e in a)
					a.hasOwnProperty(e) && b.call(c, a[e], e, a)
	}
	function h(b, c, d) {
		var e = "DEPRECATED METHOD: " + c + "\n" + d + " AT \n";
		return function () {
			var c = new Error("get-stack-trace"),
			d = c && c.stack ? c.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace",
			f = a.console && (a.console.warn || a.console.log);
			return f && f.call(a.console, e, d),
			b.apply(this, arguments)
		}
	}
	function i(a, b, c) {
		var d,
		e = b.prototype;
		d = a.prototype = Object.create(e),
		d.constructor = a,
		d._super = e,
		c && la(d, c)
	}
	function j(a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}
	function k(a, b) {
		return typeof a == oa ? a.apply(b ? b[0] || d : d, b) : a
	}
	function l(a, b) {
		return a === d ? b : a
	}
	function m(a, b, c) {
		g(q(b), function (b) {
			a.addEventListener(b, c, !1)
		})
	}
	function n(a, b, c) {
		g(q(b), function (b) {
			a.removeEventListener(b, c, !1)
		})
	}
	function o(a, b) {
		for (; a; ) {
			if (a == b)
				return !0;
			a = a.parentNode
		}
		return !1
	}
	function p(a, b) {
		return a.indexOf(b) > -1
	}
	function q(a) {
		return a.trim().split(/\s+/g)
	}
	function r(a, b, c) {
		if (a.indexOf && !c)
			return a.indexOf(b);
		for (var d = 0; d < a.length; ) {
			if (c && a[d][c] == b || !c && a[d] === b)
				return d;
			d++
		}
		return -1
	}
	function s(a) {
		return Array.prototype.slice.call(a, 0)
	}
	function t(a, b, c) {
		for (var d = [], e = [], f = 0; f < a.length; ) {
			var g = b ? a[f][b] : a[f];
			r(e, g) < 0 && d.push(a[f]),
			e[f] = g,
			f++
		}
		return c && (d = b ? d.sort(function (a, c) {
				return a[b] > c[b]
			}) : d.sort()),
		d
	}
	function u(a, b) {
		for (var c, e, f = b[0].toUpperCase() + b.slice(1), g = 0; g < ma.length; ) {
			if (c = ma[g], e = c ? c + f : b, e in a)
				return e;
			g++
		}
		return d
	}
	function v() {
		return ua++
	}
	function w(b) {
		var c = b.ownerDocument || b;
		return c.defaultView || c.parentWindow || a
	}
	function x(a, b) {
		var c = this;
		this.manager = a,
		this.callback = b,
		this.element = a.element,
		this.target = a.options.inputTarget,
		this.domHandler = function (b) {
			k(a.options.enable, [a]) && c.handler(b)
		},
		this.init()
	}
	function y(a) {
		var b,
		c = a.options.inputClass;
		return new(b = c ? c : xa ? M : ya ? P : wa ? R : L)(a, z)
	}
	function z(a, b, c) {
		var d = c.pointers.length,
		e = c.changedPointers.length,
		f = b & Ea && d - e === 0,
		g = b & (Ga | Ha) && d - e === 0;
		c.isFirst = !!f,
		c.isFinal = !!g,
		f && (a.session = {}),
		c.eventType = b,
		A(a, c),
		a.emit("hammer.input", c),
		a.recognize(c),
		a.session.prevInput = c
	}
	function A(a, b) {
		var c = a.session,
		d = b.pointers,
		e = d.length;
		c.firstInput || (c.firstInput = D(b)),
		e > 1 && !c.firstMultiple ? c.firstMultiple = D(b) : 1 === e && (c.firstMultiple = !1);
		var f = c.firstInput,
		g = c.firstMultiple,
		h = g ? g.center : f.center,
		i = b.center = E(d);
		b.timeStamp = ra(),
		b.deltaTime = b.timeStamp - f.timeStamp,
		b.angle = I(h, i),
		b.distance = H(h, i),
		B(c, b),
		b.offsetDirection = G(b.deltaX, b.deltaY);
		var j = F(b.deltaTime, b.deltaX, b.deltaY);
		b.overallVelocityX = j.x,
		b.overallVelocityY = j.y,
		b.overallVelocity = qa(j.x) > qa(j.y) ? j.x : j.y,
		b.scale = g ? K(g.pointers, d) : 1,
		b.rotation = g ? J(g.pointers, d) : 0,
		b.maxPointers = c.prevInput ? b.pointers.length > c.prevInput.maxPointers ? b.pointers.length : c.prevInput.maxPointers : b.pointers.length,
		C(c, b);
		var k = a.element;
		o(b.srcEvent.target, k) && (k = b.srcEvent.target),
		b.target = k
	}
	function B(a, b) {
		var c = b.center,
		d = a.offsetDelta || {},
		e = a.prevDelta || {},
		f = a.prevInput || {};
		b.eventType !== Ea && f.eventType !== Ga || (e = a.prevDelta = {
				x: f.deltaX || 0,
				y: f.deltaY || 0
			}, d = a.offsetDelta = {
				x: c.x,
				y: c.y
			}),
		b.deltaX = e.x + (c.x - d.x),
		b.deltaY = e.y + (c.y - d.y)
	}
	function C(a, b) {
		var c,
		e,
		f,
		g,
		h = a.lastInterval || b,
		i = b.timeStamp - h.timeStamp;
		if (b.eventType != Ha && (i > Da || h.velocity === d)) {
			var j = b.deltaX - h.deltaX,
			k = b.deltaY - h.deltaY,
			l = F(i, j, k);
			e = l.x,
			f = l.y,
			c = qa(l.x) > qa(l.y) ? l.x : l.y,
			g = G(j, k),
			a.lastInterval = b
		} else
			c = h.velocity, e = h.velocityX, f = h.velocityY, g = h.direction;
		b.velocity = c,
		b.velocityX = e,
		b.velocityY = f,
		b.direction = g
	}
	function D(a) {
		for (var b = [], c = 0; c < a.pointers.length; )
			b[c] = {
				clientX: pa(a.pointers[c].clientX),
				clientY: pa(a.pointers[c].clientY)
			},
		c++;
		return {
			timeStamp: ra(),
			pointers: b,
			center: E(b),
			deltaX: a.deltaX,
			deltaY: a.deltaY
		}
	}
	function E(a) {
		var b = a.length;
		if (1 === b)
			return {
				x: pa(a[0].clientX),
				y: pa(a[0].clientY)
			};
		for (var c = 0, d = 0, e = 0; b > e; )
			c += a[e].clientX, d += a[e].clientY, e++;
		return {
			x: pa(c / b),
			y: pa(d / b)
		}
	}
	function F(a, b, c) {
		return {
			x: b / a || 0,
			y: c / a || 0
		}
	}
	function G(a, b) {
		return a === b ? Ia : qa(a) >= qa(b) ? 0 > a ? Ja : Ka : 0 > b ? La : Ma
	}
	function H(a, b, c) {
		c || (c = Qa);
		var d = b[c[0]] - a[c[0]],
		e = b[c[1]] - a[c[1]];
		return Math.sqrt(d * d + e * e)
	}
	function I(a, b, c) {
		c || (c = Qa);
		var d = b[c[0]] - a[c[0]],
		e = b[c[1]] - a[c[1]];
		return 180 * Math.atan2(e, d) / Math.PI
	}
	function J(a, b) {
		return I(b[1], b[0], Ra) + I(a[1], a[0], Ra)
	}
	function K(a, b) {
		return H(b[0], b[1], Ra) / H(a[0], a[1], Ra)
	}
	function L() {
		this.evEl = Ta,
		this.evWin = Ua,
		this.pressed = !1,
		x.apply(this, arguments)
	}
	function M() {
		this.evEl = Xa,
		this.evWin = Ya,
		x.apply(this, arguments),
		this.store = this.manager.session.pointerEvents = []
	}
	function N() {
		this.evTarget = $a,
		this.evWin = _a,
		this.started = !1,
		x.apply(this, arguments)
	}
	function O(a, b) {
		var c = s(a.touches),
		d = s(a.changedTouches);
		return b & (Ga | Ha) && (c = t(c.concat(d), "identifier", !0)),
		[c, d]
	}
	function P() {
		this.evTarget = bb,
		this.targetIds = {},
		x.apply(this, arguments)
	}
	function Q(a, b) {
		var c = s(a.touches),
		d = this.targetIds;
		if (b & (Ea | Fa) && 1 === c.length)
			return d[c[0].identifier] = !0, [c, c];
		var e,
		f,
		g = s(a.changedTouches),
		h = [],
		i = this.target;
		if (f = c.filter(function (a) {
				return o(a.target, i)
			}), b === Ea)
			for (e = 0; e < f.length; )
				d[f[e].identifier] = !0, e++;
		for (e = 0; e < g.length; )
			d[g[e].identifier] && h.push(g[e]), b & (Ga | Ha) && delete d[g[e].identifier], e++;
		return h.length ? [t(f.concat(h), "identifier", !0), h] : void 0
	}
	function R() {
		x.apply(this, arguments);
		var a = j(this.handler, this);
		this.touch = new P(this.manager, a),
		this.mouse = new L(this.manager, a),
		this.primaryTouch = null,
		this.lastTouches = []
	}
	function S(a, b) {
		a & Ea ? (this.primaryTouch = b.changedPointers[0].identifier, T.call(this, b)) : a & (Ga | Ha) && T.call(this, b)
	}
	function T(a) {
		var b = a.changedPointers[0];
		if (b.identifier === this.primaryTouch) {
			var c = {
				x: b.clientX,
				y: b.clientY
			};
			this.lastTouches.push(c);
			var d = this.lastTouches,
			e = function () {
				var a = d.indexOf(c);
				a > -1 && d.splice(a, 1)
			};
			setTimeout(e, cb)
		}
	}
	function U(a) {
		for (var b = a.srcEvent.clientX, c = a.srcEvent.clientY, d = 0; d < this.lastTouches.length; d++) {
			var e = this.lastTouches[d],
			f = Math.abs(b - e.x),
			g = Math.abs(c - e.y);
			if (db >= f && db >= g)
				return !0
		}
		return !1
	}
	function V(a, b) {
		this.manager = a,
		this.set(b)
	}
	function W(a) {
		if (p(a, jb))
			return jb;
		var b = p(a, kb),
		c = p(a, lb);
		return b && c ? jb : b || c ? b ? kb : lb : p(a, ib) ? ib : hb
	}
	function X() {
		if (!fb)
			return !1;
		var b = {},
		c = a.CSS && a.CSS.supports;
		return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function (d) {
			b[d] = c ? a.CSS.supports("touch-action", d) : !0
		}),
		b
	}
	function Y(a) {
		this.options = la({}, this.defaults, a || {}),
		this.id = v(),
		this.manager = null,
		this.options.enable = l(this.options.enable, !0),
		this.state = nb,
		this.simultaneous = {},
		this.requireFail = []
	}
	function Z(a) {
		return a & sb ? "cancel" : a & qb ? "end" : a & pb ? "move" : a & ob ? "start" : ""
	}
	function $(a) {
		return a == Ma ? "down" : a == La ? "up" : a == Ja ? "left" : a == Ka ? "right" : ""
	}
	function _(a, b) {
		var c = b.manager;
		return c ? c.get(a) : a
	}
	function aa() {
		Y.apply(this, arguments)
	}
	function ba() {
		aa.apply(this, arguments),
		this.pX = null,
		this.pY = null
	}
	function ca() {
		aa.apply(this, arguments)
	}
	function da() {
		Y.apply(this, arguments),
		this._timer = null,
		this._input = null
	}
	function ea() {
		aa.apply(this, arguments)
	}
	function fa() {
		aa.apply(this, arguments)
	}
	function ga() {
		Y.apply(this, arguments),
		this.pTime = !1,
		this.pCenter = !1,
		this._timer = null,
		this._input = null,
		this.count = 0
	}
	function ha(a, b) {
		return b = b || {},
		b.recognizers = l(b.recognizers, ha.defaults.preset),
		new ia(a, b)
	}
	function ia(a, b) {
		this.options = la({}, ha.defaults, b || {}),
		this.options.inputTarget = this.options.inputTarget || a,
		this.handlers = {},
		this.session = {},
		this.recognizers = [],
		this.oldCssProps = {},
		this.element = a,
		this.input = y(this),
		this.touchAction = new V(this, this.options.touchAction),
		ja(this, !0),
		g(this.options.recognizers, function (a) {
			var b = this.add(new a[0](a[1]));
			a[2] && b.recognizeWith(a[2]),
			a[3] && b.requireFailure(a[3])
		}, this)
	}
	function ja(a, b) {
		var c = a.element;
		if (c.style) {
			var d;
			g(a.options.cssProps, function (e, f) {
				d = u(c.style, f),
				b ? (a.oldCssProps[d] = c.style[d], c.style[d] = e) : c.style[d] = a.oldCssProps[d] || ""
			}),
			b || (a.oldCssProps = {})
		}
	}
	function ka(a, c) {
		var d = b.createEvent("Event");
		d.initEvent(a, !0, !0),
		d.gesture = c,
		c.target.dispatchEvent(d)
	}
	var la,
	ma = ["", "webkit", "Moz", "MS", "ms", "o"],
	na = b.createElement("div"),
	oa = "function",
	pa = Math.round,
	qa = Math.abs,
	ra = Date.now;
	la = "function" != typeof Object.assign ? function (a) {
		if (a === d || null === a)
			throw new TypeError("Cannot convert undefined or null to object");
		for (var b = Object(a), c = 1; c < arguments.length; c++) {
			var e = arguments[c];
			if (e !== d && null !== e)
				for (var f in e)
					e.hasOwnProperty(f) && (b[f] = e[f])
		}
		return b
	}
	 : Object.assign;
	var sa = h(function (a, b, c) {
		for (var e = Object.keys(b), f = 0; f < e.length; )
			(!c || c && a[e[f]] === d) && (a[e[f]] = b[e[f]]), f++;
		return a
	}, "extend", "Use `assign`."),
	ta = h(function (a, b) {
		return sa(a, b, !0)
	}, "merge", "Use `assign`."),
	ua = 1,
	va = /mobile|tablet|ip(ad|hone|od)|android/i,
	wa = "ontouchstart" in a,
	xa = u(a, "PointerEvent") !== d,
	ya = wa && va.test(navigator.userAgent),
	za = "touch",
	Aa = "pen",
	Ba = "mouse",
	Ca = "kinect",
	Da = 25,
	Ea = 1,
	Fa = 2,
	Ga = 4,
	Ha = 8,
	Ia = 1,
	Ja = 2,
	Ka = 4,
	La = 8,
	Ma = 16,
	Na = Ja | Ka,
	Oa = La | Ma,
	Pa = Na | Oa,
	Qa = ["x", "y"],
	Ra = ["clientX", "clientY"];
	x.prototype = {
		handler: function () {},
		init: function () {
			this.evEl && m(this.element, this.evEl, this.domHandler),
			this.evTarget && m(this.target, this.evTarget, this.domHandler),
			this.evWin && m(w(this.element), this.evWin, this.domHandler)
		},
		destroy: function () {
			this.evEl && n(this.element, this.evEl, this.domHandler),
			this.evTarget && n(this.target, this.evTarget, this.domHandler),
			this.evWin && n(w(this.element), this.evWin, this.domHandler)
		}
	};
	var Sa = {
		mousedown: Ea,
		mousemove: Fa,
		mouseup: Ga
	},
	Ta = "mousedown",
	Ua = "mousemove mouseup";
	i(L, x, {
		handler: function (a) {
			var b = Sa[a.type];
			b & Ea && 0 === a.button && (this.pressed = !0),
			b & Fa && 1 !== a.which && (b = Ga),
			this.pressed && (b & Ga && (this.pressed = !1), this.callback(this.manager, b, {
					pointers: [a],
					changedPointers: [a],
					pointerType: Ba,
					srcEvent: a
				}))
		}
	});
	var Va = {
		pointerdown: Ea,
		pointermove: Fa,
		pointerup: Ga,
		pointercancel: Ha,
		pointerout: Ha
	},
	Wa = {
		2: za,
		3: Aa,
		4: Ba,
		5: Ca
	},
	Xa = "pointerdown",
	Ya = "pointermove pointerup pointercancel";
	a.MSPointerEvent && !a.PointerEvent && (Xa = "MSPointerDown", Ya = "MSPointerMove MSPointerUp MSPointerCancel"),
	i(M, x, {
		handler: function (a) {
			var b = this.store,
			c = !1,
			d = a.type.toLowerCase().replace("ms", ""),
			e = Va[d],
			f = Wa[a.pointerType] || a.pointerType,
			g = f == za,
			h = r(b, a.pointerId, "pointerId");
			e & Ea && (0 === a.button || g) ? 0 > h && (b.push(a), h = b.length - 1) : e & (Ga | Ha) && (c = !0),
			0 > h || (b[h] = a, this.callback(this.manager, e, {
					pointers: b,
					changedPointers: [a],
					pointerType: f,
					srcEvent: a
				}), c && b.splice(h, 1))
		}
	});
	var Za = {
		touchstart: Ea,
		touchmove: Fa,
		touchend: Ga,
		touchcancel: Ha
	},
	$a = "touchstart",
	_a = "touchstart touchmove touchend touchcancel";
	i(N, x, {
		handler: function (a) {
			var b = Za[a.type];
			if (b === Ea && (this.started = !0), this.started) {
				var c = O.call(this, a, b);
				b & (Ga | Ha) && c[0].length - c[1].length === 0 && (this.started = !1),
				this.callback(this.manager, b, {
					pointers: c[0],
					changedPointers: c[1],
					pointerType: za,
					srcEvent: a
				})
			}
		}
	});
	var ab = {
		touchstart: Ea,
		touchmove: Fa,
		touchend: Ga,
		touchcancel: Ha
	},
	bb = "touchstart touchmove touchend touchcancel";
	i(P, x, {
		handler: function (a) {
			var b = ab[a.type],
			c = Q.call(this, a, b);
			c && this.callback(this.manager, b, {
				pointers: c[0],
				changedPointers: c[1],
				pointerType: za,
				srcEvent: a
			})
		}
	});
	var cb = 2500,
	db = 25;
	i(R, x, {
		handler: function (a, b, c) {
			var d = c.pointerType == za,
			e = c.pointerType == Ba;
			if (!(e && c.sourceCapabilities && c.sourceCapabilities.firesTouchEvents)) {
				if (d)
					S.call(this, b, c);
				else if (e && U.call(this, c))
					return;
				this.callback(a, b, c)
			}
		},
		destroy: function () {
			this.touch.destroy(),
			this.mouse.destroy()
		}
	});
	var eb = u(na.style, "touchAction"),
	fb = eb !== d,
	gb = "compute",
	hb = "auto",
	ib = "manipulation",
	jb = "none",
	kb = "pan-x",
	lb = "pan-y",
	mb = X();
	V.prototype = {
		set: function (a) {
			a == gb && (a = this.compute()),
			fb && this.manager.element.style && mb[a] && (this.manager.element.style[eb] = a),
			this.actions = a.toLowerCase().trim()
		},
		update: function () {
			this.set(this.manager.options.touchAction)
		},
		compute: function () {
			var a = [];
			return g(this.manager.recognizers, function (b) {
				k(b.options.enable, [b]) && (a = a.concat(b.getTouchAction()))
			}),
			W(a.join(" "))
		},
		preventDefaults: function (a) {
			var b = a.srcEvent,
			c = a.offsetDirection;
			if (this.manager.session.prevented)
				return void b.preventDefault();
			var d = this.actions,
			e = p(d, jb) && !mb[jb],
			f = p(d, lb) && !mb[lb],
			g = p(d, kb) && !mb[kb];
			if (e) {
				var h = 1 === a.pointers.length,
				i = a.distance < 2,
				j = a.deltaTime < 250;
				if (h && i && j)
					return
			}
			return g && f ? void 0 : e || f && c & Na || g && c & Oa ? this.preventSrc(b) : void 0
		},
		preventSrc: function (a) {
			this.manager.session.prevented = !0,
			a.preventDefault()
		}
	};
	var nb = 1,
	ob = 2,
	pb = 4,
	qb = 8,
	rb = qb,
	sb = 16,
	tb = 32;
	Y.prototype = {
		defaults: {},
		set: function (a) {
			return la(this.options, a),
			this.manager && this.manager.touchAction.update(),
			this
		},
		recognizeWith: function (a) {
			if (f(a, "recognizeWith", this))
				return this;
			var b = this.simultaneous;
			return a = _(a, this),
			b[a.id] || (b[a.id] = a, a.recognizeWith(this)),
			this
		},
		dropRecognizeWith: function (a) {
			return f(a, "dropRecognizeWith", this) ? this : (a = _(a, this), delete this.simultaneous[a.id], this)
		},
		requireFailure: function (a) {
			if (f(a, "requireFailure", this))
				return this;
			var b = this.requireFail;
			return a = _(a, this),
			-1 === r(b, a) && (b.push(a), a.requireFailure(this)),
			this
		},
		dropRequireFailure: function (a) {
			if (f(a, "dropRequireFailure", this))
				return this;
			a = _(a, this);
			var b = r(this.requireFail, a);
			return b > -1 && this.requireFail.splice(b, 1),
			this
		},
		hasRequireFailures: function () {
			return this.requireFail.length > 0
		},
		canRecognizeWith: function (a) {
			return !!this.simultaneous[a.id]
		},
		emit: function (a) {
			function b(b) {
				c.manager.emit(b, a)
			}
			var c = this,
			d = this.state;
			qb > d && b(c.options.event + Z(d)),
			b(c.options.event),
			a.additionalEvent && b(a.additionalEvent),
			d >= qb && b(c.options.event + Z(d))
		},
		tryEmit: function (a) {
			return this.canEmit() ? this.emit(a) : void(this.state = tb)
		},
		canEmit: function () {
			for (var a = 0; a < this.requireFail.length; ) {
				if (!(this.requireFail[a].state & (tb | nb)))
					return !1;
				a++
			}
			return !0
		},
		recognize: function (a) {
			var b = la({}, a);
			return k(this.options.enable, [this, b]) ? (this.state & (rb | sb | tb) && (this.state = nb), this.state = this.process(b), void(this.state & (ob | pb | qb | sb) && this.tryEmit(b))) : (this.reset(), void(this.state = tb))
		},
		process: function (a) {},
		getTouchAction: function () {},
		reset: function () {}
	},
	i(aa, Y, {
		defaults: {
			pointers: 1
		},
		attrTest: function (a) {
			var b = this.options.pointers;
			return 0 === b || a.pointers.length === b
		},
		process: function (a) {
			var b = this.state,
			c = a.eventType,
			d = b & (ob | pb),
			e = this.attrTest(a);
			return d && (c & Ha || !e) ? b | sb : d || e ? c & Ga ? b | qb : b & ob ? b | pb : ob : tb
		}
	}),
	i(ba, aa, {
		defaults: {
			event: "pan",
			threshold: 10,
			pointers: 1,
			direction: Pa
		},
		getTouchAction: function () {
			var a = this.options.direction,
			b = [];
			return a & Na && b.push(lb),
			a & Oa && b.push(kb),
			b
		},
		directionTest: function (a) {
			var b = this.options,
			c = !0,
			d = a.distance,
			e = a.direction,
			f = a.deltaX,
			g = a.deltaY;
			return e & b.direction || (b.direction & Na ? (e = 0 === f ? Ia : 0 > f ? Ja : Ka, c = f != this.pX, d = Math.abs(a.deltaX)) : (e = 0 === g ? Ia : 0 > g ? La : Ma, c = g != this.pY, d = Math.abs(a.deltaY))),
			a.direction = e,
			c && d > b.threshold && e & b.direction
		},
		attrTest: function (a) {
			return aa.prototype.attrTest.call(this, a) && (this.state & ob || !(this.state & ob) && this.directionTest(a))
		},
		emit: function (a) {
			this.pX = a.deltaX,
			this.pY = a.deltaY;
			var b = $(a.direction);
			b && (a.additionalEvent = this.options.event + b),
			this._super.emit.call(this, a)
		}
	}),
	i(ca, aa, {
		defaults: {
			event: "pinch",
			threshold: 0,
			pointers: 2
		},
		getTouchAction: function () {
			return [jb]
		},
		attrTest: function (a) {
			return this._super.attrTest.call(this, a) && (Math.abs(a.scale - 1) > this.options.threshold || this.state & ob)
		},
		emit: function (a) {
			if (1 !== a.scale) {
				var b = a.scale < 1 ? "in" : "out";
				a.additionalEvent = this.options.event + b
			}
			this._super.emit.call(this, a)
		}
	}),
	i(da, Y, {
		defaults: {
			event: "press",
			pointers: 1,
			time: 251,
			threshold: 9
		},
		getTouchAction: function () {
			return [hb]
		},
		process: function (a) {
			var b = this.options,
			c = a.pointers.length === b.pointers,
			d = a.distance < b.threshold,
			f = a.deltaTime > b.time;
			if (this._input = a, !d || !c || a.eventType & (Ga | Ha) && !f)
				this.reset();
			else if (a.eventType & Ea)
				this.reset(), this._timer = e(function () {
					this.state = rb,
					this.tryEmit()
				}, b.time, this);
			else if (a.eventType & Ga)
				return rb;
			return tb
		},
		reset: function () {
			clearTimeout(this._timer)
		},
		emit: function (a) {
			this.state === rb && (a && a.eventType & Ga ? this.manager.emit(this.options.event + "up", a) : (this._input.timeStamp = ra(), this.manager.emit(this.options.event, this._input)))
		}
	}),
	i(ea, aa, {
		defaults: {
			event: "rotate",
			threshold: 0,
			pointers: 2
		},
		getTouchAction: function () {
			return [jb]
		},
		attrTest: function (a) {
			return this._super.attrTest.call(this, a) && (Math.abs(a.rotation) > this.options.threshold || this.state & ob)
		}
	}),
	i(fa, aa, {
		defaults: {
			event: "swipe",
			threshold: 10,
			velocity: .3,
			direction: Na | Oa,
			pointers: 1
		},
		getTouchAction: function () {
			return ba.prototype.getTouchAction.call(this)
		},
		attrTest: function (a) {
			var b,
			c = this.options.direction;
			return c & (Na | Oa) ? b = a.overallVelocity : c & Na ? b = a.overallVelocityX : c & Oa && (b = a.overallVelocityY),
			this._super.attrTest.call(this, a) && c & a.offsetDirection && a.distance > this.options.threshold && a.maxPointers == this.options.pointers && qa(b) > this.options.velocity && a.eventType & Ga
		},
		emit: function (a) {
			var b = $(a.offsetDirection);
			b && this.manager.emit(this.options.event + b, a),
			this.manager.emit(this.options.event, a)
		}
	}),
	i(ga, Y, {
		defaults: {
			event: "tap",
			pointers: 1,
			taps: 1,
			interval: 300,
			time: 250,
			threshold: 9,
			posThreshold: 10
		},
		getTouchAction: function () {
			return [ib]
		},
		process: function (a) {
			var b = this.options,
			c = a.pointers.length === b.pointers,
			d = a.distance < b.threshold,
			f = a.deltaTime < b.time;
			if (this.reset(), a.eventType & Ea && 0 === this.count)
				return this.failTimeout();
			if (d && f && c) {
				if (a.eventType != Ga)
					return this.failTimeout();
				var g = this.pTime ? a.timeStamp - this.pTime < b.interval : !0,
				h = !this.pCenter || H(this.pCenter, a.center) < b.posThreshold;
				this.pTime = a.timeStamp,
				this.pCenter = a.center,
				h && g ? this.count += 1 : this.count = 1,
				this._input = a;
				var i = this.count % b.taps;
				if (0 === i)
					return this.hasRequireFailures() ? (this._timer = e(function () {
							this.state = rb,
							this.tryEmit()
						}, b.interval, this), ob) : rb
			}
			return tb
		},
		failTimeout: function () {
			return this._timer = e(function () {
				this.state = tb
			}, this.options.interval, this),
			tb
		},
		reset: function () {
			clearTimeout(this._timer)
		},
		emit: function () {
			this.state == rb && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input))
		}
	}),
	ha.VERSION = "2.0.8",
	ha.defaults = {
		domEvents: !1,
		touchAction: gb,
		enable: !0,
		inputTarget: null,
		inputClass: null,
		preset: [[ea, {
					enable: !1
				}
			], [ca, {
					enable: !1
				}, ["rotate"]], [fa, {
					direction: Na
				}
			], [ba, {
					direction: Na
				}, ["swipe"]], [ga], [ga, {
					event: "doubletap",
					taps: 2
				}, ["tap"]], [da]],
		cssProps: {
			userSelect: "none",
			touchSelect: "none",
			touchCallout: "none",
			contentZooming: "none",
			userDrag: "none",
			tapHighlightColor: "rgba(0,0,0,0)"
		}
	};
	var ub = 1,
	vb = 2;
	ia.prototype = {
		set: function (a) {
			return la(this.options, a),
			a.touchAction && this.touchAction.update(),
			a.inputTarget && (this.input.destroy(), this.input.target = a.inputTarget, this.input.init()),
			this
		},
		stop: function (a) {
			this.session.stopped = a ? vb : ub
		},
		recognize: function (a) {
			var b = this.session;
			if (!b.stopped) {
				this.touchAction.preventDefaults(a);
				var c,
				d = this.recognizers,
				e = b.curRecognizer;
				(!e || e && e.state & rb) && (e = b.curRecognizer = null);
				for (var f = 0; f < d.length; )
					c = d[f], b.stopped === vb || e && c != e && !c.canRecognizeWith(e) ? c.reset() : c.recognize(a), !e && c.state & (ob | pb | qb) && (e = b.curRecognizer = c), f++
			}
		},
		get: function (a) {
			if (a instanceof Y)
				return a;
			for (var b = this.recognizers, c = 0; c < b.length; c++)
				if (b[c].options.event == a)
					return b[c];
			return null
		},
		add: function (a) {
			if (f(a, "add", this))
				return this;
			var b = this.get(a.options.event);
			return b && this.remove(b),
			this.recognizers.push(a),
			a.manager = this,
			this.touchAction.update(),
			a
		},
		remove: function (a) {
			if (f(a, "remove", this))
				return this;
			if (a = this.get(a)) {
				var b = this.recognizers,
				c = r(b, a);
				-1 !== c && (b.splice(c, 1), this.touchAction.update())
			}
			return this
		},
		on: function (a, b) {
			if (a !== d && b !== d) {
				var c = this.handlers;
				return g(q(a), function (a) {
					c[a] = c[a] || [],
					c[a].push(b)
				}),
				this
			}
		},
		off: function (a, b) {
			if (a !== d) {
				var c = this.handlers;
				return g(q(a), function (a) {
					b ? c[a] && c[a].splice(r(c[a], b), 1) : delete c[a]
				}),
				this
			}
		},
		emit: function (a, b) {
			this.options.domEvents && ka(a, b);
			var c = this.handlers[a] && this.handlers[a].slice();
			if (c && c.length) {
				b.type = a,
				b.preventDefault = function () {
					b.srcEvent.preventDefault()
				};
				for (var d = 0; d < c.length; )
					c[d](b), d++
			}
		},
		destroy: function () {
			this.element && ja(this, !1),
			this.handlers = {},
			this.session = {},
			this.input.destroy(),
			this.element = null
		}
	},
	la(ha, {
		INPUT_START: Ea,
		INPUT_MOVE: Fa,
		INPUT_END: Ga,
		INPUT_CANCEL: Ha,
		STATE_POSSIBLE: nb,
		STATE_BEGAN: ob,
		STATE_CHANGED: pb,
		STATE_ENDED: qb,
		STATE_RECOGNIZED: rb,
		STATE_CANCELLED: sb,
		STATE_FAILED: tb,
		DIRECTION_NONE: Ia,
		DIRECTION_LEFT: Ja,
		DIRECTION_RIGHT: Ka,
		DIRECTION_UP: La,
		DIRECTION_DOWN: Ma,
		DIRECTION_HORIZONTAL: Na,
		DIRECTION_VERTICAL: Oa,
		DIRECTION_ALL: Pa,
		Manager: ia,
		Input: x,
		TouchAction: V,
		TouchInput: P,
		MouseInput: L,
		PointerEventInput: M,
		TouchMouseInput: R,
		SingleTouchInput: N,
		Recognizer: Y,
		AttrRecognizer: aa,
		Tap: ga,
		Pan: ba,
		Swipe: fa,
		Pinch: ca,
		Rotate: ea,
		Press: da,
		on: m,
		off: n,
		each: g,
		merge: ta,
		extend: sa,
		assign: la,
		inherit: i,
		bindFn: j,
		prefixed: u
	});
	var wb = "undefined" != typeof a ? a : "undefined" != typeof self ? self : {};
	wb.Hammer = ha,
	"function" == typeof define && define.amd ? define(function () {
		return ha
	}) : "undefined" != typeof module && module.exports ? module.exports = ha : a[c] = ha
}
(window, document, "Hammer");
/******************************************************************************
rtree.js -Non-Recursive Javascript R-Tree Library
Version 1.4.2, Aug 22, 2014

https://github.com/leaflet-extras/RTree.
(2020-03-30 Note: use 'define&&define.amd)window.RTree=e();{var' to replace 'define&&define.amd)define(e);else{var')
 ******************************************************************************/

!function (e) {
	if ("object" == typeof exports)
		module.exports = e();
	else if ("function" == typeof define && define.amd)
		window.RTree = e(); {
		var f;
		"undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self),
		f.RTree = e()
	}
}
(function () {
	var define,
	module,
	exports;
	return function e(t, n, r) {
		function s(o, u) {
			if (!n[o]) {
				if (!t[o]) {
					var a = typeof require == "function" && require;
					if (!u && a)
						return a(o, !0);
					if (i)
						return i(o, !0);
					throw new Error("Cannot find module '" + o + "'")
				}
				var f = n[o] = {
					exports: {}
				};
				t[o][0].call(f.exports, function (e) {
					var n = t[o][1][e];
					return s(n ? n : e)
				}, f, f.exports, e, t, n, r)
			}
			return n[o].exports
		}
		var i = typeof require == "function" && require;
		for (var o = 0; o < r.length; o++)
			s(r[o]);
		return s
	}
	({
		1: [function (_dereq_, module, exports) {
				"use strict";
				var rectangle = _dereq_("./rectangle");
				var bbox = function (ar, obj) {
					if (obj && obj.bbox) {
						return {
							leaf: obj,
							x: obj.bbox[0],
							y: obj.bbox[1],
							w: obj.bbox[2] - obj.bbox[0],
							h: obj.bbox[3] - obj.bbox[1]
						}
					}
					var len = ar.length;
					var i = 0;
					var a = new Array(len);
					while (i < len) {
						a[i] = [ar[i][0], ar[i][1]];
						i++
					}
					var first = a[0];
					len = a.length;
					i = 1;
					var temp = {
						min: [].concat(first),
						max: [].concat(first)
					};
					while (i < len) {
						if (a[i][0] < temp.min[0]) {
							temp.min[0] = a[i][0]
						} else if (a[i][0] > temp.max[0]) {
							temp.max[0] = a[i][0]
						}
						if (a[i][1] < temp.min[1]) {
							temp.min[1] = a[i][1]
						} else if (a[i][1] > temp.max[1]) {
							temp.max[1] = a[i][1]
						}
						i++
					}
					var out = {
						x: temp.min[0],
						y: temp.min[1],
						w: temp.max[0] - temp.min[0],
						h: temp.max[1] - temp.min[1]
					};
					if (obj) {
						out.leaf = obj
					}
					return out
				};
				var geoJSON = {};
				geoJSON.point = function (obj, self) {
					return self.insertSubtree({
						x: obj.geometry.coordinates[0],
						y: obj.geometry.coordinates[1],
						w: 0,
						h: 0,
						leaf: obj
					}, self.root)
				};
				geoJSON.multiPointLineString = function (obj, self) {
					return self.insertSubtree(bbox(obj.geometry.coordinates, obj), self.root)
				};
				geoJSON.multiLineStringPolygon = function (obj, self) {
					return self.insertSubtree(bbox(Array.prototype.concat.apply([], obj.geometry.coordinates), obj), self.root)
				};
				geoJSON.multiPolygon = function (obj, self) {
					return self.insertSubtree(bbox(Array.prototype.concat.apply([], Array.prototype.concat.apply([], obj.geometry.coordinates)), obj), self.root)
				};
				geoJSON.makeRec = function (obj) {
					return rectangle(obj.x, obj.y, obj.w, obj.h)
				};
				geoJSON.geometryCollection = function (obj, self) {
					if (obj.bbox) {
						return self.insertSubtree({
							leaf: obj,
							x: obj.bbox[0],
							y: obj.bbox[1],
							w: obj.bbox[2] - obj.bbox[0],
							h: obj.bbox[3] - obj.bbox[1]
						}, self.root)
					}
					var geos = obj.geometry.geometries;
					var i = 0;
					var len = geos.length;
					var temp = [];
					var g;
					while (i < len) {
						g = geos[i];
						switch (g.type) {
						case "Point":
							temp.push(geoJSON.makeRec({
									x: g.coordinates[0],
									y: g.coordinates[1],
									w: 0,
									h: 0
								}));
							break;
						case "MultiPoint":
							temp.push(geoJSON.makeRec(bbox(g.coordinates)));
							break;
						case "LineString":
							temp.push(geoJSON.makeRec(bbox(g.coordinates)));
							break;
						case "MultiLineString":
							temp.push(geoJSON.makeRec(bbox(Array.prototype.concat.apply([], g.coordinates))));
							break;
						case "Polygon":
							temp.push(geoJSON.makeRec(bbox(Array.prototype.concat.apply([], g.coordinates))));
							break;
						case "MultiPolygon":
							temp.push(geoJSON.makeRec(bbox(Array.prototype.concat.apply([], Array.prototype.concat.apply([], g.coordinates)))));
							break;
						case "GeometryCollection":
							geos = geos.concat(g.geometries);
							len = geos.length;
							break
						}
						i++
					}
					var first = temp[0];
					i = 1;
					len = temp.length;
					while (i < len) {
						first.expand(temp[i]);
						i++
					}
					return self.insertSubtree({
						leaf: obj,
						x: first.x(),
						y: first.y(),
						h: first.h(),
						w: first.w()
					}, self.root)
				};
				exports.geoJSON = function (prelim) {
					var that = this;
					var features,
					feature;
					if (Array.isArray(prelim)) {
						features = prelim.slice()
					} else if (prelim.features && Array.isArray(prelim.features)) {
						features = prelim.features.slice()
					} else if (prelim instanceof Object) {
						features = [prelim]
					} else {
						throw "this isn't what we're looking for"
					}
					var len = features.length;
					var i = 0;
					while (i < len) {
						feature = features[i];
						if (feature.type === "Feature") {
							switch (feature.geometry.type) {
							case "Point":
								geoJSON.point(feature, that);
								break;
							case "MultiPoint":
								geoJSON.multiPointLineString(feature, that);
								break;
							case "LineString":
								geoJSON.multiPointLineString(feature, that);
								break;
							case "MultiLineString":
								geoJSON.multiLineStringPolygon(feature, that);
								break;
							case "Polygon":
								geoJSON.multiLineStringPolygon(feature, that);
								break;
							case "MultiPolygon":
								geoJSON.multiPolygon(feature, that);
								break;
							case "GeometryCollection":
								geoJSON.geometryCollection(feature, that);
								break
							}
						}
						i++
					}
				};
				exports.bbox = function () {
					var x1,
					y1,
					x2,
					y2;
					switch (arguments.length) {
					case 1:
						x1 = arguments[0][0][0];
						y1 = arguments[0][0][1];
						x2 = arguments[0][1][0];
						y2 = arguments[0][1][1];
						break;
					case 2:
						x1 = arguments[0][0];
						y1 = arguments[0][1];
						x2 = arguments[1][0];
						y2 = arguments[1][1];
						break;
					case 4:
						x1 = arguments[0];
						y1 = arguments[1];
						x2 = arguments[2];
						y2 = arguments[3];
						break
					}
					return this.search({
						x: x1,
						y: y1,
						w: x2 - x1,
						h: y2 - y1
					})
				}
			}, {
				"./rectangle": 3
			}
		],
		2: [function (_dereq_, module, exports) {
				"use strict";
				var RTree = _dereq_("./rtree");
				var geojson = _dereq_("./geojson");
				RTree.prototype.bbox = geojson.bbox;
				RTree.prototype.geoJSON = geojson.geoJSON;
				RTree.Rectangle = _dereq_("./rectangle");
				module.exports = RTree
			}, {
				"./geojson": 1,
				"./rectangle": 3,
				"./rtree": 4
			}
		],
		3: [function (_dereq_, module, exports) {
				"use strict";
				function Rectangle(x, y, w, h) {
					if (!(this instanceof Rectangle)) {
						return new Rectangle(x, y, w, h)
					}
					var x2,
					y2,
					p;
					if (x.x) {
						w = x.w;
						h = x.h;
						y = x.y;
						if (x.w !== 0 && !x.w && x.x2) {
							w = x.x2 - x.x;
							h = x.y2 - x.y
						} else {
							w = x.w;
							h = x.h
						}
						x = x.x;
						x2 = x + w;
						y2 = y + h;
						p = h + w ? false : true
					} else {
						x2 = x + w;
						y2 = y + h;
						p = h + w ? false : true
					}
					this.x1 = this.x = function () {
						return x
					};
					this.y1 = this.y = function () {
						return y
					};
					this.x2 = function () {
						return x2
					};
					this.y2 = function () {
						return y2
					};
					this.w = function () {
						return w
					};
					this.h = function () {
						return h
					};
					this.p = function () {
						return p
					};
					this.overlap = function (a) {
						if (p || a.p()) {
							return x <= a.x2() && x2 >= a.x() && y <= a.y2() && y2 >= a.y()
						}
						return x < a.x2() && x2 > a.x() && y < a.y2() && y2 > a.y()
					};
					this.expand = function (a) {
						var nx,
						ny;
						var ax = a.x();
						var ay = a.y();
						var ax2 = a.x2();
						var ay2 = a.y2();
						if (x > ax) {
							nx = ax
						} else {
							nx = x
						}
						if (y > ay) {
							ny = ay
						} else {
							ny = y
						}
						if (x2 > ax2) {
							w = x2 - nx
						} else {
							w = ax2 - nx
						}
						if (y2 > ay2) {
							h = y2 - ny
						} else {
							h = ay2 - ny
						}
						x = nx;
						y = ny;
						return this
					}
				}
				Rectangle.overlapRectangle = function (a, b) {
					if (a.h === 0 && a.w === 0 || b.h === 0 && b.w === 0) {
						return a.x <= b.x + b.w && a.x + a.w >= b.x && a.y <= b.y + b.h && a.y + a.h >= b.y
					} else {
						return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y
					}
				};
				Rectangle.containsRectangle = function (a, b) {
					return a.x + a.w <= b.x + b.w && a.x >= b.x && a.y + a.h <= b.y + b.h && a.y >= b.y
				};
				Rectangle.expandRectangle = function (a, b) {
					var nx,
					ny;
					var axw = a.x + a.w;
					var bxw = b.x + b.w;
					var ayh = a.y + a.h;
					var byh = b.y + b.h;
					if (a.x > b.x) {
						nx = b.x
					} else {
						nx = a.x
					}
					if (a.y > b.y) {
						ny = b.y
					} else {
						ny = a.y
					}
					if (axw > bxw) {
						a.w = axw - nx
					} else {
						a.w = bxw - nx
					}
					if (ayh > byh) {
						a.h = ayh - ny
					} else {
						a.h = byh - ny
					}
					a.x = nx;
					a.y = ny;
					return a
				};
				Rectangle.makeMBR = function (nodes, rect) {
					if (!nodes.length) {
						return {
							x: 0,
							y: 0,
							w: 0,
							h: 0
						}
					}
					rect = rect || {};
					rect.x = nodes[0].x;
					rect.y = nodes[0].y;
					rect.w = nodes[0].w;
					rect.h = nodes[0].h;
					for (var i = 1, len = nodes.length; i < len; i++) {
						Rectangle.expandRectangle(rect, nodes[i])
					}
					return rect
				};
				Rectangle.squarifiedRatio = function (l, w, fill) {
					var lperi = (l + w) / 2;
					var larea = l * w;
					var lgeo = larea / (lperi * lperi);
					return larea * fill / lgeo
				};
				module.exports = Rectangle
			}, {}
		],
		4: [function (_dereq_, module, exports) {
				"use strict";
				var rectangle = _dereq_("./rectangle");
				function RTree(width) {
					if (!(this instanceof RTree)) {
						return new RTree(width)
					}
					var minWidth = 3;
					var maxWidth = 6;
					if (!isNaN(width)) {
						minWidth = Math.floor(width / 2);
						maxWidth = width
					}
					var rootTree = {
						x: 0,
						y: 0,
						w: 0,
						h: 0,
						id: "root",
						nodes: []
					};
					this.root = rootTree;
					var flatten = function (tree) {
						var todo = tree.slice();
						var done = [];
						var current;
						while (todo.length) {
							current = todo.pop();
							if (current.nodes) {
								todo = todo.concat(current.nodes)
							} else if (current.leaf) {
								done.push(current)
							}
						}
						return done
					};
					var removeSubtree = function (rect, obj, root) {
						var hitStack = [];
						var countStack = [];
						var retArray = [];
						var currentDepth = 1;
						var tree,
						i,
						ltree;
						if (!rect || !rectangle.overlapRectangle(rect, root)) {
							return retArray
						}
						var retObj = {
							x: rect.x,
							y: rect.y,
							w: rect.w,
							h: rect.h,
							target: obj
						};
						countStack.push(root.nodes.length);
						hitStack.push(root);
						while (hitStack.length > 0) {
							tree = hitStack.pop();
							i = countStack.pop() - 1;
							if ("target" in retObj) {
								while (i >= 0) {
									ltree = tree.nodes[i];
									if (rectangle.overlapRectangle(retObj, ltree)) {
										if (retObj.target && "leaf" in ltree && ltree.leaf === retObj.target || !retObj.target && ("leaf" in ltree || rectangle.containsRectangle(ltree, retObj))) {
											if ("nodes" in ltree) {
												retArray = flatten(tree.nodes.splice(i, 1))
											} else {
												retArray = tree.nodes.splice(i, 1)
											}
											rectangle.makeMBR(tree.nodes, tree);
											delete retObj.target;
											break
										} else if ("nodes" in ltree) {
											currentDepth++;
											countStack.push(i);
											hitStack.push(tree);
											tree = ltree;
											i = ltree.nodes.length
										}
									}
									i--
								}
							} else if ("nodes" in retObj) {
								tree.nodes.splice(i + 1, 1);
								if (tree.nodes.length > 0) {
									rectangle.makeMBR(tree.nodes, tree)
								}
								for (var t = 0; t < retObj.nodes.length; t++) {
									insertSubtree(retObj.nodes[t], tree)
								}
								retObj.nodes = [];
								if (hitStack.length === 0 && tree.nodes.length <= 1) {
									retObj.nodes = searchSubtree(tree, true, retObj.nodes, tree);
									tree.nodes = [];
									hitStack.push(tree);
									countStack.push(1)
								} else if (hitStack.length > 0 && tree.nodes.length < minWidth) {
									retObj.nodes = searchSubtree(tree, true, retObj.nodes, tree);
									tree.nodes = []
								} else {
									delete retObj.nodes
								}
							} else {
								rectangle.makeMBR(tree.nodes, tree)
							}
							currentDepth -= 1
						}
						return retArray
					};
					var chooseLeafSubtree = function (rect, root) {
						var bestChoiceIndex = -1;
						var bestChoiceStack = [];
						var bestChoiceArea;
						var first = true;
						bestChoiceStack.push(root);
						var nodes = root.nodes;
						while (first || bestChoiceIndex !== -1) {
							if (first) {
								first = false
							} else {
								bestChoiceStack.push(nodes[bestChoiceIndex]);
								nodes = nodes[bestChoiceIndex].nodes;
								bestChoiceIndex = -1
							}
							for (var i = nodes.length - 1; i >= 0; i--) {
								var ltree = nodes[i];
								if ("leaf" in ltree) {
									bestChoiceIndex = -1;
									break
								}
								var oldLRatio = rectangle.squarifiedRatio(ltree.w, ltree.h, ltree.nodes.length + 1);
								var nw = Math.max(ltree.x + ltree.w, rect.x + rect.w) - Math.min(ltree.x, rect.x);
								var nh = Math.max(ltree.y + ltree.h, rect.y + rect.h) - Math.min(ltree.y, rect.y);
								var lratio = rectangle.squarifiedRatio(nw, nh, ltree.nodes.length + 2);
								if (bestChoiceIndex < 0 || Math.abs(lratio - oldLRatio) < bestChoiceArea) {
									bestChoiceArea = Math.abs(lratio - oldLRatio);
									bestChoiceIndex = i
								}
							}
						}
						return bestChoiceStack
					};
					var linearSplit = function (nodes) {
						var n = pickLinear(nodes);
						while (nodes.length > 0) {
							pickNext(nodes, n[0], n[1])
						}
						return n
					};
					var pickNext = function (nodes, a, b) {
						var areaA = rectangle.squarifiedRatio(a.w, a.h, a.nodes.length + 1);
						var areaB = rectangle.squarifiedRatio(b.w, b.h, b.nodes.length + 1);
						var highAreaDelta;
						var highAreaNode;
						var lowestGrowthGroup;
						for (var i = nodes.length - 1; i >= 0; i--) {
							var l = nodes[i];
							var newAreaA = {};
							newAreaA.x = Math.min(a.x, l.x);
							newAreaA.y = Math.min(a.y, l.y);
							newAreaA.w = Math.max(a.x + a.w, l.x + l.w) - newAreaA.x;
							newAreaA.h = Math.max(a.y + a.h, l.y + l.h) - newAreaA.y;
							var changeNewAreaA = Math.abs(rectangle.squarifiedRatio(newAreaA.w, newAreaA.h, a.nodes.length + 2) - areaA);
							var newAreaB = {};
							newAreaB.x = Math.min(b.x, l.x);
							newAreaB.y = Math.min(b.y, l.y);
							newAreaB.w = Math.max(b.x + b.w, l.x + l.w) - newAreaB.x;
							newAreaB.h = Math.max(b.y + b.h, l.y + l.h) - newAreaB.y;
							var changeNewAreaB = Math.abs(rectangle.squarifiedRatio(newAreaB.w, newAreaB.h, b.nodes.length + 2) - areaB);
							if (!highAreaNode || !highAreaDelta || Math.abs(changeNewAreaB - changeNewAreaA) < highAreaDelta) {
								highAreaNode = i;
								highAreaDelta = Math.abs(changeNewAreaB - changeNewAreaA);
								lowestGrowthGroup = changeNewAreaB < changeNewAreaA ? b : a
							}
						}
						var tempNode = nodes.splice(highAreaNode, 1)[0];
						if (a.nodes.length + nodes.length + 1 <= minWidth) {
							a.nodes.push(tempNode);
							rectangle.expandRectangle(a, tempNode)
						} else if (b.nodes.length + nodes.length + 1 <= minWidth) {
							b.nodes.push(tempNode);
							rectangle.expandRectangle(b, tempNode)
						} else {
							lowestGrowthGroup.nodes.push(tempNode);
							rectangle.expandRectangle(lowestGrowthGroup, tempNode)
						}
					};
					var pickLinear = function (nodes) {
						var lowestHighX = nodes.length - 1;
						var highestLowX = 0;
						var lowestHighY = nodes.length - 1;
						var highestLowY = 0;
						var t1,
						t2;
						for (var i = nodes.length - 2; i >= 0; i--) {
							var l = nodes[i];
							if (l.x > nodes[highestLowX].x) {
								highestLowX = i
							} else if (l.x + l.w < nodes[lowestHighX].x + nodes[lowestHighX].w) {
								lowestHighX = i
							}
							if (l.y > nodes[highestLowY].y) {
								highestLowY = i
							} else if (l.y + l.h < nodes[lowestHighY].y + nodes[lowestHighY].h) {
								lowestHighY = i
							}
						}
						var dx = Math.abs(nodes[lowestHighX].x + nodes[lowestHighX].w - nodes[highestLowX].x);
						var dy = Math.abs(nodes[lowestHighY].y + nodes[lowestHighY].h - nodes[highestLowY].y);
						if (dx > dy) {
							if (lowestHighX > highestLowX) {
								t1 = nodes.splice(lowestHighX, 1)[0];
								t2 = nodes.splice(highestLowX, 1)[0]
							} else {
								t2 = nodes.splice(highestLowX, 1)[0];
								t1 = nodes.splice(lowestHighX, 1)[0]
							}
						} else {
							if (lowestHighY > highestLowY) {
								t1 = nodes.splice(lowestHighY, 1)[0];
								t2 = nodes.splice(highestLowY, 1)[0]
							} else {
								t2 = nodes.splice(highestLowY, 1)[0];
								t1 = nodes.splice(lowestHighY, 1)[0]
							}
						}
						return [{
								x: t1.x,
								y: t1.y,
								w: t1.w,
								h: t1.h,
								nodes: [t1]
							}, {
								x: t2.x,
								y: t2.y,
								w: t2.w,
								h: t2.h,
								nodes: [t2]
							}
						]
					};
					var attachData = function (node, moreTree) {
						node.nodes = moreTree.nodes;
						node.x = moreTree.x;
						node.y = moreTree.y;
						node.w = moreTree.w;
						node.h = moreTree.h;
						return node
					};
					var searchSubtree = function (rect, returnNode, returnArray, root) {
						var hitStack = [];
						if (!rectangle.overlapRectangle(rect, root)) {
							return returnArray
						}
						hitStack.push(root.nodes);
						while (hitStack.length > 0) {
							var nodes = hitStack.pop();
							for (var i = nodes.length - 1; i >= 0; i--) {
								var ltree = nodes[i];
								if (rectangle.overlapRectangle(rect, ltree)) {
									if ("nodes" in ltree) {
										hitStack.push(ltree.nodes)
									} else if ("leaf" in ltree) {
										if (!returnNode) {
											returnArray.push(ltree.leaf)
										} else {
											returnArray.push(ltree)
										}
									}
								}
							}
						}
						return returnArray
					};
					var insertSubtree = function (node, root) {
						var bc;
						if (root.nodes.length === 0) {
							root.x = node.x;
							root.y = node.y;
							root.w = node.w;
							root.h = node.h;
							root.nodes.push(node);
							return
						}
						var treeStack = chooseLeafSubtree(node, root);
						var retObj = node;
						var pbc;
						while (treeStack.length > 0) {
							if (bc && "nodes" in bc && bc.nodes.length === 0) {
								pbc = bc;
								bc = treeStack.pop();
								for (var t = 0; t < bc.nodes.length; t++) {
									if (bc.nodes[t] === pbc || bc.nodes[t].nodes.length === 0) {
										bc.nodes.splice(t, 1);
										break
									}
								}
							} else {
								bc = treeStack.pop()
							}
							if ("leaf" in retObj || "nodes" in retObj || Array.isArray(retObj)) {
								if (Array.isArray(retObj)) {
									for (var ai = 0; ai < retObj.length; ai++) {
										rectangle.expandRectangle(bc, retObj[ai])
									}
									bc.nodes = bc.nodes.concat(retObj)
								} else {
									rectangle.expandRectangle(bc, retObj);
									bc.nodes.push(retObj)
								}
								if (bc.nodes.length <= maxWidth) {
									retObj = {
										x: bc.x,
										y: bc.y,
										w: bc.w,
										h: bc.h
									}
								} else {
									var a = linearSplit(bc.nodes);
									retObj = a;
									if (treeStack.length < 1) {
										bc.nodes.push(a[0]);
										treeStack.push(bc);
										retObj = a[1]
									}
								}
							} else {
								rectangle.expandRectangle(bc, retObj);
								retObj = {
									x: bc.x,
									y: bc.y,
									w: bc.w,
									h: bc.h
								}
							}
						}
					};
					this.insertSubtree = insertSubtree;
					this.getTree = function () {
						return rootTree
					};
					this.setTree = function (newTree, where) {
						if (!where) {
							where = rootTree
						}
						return attachData(where, newTree)
					};
					this.search = function (rect, returnNode, returnArray) {
						returnArray = returnArray || [];
						return searchSubtree(rect, returnNode, returnArray, rootTree)
					};
					var removeArea = function (rect) {
						var numberDeleted = 1,
						retArray = [],
						deleted;
						while (numberDeleted > 0) {
							deleted = removeSubtree(rect, false, rootTree);
							numberDeleted = deleted.length;
							retArray = retArray.concat(deleted)
						}
						return retArray
					};
					var removeObj = function (rect, obj) {
						var retArray = removeSubtree(rect, obj, rootTree);
						return retArray
					};
					this.remove = function (rect, obj) {
						if (!obj || typeof obj === "function") {
							return removeArea(rect, obj)
						} else {
							return removeObj(rect, obj)
						}
					};
					this.insert = function (rect, obj) {
						var retArray = insertSubtree({
							x: rect.x,
							y: rect.y,
							w: rect.w,
							h: rect.h,
							leaf: obj
						}, rootTree);
						return retArray
					}
				}
				RTree.prototype.toJSON = function (printing) {
					return JSON.stringify(this.root, false, printing)
				};
				RTree.fromJSON = function (json) {
					var rt = new RTree;
					rt.setTree(JSON.parse(json));
					return rt
				};
				module.exports = RTree;
				if (typeof Array.isArray !== "function") {
					Array.isArray = function (a) {
						return typeof a === "object" && {}
						.toString.call(a) === "[object Array]"
					}
				}
			}, {
				"./rectangle": 3
			}
		]
	}, {}, [2])(2)
});
var ouilib;
(function () {
	function a(b, d) {
		if (!b) {
			b = {};
		}
		var b = b || {};
		b.config = b.config || {
			defaultViewportWidth: undefined,
			defaultViewportHeight: undefined,
			defaultLayoutDir: undefined,
			defaultLogLevel: "FINEST",
			defaultLogHandler: undefined,
			embeddedResourcesMap: undefined,
			preventTimerStart: false,
			frameRate: undefined,
			environment: undefined,
			base: ".",
			catchAllEventListener: undefined,
			altText: "",
			hiDPI: true,
			silverlight: undefined
		};
		b.setUp = function (e) {
			var f = b.config;
			if (b.equalIgnoreCase(b.RTL, f.defaultLayoutDir)) {
				b.layoutDir = b.RTL;
				b.filters._onLayoutDir(b.layoutDir);
			} else {
				b.layoutDir = b.LTR;
			}
			if (b.equalIgnoreCase(b.EnvironmentEnum.MOBILE, f.environment)) {
				b.environment = b.EnvironmentEnum.MOBILE;
			} else {
				b.environment = b.EnvironmentEnum.DESKTOP;
			}
			b.deviceOrientation = b.DeviceOrientationEnum.LANDSCAPE;
			b.viewportWidth = 0;
			if (b.isPositiveNumber(f.defaultViewportWidth)) {
				b.viewportWidth = f.defaultViewportWidth;
			}
			b.viewportHeight = 0;
			if (b.isPositiveNumber(f.defaultViewportHeight)) {
				b.viewportHeight = f.defaultViewportHeight;
			}
			b.viewportBounds = {
				x: 0,
				y: 0,
				width: b.viewportWidth,
				height: b.viewportHeight
			};
			b.tree = new b.scene.Tree();
			b.timer = new b.timing.Timer(f.frameRate);
			b.tree._setContainerImpl(e);
			b.rootNode = b.tree.userLayer;
			b.focusManager = new b.focus.FocusManager(b.rootNode);
			b.tooltipManager = new b.tooltip.TooltipManager();
			b.resourcesManager = new b.utils.ResourcesManager();
			b.rootNode.addEventListener(b.ViewEvents.USER_EVENTS_SUPPORTED, b.events.setUserEventsSupported);
			b.rootNode.addEventListener(b.ViewEvents.ABOUT_INFO_REQUEST, function (g) {
				g.returnValue = b.aboutInfo;
			});
			if (f.preventTimerStart !== true) {
				b.timer.start();
			}
		};
		(function () {
			b.NO_OP = function () {};
			b.BASE_VALUE = "base";
			b.FillEnum = {
				REMOVE: "REMOVE",
				FREEZE: "FREEZE",
				_LEGACY: "_LEGACY"
			};
			b.DEFAULT_TAG = "defaultTag";
			b.TAGS = {
				LAYOUT_DIR: "layoutDir",
				PAINT: "paint",
				GEOM: "geom",
				TRANSFO_SET: "transfoSet",
				TRANSFO: "transfo",
				SENSITIVITY: "sensitivity",
				VISIBILITY: "visibility",
				DISPLAY: "display",
				OPACITY: "opacity",
				NAME: "name",
				CLIP: "clip",
				CURSOR: "cursor",
				FOCUSABLE: "focusable",
				DESC: "desc",
				FILTER: "filter",
				LAYOUT: "layout",
				PREF_SIZE: "prefSize",
				SRC: "src",
				MARKER_START: "markerStart",
				MARKER_START_DATA: "markerStartData",
				MARKER_START_PAINT: "markerStartPaint",
				MARKER_END: "markerEnd",
				MARKER_END_DATA: "markerEndData",
				MARKER_END_PAINT: "markerEndPaint"
			};
			b.EnvironmentEnum = {
				DESKTOP: "DESKTOP",
				MOBILE: "MOBILE"
			};
			b.DeviceOrientationEnum = {
				LANDSCAPE: "LANDSCAPE",
				PORTRAIT: "PORTRAIT"
			};
			b.CursorType = {
				AUTO: "auto",
				DEFAULT: "default",
				MOVE: "move",
				POINTER: "pointer",
				TEXT: "text",
				WAIT: "wait",
				NONE: "none",
				HELP: "help",
				CROSSHAIR: "crosshair"
			};
			b.TextAlignEnum = {
				LINE_BEGIN: "LINE_BEGIN",
				CENTER: "CENTER",
				LINE_END: "LINE_END",
				JUSTIFY: "JUSTIFY"
			};
			b.LineCap = {
				BUTT: "butt",
				ROUND: "round",
				SQUARE: "square"
			};
			b.DirectionEnum = {
				UP: "UP",
				DOWN: "DOWN",
				LEFT: "LEFT",
				RIGHT: "RIGHT",
				TO_LINE_BEGIN: "TO_LINE_BEGIN",
				TO_LINE_END: "TO_LINE_END"
			};
			b.OrientationEnum = {
				VERTICAL: "VERTICAL",
				HORIZONTAL: "HORIZONTAL"
			};
			b.LineJoin = {
				MITER: "miter",
				ROUND: "round",
				BEVEL: "bevel"
			};
			b.FontWeightEnum = {
				NORMAL: "NORMAL",
				BOLD: "BOLD"
			};
			b.FontStyleEnum = {
				NORMAL: "NORMAL",
				ITALIC: "ITALIC"
			};
			b.LayoutDirEnum = {
				LTR: "LTR",
				RTL: "RTL"
			};
			b.LTR = "LTR";
			b.RTL = "RTL";
			b.NodeAlign = {
				TOP: 0,
				CENTER: 0.5,
				BOTTOM: 1,
				LINE_BEGIN: 0,
				LINE_END: 1
			};
			b._BoundsType = {
				DEFAULT: 0,
				LAYOUT: 1,
				RENDER: 2
			};
			b.KeyCode = {
				BACKSPACE: 8,
				TAB: 9,
				ENTER: 13,
				SHIFT: 16,
				CONTROL: 17,
				CAPS_LOCK: 20,
				ESC: 27,
				SPACEBAR: 32,
				PAGE_UP: 33,
				PAGE_DOWN: 34,
				END: 35,
				HOME: 36,
				LEFT_ARROW: 37,
				UP_ARROW: 38,
				RIGHT_ARROW: 39,
				DOWN_ARROW: 40,
				INSERT: 45,
				DELETE: 46,
				MULTIPLY: 106,
				PLUS: 107,
				MINUS: 109,
				DIVIDE: 111,
				DASH: 189,
				FORWARD_SLASH: 191,
				BACK_SLASH: 220
			};
			b.PreserveAspectRatioEnum = {
				NONE: "NONE",
				MIN: "MIN",
				MAX: "MAX"
			};
			b.WindingRuleEnum = {
				EVEN_ODD: "EVEN_ODD",
				NON_ZERO: "NON_ZERO"
			};
			b.AUTO = "AUTO";
			b.QuoteStyleEnum = {
				ENT_COMPAT: "ENT_COMPAT",
				ENT_QUOTES: "ENT_QUOTES",
				ENT_NOQUOTES: "ENT_NOQUOTES"
			};
			b.GENERIC_FONTS = {
				SERIF: "serif",
				SANS_SERIF: "sans-serif",
				CURSIVE: "cursive",
				MONOSPACE: "monospace"
			};
		}
			());
		b.LogLevel = {
			OFF: "OFF",
			ERROR: "ERROR",
			SEVERE: "SEVERE",
			WARNING: "WARNING",
			INFO: "INFO",
			FINEST: "FINEST",
			ALL: "ALL",
			LOG: "LOG"
		};
		var c;
		b.log = c = (function () {
			var o = b.LogLevel,
			f = {
				OFF: 0,
				SEVERE: 1,
				WARNING: 2,
				INFO: 3,
				FINEST: 4,
				ALL: 5
			},
			n = [],
			j = 0,
			i = [],
			p,
			l,
			h,
			e,
			k;
			p = function () {
				k.release();
			};
			function m(w, u) {
				var r = n,
				t,
				s,
				v = r.length;
				for (s = 0; s < v; s++) {
					t = r[s];
					if (typeof t === "function") {
						t.call(null, w, u);
					} else {
						t.log(w, u);
					}
				}
			}
			function q(s, r) {
				if (i.length === j) {
					i.shift();
				}
				i.push({
					level: s,
					message: r
				});
			}
			function g(s) {
				var r = o.INFO;
				if (typeof s === "string") {
					s = s.toUpperCase();
				}
				if (o.hasOwnProperty(s)) {
					r = o[s];
				}
				return r;
			}
			k = function (r, u, s) {
				var t,
				v;
				if (u) {
					r = g(r);
					if (u instanceof Error) {
						u = u.toString();
					}
					if (e) {
						u = e(u, s);
					}
					if (r === o.ERROR) {
						throw new Error(u);
					} else {
						t = f[h];
						v = f[r];
						if (v <= t) {
							if (j > 0) {
								q(r, u);
							} else {
								m(r, u);
							}
						}
					}
				}
			};
			k.setLevel = function (r) {
				h = g(r);
			};
			k.setFormatter = function (r) {
				if (typeof r === "function") {
					e = r;
				}
			};
			k.error = function (s, r) {
				k(o.ERROR, s, r);
			};
			k.severe = function (s, r) {
				k(o.SEVERE, s, r);
			};
			k.warn = k.warning = function (s, r) {
				k(o.WARNING, s, r);
			};
			k.info = function (s, r) {
				k(o.INFO, s, r);
			};
			k.finest = function (s, r) {
				k(o.FINEST, s, r);
			};
			k.addLogHandler = function (r) {
				if (typeof r === "function" || (r && typeof r.log === "function")) {
					n.push(r);
				}
			};
			k.delay = function (r, s) {
				if (l) {
					clearTimeout(l);
				}
				k.hold(s);
				l = setTimeout(p, r);
			};
			k.hold = function (r) {
				j = r > 0 ? r : 500;
			};
			k.release = function () {
				var r,
				s = i.length;
				if (s > 0) {
					m(o.LOG, ">>>> releasing " + s + " logs.");
					while (s--) {
						r = i.shift();
						m(r.level, r.message);
					}
					m(o.LOG, ">>>> end logs release");
				}
				j = 0;
			};
			k.setLevel(b.config.defaultLogLevel || b.LogLevel.FINEST);
			k.addLogHandler(b.config.defaultLogHandler);
			k.setFormatter(function (s, r) {
				if (r !== undefined) {
					if (r.constructor === Array) {
						s += "::" + r.join(",");
					} else {
						s += "::" + r;
					}
				}
				return s;
			});
			return k;
		}
				());
		(function () {
			b.errors = {
				ERR__MIX__INV_TARGET: "ERROR.\noui.mixin(target, source), target must be an instance of the Function or Object built-in classes.",
				ERR__MIX__INV_SRC: "ERROR.\noui.mixin(target, source), source must be an instance of the Object class.",
				ERR__EXT__INV_CHILD: "ERROR.\noui.extend(child, parent), child must be a valid Function instance.",
				ERR__EXT__INV_PARENT: "ERROR.\noui.extend(child, parent), parent must be a valid Function instance.",
				ERR__EXT__MULT_INHERIT: "ERROR.\noui.extend(child, parent) doesn't support multiple inheritance.",
				ERR__CONFIG__DUP_PROP: "ERROR.\n_copyConfigurationSupport(target, source), target configuration already defined = {0}",
				ERR__CONFIG__NO_DEFAULT: "ERROR.\n_copyConfigurationSupport(target, source), source configuration missing default value for {0}",
				ERR__DECL__INV_CLASS_DEF: "ERROR.\noui.declare(classDef), classDef must be an instance of the Object class.",
				ERR__DECL__INV_CLASS_NAME: "ERROR.\noui.declare(classDef), classDef must have a valid name.",
				ERR__DECL__DUP_CLASS: "ERROR.\noui.declare(classDef), class {0} already exists.",
				ERR__ABSTR_CLASS: "ERROR.\n{0} is abstract and cannot be instantiated.",
				ERR__NAMESPACE__ILLEGAL_CHAR: 'ERROR.\nIllegal characters found in  namespace name:"{0}".',
				ERR__NS__ROOT_FAIL: 'ERROR.\nThe require namespace "{0}" cannot be dynamically generated.',
				ERR__NS__INV_STR: 'ERROR.\nThe required namespace "{0}" is not a valid string, it is a {1}.',
				ERR__DEFS__INV: "ERROR.\nInvalid parameter {0} in definition function {1}",
				ERR__MTX__INV: "ERROR.\nMatrix is not invertible.",
				ERR__EVT__INV_HANDLER: "ILLEGAL ARGUMENT ERROR in handler().\nThe first parameter isn't a proper function or method or listener object.",
				ERR__PATH__MALFORMED_DATA: 'PATH PARSER ERROR.\nMalformed path data: "{0}".',
				ERR__PATH__NO_ARCTO: "PATH PARSER ERROR.\nThe arcTo commandd are not supported.",
				ERR__PATH__UNKNOWN_CMD: 'PATH PARSER ERROR.\nUnknown command "{0}" found at index {1}.',
				ERR__SMIL__INV_TIMER: "Invalid timer object specified to SMILSampler.",
				ERR__SMIL__INV_TREE: "Invalid tree object specified to SMILSampler.",
				ERR__SMIL__INV_CLOCK: "Invalid tree clock specified to SMILSampler.",
				ERR__SMIL__ILLEGAL_STATE: "Illegal State Exception",
				ERR__SMIL__ILLEGAL_ARG: "Illegal Argument Exception.",
				ERR__FORMAT__ILLEGAL_ARG_INDEX: "ILLEGAL ARGUMENT ERROR in oui.text.FormatElement.\n.The argIndex parameter must be a finite and strictly positive integer",
				ERR__FORMAT__ILLEGAL_ARG_VALUE: "ILLEGAL ARGUMENT ERROR in oui.text.FormatElement.\n.The specified value type doesn't match the type of one its corresponding format elements.",
				ERR__FORMAT__ILLEGAL_ARG_TYPE: "ILLEGAL ARGUMENT ERROR in oui.text.FormatElement.\n.The specified type is not supported {0}.",
				ERR__FORMAT__ILLEGAL_ARG_NO_STYLE: "ILLEGAL ARGUMENT ERROR in oui.text.FormatElement.\n.A format element cannot be created with a type but no style.",
				ERR__FORMAT__ILLEGAL_ARG_NO_TYPE: "ILLEGAL ARGUMENT ERROR in oui.text.FormatElement.\n.A format element cannot be created with a style but no type.",
				ERR__FORMAT__ILLEGAL_DATE_PATTERN: "ILLEGAL ARGUMENT ERROR in oui.text.DateFormatter.\n.{0} is not a supported pattern character.",
				ERR__LINEBREAK__ILLEGAL_REPLACE_ARG: "ILLEGAL ARGUMENT ERROR in LineBreakMeasurer.replaceText.\n.Both beginIndex and endIndex need to be in the [0, textLength] range, and beginIndex must be inferior or equal to endIndex.",
				ERR__TIMER__START: "ERROR.\nUnable to start the timer. It seems the current platformmight be missing an implementation of Timer class start method.",
				ERR__TIMER__STOP: "ERROR.\nUnable to start the timer. It seems the current platformmight be missing an implementation of Timer class start method.",
				ERR__BASE64: "ERROR.\nBase64 encoding exception.",
				ERR__JSONLOAD__INV_CLASS: "ILLEGAL ARGUMENT ERROR in addJSONLoaderSupport.\n.Only oui.scene.AbstractNode classes support JSON loading.",
				ERR__CNV__NO_SUPPORT: "ERROR.\n<canvas /> not supported in this environment.",
				ERR__CNV__INV_PATHDATA: "ERROR.\nThe specified path command is not supported by canvas.",
				ERR__FL__INV_CONTAINER: "ERROR.\nThe specified container is not a valid flash container. Please check that the container object is a flash.display.DisplayObjectContainer instance.",
				ERR__FL__INV_PATHDATA: "ERROR.\nFlashPath.drawFlashShape, the specified path command is not supported by flash.",
				ERR__FL__URLREQ: "ERROR.\nFail to navigate to URL={0}, with target={1}.\n{2}",
				ERR__J2D__INV_PATHDATA: "ERROR.\nThe specified path command is not handled in java2D.",
				ERR__SL__INV_CONTAINER: "ERROR.\nThe specified container is not a valid silverlight container.",
				ERR__SVG__INV_CONTAINER: "ERROR.\nThe specified container is not a valid SVG container.",
				ERR__VML__INV_CONTAINER: "ERROR.\nThe specified container is not a valid VML container. Please check that the specified ID corresponds to valid VML node.",
				WARN__HRCHY_REQ__INSERT_ANCEST: "HIERARCHY REQUEST.\nCalling node.insertBefore(elt, ref) with refan ancestor of elt.",
				WARN__HRCHY_REQ__INV_TYPE: "HIERARCHY REQUEST.\nCalling node.insertBefore(elt, ref) with refnot an allowed type of child for elt.",
				WARN__NOTFOUND__INSERT: "NOT FOUND.\nCalling node.insertBefore(elt, ref) with ref not a child of node.",
				WARN__NOTFOUND__REMOVE: "NOT FOUND.\nCalling node.removeChild(elt) with elt not a child of node.",
				WARN__EVT__NPE: "External event received but event is null.",
				WARN__PATH__NO_OVERRIDE: "getPathCommands should be overriden by children.",
				WARN__TEXT__NO_JUSTIFY: "Text justification not supported yet.",
				WARN__NET__UNSUPP: "oui.net.goToURL not supported by this platform.",
				WARN__SMIL__UNSUPP_TIME_VALUE: "oui.smil.TimedElement: only offset and event values are currently supported by this implementation of the SMIL specification timing engine.",
				WARN__JSONLOAD__DUP_TYPE: 'The JSON type "{0}" already exists, couldn\'t overwrite it.',
				WARN__JSONLOAD__EMPTY_STR: "The type property of a jsonDef must be a non-empty string.",
				WARN__RES_MGR__LOAD_FAIL: 'An error was encountered loading the resource: "{0}".\nCheck that this resource exists.',
				WARN__IO__HTML_FAIL: "HTML Exporter unsupported feature:\n{0}",
				WARN__CNV__REQ_ANIM_FRAME: "requestAnimationFrame is not available.",
				WARN__SL__NO_TEXT_JUSTIFY: "TextBlock justification not supported yet in Silverlight.",
				WARN__SL__NO_PATTERN: "PatternPaint not supported in Silverlight.",
				WARN__SVG__BBOX_FAIL: "An error was encountered in svgGetBBox.\n{0}",
				INFO__CONSTRAINT_FAIL: 'isValueInConstraint.\nGot an error "{0}", while trying to validate value {1} against {2} with {3} as context.',
				INFO__I18N__INVALID: "I18N. Cannot update translations from an undefined object.",
				INFO__I18N__MISSING: "I18N. Missing translation for property {0}.",
				INFO__I18N__UNSUPP: "I18N. {0} is not supported.",
				valueToJSON: function (j, l, h) {
					var e = "",
					k = "",
					g,
					f;
					if (l !== undefined) {
						k = l;
					}
					h = h || [];
					if (typeof j === "number" || typeof j === "boolean") {
						e += j;
					} else {
						if (typeof j === "string") {
							e += '"' + j + '"';
						} else {
							if (j === Object) {
								e += "Object";
							} else {
								if (j === String) {
									e += "String";
								} else {
									if (j === Number) {
										e += "Number";
									} else {
										if (j === Boolean) {
											e += "Boolean";
										} else {
											if (j === Function) {
												e += "Function";
											} else {
												if (j === Array) {
													e += "Array";
												} else {
													if (typeof j === "function") {
														e += "function ()";
													} else {
														if (j === null) {
															e += "null";
														} else {
															if (j === undefined) {
																e += "undefined";
															} else {
																if (j.constructor === Object) {
																	e += "{\n";
																	e += b.errors.toJSON(j, k + "    ", h);
																	e += "\n" + k + "}";
																} else {
																	if (j.constructor === Array) {
																		if (h.indexOf(j) >= 0) {
																			e = "recursive array reference";
																		} else {
																			h.push(j);
																			e += "[";
																			f = j.length;
																			if (f > 0) {
																				e += "\n";
																			}
																			for (g = 0; g < f; g++) {
																				e += k + "    " + b.errors.valueToJSON(j[g], k + "    ", h);
																				if (g !== f - 1) {
																					e += ",\n";
																				} else {
																					e += "\n" + k;
																				}
																			}
																			h.pop();
																			e += "]";
																		}
																	} else {
																		e += "unknown type (" + j.toString() + ")";
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
					return e;
				},
				toJSON: function (g, i, f) {
					var m = "",
					n = "",
					k,
					h,
					j,
					e,
					l;
					if (i !== undefined) {
						n = i;
					} else {
						m = "{\n";
						n = "    ";
					}
					f = f || [];
					if (f.indexOf(g) >= 0) {
						m = "recursive reference";
					} else {
						k = [];
						h = 0;
						j = "";
						e = null;
						f.push(g);
						for (e in g) {
							k[h++] = e;
						}
						k.sort();
						l = k.length;
						for (h = 0; h < l; h++) {
							e = k[h];
							j = n + e + ": ";
							m += j + b.errors.valueToJSON(g[e], n, f);
							if (h !== k.length - 1) {
								m += ",\n";
							}
						}
						if (!i) {
							m += "\n}\n";
						}
						f.pop();
					}
					return m;
				}
			};
			c.setFormatter(function (h, f) {
				var g,
				k,
				j = h,
				e = b.errors.valueToJSON;
				if (b.errors.hasOwnProperty(j)) {
					j = b.errors[j];
				}
				if (arguments.length >= 2) {
					if (f && f.constructor === Array) {
						for (g = 0, k = f.length;
							g < k; g++) {
							j = j.replace("{" + g + "}", e(f[g]));
						}
					} else {
						j = j.replace("{0}", e(f));
					}
				}
				return j;
			});
		}
			());
		b.ns = function (j) {
			var g,
			f,
			k,
			e,
			h,
			m,
			l;
			if (typeof j === "string") {
				for (h = 0, m = j.length; h < m; h++) {
					l = j.charAt(h);
					if ((l === ".") || ((l >= "a") && (l <= "z")) || ((l >= "A") && (l <= "Z")) || ((l >= "0") && (l <= "9"))) {
						continue;
					} else {
						c.error("ERR__NAMESPACE__ILLEGAL_CHAR", j);
					}
				}
				k = j.split(".");
				f = undefined;
				if (k[0] === "oui") {
					f = b;
				}
				if (f === undefined || f.length === 0) {
					c.error("ERR__NS__ROOT_FAIL", k[0]);
				}
				for (h = 1, m = k.length; h < m; h++) {
					e = k[h];
					f[e] = f[e] || {};
					f = f[e];
				}
				g = f;
			} else {
				c.error("ERR__NS__INV_STR", [j, typeof j]);
			}
			return g;
		};
		(function () {
			b.ns("oui.lang");
			b.lang.AspectSupport = {
				addAspect: function (g, f, j, i) {
					var h = this[g],
					e;
					if (b.isA(h, Function) && b.isA(f, Function)) {
						if (j === true) {
							e = function () {
								e.aspect.apply(this, arguments);
								return e.nextMethod.apply(this, arguments);
							};
						} else {
							e = function () {
								var k = h.apply(this, arguments);
								e.aspect.apply(this, arguments);
								return k;
							};
						}
						e.nextMethod = h;
						e.aspect = f;
						e.aspectName = i;
						this[g] = e;
					}
				},
				removeAspect: function (f, e) {
					var h = this[f],
					g;
					while (h) {
						if (h.aspect === e) {
							if (g) {
								g.nextMethod = h.nextMethod;
							} else {
								this[f] = h.nextMethod;
							}
							break;
						} else {
							g = h;
							h = h.nextMethod;
						}
					}
				}
			};
		}
			());
		(function () {
			b.ns("oui.lang");
			var f,
			e = {
				superClass: false,
				__configs: false,
				events: true
			};
			b.lang.Class = f = {
				mixin: function (i, h, g) {
					if (!i) {
						c.error("ERR__MIX__INV_TARGET");
					} else {
						if (!h || !f._isStrictObject(h)) {
							c.error("ERR__MIX__INV_SRC");
						} else {
							if (g === undefined) {
								g = true;
							}
							if (f._isClass(i)) {
								f.merge(i.prototype, h, g, e);
							} else {
								if (f._isStrictObject(i)) {
									f.merge(i, h, g, e);
								} else {
									c.error("ERR__MIX__INV_TARGET");
								}
							}
							f._copyConfigs(i, h);
						}
					}
				},
				_copyConfigs: function (l, j) {
					var n,
					m,
					i,
					g,
					h,
					k;
					if (j.__configs) {
						if (!l.__configs) {
							l.__configs = {};
						}
						for (n in j.__configs) {
							if (!l.__configs[n]) {
								b.lang.PropertiesUtil.addConfig(l, {}, n);
							}
							m = j.__configs[n].definitionClass.prototype;
							i = j.__configs[n].configClass.prototype;
							g = l.__configs[n].definitionClass.prototype;
							h = l.__configs[n].configClass.prototype;
							for (k in m) {
								if (!i[k]) {
									c.error("ERR__CONFIG__NO_DEFAULT", k);
								}
								if (!g[k] && !h[k]) {
									g[k] = m[k];
									h[k] = i[k];
								} else {
									c.error("ERR__CONFIG__DUP_PROP", k);
								}
							}
						}
					}
				},
				merge: function (k, h, g, j) {
					var i;
					j = j || {};
					for (i in h) {
						if (!j.hasOwnProperty(i) && (g || !k.hasOwnProperty(i))) {
							k[i] = h[i];
						} else {
							if (j[i] === true) {
								if (!k[i]) {
									k[i] = {};
								}
								this.merge(k[i], h[i], g, j);
							}
						}
					}
					if (h.hasOwnProperty("toString") && g) {
						k.toString = h.toString;
					}
				},
				extend: function (i, g) {
					var h;
					if (!i || !f._isClass(i)) {
						c.error("ERR__EXT__INV_CHILD");
					} else {
						if (!g || !f._isClass(g)) {
							c.error("ERR__EXT__INV_PARENT");
						} else {
							if (i.superClass !== undefined) {
								c.error("ERR__EXT__MULT_INHERIT");
							}
							h = function () {};
							h.prototype = g.prototype;
							i.prototype = new h();
							i.prototype.constructor = i;
							i.superClass = g;
						}
					}
				},
				isA: function (i, h) {
					var g = false;
					if (typeof i === "boolean") {
						g = (h === Boolean);
					} else {
						if (typeof i === "number") {
							g = (h === Number);
						} else {
							if (typeof i === "string") {
								g = (h === String);
							} else {
								if (h === Function) {
									g = (typeof i === "function" || i === Date);
								} else {
									if (h && i) {
										if (i.constructor === h) {
											g = true;
										} else {
											if (f._isClass(h) && i instanceof h) {
												g = true;
											} else {
												if (i.constructor !== undefined) {
													g = f._inheritsFrom(i.constructor, h);
												}
											}
										}
									}
								}
							}
						}
					}
					return g;
				},
				isAny: function (h) {
					var k = arguments.length,
					g = false,
					j;
					for (j = 1; j < k; j++) {
						if (b.isA(h, arguments[j])) {
							g = true;
							break;
						}
					}
					return g;
				},
				_isStrictObject: function (g) {
					return g.constructor === Object;
				},
				_isClass: function (g) {
					return (g.constructor === Function || (b.as3Class !== undefined && g.constructor === b.as3Class));
				},
				_inheritsFrom: function (j, i) {
					var g = false,
					h = j.superClass;
					if (j === i) {
						g = true;
					} else {
						if (h !== undefined) {
							g = f._inheritsFrom(h, i);
						}
					}
					return g;
				},
				declare: function (l) {
					var m,
					h,
					o,
					j,
					k,
					p,
					g;
					if (!b.isA(l, Object)) {
						c.error("ERR__DECL__INV_CLASS_DEF");
					}
					m = l.name;
					if (!b.isA(m, String) || m.indexOf(".") < 0) {
						c.error("ERR__DECL__INV_CLASS_NAME");
					}
					j = m.lastIndexOf(".");
					h = b.ns(m.substr(0, j));
					m = m.substr(j + 1);
					if (l.isAbstract === true) {
						o = function () {
							c.error("ERR__ABSTR_CLASS", l.name);
						};
					} else {
						o = function () {
							this.init.apply(this, arguments);
						};
					}
					if (h[m] !== undefined) {
						c.error("ERR__DECL__DUP_CLASS", l.name);
					}
					h[m] = o;
					if (b.isA(l.extend, Function)) {
						b.extend(o, l.extend);
					}
					if (b.isA(l.mixins, Array)) {
						for (k = 0, p = l.mixins.length;
							k < p; k++) {
							b.mixin(o, l.mixins[k]);
						}
					}
					g = [{
							name: "styleDef",
							call: b.addStyleSupport
						}, {
							name: "modelDef",
							call: b.addModelSupport
						}, {
							name: "propertiesDef",
							call: b.addPropertiesSupport
						}, {
							name: "resourcesDef",
							call: b.addI18nSupport
						}, {
							name: "jsonDef",
							call: b.addJSONLoaderSupport
						}, {
							name: "eventsDef",
							call: b.addEventsSupport
						}
					];
					for (k = 0, p = g.length; k < p; k++) {
						if (b.isA(l[g[k].name], Object)) {
							g[k].call(o, l[g[k].name]);
						}
					}
					if (b.isA(l.membersDef, Object)) {
						b.mixin(o, l.membersDef);
					}
					return o;
				}
			};
			b.merge = f.merge;
			b.extend = f.extend;
			b.mixin = f.mixin;
			b.isA = f.isA;
			b.isAny = f.isAny;
			b.declare = f.declare;
		}
			());
		(function () {
			b.ns("oui.lang");
			b.mixin(b, {
				isChar: function (e) {
					return typeof e === "string" && e.length === 1;
				},
				isStringNotEmpty: function (e) {
					return typeof e === "string" && e.length > 0;
				},
				isValueInEnum: function (f, e) {
					return typeof f === "string" && e !== undefined && e.hasOwnProperty(f);
				},
				isPositiveNumber: function (f, e) {
					return typeof f === "number" && (e === true ? f > 0 : f >= 0);
				},
				isFiniteNumber: function (e) {
					return typeof e === "number" && isFinite(e);
				},
				isFinitePositiveNumber: function (f, e) {
					return typeof f === "number" && isFinite(f) && (e === true ? f > 0 : f >= 0);
				},
				isNumberInRange: function (g, e, h) {
					var f;
					if (h === true) {
						f = b.isArrayOfType(e, {
							type: Number
						}) && e.length === 2 && !isNaN(e[0]) && !isNaN(e[1]);
					} else {
						f = true;
					}
					return f && typeof g === "number" && !isNaN(g) && g >= e[0] && g <= e[1];
				},
				isFunctionWithArgCount: function (e, f) {
					return typeof e === "function" && e.length === f;
				},
				isArrayOfType: function (f, g, l, m, k) {
					var e = true,
					j,
					h;
					if (g === undefined || g === null || g.type === undefined) {
						e = false;
					} else {
						if (f && f.constructor === Array) {
							j = f.length;
							if (l !== undefined) {
								if (k === true && typeof l !== "number") {
									e = false;
								}
								if (j < l) {
									e = false;
								}
							}
							if (m !== undefined) {
								if (k === true && typeof m !== "number") {
									e = false;
								}
								if (j > m) {
									e = false;
								}
							}
							for (h = 0;
								h < j && e === true; h++) {
								e = b.isValueValid(f[h], g);
							}
						} else {
							e = false;
						}
					}
					return e;
				},
				isArrayOfProperties: function (l, e, f, m, k) {
					var n = true,
					h = null,
					j,
					g;
					if (e === undefined || e === null) {
						n = false;
					} else {
						if (l && l.constructor === Array) {
							j = l.length;
							if (f !== undefined) {
								if (k === true && typeof f !== "number") {
									n = false;
								}
								if (j < f) {
									n = false;
								}
							}
							if (m !== undefined) {
								if (k === true && typeof m !== "number") {
									n = false;
								}
								if (j > m) {
									n = false;
								}
							}
							for (g = 0;
								g < j && n === true; g++) {
								h = l[g];
								n = h !== undefined && h !== null && h.constructor === Object && b.isObjectValid(h, e, true);
							}
						} else {
							n = false;
						}
					}
					return n;
				},
				isMapOfType: function (h, f) {
					var e = true,
					g;
					if (f === undefined || f === null || f.type === undefined) {
						e = false;
					} else {
						if (typeof h === "object") {
							for (g in h) {
								if (h.hasOwnProperty(g)) {
									e = b.isValueValid(h[g], f);
								}
							}
						} else {
							e = false;
						}
					}
					return e;
				},
				isMapOfProperties: function (k, g, h, f, i) {
					var e = false,
					j;
					if (g && k && k.constructor === Object) {
						if (typeof h !== "boolean") {
							h = true;
						}
						e = true;
						for (j in k) {
							if (k.hasOwnProperty(j)) {
								e = b.isObjectValid(k[j], g, h, f);
								if (e === false && i === true) {
									e = b.isMapOfProperties(k[j], g, h, f, i);
								}
								if (e === false) {
									break;
								}
							}
						}
					}
					return e;
				},
				isObjectValid: function (l, k, h, i) {
					var n = false,
					f = false,
					m = false,
					e,
					j,
					g;
					if (k !== undefined && l !== undefined && k !== null && l !== null) {
						for (e in k) {
							if (k[e] !== undefined) {
								j = l[e];
								g = k[e];
								if (j !== undefined) {
									f = b.isValueValid(j, g, h);
									n = f;
								} else {
									m = m || !l.hasOwnProperty(e);
									n = !h;
								}
								if (n !== true) {
									break;
								}
							}
						}
						if (n === true && h === false && i === true && m) {
							if (f === true) {
								for (e in k) {
									if (l.hasOwnProperty(e) === false) {
										g = k[e];
										l[e] = g.defaultValue;
									}
								}
							} else {
								n = false;
							}
						}
					}
					return n;
				},
				inheritsFrom: function (h, i, f) {
					var e = false,
					g = true;
					if (f !== false) {
						g = b.isA(i, Function);
					}
					if (g && b.isA(h, Function)) {
						e = b.lang.Class._inheritsFrom(h, i);
					}
					return e;
				}
			});
		}
			());
		(function () {
			b.ns("oui.lang");
			var e = b.QuoteStyleEnum,
			f = "(&amp;|&lt;|&gt;|&quot;|&#039;|&#8230;)",
			g = new RegExp(f, "gi"),
			h = new RegExp("^" + f + "$", "i");
			b.mixin(b, {
				currentTimeMillis: function () {
					return new Date().getTime();
				},
				equalIgnoreCase: function (k, j) {
					var i = false;
					if (typeof k === "string" && typeof j === "string") {
						i = (k.toLowerCase() === j.toLowerCase());
					}
					return i;
				},
				trim: function (i) {
					return i.replace(/^\s+|\s+$/g, "");
				},
				arrayRemove: function (o, l, k) {
					var j,
					m = o.length;
					for (j = m - 1; j >= 0; j--) {
						if (o[j] === l) {
							o.splice(j, 1);
							if (k === false) {
								break;
							}
						}
					}
					return o;
				},
				hasOwnValue: function (l, n, k) {
					var m,
					j = false,
					i;
					if (l !== undefined) {
						if (typeof n === "string" && k === true) {
							i = n.toLowerCase();
							for (m in l) {
								if (l.hasOwnProperty(m) && l[m].toLowerCase() === i) {
									j = true;
									break;
								}
							}
						} else {
							for (m in l) {
								if (l.hasOwnProperty(m) && l[m] === n) {
									j = true;
									break;
								}
							}
						}
					}
					return j;
				},
				supportsEvents: function (i) {
					return i !== null && i !== undefined && b.isA(i.addEventListener, Function);
				},
				getValidIndex: function (j, l) {
					var m,
					k;
					if (j < 0) {
						k = j % l;
						m = (k === 0) ? 0 : l + (j % l);
					} else {
						if (j > 0) {
							m = (j < l) ? j : j % l;
						} else {
							m = 0;
						}
					}
					return m;
				},
				isValueOfType: function (n, m, o) {
					var i = false,
					l,
					k;
					if (m === Object) {
						i = true;
					} else {
						if (n !== undefined && n !== null && m !== undefined && m !== null) {
							if (m === String || m === Number || m === Boolean || m === Array || m === Date || m === Function) {
								i = (n.constructor === m);
							} else {
								if (m.constructor === Object && n.constructor === Object) {
									i = (b.isObjectValid(n, m, o) === true);
								} else {
									if (m.constructor === Function) {
										i = b.isA(n, m);
									} else {
										if (m.constructor === Array) {
											k = m.length;
											for (l = 0; l < k; l++) {
												if (n === m[l]) {
													i = true;
													break;
												}
											}
										}
									}
								}
							}
						}
					}
					return i;
				},
				isValueInConstraint: function (m, o, k) {
					var l = null,
					j = null,
					i = true;
					if (o) {
						i = false;
						if (o.constructor === Function) {
							l = o;
							j = [m];
						} else {
							if (o.constructor === Array && o.length > 0 && o[0] !== undefined && o[0] !== null && o[0].constructor === Function) {
								l = o[0];
								j = o.concat();
								j[0] = m;
							}
						}
					}
					if (k === undefined) {
						k = null;
					}
					if (l !== null) {
						try {
							i = l.apply(k, j);
						} catch (n) {
							c.info("INFO__CONSTRAINT_FAIL", [n.message, m, o, k]);
						}
					}
					return i;
				},
				isValueValid: function (k, j, l) {
					var i = false;
					if (j.type !== undefined) {
						i = b.isValueOfType(k, j.type, l);
					} else {
						i = b.isValueOfType(k, j, l);
					}
					if (i === true && j.constraint !== undefined) {
						i = b.isValueInConstraint(k, j.constraint);
					}
					return i;
				},
				buildDefaults: function (j, m) {
					var i = m,
					k,
					l;
					if (typeof i !== "object" || i === null) {
						i = {};
					}
					for (l in j) {
						k = j[l];
						if (k !== null && k !== undefined && k.constructor === Object) {
							if (k.defaultValue !== undefined) {
								i[l] = k.defaultValue;
							} else {
								if (k.type !== undefined && k.type.constructor === Object) {
									k = k.type;
								}
								i[l] = b.buildDefaults(k);
							}
						}
					}
					return i;
				},
				applyProperties: function (l, m, k, i) {
					var j = {};
					if (l && k) {
						b._applyPropertiesImpl(l, m, k, i, j);
					}
					return j;
				},
				_applyPropertiesImpl: function (i, q, l, t, v) {
					var j,
					s,
					m,
					n,
					k,
					r,
					u,
					o = b._applyPropertiesImpl;
					for (j in i) {
						m = l[j];
						s = i[j];
						n = q[j];
						if (m !== undefined && s !== n) {
							if (m.type === undefined) {
								if (m.constructor === Object) {
									o(s, n, m, t, v);
								}
							} else {
								if (m.type.constructor === Object) {
									o(s, n, m.type, t, v);
								} else {
									k = false;
									r = undefined;
									k = (s === null && m.allowsNull) || (s === undefined && m.allowsUndef) || b.isValueOfType(s, m.type, false);
									if (k === true) {
										r = s;
									} else {
										if (m.convertor) {
											u = {
												value: undefined,
												validValue: false
											};
											m.convertor(s, u);
											k = (u.validValue === true);
											r = u.value;
										}
									}
									if (k === true && m.comparator) {
										k = !m.comparator(n, s);
									}
									if (k === true && m.constraint) {
										k = b.isValueInConstraint(r, m.constraint, t);
										if (!k && m.itemsConvertor) {
											u = {
												value: undefined,
												validValue: false
											};
											m.itemsConvertor(r, u);
											k = (u.validValue === true);
											r = u.value;
										}
									}
									if (k === true) {
										q[j] = r;
										if (m.tag) {
											v[m.tag] = true;
										} else {
											v[b.DEFAULT_TAG] = true;
										}
									}
								}
							}
						}
					}
				},
				xmlSpecialChars: function (p, j, k) {
					var o,
					m,
					l,
					q;
					if (!b.hasOwnValue(e, j)) {
						j = e.ENT_COMPAT;
					}
					if (k === false) {
						o = p.split(g);
						for (l = 0, q = o.length; l < q; l++) {
							m = o[l];
							if (m.match(h) === null) {
								o[l] = m.replace(/&/g, "&amp;");
							}
						}
						p = o.join("");
					} else {
						p = p.replace(/&/g, "&amp;");
					}
					p = p.replace(/</g, "&lt;");
					p = p.replace(/>/g, "&gt;");
					if (j === e.ENT_COMPAT) {
						p = p.replace(/"/g, "&quot;");
					} else {
						if (j === e.ENT_QUOTES) {
							p = p.replace(/"/g, "&quot;");
							p = p.replace(/'/g, "&#039;");
						}
					}
					p = p.replace(/\u2026/g, "&#8230;");
					return p;
				}
			});
		}
			());
		(function () {
			b.ns("oui.defs");
			function l(w, u, v, A, y, o, t, x, s) {
				var q,
				p,
				z,
				r = (v === null && x) || (v === undefined && s) || b.isValueOfType(v, u, false);
				if (!r || !b.isValueInConstraint(v, o)) {
					if (t === undefined) {
						t = ["def=", v];
						if (b.isA(o, Array)) {
							t.push(" with constraints: ");
							for (q = 1, p = o.length; q < p; q++) {
								t.push(o[q], ", ");
							}
						}
					}
					c.error("ERR__DEFS__INV", [t, "oui.defs." + w]);
				} else {
					if (A !== undefined && !b.isA(A, String)) {
						c.error("ERR__DEFS__INV", ["tag", "oui.defs." + w]);
					} else {
						z = {
							type: u,
							constraint: o,
							defaultValue: v,
							convertor: y,
							tag: A
						};
					}
				}
				return z;
			}
			function f(q, p, o, r) {
				var n = false;
				if (q === null) {
					n = o;
				} else {
					if (q === undefined) {
						n = r;
					} else {
						n = b.isValueOfType(q, p, true);
					}
				}
				return n;
			}
			function i(p, r, o, q) {
				var n = false;
				if (p === null) {
					n = o;
				} else {
					if (p === undefined) {
						n = q;
					} else {
						n = b.isValueInConstraint(p, r);
					}
				}
				return n;
			}
			function k(o, n) {
				if (o === 1 || o === "1" || o === "true" || o === "TRUE") {
					n.validValue = true;
					n.value = true;
				} else {
					if (o === 0 || o === "0" || o === "false" || o === "FALSE") {
						n.validValue = true;
						n.value = false;
					}
				}
			}
			function m(o, n) {
				if (o !== undefined && o !== null) {
					n.validValue = true;
					n.value = o.toString();
				}
			}
			function e(o, n) {
				if (b.isA(o, String)) {
					var p = parseFloat(o);
					if (!isNaN(p)) {
						n.valueValid = true;
						n.value = p;
					}
				}
			}
			function g(p, o) {
				if (b.isA(p, String)) {
					var n = Date.parse(p);
					if (!isNaN(n)) {
						o.validValue = true;
						o.value = new Date(n);
					}
				}
			}
			function j(p) {
				var s,
				r = p.convertor,
				q,
				u,
				t,
				o;
				if (r !== undefined) {
					s = function (v, n) {
						u = [].concat(v);
						t = u.length;
						for (q = 0; q < t; q++) {
							o = b.isValueOfType(u[q], p.type, false);
							if (o === false) {
								n.validValue = false;
								r(u[q], n, q, t);
								if (n.validValue === true) {
									o = n.validValue;
									u[q] = n.value;
								}
							}
							if (o === false) {
								break;
							}
						}
						if (q === t) {
							n.validValue = true;
							n.value = u;
						} else {
							n.validValue = false;
						}
					};
				}
				return s;
			}
			function h(o, r, q) {
				var p,
				n = false;
				if (o !== null && o !== undefined && r !== null && r !== undefined && o.constructor === Array && r.constructor === Array && o.length === r.length) {
					n = true;
					p = o.length;
					if (q === true) {
						while (n && p--) {
							if (o[p].constructor === Array) {
								n = h(o[p], r[p], q);
							}
						}
					} else {
						while (n && p--) {
							n = (o[p] === r[p]);
						}
					}
				}
				return n;
			}
			b.mixin(b.defs, {
				_createDef: l,
				Boolean: function (o, n) {
					return l("Boolean", Boolean, o, n, k);
				},
				String: function (o, n) {
					return l("String", String, o, n, m);
				},
				Char: function (o, n) {
					return l("Char", String, o, n, m, b.isChar);
				},
				Number: function (o, n) {
					return l("Number", Number, o, n, e);
				},
				FiniteNumber: function (o, n) {
					return l("FiniteNumber", Number, o, n, e, b.isFiniteNumber);
				},
				FinitePositiveNumber: function (o, n) {
					return l("FinitePositiveNumber", Number, o, n, e, b.isFinitePositiveNumber);
				},
				PositiveNumber: function (o, n) {
					return l("PositiveNumber", Number, o, n, e, b.isPositiveNumber);
				},
				StrictlyPositiveNumber: function (o, n) {
					return l("StrictlyPositiveNumber", Number, o, n, e, [b.isPositiveNumber, true]);
				},
				NumberInRange: function (o, q, n) {
					var r = [b.isNumberInRange, o, true],
					p = l("NumberInRange", Number, q, n, e, r);
					r[2] = false;
					return p;
				},
				Enum: function (q, o, n) {
					var s = [],
					r;
					for (r in q) {
						if (q.hasOwnProperty(r)) {
							s.push(q[r]);
						}
					}
					return l("Enum", s, o, n);
				},
				Date: function (o, n) {
					return l("Date", Date, o, n, g);
				},
				MapOfProperties: function (r, s, p, o, q, n) {
					return l("MapOfProperties", Object, s, n, undefined, [b.isMapOfProperties, r, p, o, q]);
				},
				MapOfType: function (o, p, n) {
					return l("MapOfType", Object, p, n, undefined, [b.isMapOfType, o]);
				},
				ArrayOfProperties: function (o, s, t, q, n) {
					var r = [b.isArrayOfProperties, o, s, t, true],
					p = l("ArrayOfProperties", Array, q, n, undefined, r);
					r[4] = false;
					return p;
				},
				ArrayOfType: function (u, n, t, p, x, v, s) {
					var o = [b.isArrayOfType, u, n, t, true],
					q,
					w = {},
					r;
					if (s) {
						r = j(u);
						r(p, w);
						if (w.validValue) {
							p = w.value;
						}
					}
					q = l("ArrayOfType", Array, p, x, null, o);
					if (s) {
						q.itemsConvertor = r;
					}
					if (v) {
						q.comparator = h;
					}
					o[4] = false;
					return q;
				},
				ObjectOfType: function (p, r, o, q, n) {
					return l("ObjectOfType", Object, r, n, undefined, [f, p, o, q]);
				},
				ObjectOfConstraint: function (p, r, o, q, n) {
					return l("ObjectOfConstraint", Object, r, n, undefined, [i, p, o, q]);
				},
				Function: function (p, o, n) {
					return l("Function", Function, o, n, undefined, [b.isFunctionWithArgCount, p]);
				},
				Class: function (r, p, n) {
					var q = [b.inheritsFrom, r],
					o = l("Class", Function, p, n, undefined, q);
					q[2] = false;
					return o;
				}
			});
		}
			());
		(function () {
			b.ns("oui.lang");
			b.lang.PropertiesSupport = {
				_initProperties: function (e) {
					this._properties = new this.Properties();
					this.setProperties(e);
				},
				setProperties: function (f) {
					var e = this._properties.updateObject(f),
					g;
					for (g in e) {
						if (e[g] === true) {
							this.onPropChanged(g);
						}
					}
				},
				applyProperties: function (e) {
					this.setProperties(e);
				},
				onPropChanged: function () {}
			};
		}
			());
		(function () {
			b.ns("oui.lang");
			var e = /\^\.([a-zA-Z0-9\-_]*)\[([a-zA-Z0-9\-]*)\]/;
			b.lang.BindingSupport = {
				applyBinding: function (i, g, h, k, j, f) {
					var l = this[j];
					if (b.isA(l, Function)) {
						this._applyBinding(i, g, h, k, l, f);
					}
				},
				_applyBinding: function (o, g, k, f, p, t) {
					var r = this[k],
					l,
					s,
					h,
					q,
					m,
					j;
					if (t === true && r !== undefined) {
						l = this._computeBinding(o, r, g, this);
						p.call(this, l);
					}
					s = this[f];
					if (s === undefined || g === s) {
						q = this.firstChild;
						while (q) {
							q._applyBinding(o, g, k, f, p, true);
							q = q.nextSibling;
						}
					} else {
						h = this.getOutOfBindingScopeChildren(k);
						for (m = 0, j = h.length; m < j; m++) {
							h[m]._applyBinding(o, g, k, f, p, true);
						}
					}
				},
				getOutOfBindingScopeChildren: function (f) {
					return [];
				},
				_computeBinding: function (i, j, g, h) {
					var f;
					if (j.constructor === String) {
						f = this._computeStringBinding(i, j, g, h);
					} else {
						if (j.constructor === Object) {
							f = this._computeObjectBinding(i, j, g, h);
						} else {
							if (j.constructor === Function) {
								f = j.call(g, i, h);
							}
						}
					}
					return f;
				},
				_computeStringBinding: function (k, n, f, g) {
					var q,
					p,
					o = 0,
					m = n.charAt(0),
					j,
					h,
					l;
					if (m === "@") {
						p = n.slice(1).split(".");
						o = p.length;
						if (o > 0) {
							q = k;
							for (j = 0; j < o; j++) {
								q = q[p[j]];
							}
						}
					} else {
						if (m === "$") {
							h = f[n.slice(1)];
							if (h !== undefined && h.constructor === Function) {
								q = h.call(f, k, g);
							}
						} else {
							if (m === "^") {
								l = e.exec(n);
								if (l[1] && l[2]) {
									q = b.tree.getCSSValue(l[1], l[2]);
								}
							}
						}
					}
					return q;
				},
				_computeObjectBinding: function (j, g, h, i) {
					var f = {},
					k;
					for (k in g) {
						if (g.hasOwnProperty(k)) {
							f[k] = this._computeBinding(j, g[k], h, i);
						}
					}
					return f;
				}
			};
		}
			());
		(function () {
			b.ns("oui.lang");
			b.lang.LinkedListSupport = {
				addLinkedList: function (C, u, n, B, g, h, A, l, x, y, s, r, v, m, w, o, i, z, k, q) {
					var t = C.prototype,
					j,
					p,
					e,
					f;
					if (!b.isA(i, String)) {
						i = "_numChildren";
					}
					t[n] = null;
					t[B] = null;
					t[g] = null;
					t[h] = null;
					t[A] = null;
					t[i] = 0;
					if (b.isA(m, String) && b.isA(t[m], Function)) {
						j = function (D) {
							return this[m](D);
						};
					}
					if (!j) {
						j = function (D) {
							return b.isA(D, u);
						};
					}
					if (b.isA(w, String)) {
						p = t[w];
					}
					if (!p) {
						p = function (D) {};
					}
					if (b.isA(o, String)) {
						e = t[o];
					}
					if (!e) {
						e = function (D) {};
					}
					f = "_safe" + x.charAt(0).toUpperCase() + x.slice(1);
					t[l] = function (D) {
						return this[s](D);
					};
					t[s] = function (F, I) {
						var D,
						E,
						G,
						H;
						if (j.call(this, F) === true) {
							E = true;
							G = this;
							while (G && G !== F) {
								G = G[g];
							}
							if (G !== null) {
								E = false;
								c.warn("WARN__HRCHY_REQ__INSERT_ANCEST");
							}
						} else {
							E = false;
							c.warn("WARN__HRCHY_REQ__INV_TYPE");
						}
						if (E) {
							H = F[g];
							if (H !== null) {
								H[f](F, (H === this));
							}
							if (!I) {
								if (this[A] !== null) {
									F[B] = this[A];
									this[A][n] = F;
								} else {
									F[B] = null;
									this[h] = F;
								}
								F[n] = null;
								this[A] = F;
								D = F;
							} else {
								if (I === this[h]) {
									this[h] = F;
									F[n] = I;
									F[B] = null;
									I[B] = F;
									D = F;
								} else {
									if (I[g] === this) {
										I[B][n] = F;
										F[B] = I[B];
										I[B] = F;
										F[n] = I;
										D = F;
									} else {
										c.warn("WARN__NOTFOUND__INSERT");
									}
								}
							}
							if (D) {
								F[g] = this;
								p.call(this, F, I, (H === this));
								this[i]++;
							}
						}
						return D;
					};
					t[f] = function (E, D) {
						if (this[h] === E) {
							this[h] = E[n];
							if (this[A] === E) {
								this[A] = null;
							}
						} else {
							if (this[A] === E) {
								this[A] = E[B];
							}
						}
						if (E[B] !== null) {
							E[B][n] = E[n];
						}
						if (E[n] !== null) {
							E[n][B] = E[B];
						}
						E[B] = null;
						E[n] = null;
						E[g] = null;
						if (D !== true) {
							e.call(this, E, false, true);
						}
						this[i]--;
					};
					t[x] = function (E) {
						var D;
						if (E && E[g] === this) {
							this[f](E, false);
							D = E;
						} else {
							c.warn("WARN__NOTFOUND__REMOVE");
						}
						return D;
					};
					t[y] = function () {
						var D = this[h],
						E;
						if (D !== null) {
							while (D) {
								E = D[n];
								D[g] = null;
								D[B] = null;
								D[n] = null;
								e.call(this, D, true, (E === null));
								D = E;
							}
							this[h] = null;
							this[A] = null;
							this[i] = 0;
						}
					};
					t[r] = function (G, E) {
						var D,
						F;
						if (b.isA(E, u) && E[g] === this) {
							F = E.nextSibling;
							this[x](E);
							this[s](G, F);
							D = E;
						}
						return D;
					};
					t[v] = function () {
						return (this[h] !== null);
					};
					if (b.isA(z, String)) {
						t[z] = function (D) {
							var F = null,
							E = this[i];
							if (D >= 0 && D < E) {
								F = this[h];
								E = 0;
								while (E < D) {
									F = F[n];
									E++;
								}
							}
							return F;
						};
					}
					if (b.isA(k, String)) {
						t[k] = function (E) {
							var D = 0,
							F = this[h];
							while (F && F !== E) {
								F = F[n];
								D++;
							}
							return (F === E) ? D : -1;
						};
					}
					if (b.isA(q, String)) {
						t[q] = function (E, D) {
							var F = this[z](D);
							this[s](E, F);
						};
					}
				}
			};
		}
			());
		(function () {
			b.ns("oui.lang");
			function f(m, l) {
				return function () {
					return this[m][l];
				};
			}
			function k(n, m) {
				var l = m.concat();
				return function () {
					var p = this[n],
					o,
					q = l.length;
					for (o = 0; o < q; o++) {
						p = p[l[o]];
					}
					return p;
				};
			}
			function i(l) {
				return function (n) {
					var m;
					if (n.length === 1) {
						m = f(l, n[0]);
					} else {
						m = k(l, n);
					}
					return m;
				};
			}
			function h(l, m) {
				return function (n) {
					var o = {};
					o[m] = n;
					this[l](o);
				};
			}
			function e(l, n) {
				var m = n.concat();
				return function (r) {
					var s = {},
					p = s,
					o,
					q = m.length;
					for (o = 0; o < q - 1; o++) {
						p[m[o]] = {};
						p = p[m[o]];
					}
					p[m[q - 1]] = r;
					this[l](s);
				};
			}
			function j(l) {
				return function (n) {
					var m;
					if (n.length === 1) {
						m = h(l, n[0]);
					} else {
						m = e(l, n);
					}
					return m;
				};
			}
			b.lang.PropertiesUtil = {
				addConfig: function (w, l, t, u, o) {
					var n = t + "Definition",
					p = function () {},
					r = this._getSuperConfig(w, t),
					v,
					m,
					q,
					s,
					x;
					if (r !== undefined) {
						v = r.__configs[t].definitionClass;
						m = r.__configs[t].configClass;
						b.extend(p, v);
					}
					b.mixin(p, l);
					s = (function (y) {
						return function (A) {
							var C,
							B,
							z;
							if (A !== undefined) {
								C = function () {};
								if (y !== undefined) {
									b.extend(C, y);
								}
								for (B in A) {
									C.prototype[B] = A[B];
								}
								this.definition = new C();
								b.buildDefaults(this.definition, this);
							} else {
								z = this.compounds;
								for (B in z) {
									if (z.hasOwnProperty(B)) {
										this[B] = new z[B]();
									}
								}
							}
						};
					}
						(v));
					q = {
						updateObject: function (z, y) {
							return b.applyProperties(z, this, this.definition, y);
						},
						definition: new p(),
						compounds: {}
					};
					this._getDefaultsAndCompounds(q.definition, q, q.compounds);
					if (m !== undefined) {
						b.extend(s, m);
					}
					b.mixin(s, q);
					x = w;
					if (b.isA(w, Function)) {
						x = w.prototype;
					}
					if (u) {
						this._addAccessors(l, "get", [], i("_" + t.toLowerCase()), x, true);
					}
					if (o) {
						this._addAccessors(l, "set", [], j("apply" + t), x, false);
					}
					if (w.constructor === Function) {
						w.prototype[n] = p;
						w.prototype[t] = s;
						w[n] = l;
					}
					if (!w.__configs) {
						w.__configs = {};
					}
					w.__configs[t] = {
						definitionClass: p,
						configClass: s
					};
				},
				_addAccessors: function (q, v, y, u, t, x) {
					var l,
					m,
					s,
					r,
					o,
					w;
					if (q !== undefined) {
						if (!this._isCompound(q)) {
							m = "";
							r = y.length;
							for (s = 0; s < r; s++) {
								o = y[s];
								if (o.length > 0) {
									m += o.charAt(0).toUpperCase() + o.slice(1);
								}
							}
							l = u(y);
							if (x) {
								t[m.charAt(0).toLowerCase() + m.slice(1)] = l;
							}
							t[v + m] = l;
						} else {
							w = q;
							if (q.type !== undefined) {
								w = q.type;
							}
							for (o in w) {
								if (w.hasOwnProperty(o) === true) {
									y.push(o);
									this._addAccessors(w[o], v, y, u, t, x);
									y.pop();
								}
							}
						}
					}
				},
				_getSuperConfig: function (l, n) {
					var m = l.superClass;
					if (m) {
						if (!m.__configs || !m.__configs[n]) {
							m = this._getSuperConfig(m, n);
						}
					}
					return m;
				},
				_isCompound: function (l) {
					return (l.type === undefined && l.constructor === Object) || (l.type !== undefined && l.type.constructor === Object);
				},
				_compoundedDefaultsFactory: function (m) {
					var l = {},
					n = {},
					o;
					this._getDefaultsAndCompounds(m, n, l);
					o = function () {
						var q;
						for (q in l) {
							if (l.hasOwnProperty(q) === true) {
								this[q] = new l[q]();
							}
						}
					};
					o.prototype = n;
					return o;
				},
				_getDefaultsAndCompounds: function (m, o, l) {
					var q,
					n;
					for (n in m) {
						if ((q = m[n]) !== null && q !== undefined && q.constructor === Object) {
							if (this._isCompound(q)) {
								l[n] = this._compoundedDefaultsFactory(q);
							} else {
								o[n] = q.defaultValue;
							}
						}
					}
				}
			};
			var g = b.lang.PropertiesUtil;
			b.addStyleSupport = function (l, m) {
				g.addConfig(l, m, "Style", true, true);
			};
			b.addModelSupport = function (l, m) {
				g.addConfig(l, m, "Model", false, false);
			};
			b.addPropertiesSupport = function (l, m) {
				g.addConfig(l, m, "Properties", true, true);
			};
		}
			());
		(function () {
			b.declare({
				name: "oui.geom.Matrix",
				membersDef: {
					init: function (l, j, n, m, k, i) {
						if (arguments.length >= 1 && b.isA(l, Number) && b.isA(j, Number) && b.isA(n, Number) && b.isA(m, Number) && b.isA(k, Number) && b.isA(i, Number)) {
							this.a = l;
							this.b = j;
							this.c = n;
							this.d = m;
							this.tx = k;
							this.ty = i;
						} else {
							this.a = 1;
							this.b = 0;
							this.c = 0;
							this.d = 1;
							this.tx = 0;
							this.ty = 0;
						}
					},
					_safeTranslate: function (i, j) {
						this.tx += this.a * i + this.c * j;
						this.ty += this.b * i + this.d * j;
						return this;
					},
					_safeRotate: function (p, j, r) {
						var l = (j !== 0 || r !== 0),
						i,
						q,
						k = Math.cos(p),
						o = Math.sin(p);
						if (l) {
							this._safeTranslate(j, r);
						}
						i = this.a;
						q = this.c;
						this.a = i * k + q * o;
						this.c = i * -o + q * k;
						i = this.b;
						q = this.d;
						this.b = i * k + q * o;
						this.d = i * -o + q * k;
						if (l) {
							this._safeTranslate(-j, -r);
						}
						return this;
					},
					_safeScale: function (i, j) {
						this.a *= i;
						this.c *= j;
						this.b *= i;
						this.d *= j;
						return this;
					},
					set: function (i) {
						if (b.isA(i, b.geom.Matrix)) {
							this.a = i.a;
							this.b = i.b;
							this.c = i.c;
							this.d = i.d;
							this.tx = i.tx;
							this.ty = i.ty;
						}
						return this;
					},
					isIdentity: function () {
						return this.tx === 0 && this.ty === 0 && this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1;
					},
					concat: function (i) {
						if (b.isA(i, b.geom.Matrix)) {
							this._concat(i);
						}
						return this;
					},
					_concat: function (o) {
						var n,
						m,
						l;
						n = this.a;
						m = this.c;
						l = this.tx;
						this.a = n * o.a + m * o.b;
						this.c = n * o.c + m * o.d;
						this.tx = n * o.tx + m * o.ty + l;
						n = this.b;
						m = this.d;
						l = this.ty;
						this.b = n * o.a + m * o.b;
						this.d = n * o.c + m * o.d;
						this.ty = n * o.tx + m * o.ty + l;
					},
					transformAll: function (q, t) {
						var l = q.length || 0,
						s,
						o,
						r,
						p,
						n,
						m,
						k,
						j;
						t = t || q;
						l += l % 2;
						r = this.a;
						p = this.b;
						n = this.c;
						m = this.d;
						k = this.tx;
						j = this.ty;
						while (l--) {
							s = q[--l];
							o = q[l + 1];
							t[l] = r * s + n * o + k;
							t[l + 1] = p * s + m * o + j;
						}
						return t;
					},
					transform: function (i, j) {
						return {
							x: this.a * i + this.c * j + this.tx,
							y: this.b * i + this.d * j + this.ty
						};
					},
					det: function () {
						return (this.a * this.d) - (this.b * this.c);
					},
					inv: function () {
						var i,
						j = this.det();
						if (j !== 0) {
							i = new b.geom.Matrix();
							i.a = this.d / j;
							i.b = -this.b / j;
							i.c = -this.c / j;
							i.d = this.a / j;
							i.tx = (this.c * this.ty - this.tx * this.d) / j;
							i.ty = (this.tx * this.b - this.a * this.ty) / j;
						} else {
							c.error("ERR__MTX__INV");
						}
						return i;
					},
					clone: function () {
						var i = new b.geom.Matrix();
						i.a = this.a;
						i.b = this.b;
						i.c = this.c;
						i.d = this.d;
						i.tx = this.tx;
						i.ty = this.ty;
						return i;
					},
					equals: function (k, i) {
						var j = false;
						if (b.isA(k, b.geom.Matrix)) {
							if (!i) {
								j = k.a === this.a && k.c === this.c && k.tx === this.tx && k.b === this.b && k.d === this.d && k.ty === this.ty;
							} else {
								j = Math.abs(k.a - this.a) < i && Math.abs(k.c - this.c) < i && Math.abs(k.tx - this.tx) < i && Math.abs(k.b - this.b) < i && Math.abs(k.d - this.d) < i && Math.abs(k.ty - this.ty) < i;
							}
						}
						return j;
					}
				}
			});
			b.geom.Matrix.IDENTITY = new b.geom.Matrix();
			function h(j) {
				var i = j.length;
				return function () {
					var l = arguments,
					k = [];
					k.push.apply(k, l);
					if (k.length > 0 && typeof k[0] === "number") {
						if (i === 3 && l[1] === undefined) {
							k[1] = 0;
							k[2] = 0;
						} else {
							if (l[i - 1] === undefined) {
								k[i - 1] = k[i - 2];
							}
						}
						j.apply(this, k);
					}
					return this;
				};
			}
			var g = b.geom.Matrix.prototype,
			e = {},
			f;
			for (f in g) {
				if (f.indexOf("_safe") === 0) {
					e[f.charAt(5).toLowerCase() + f.substr(6)] = h(g[f]);
				}
			}
			b.mixin(b.geom.Matrix, e);
		}
			());
		(function () {
			var j = "([+-]?\\d+(\\.\\d+)?)",
			h = "translate\\(\\s*" + j + "\\s*,\\s*" + j + "\\s*\\)",
			g = "matrix\\(\\s*" + j + "\\s*,\\s*" + j + "\\s*,\\s*" + j + "\\s*,\\s*" + j + "\\s*,\\s*" + j + "\\s*,\\s*" + j + "\\s*\\)",
			e = new RegExp(h, "g"),
			f = new RegExp(g, "g");
			function i(m, k) {
				var l,
				n = null;
				f.lastIndex = 0;
				e.lastIndex = 0;
				if (b.isA(m, Array) && m.length === 6) {
					n = new b.geom.Matrix(m[0], m[1], m[2], m[3], m[4], m[5]);
				} else {
					l = f.exec(m);
					if (l === null) {
						l = e.exec(m);
						if (l !== null) {
							n = new b.geom.Matrix(1, 0, 0, 1, parseFloat(l[1]), parseFloat(l[3]));
						}
					} else {
						n = new b.geom.Matrix(parseFloat(l[1]), parseFloat(l[3]), parseFloat(l[5]), parseFloat(l[7]), parseFloat(l[9]), parseFloat(l[11]));
					}
				}
				if (n === null) {
					k.validValue = false;
				} else {
					k.validValue = true;
					k.value = n;
				}
			}
			b.mixin(b.defs, {
				Matrix: function (l, k) {
					return b.defs._createDef("Matrix", b.geom.Matrix, l, k, i);
				}
			});
		}
			());
		(function () {
			b.ns("oui.geom");
			function g(i, h, j) {
				return i + (h - i) * j;
			}
			function f(i, h) {
				return (i + h) / 2;
			}
			var e = 5;
			b.mixin(b.geom, {
				DEG_TO_RAD: Math.PI / 180,
				computeBounds: function (m) {
					var n = m.length || 0,
					j,
					l,
					k,
					h,
					p,
					o;
					if (n % 2 === 0 && n > 1) {
						k = m[0];
						p = m[0];
						h = m[1];
						o = m[1];
						for (l = 2; l < n; l += 2) {
							k = m[l] < k ? m[l] : k;
							p = m[l] > p ? m[l] : p;
							h = m[l + 1] < h ? m[l + 1] : h;
							o = m[l + 1] > o ? m[l + 1] : o;
						}
						j = {
							x: k,
							y: h,
							width: p - k,
							height: o - h
						};
					}
					return j;
				},
				intersectLine: function (s, i, q, h, k, p, j, m) {
					var t = b.geom.slope(s, i, q, h),
					r = b.geom.slope(k, p, j, m),
					o = i - (t * s),
					l = p - (r * k),
					n,
					u;
					if (t === r || Math.abs(t - r) < 0.000001) {
						u = [];
					} else {
						if (!isFinite(t)) {
							u = [s, r * s + l];
						} else {
							if (!isFinite(r)) {
								u = [k, t * k + o];
							} else {
								n = (o - l) / (r - t);
								u = [n, (t * n + o + r * n + l) / 2];
							}
						}
					}
					return u;
				},
				intersectRect: function (l, k, q) {
					var s,
					m,
					j,
					i,
					r,
					h,
					p,
					o,
					n;
					if (l && k) {
						if (q !== true) {
							if ((m = l.x) <= (p = k.x + k.width) && (h = k.x) <= (j = l.x + l.width) && (i = l.y) <= (n = k.y + k.height) && (o = k.y) <= (r = l.y + l.height)) {
								s = {
									x: m > h ? m : h,
									y: i > o ? i : o
								};
								s.width = (j > p ? p : j) - s.x;
								s.height = (r > n ? n : r) - s.y;
							}
						} else {
							if ((m = l.x) < (p = k.x + k.width) && (h = k.x) < (j = l.x + l.width) && (i = l.y) < (n = k.y + k.height) && (o = k.y) < (r = l.y + l.height)) {
								s = {
									x: m > h ? m : h,
									y: i > o ? i : o
								};
								s.width = (j > p ? p : j) - s.x;
								s.height = (r > n ? n : r) - s.y;
							}
						}
					}
					return s;
				},
				unionRect: function (m, k) {
					var i,
					j,
					n,
					o,
					h;
					if (m && k) {
						j = Math.min(m.x, k.x);
						n = Math.min(m.y, k.y);
						o = Math.max(m.x + m.width, k.x + k.width);
						h = Math.max(m.y + m.height, k.y + k.height);
						i = {
							x: j,
							y: n,
							width: o - j,
							height: h - n
						};
					} else {
						i = m || k;
					}
					return i;
				},
				calculateAngle: function (h, l, j, i) {
					var k = Math.atan2(i, j) - Math.atan2(l, h);
					if (k < 0) {
						k += 2 * Math.PI;
					}
					return k;
				},
				slope: function (i, k, h, j) {
					return (h - i === 0) ? Number.POSITIVE_INFINITY : ((j - k) / (h - i));
				},
				distSq: function (i, k, h, j) {
					return (i - h) * (i - h) + (k - j) * (k - j);
				},
				dist: function (i, k, h, j) {
					return Math.sqrt(b.geom.distSq(i, k, h, j));
				},
				centroid: function (o, k, h) {
					var m = 0,
					l = 0,
					p = o.length,
					j = p - 1;
					while (j >= 0) {
						m += o[j][k];
						l += o[j][h];
						j--;
					}
					return {
						x: (m / p),
						y: (l / p)
					};
				},
				dotprod: function (h, k, j, i) {
					return (h * j) + (k * i);
				},
				ptSegDistSq: function (j, n, i, l, p, o) {
					var m,
					h,
					k;
					i -= j;
					l -= n;
					p -= j;
					o -= n;
					m = p * i + o * l;
					if (m <= 0) {
						h = 0;
					} else {
						p = i - p;
						o = l - o;
						m = p * i + o * l;
						if (m <= 0) {
							h = 0;
						} else {
							h = m * m / (i * i + l * l);
						}
					}
					k = p * p + o * o - h;
					if (k < 0) {
						k = 0;
					}
					return k;
				},
				isPointInEllipse: function (i, m, h, l, k, j) {
					i = (i - h) / k;
					m = (m - l) / j;
					return (i * i + m * m) <= 1;
				},
				isPointInTriangle: function (s, q, t, r, H, G, n, l) {
					var A = b.geom.dotprod,
					k = n - t,
					j = l - r,
					p = H - t,
					o = G - r,
					F = s - t,
					D = q - r,
					E = A(k, j, k, j),
					C = A(k, j, p, o),
					B = A(k, j, F, D),
					i = A(p, o, p, o),
					h = A(p, o, F, D),
					m = 1 / (E * i - C * C),
					z = (i * B - C * h) * m,
					w = (E * h - C * B) * m;
					return (z >= 0) && (w >= 0) && (z + w <= 1);
				},
				isValidRect: function (h) {
					return h !== undefined && h !== null && !isNaN(h.x) && !isNaN(h.y) && h.width >= 0 && h.height >= 0;
				},
				getBoundedXY: function (m, A, o, v) {
					var j = b.geom,
					n = null,
					l,
					k,
					q,
					p,
					u,
					t,
					i,
					h,
					s,
					r,
					z,
					w;
					if (!b.isFiniteNumber(o)) {
						o = e;
					}
					if (j.isValidRect(m) && j.isValidRect(A)) {
						l = m.x;
						k = m.y;
						q = m.width;
						p = m.height;
						u = A.x + o;
						t = A.y + o;
						i = A.width - 2 * o;
						h = A.height - 2 * o;
						if (v) {
							s = v.x;
							r = v.y;
							z = 2 * s - (l + q);
							w = 2 * r - (k + p);
						}
						if (i > q) {
							if (l < u) {
								l = u;
							} else {
								if (l + q > u + i) {
									l = u + i - q;
									if (v && s > l && s < l + q && r > k && r < k + p && z >= u && z + q <= u + i) {
										l = z;
									}
								}
							}
						} else {
							if (i === q) {
								l = u;
							}
						}
						if (h > p) {
							if (k < t) {
								k = t;
							} else {
								if (k + p > t + h) {
									k = t + h - p;
									if (v && s > l && s < l + q && r > k && r < k + p && w >= t && w + p <= t + h) {
										k = w;
									}
								}
							}
						} else {
							if (h === p) {
								k = t;
							}
						}
						n = {
							x: l,
							y: k
						};
					}
					return n;
				},
				getBoxCtrlPts: function (i, l, k, h) {
					var j = [];
					if (k > 0 && h > 0) {
						j.push(i, l, i + k, l, i + k, l + h, i, l + h);
					} else {
						if (k > 0) {
							j.push(i, l, i + k, l);
						} else {
							if (h > 0) {
								j.push(i, l, i, l + h);
							} else {
								j.push(i, l);
							}
						}
					}
					return j;
				},
				crossLine: function (k, m, j, l, i, n) {
					var h;
					if ((i < k && i < j) || (i > k && i > j) || (n > m && n > l) || (k === j)) {
						h = 0;
					} else {
						if (i === k) {
							h = k < j ? 0 : -1;
						} else {
							if (i === j) {
								h = k < j ? 1 : 0;
							} else {
								if ((n - m) - (l - m) * (i - k) / (j - k) < 0) {
									h = (k < j) ? 1 : -1;
								} else {
									h = 0;
								}
							}
						}
					}
					return h;
				},
				crossQuad: function (j, n, i, m, h, k, o, l) {
					var p;
					if ((o < j && o < i && o < h) || (o > j && o > i && o > h) || (l > n && l > m && l > k) || (j === i && i === h)) {
						p = 0;
					} else {
						p = b.geom.crossLine(j, n, i, m, o, l) + b.geom.crossLine(i, m, h, k, o, l);
					}
					return p;
				},
				crossCubic: function (j, p, i, n, h, l, r, k, o, m) {
					var q;
					if ((o < j && o < i && o < h && o < r) || (o > j && o > i && o > h && o > r) || (m > p && m > n && m > l && m > k) || (j === i && i === h && h === r)) {
						q = 0;
					} else {
						q = b.geom.crossLine(j, p, i, n, o, m) + b.geom.crossLine(i, n, h, l, o, m) + b.geom.crossLine(h, l, r, k, o, m);
					}
					return q;
				},
				cubic2Quad: function (y, x, I, H, m, k, A, z) {
					var u = f(y, I),
					t = f(x, H),
					o = f(I, m),
					n = f(H, k),
					l = f(m, A),
					j = f(k, z),
					C = f(u, o),
					B = f(t, n),
					K = f(o, l),
					J = f(n, j),
					r = g(y, u, 3 / 4),
					p = g(x, t, 3 / 4),
					E = g(C, K, 1 / 8),
					D = g(B, J, 1 / 8),
					M = g(K, C, 1 / 8),
					L = g(J, B, 1 / 8),
					s = g(A, l, 3 / 4),
					q = g(z, j, 3 / 4),
					w = f(r, E),
					v = f(p, D),
					G = f(C, K),
					F = f(B, J),
					i = f(M, s),
					h = f(L, q);
					return [r, p, w, v, E, D, G, F, M, L, i, h, s, q, A, z];
				},
				quad2Cubic: function (q, p, m, l, j, h) {
					var k = q + (2 / 3) * (m - q),
					i = p + (2 / 3) * (l - p),
					o = k + (1 / 3) * (j - q),
					n = i + (1 / 3) * (h - p);
					return [k, i, o, n, j, h];
				},
				_isFlatQuad: function (j, q, m, k, h, p, l, i) {
					var n,
					r,
					o = b.geom.dist;
					if (i === undefined || i < 0) {
						n = 2 / l;
						r = o(j, q, m, k) + o(m, k, h, p) - o(j, q, h, p);
					} else {
						n = i * i;
						r = b.geom.ptSegDistSq(j, q, h, p, m, k);
					}
					return r < n;
				},
				_isFlatCubic: function (j, t, q, m, p, l, h, s, n, i) {
					var o,
					u,
					r = b.geom.dist,
					k;
					if (i === undefined || i < 0) {
						o = 2 / n;
						u = r(j, t, q, m) + r(q, m, p, l) + r(p, l, h, s) - r(j, t, h, s);
					} else {
						k = b.geom.ptSegDistSq;
						o = i * i;
						u = Math.max(k(j, t, h, s, q, m), k(j, t, h, s, p, l));
					}
					return u < o;
				},
				flattenQuad: function (k, s, p, n, h, r, q, o, j) {
					var x = b.geom.flattenQuad,
					i = b.geom._isFlatQuad,
					w,
					v,
					m,
					l,
					u,
					t;
					if (o <= 0 || i(k, s, p, n, h, r, o, j)) {
						q.push(h, r);
					} else {
						o--;
						w = (k + p) / 2;
						v = (s + n) / 2;
						m = (p + h) / 2;
						l = (n + r) / 2;
						u = (w + m) / 2;
						t = (v + l) / 2;
						x(k, s, w, v, u, t, q, o, j);
						x(u, t, m, l, h, r, q, o, j);
					}
				},
				flattenCubic: function (w, i, s, C, q, B, v, h, u, z, A) {
					var t = b.geom.flattenCubic,
					D = b.geom._isFlatCubic,
					r,
					o,
					F,
					m,
					E,
					l,
					y,
					k,
					x,
					j,
					p,
					n;
					if (z <= 0 || D(w, i, s, C, q, B, v, h, z, A)) {
						u.push(v, h);
					} else {
						z--;
						r = (s + q) / 2;
						o = (C + B) / 2;
						F = (w + s) / 2;
						m = (i + C) / 2;
						E = (F + r) / 2;
						l = (m + o) / 2;
						x = (q + v) / 2;
						j = (B + h) / 2;
						y = (r + x) / 2;
						k = (o + j) / 2;
						p = (E + y) / 2;
						n = (l + k) / 2;
						t(w, i, F, m, E, l, p, n, u, z, A);
						t(p, n, y, k, x, j, v, h, u, z, A);
					}
				}
			});
		}
			());
		(function () {
			function e(j, l, h, k, g, i) {
				return (h - j) * (i - l) - (k - l) * (g - j);
			}
			function f(j, o, h, m, g, l) {
				var p,
				n,
				k,
				q = (h - j),
				i = (m - o);
				p = ((g - j) * q + (l - o) * i) / (q * q + i * i);
				n = j + p * q;
				k = o + p * i;
				return (n - g) * (n - g) + (k - l) * (k - l);
			}
			b.mixin(b.geom, {
				computeConvexHull: function (h) {
					var g,
					i = h.length;
					if (i > 2 && (i % 2) === 0) {
						g = this._quickHull(h);
					} else {
						if (i === 2) {
							g = [h[0], h[1]];
						} else {
							g = [];
						}
					}
					return g;
				},
				_quickHull: function (y) {
					var t = [],
					p = y.length,
					h,
					q,
					s,
					v,
					u,
					g,
					o,
					m,
					k,
					j,
					w;
					for (s = h = q = 0; s < p; s += 2) {
						v = y[s];
						if (y[q] < v || (y[q] === v && y[q + 1] < y[s + 1])) {
							q = s;
						}
						if (y[h] > v || (y[h] === v && y[h + 1] > y[s + 1])) {
							h = s;
						}
					}
					if (q === h) {
						t.push(y[q], y[q + 1]);
					} else {
						u = [];
						g = [];
						o = y[q];
						m = y[q + 1];
						k = y[h];
						j = y[h + 1];
						for (s = 0; s < p; s += 2) {
							if (s === q || s === h) {
								continue;
							}
							w = e(o, m, k, j, y[s], y[s + 1]);
							if (w > 0) {
								u.push(y[s], y[s + 1]);
							} else {
								if (w < 0) {
									g.push(y[s], y[s + 1]);
								}
							}
						}
						t.push(k, j);
						b.geom._quickHullRecurse(k, j, o, m, u, t);
						t.push(o, m);
						b.geom._quickHullRecurse(o, m, k, j, g, t);
					}
					return t;
				},
				_quickHullRecurse: function (j, s, h, r, v, m) {
					var l,
					k = v.length,
					g,
					p,
					u,
					t,
					q,
					o;
					if (k > 0) {
						l = b.geom._farthestPointIndex(j, s, h, r, v);
						g = v[l];
						p = v[l + 1];
						u = [];
						t = [];
						for (l = 0; l < k; l += 2) {
							q = v[l];
							o = v[l + 1];
							if ((q === j && o === s) || (q === h && o === r)) {
								continue;
							} else {
								if (e(g, p, j, s, q, o) > 0) {
									u.push(q, o);
								} else {
									if (e(h, r, g, p, q, o) > 0) {
										t.push(q, o);
									}
								}
							}
						}
						b.geom._quickHullRecurse(j, s, g, p, u, m);
						m.push(g, p);
						b.geom._quickHullRecurse(g, p, h, r, t, m);
					}
				},
				_farthestPointIndex: function (h, q, g, p, s) {
					var k,
					j = s.length,
					t = -1,
					r = -1,
					o,
					m,
					l;
					for (k = 0; k < j; k += 2) {
						o = s[k];
						m = s[k + 1];
						if ((o === h && m === q) || (o === g && m === p)) {
							continue;
						}
						l = f(h, q, g, p, o, m);
						if (l > r) {
							r = l;
							t = k;
						}
					}
					return t;
				}
			});
		}
			());
		(function () {
			b.UIEvents = {
				ACTIVATE: "activate",
				FOCUS_IN: "focusIn",
				FOCUS_OUT: "focusOut"
			};
			b.MouseEvents = {
				CLICK: "click",
				DBL_CLICK: "dblClick",
				MOUSE_DOWN: "mouseDown",
				MOUSE_UP: "mouseUp",
				MOUSE_OVER: "mouseOver",
				MOUSE_OUT: "mouseOut",
				MOUSE_MOVE: "mouseMove",
				MOUSE_ENTER: "mouseEnter",
				MOUSE_LEAVE: "mouseLeave",
				MOUSE_WHEEL: "mouseWheel"
			};
			b.KeyEvents = {
				KEY_DOWN: "keyDown",
				KEY_UP: "keyUp"
			};
			b.SyncEvents = {
				BEGIN: "begin",
				END: "end",
				REPEAT: "repeat"
			};
			b.DragEvents = {
				DRAG: "drag",
				DRAG_START: "dragStart",
				DRAG_END: "dragEnd"
			};
			b.TouchEvents = {
				TOUCH_START: "touchStart",
				TOUCH_END: "touchEnd",
				TOUCH_MOVE: "touchMove",
				TOUCH_ENTER: "touchEnter",
				TOUCH_LEAVE: "touchLeave"
			};
			b.GenericGestureEvents = {
				GESTURE_START: "gestureStart",
				GESTURE_CHANGE: "gestureChange",
				GESTURE_END: "gestureEnd"
			};
			b.GestureEvents = {
				TAP: "tap",
				DBL_TAP: "dblTap",
				TOUCH_LONG_PRESS: "touchLongPress",
				PRESS_AND_TAP: "pressAndTap",
				SWIPE: "swipe",
				PINCH: "pinch"
			};
			b.GestureEventPhases = {
				BEGIN: "Begin",
				CHANGE: "Change",
				CANCEL: "Cancel",
				END: "End"
			};
			b.MouseButton = {
				LEFT: 0,
				MIDDLE: 1,
				RIGHT: 2
			};
			b.ViewEvents = {
				LOAD: "load",
				VIEWPORT_RESIZE: "viewportResize",
				RELEASE_FOCUS: "releaseFocus",
				FOCUS_COMPONENT: "focusComponent",
				BLUR_COMPONENT: "blurComponent",
				USER_EVENTS_SUPPORTED: "userEventsSupported",
				ABOUT_INFO_REQUEST: "aboutInfoRequest",
				DEVICE_ORIENTATION: "deviceOrientation"
			};
		}
			());
		(function () {
			b.ns("oui.events");
			var i = "CAPTURE",
			j = "BUBBLE";
			function e(m, l) {
				if (m) {
					if (m.handleEvent) {
						m.handleEvent(l);
					} else {
						m.call(null, l);
					}
				}
			}
			function k(l) {
				return (typeof l === "function" || (l !== null && l !== undefined && typeof l.handleEvent === "function"));
			}
			function f(l) {
				this.defaultPrevented = true;
				if (l !== true && this.preventNativeDefault) {
					this.preventNativeDefault();
				}
			}
			function g(l) {
				this.stopped = true;
				if (l !== true && this.stopNativePropagation) {
					this.stopNativePropagation();
				}
			}
			function h(l) {
				this.stoppedImmediate = true;
				this.stopPropagation(l);
			}
			b.events.EventSupport = {
				_snapshotListeners: function (p) {
					var o = [],
					n = [],
					r = [],
					m = [],
					l = [],
					q = this;
					p = p.toLowerCase();
					while (q) {
						o.push(q);
						q._appendListeners(p, n, r, m, l);
						q = q.parentNode;
					}
					return {
						nodes: o,
						bubbleListeners: n,
						captureListeners: r,
						bubbleIndices: m,
						captureIndices: l
					};
				},
				_appendListeners: function (o, q, m, l, n) {
					var p = this.listeners;
					n.push(m.length);
					if (p && p[o]) {
						m.push.apply(m, p[o][i]);
						q.push.apply(q, p[o][j]);
					}
					l.push(q.length - 1);
				},
				_checkListeners: function () {
					if (this.listeners === undefined) {
						this.listeners = {};
					}
				},
				addEventListener: function (p, q, m) {
					var r,
					l,
					o,
					n = false;
					if (typeof p === "string" && k(q)) {
						p = p.toLowerCase();
						this._checkListeners();
						if (this.listeners[p] === undefined) {
							this.listeners[p] = {};
							this.listeners[p][i] = [];
							this.listeners[p][j] = [];
						}
						r = m === true ? i : j;
						l = this.listeners[p][r];
						o = l.length;
						while (o-- && !n) {
							n = (q === l[o]);
						}
						if (!n) {
							l.push(q);
						}
					}
				},
				removeEventListener: function (n, o, m) {
					var l,
					p;
					if (typeof n === "string" && k(o) && this.listeners) {
						n = n.toLowerCase();
						l = this.listeners[n];
						if (l) {
							p = m === true ? i : j;
							b.arrayRemove(l[p], o, false);
						}
					}
				},
				dispatchEvent: function (l) {
					var u,
					p,
					v,
					m,
					n,
					q,
					x,
					z,
					r,
					y,
					o,
					w,
					t,
					s;
					if (l && typeof l.type === "string") {
						l.timeStamp = b.currentTimeMillis();
						u = (l.bubbles !== false);
						p = (l.cancelable === true);
						v = null;
						if (typeof l.defaultAction === "function") {
							v = l.defaultAction;
						}
						l.CAPTURING_PHASE = 1;
						l.AT_TARGET = 2;
						l.BUBBLING_PHASE = 3;
						l.preventDefault = f;
						l.stopPropagation = g;
						l.stopImmediatePropagation = h;
						m = this._snapshotListeners(l.type);
						n = m.nodes;
						q = m.captureListeners;
						x = m.bubbleListeners;
						z = m.captureIndices;
						r = m.bubbleIndices;
						l.eventPhase = l.CAPTURING_PHASE;
						l.target = this;
						l.stopped = false;
						l.stoppedImmediate = false;
						l.defaultPrevented = false;
						y = q.length - 1;
						for (t = n.length - 1;
							t > 0 && l.stopped === false; t--) {
							l.currentTarget = n[t];
							for (s = y; s >= z[t] && l.stoppedImmediate === false; s--) {
								e(q[y], l);
								y--;
							}
						}
						l.eventPhase = l.AT_TARGET;
						l.currentTarget = this;
						o = 0;
						if (l.stopped !== true) {
							for (s = y; s >= 0 && l.stoppedImmediate === false;
								s--) {
								e(q[y], l);
								y--;
							}
							for (s = 0; s <= r[0] && l.stoppedImmediate === false; s++) {
								e(x[o], l);
								o++;
							}
						}
						if (u) {
							l.eventPhase = l.BUBBLING_PHASE;
							w = n.length;
							for (t = 1; t < w && l.stopped === false; t++) {
								l.currentTarget = n[t];
								for (s = o; s <= r[t] && l.stoppedImmediate === false;
									s++) {
									e(x[o], l);
									o++;
								}
							}
						}
						if (v !== null && (p === false || l.defaultPrevented !== true)) {
							v.call(null, l);
						}
					}
				},
				getDefaultActivateAction: function () {
					var l;
					if (this.activateAction) {
						l = this.activateAction;
					} else {
						if (b.isA(this.getActivateAction, Function)) {
							l = this.getActivateAction();
						}
					}
					return l;
				},
				handler: function (p, n, m, l, q) {
					var o = null,
					r = null;
					if (p) {
						if (typeof p === "string") {
							if (typeof this[p] === "function") {
								o = this;
								r = this[p];
							}
						} else {
							if (typeof p === "function") {
								r = p;
							} else {
								if (typeof p.handleEvent === "function") {
									o = p;
									r = p.handleEvent;
								}
							}
						}
					}
					if (!r) {
						c.error("ERR__EVT__INV_HANDLER");
					}
					return function (s) {
						if (b.isValueInConstraint(s, q)) {
							if (l === true) {
								s.stopPropagation();
							}
							if (m === true) {
								s.preventDefault();
							}
							r.call(o, s, n);
						}
					};
				}
			};
		}
			());
		(function () {
			b.ns("oui.events");
			var l = b.events,
			i = b.defs,
			m = {},
			o,
			s,
			n,
			r,
			p,
			f,
			k;
			function e(w, v) {
				var t,
				u = Math.min(w.length, v.length);
				for (t = 0; t < u; t++) {
					if (w[t] !== v[t]) {
						break;
					}
				}
				return (t - 1);
			}
			function g() {
				l._stopNextNativeMouseEvent(this.type, this.clientX, this.clientY);
			}
			r = {
				mousedown: function (t, u) {
					if (!o || u !== o.target || t.clientX !== o.clientX || t.clientY !== o.clientY) {
						n = 1;
					} else {
						n++;
					}
					if (t.hasOwnProperty("detail") === false) {
						t.detail = n;
					}
					o = t;
				},
				mouseup: function (t, u) {
					if (!o || u !== o.target || t.clientX !== o.clientX || t.clientY !== o.clientY) {
						n = 1;
					}
					if (t.hasOwnProperty("detail") === false) {
						t.detail = n;
					}
				}
			};
			p = {
				mouseover: function (t) {
					l.handleEnter(t.target, t.relatedTarget, b.MouseEvents.MOUSE_ENTER, t);
				},
				mouseout: function (t) {
					l.handleLeave(t.target, t.relatedTarget, b.MouseEvents.MOUSE_LEAVE, t);
				},
				mousedown: function (t) {
					var u = t.target,
					v = u;
					if (b.focus.isFocusableTarget(u) !== true) {
						v = b.focus.getFocusableAncestor(u);
					}
					if (v !== null) {
						b.focusManager.requestFocus(v, t);
						v.dispatchEvent({
							type: b.UIEvents.ACTIVATE,
							defaultAction: v.getDefaultActivateAction()
						});
					}
				},
				mouseup: function (w) {
					var v = b.MouseEvents.CLICK,
					u = b.MouseEvents.DBL_CLICK,
					t;
					if (o && w.target === o.target && w.clientX === o.clientX && w.clientY === o.clientY) {
						t = {
							type: v,
							clientX: w.clientX,
							clientY: w.clientY,
							pageX: w.pageX,
							pageY: w.pageY,
							userX: w.userX,
							userY: w.userY,
							ctrlKey: w.ctrlKey,
							shiftKey: w.shiftKey,
							altKey: w.altKey,
							button: w.button,
							detail: w.detail,
							defaultAction: null,
							stopNativePropagation: g
						};
						w.target.dispatchEvent(t);
						if (s && t.target === s.target && t.userX === s.userX && t.userY === s.userY && t.button === s.button && t.detail % 2 === 0 && t.timeStamp - s.timeStamp < 500) {
							t.target.dispatchEvent({
								type: u,
								clientX: t.clientX,
								clientY: t.clientY,
								pageX: t.pageX,
								pageY: t.pageY,
								userX: t.userX,
								userY: t.userY,
								ctrlKey: t.ctrlKey,
								altKey: t.altKey,
								shiftKey: t.shiftKey,
								button: t.button,
								detail: t.detail,
								defaultAction: null,
								stopNativePropagation: g
							});
						}
						s = t;
					}
				}
			};
			f = {
				KEYS: "KEYS",
				MOUSE: "MOUSE",
				WHEEL: "WHEEL",
				TOUCHES: "TOUCHES",
				GESTURES: "GESTURES"
			};
			k = function () {
				this._initProperties();
			};
			b.mixin(k, b.lang.PropertiesSupport);
			b.mixin(k, {
				onPropChanged: function (u) {
					var t = this._properties.fromPlatform;
					switch (u) {
					case f.KEYS:
						l.toggleNativeKeys(t.keyEvents);
						break;
					case f.MOUSE:
						l.toggleNativeMouse(t.mouseEvents);
						break;
					case f.WHEEL:
						l.toggleNativeWheel(t.wheelEvents);
						break;
					case f.TOUCHES:
						l.toggleNativeTouches(t.touchEvents);
						break;
					case f.GESTURES:
						l.toggleNativeGestures(t.gestureEvents);
						break;
					default:
					}
				}
			});
			b.addPropertiesSupport(k, {
				fromPlatform: {
					keyEvents: i.Boolean(false, f.KEYS),
					mouseEvents: i.Boolean(false, f.MOUSE),
					wheelEvents: i.Boolean(false, f.WHEEL),
					touchEvents: i.Boolean(false, f.TOUCHES),
					gestureEvents: i.Boolean(false, f.GESTURES)
				},
				fromContainer: {
					keyEvents: i.Boolean(true),
					mouseEvents: i.Boolean(true),
					wheelEvents: i.Boolean(true),
					touchEvents: i.Boolean(true),
					gestureEvents: i.Boolean(true)
				}
			});
			b.mixin(b.events, {
				_userEventsSupport: new k(),
				setUserEventsSupported: function (t) {
					l._userEventsSupport.applyProperties(t);
				},
				getUserEventsSupported: function () {
					var t = l._userEventsSupport;
					return {
						fromPlatform: {
							keyEvents: t.fromPlatformKeyEvents(),
							mouseEvents: t.fromPlatformMouseEvents(),
							wheelEvents: t.fromPlatformWheelEvents(),
							touchEvents: t.fromPlatformTouchEvents(),
							gestureEvents: t.fromPlatformGestureEvents()
						},
						fromContainer: {
							keyEvents: t.fromContainerKeyEvents(),
							mouseEvents: t.fromContainerMouseEvents(),
							wheelEvents: t.fromContainerWheelEvents(),
							touchEvents: t.fromContainerTouchEvents(),
							gestureEvents: t.fromContainerGestureEvents()
						}
					};
				},
				toggleNativeKeys: function (t) {},
				toggleNativeMouse: function (t) {},
				toggleNativeWheel: function (t) {},
				toggleNativeTouches: function (t) {},
				toggleNativeGestures: function (t) {},
				dispatchExternalEvent: function (u) {
					var t = null;
					if (typeof b.config.catchAllEventListener === "function" && u) {
						u.domId = b.config.domId;
						b.config.catchAllEventListener(u, u.domId);
						t = u.returnValue;
					}
					return t;
				},
				handleExternalEvent: function (A) {
					var C = l._userEventsSupport,
					D,
					u,
					y,
					v,
					t = C.fromContainerKeyEvents(),
					x = C.fromContainerMouseEvents(),
					B = C.fromContainerWheelEvents(),
					w = C.fromContainerTouchEvents(),
					z = C.fromContainerGestureEvents();
					if (A === null) {
						c.warn("WARN__EVT__NPE");
					} else {
						if (A) {
							u = {
								type: A.type
							};
							y = null;
							if (b.hasOwnValue(b.KeyEvents, u.type, true)) {
								if (t) {
									u.cancelable = true;
									y = b.focusManager.getFocusOwner();
									u.keyCode = A.keyCode;
									l._getModifiers(u, A);
								}
							} else {
								if (b.equalIgnoreCase(b.MouseEvents.MOUSE_WHEEL, u.type)) {
									if (B) {
										y = l._getNodeFromContainer(A);
										if (y) {
											l._getCoordsFromContainer(u, A, y);
											l._getModifiers(u, A);
											if (typeof A.delta === "number") {
												u.delta = A.delta;
											} else {
												u.delta = 0;
											}
										}
									}
								} else {
									if (b.hasOwnValue(b.MouseEvents, u.type, true)) {
										if (x) {
											y = l._getNodeFromContainer(A);
											if (y) {
												l._getCoordsFromContainer(u, A, y);
												l._getModifiers(u, A);
												if (b.equalIgnoreCase(b.MouseEvents.MOUSE_OVER, u.type) || b.equalIgnoreCase(b.MouseEvents.MOUSE_OUT, u.type)) {
													u.relatedTarget = null;
												}
												if (typeof A.button === "number") {
													u.button = A.button;
												} else {
													u.button = 0;
												}
											}
										}
									} else {
										if (b.hasOwnValue(b.TouchEvents, u.type, true)) {
											if (w) {
												y = l._getNodeFromContainer(A);
												if (y) {
													l._getCoordsFromContainer(u, A, y);
													l._getModifiers(u, A);
												}
											}
										} else {
											if (b.hasOwnValue(b.GenericGestureEvents, u.type, true)) {
												if (z) {
													y = b.rootNode;
													u.rotation = A.rotation;
													u.scale = A.scale;
												}
											} else {
												y = b.rootNode;
												for (v in A) {
													if (v !== "type") {
														u[v] = A[v];
													}
												}
											}
										}
									}
								}
							}
							if (y !== null) {
								l._dispatchTo(y, u);
							}
							D = u.returnValue;
						}
					}
					return D;
				},
				_dispatchKeyEvent: function (v) {
					var t,
					u = b.focusManager.getFocusOwner();
					if (u !== null) {
						t = l._createAPIEvent(v, true);
						l._getKeyArgs(t, v);
						l._dispatchTo(u, t);
					}
				},
				_dispatchMouseEvent: function (v) {
					var t,
					u = l._getAPITarget(v);
					if (u !== null) {
						t = l._createAPIEvent(v);
						l._getMouseArgs(t, v, u);
						l._dispatchTo(u, t);
					}
				},
				_dispatchTouchEvent: function (w) {
					var v = l._createAPIEvent(w, true),
					C = w.changedTouches,
					E = C.length,
					F = [],
					u = w.targetTouches,
					I = u.length,
					D = [],
					G = w.touches,
					z = G.length,
					B = [],
					H,
					A,
					y,
					x;
					if (v.type === b.TouchEvents.TOUCH_START) {
						for (H = 0; H < E; H++) {
							A = C[H];
							y = l._createAPITouch(A);
							if (y) {
								x = {
									touchValue: y,
									relatedTarget: null
								};
								m[A.identifier] = x;
								l._handleTouchEnterLeave(A, x);
								F.push(y);
							}
						}
					} else {
						for (H = 0; H < E; H++) {
							A = C[H];
							x = m[A.identifier];
							if (x) {
								y = x.touchValue;
								l._updateAPITouch(A, y);
								l._handleTouchEnterLeave(A, x);
								F.push(y);
							}
						}
					}
					for (H = 0; H < I; H++) {
						A = u[H];
						x = m[A.identifier];
						if (x) {
							D.push(x.touchValue);
						}
					}
					for (H = 0; H < z; H++) {
						A = G[H];
						x = m[A.identifier];
						if (x) {
							B.push(x.touchValue);
						}
					}
					v.changedTouches = F;
					v.targetTouches = D;
					v.touches = B;
					l._getModifiers(v, w);
					l._getGestureArgs(v, w);
					if (F.length > 0 && F[0].target) {
						l._dispatchTo(F[0].target, v);
					}
				},
				_handleTouchEnterLeave: function (v, u) {
					var w = l._getAPITarget(v),
					t;
					if (w !== null) {
						t = u.relatedTarget;
						if (w !== t) {
							if (t !== null) {
								l.handleLeave(t, w, b.TouchEvents.TOUCH_LEAVE, u.touchValue);
							}
							l.handleEnter(w, t, b.TouchEvents.TOUCH_ENTER, u.touchValue);
						}
						u.relatedTarget = w;
					}
				},
				handleEnter: function (z, t, w, y) {
					var x = z.getAncestors(),
					u = -1,
					v;
					if (t !== null) {
						u = e(x, t.getAncestors());
					}
					for (v = u + 1; v < x.length; v++) {
						x[v].dispatchEvent({
							type: w,
							clientX: y.clientX,
							clientY: y.clientY,
							userX: y.userX,
							userY: y.userY,
							ctrlKey: y.ctrlKey,
							shiftKey: y.shiftKey,
							altKey: y.altKey,
							relatedTarget: t,
							bubbles: false
						});
					}
				},
				handleLeave: function (z, t, w, y) {
					var x = z.getAncestors(),
					u = -1,
					v;
					if (t !== null) {
						u = e(x, t.getAncestors());
					}
					for (v = x.length - 1;
						v > u; v--) {
						x[v].dispatchEvent({
							type: w,
							clientX: y.clientX,
							clientY: y.clientY,
							userX: y.userX,
							userY: y.userY,
							ctrlKey: y.ctrlKey,
							shiftKey: y.shiftKey,
							altKey: y.altKey,
							relatedTarget: t,
							bubbles: false
						});
					}
				},
				_createAPITouch: function () {},
				_updateAPITouch: function () {
					return null;
				},
				_dispatchGestureEvent: function (u) {
					var t = l._createAPIEvent(u, true);
					l._getGestureArgs(t, u);
					l._dispatchTo(b.rootNode, t);
				},
				_createAPIEvent: function (t, u) {
					return {
						type: l._getAPIType(t),
						cancelable: u,
						preventNativeDefault: l._preventNativeDefault(t),
						stopNativePropagation: l._stopNativePropagation(t)
					};
				},
				_dispatchTo: function (x, w) {
					var t = w.type.toLowerCase(),
					v = r[t],
					u = p[t];
					if (v) {
						v(w, x);
					}
					x.dispatchEvent(w);
					if (u) {
						u(w);
					}
					b.tree.layout();
				},
				_getModifiers: function (u, t) {
					u.ctrlKey = t.ctrlKey;
					u.shiftKey = t.shiftKey;
					u.altKey = t.altKey;
				},
				_getNodeFromContainer: function (w) {
					var v = null,
					u = w.clientX,
					t = w.clientY,
					x = w.delta;
					if (isFinite(u) && isFinite(t)) {
						v = b.tree.getNodeAt(u, t);
					} else {
						if (isFinite(x)) {
							v = b.rootNode;
						}
					}
					return v;
				},
				_getCoordsFromContainer: function (t, x, w) {
					var v = x.clientX,
					u = x.clientY,
					y = w.globalToLocal(v, u);
					t.clientX = v;
					t.clientY = u;
					t.pageX = x.pageX;
					t.pageY = x.pageY;
					t.userX = y.x;
					t.userY = y.y;
				},
				_getAPIType: function () {
					return undefined;
				},
				_preventNativeDefault: function (t) {
					return function () {
						t.preventDefault();
					};
				},
				_stopNativePropagation: function (t) {
					return function () {
						t.stopPropagation();
					};
				},
				_stopNextNativeMouseEvent: function () {},
				_getAPITarget: function () {
					return null;
				},
				_getKeyArgs: function () {},
				_getMouseArgs: function () {},
				_getGestureArgs: function () {}
			});
			function h(t) {
				return function (v, u) {
					this.addEventListener(t, v, u);
				};
			}
			function j(t) {
				return function (v, u) {
					this.removeEventListener(t, v, u);
				};
			}
			function q(t) {
				return function (w) {
					var u = "",
					v = "";
					if (w === undefined) {
						w = 0;
					}
					u += t;
					v += w;
					if (!this._eventDescCache) {
						this._eventDescCache = {};
					}
					if (!this._eventDescCache[u]) {
						this._eventDescCache[u] = {};
					}
					if (!this._eventDescCache[u][v]) {
						this._eventDescCache[u][v] = {
							source: this,
							type: t,
							offset: w
						};
					}
					return this._eventDescCache[u][v];
				};
			}
			b.addEventsSupport = function (B, v) {
				var z = B.superClass,
				y = B.prototype,
				C = {},
				A,
				t,
				x,
				w,
				u;
				if (b.isA(v, Array)) {
					x = {};
					for (w = 0, u = v.length; w < u; w++) {
						b.mixin(x, v[w]);
					}
					v = x;
				}
				if (z && z.prototype.events) {
					C.prototype = z.prototype.events;
				}
				for (t in v) {
					if (v.hasOwnProperty(t)) {
						A = v[t];
						C[t] = A;
						x = A.charAt(0).toUpperCase() + A.substr(1);
						y["on" + x] = h(A);
						y["off" + x] = j(A);
						y["on" + x + "At"] = q(A);
					}
				}
				y.events = C;
			};
		}
			());
		(function () {
			var i = "mousedown",
			p = "mouseup",
			r = "mouseover",
			j = "mouseout",
			o = "mousemove",
			g = "keydown",
			k = "keyup",
			l = "touchstart",
			f = "touchend",
			n = "touchmove",
			m = "gesturestart",
			q = "gesturechange",
			e = "gestureend",
			h = {};
			h[i] = b.MouseEvents.MOUSE_DOWN;
			h[p] = b.MouseEvents.MOUSE_UP;
			h[r] = b.MouseEvents.MOUSE_OVER;
			h[j] = b.MouseEvents.MOUSE_OUT;
			h[o] = b.MouseEvents.MOUSE_MOVE;
			h[g] = b.KeyEvents.KEY_DOWN;
			h[k] = b.KeyEvents.KEY_UP;
			h[l] = b.TouchEvents.TOUCH_START;
			h[n] = b.TouchEvents.TOUCH_MOVE;
			h[f] = b.TouchEvents.TOUCH_END;
			h[m] = b.GenericGestureEvents.GESTURE_START;
			h[q] = b.GenericGestureEvents.GESTURE_CHANGE;
			h[e] = b.GenericGestureEvents.GESTURE_END;
			b.mixin(b.events, {
				_stopNextNativeMouseEvent: function (u, s, x) {
					var w = b.tree.svgNode,
					t = u.toLowerCase(),
					v;
					v = function (y) {
						var z = b.tree.svgGetRootClientCoords(),
						B = y.clientX - z.x,
						A = y.clientY - z.y;
						if (s === B && x === A) {
							y.stopPropagation();
						}
						w.removeEventListener(t, v, true);
					};
					w.addEventListener(t, v, true);
				},
				_getAPIType: function (s) {
					return h[s.type];
				},
				_getAPITarget: function (s) {
					var t = null,
					u = s.target;
					if (u && u.correspondingUseElement) {
						u = u.correspondingUseElement;
					}
					while (u && !u.getUserData && !u.ecmaScriptNode) {
						u = u.parentNode;
					}
					if (u) {
						if (u.getUserData) {
							t = u.getUserData("apiNode");
						} else {
							t = u.ecmaScriptNode;
						}
					}
					return t;
				},
				_getKeyArgs: function (t, s) {
					t.keyCode = s.keyCode;
					this._getModifiers(t, s);
				},
				_getMouseArgs: function (u, s, v) {
					this.svgSetCoords(u, s, v);
					this._getModifiers(u, s);
					if (s.button !== undefined) {
						u.button = s.button;
					}
					u.relatedTarget = null;
					var t = s.relatedTarget;
					if (t) {
						if (t.getUserData !== undefined) {
							u.relatedTarget = t.getUserData("apiNode");
						} else {
							if (t.hasOwnProperty("ecmaScriptNode")) {
								u.relatedTarget = t.ecmaScriptNode;
							}
						}
					}
				},
				_createAPITouch: function (s) {
					var t,
					u = this._getAPITarget(s);
					if (u !== undefined) {
						t = {
							identifier: s.identifier,
							target: u
						};
						this.svgSetCoords(t, s, u);
					}
					return t;
				},
				_updateAPITouch: function (s, t) {
					this.svgSetCoords(t, s, t.target);
				},
				_getGestureArgs: function (t, s) {
					t.rotation = s.rotation;
					t.scale = s.scale;
				},
				svgSetCoords: function (t, u, x) {
					var s = b.tree.svgGetRootClientCoords(),
					w = u.clientX - s.x,
					v = u.clientY - s.y,
					y = x.globalToLocal(w, v);
					t.clientX = w;
					t.clientY = v;
					t.userX = y.x;
					t.userY = y.y;
					t.screenX = u.screenX;
					t.screenY = u.screenY;
				},
				toggleNativeKeys: function (u) {
					var s = b.tree.svgRootElement,
					t = (u ? "add" : "remove") + "EventListener";
					s[t](g, this._dispatchKeyEvent, false);
					s[t](k, this._dispatchKeyEvent, false);
				},
				toggleNativeMouse: function (t) {
					var u = b.tree.svgNode,
					s = (t ? "add" : "remove") + "EventListener";
					u[s](i, this._dispatchMouseEvent, false);
					u[s](p, this._dispatchMouseEvent, false);
					u[s](r, this._dispatchMouseEvent, false);
					u[s](j, this._dispatchMouseEvent, false);
					u[s](o, this._dispatchMouseEvent, false);
				},
				toggleNativeTouches: function (t) {
					var u = b.tree.svgNode,
					s = (t ? "add" : "remove") + "EventListener";
					u[s](l, this._dispatchTouchEvent, false);
					u[s](n, this._dispatchTouchEvent, false);
					u[s](f, this._dispatchTouchEvent, false);
				},
				toggleNativeGestures: function (t) {
					var u = b.tree.svgNode,
					s = (t ? "add" : "remove") + "EventListener";
					u[s](m, this._dispatchGestureEvent, false);
					u[s](q, this._dispatchGestureEvent, false);
					u[s](e, this._dispatchGestureEvent, false);
				}
			});
		}
			());
		(function () {
			b.ns("oui.events");
			b.events.addDragSupport = function (l) {
				var i,
				j,
				o,
				e,
				n,
				m,
				k,
				f,
				h,
				g;
				j = function (p) {
					var r,
					q,
					v,
					t,
					u,
					s,
					x,
					w;
					p.stopPropagation();
					p.preventDefault();
					if (p.changedTouches === undefined) {
						r = p.clientX;
						q = p.clientY;
					} else {
						w = p.changedTouches[0];
						r = w.clientX;
						q = w.clientY;
					}
					x = n.globalToLocal(r, q);
					v = x.x;
					t = x.y;
					x = n.globalToLocal(h, g);
					u = x.x;
					s = x.y;
					n.dispatchEvent({
						type: b.DragEvents.DRAG,
						cancelable: true,
						dragClientX: (r - h),
						dragClientY: (q - g),
						dragUserX: (v - u),
						dragUserY: (t - s),
						clientX: r,
						clientY: q,
						userX: v,
						userY: t,
						shiftKey: p.shiftKey,
						ctrlKey: p.ctrlKey,
						defaultAction: n.getDefaultDragAction()
					});
					h = r;
					g = q;
				};
				o = function (p) {
					var s,
					q,
					u,
					t,
					x,
					w,
					A,
					y,
					r,
					z,
					v;
					l.offMouseMove(j);
					l.offMouseUp(o);
					l.offTouchMove(j);
					l.offTouchEnd(o);
					l.offMouseLeave(o);
					if (n) {
						A = n.globalToLocal(m, k);
						x = A.x;
						w = A.y;
						s = h;
						q = g;
						y = false;
						r = false;
						if (p) {
							if (p.changedTouches === undefined) {
								s = p.clientX;
								q = p.clientY;
							} else {
								v = p.changedTouches[0];
								s = v.clientX;
								q = v.clientY;
							}
							y = p.shiftKey;
							r = p.ctrlKey;
							z = p.timeStamp - f;
						}
						A = n.globalToLocal(s, q);
						u = A.x;
						t = A.y;
						n.dispatchEvent({
							type: b.DragEvents.DRAG_END,
							cancelable: true,
							shiftKey: y,
							ctrlKey: r,
							clientX: s,
							clientY: q,
							userX: u,
							userY: t,
							totalDragClientX: (s - m),
							totalDragClientY: (q - k),
							totalDragUserX: (u - x),
							totalDragUserY: (t - w),
							totalDragTime: z
						});
						n = undefined;
					}
				};
				e = function () {
					l.onMouseLeave(o);
				};
				i = function (t) {
					var v = t.target,
					s,
					r,
					u = t.touches,
					p,
					q = false,
					w;
					if (u !== undefined) {
						if (u.length === 1) {
							p = u[0];
						} else {
							q = true;
						}
					}
					if (q) {
						o(t);
					} else {
						while (v && !v.draggable()) {
							v = v.parentNode;
						}
						if (v) {
							n = v;
							if (p === undefined) {
								s = t.clientX;
								r = t.clientY;
							} else {
								s = p.clientX;
								r = p.clientY;
							}
							w = n.globalToLocal(s, r);
							n.dispatchEvent({
								type: b.DragEvents.DRAG_START,
								cancelable: true,
								shiftKey: t.shiftKey,
								ctrlKey: t.ctrlKey,
								clientX: s,
								clientY: r,
								userX: w.x,
								userY: w.y,
								defaultAction: e,
								stopDrag: o
							});
							m = h = s;
							k = g = r;
							f = t.timeStamp;
							l.onMouseMove(j);
							l.onMouseUp(o);
							l.onTouchMove(j);
							l.onTouchEnd(o);
						}
					}
				};
				l.onMouseDown(i);
				l.onTouchStart(i);
			};
		}
			());
		var b = b || {};
		(function () {
			function e(t, u, n, p, i, m, k, l, s, h, r, o, q) {
				var j = document.createEvent("MouseEvents");
				j.initMouseEvent(t, u, n, window, p, i.x, i.y, m, k, l, h, s, r, o, q);
				return j;
			}
			function g(u, w, n, q, i, m, k, l, t, h, s, p, r, v, o, x) {
				var j = document.createEvent("TouchEvent");
				j.initTouchEvent(u, w, n, window, q, i.x, i.y, m, k, l, h, t, s, p, r, v, o, x);
				return j;
			}
			function f(h) {
				return {
					x: h.screenX,
					y: h.screenY
				};
			}
			b.addGestureSupport = function (n, r, m, u, j, l, h) {
				var s,
				q,
				i,
				t,
				v,
				p,
				o = {},
				k;
				r = r || e;
				m = m || g;
				u = u || f;
				if (typeof j !== "number") {
					j = 500;
				}
				if (typeof l !== "number") {
					l = 800;
				}
				if (typeof h !== "number") {
					h = 10;
				}
				t = function (w) {
					return function () {
						var z = o[w.identifier],
						x,
						y;
						if (z && z.longPressTimeoutID) {
							x = z.event;
							y = r("touchlongpress", true, true, k, u(w), w.clientX, w.clientY, x.ctrlKey, x.shiftKey, x.altKey, x.metaKey, 0, w.target);
							w.target.dispatchEvent(y);
							z.longPressTimeoutID = undefined;
						}
					};
				};
				q = function (y) {
					var x = y.changedTouches,
					w,
					z = x.length,
					A,
					B;
					for (w = 0; w < z; w++) {
						B = x[w];
						A = o[B.identifier];
						if (A.longPressTimeoutID && Math.abs(B.clientX - A.clientX) > h && Math.abs(B.clientY - A.clientY) > h) {
							clearTimeout(A.longPressTimeoutID);
							A.longPressTimeoutID = undefined;
						}
					}
				};
				v = function (x) {
					var w;
					if (x.detail > 1 && x.timeStamp - p.timeStamp < j) {
						w = r("dbltap", true, true, x.detail, u(x), x.clientX, x.clientY, x.ctrlKey, x.shiftKey, x.altKey, x.metaKey, 0, x.target);
						x.target.dispatchEvent(w);
					}
					p = x;
				};
				i = function (y) {
					var D,
					B,
					C,
					A,
					w,
					x,
					E,
					z;
					n.removeEventListener("touchend", i, true);
					if (y.fake !== true) {
						D = y.changedTouches;
						C = D.length;
						for (B = 0; B < C; B++) {
							A = D[B];
							w = o[A.identifier];
							if (w) {
								if (w.longPressTimeoutID) {
									clearTimeout(w.longPressTimeoutID);
									w.longPressTimeoutID = undefined;
								}
								if (Math.abs(A.clientX - w.clientX) < h && Math.abs(A.clientY - w.clientY) < h && y.timeStamp - w.timeStamp < j) {
									y.stopPropagation(true);
									x = m("touchend", true, true, y.detail, u(y), y.clientX, y.clientY, y.ctrlKey, y.shiftKey, y.altKey, y.metaKey, y.touches, y.targetTouches, y.changedTouches, y.scale, y.rotation);
									x.fake = true;
									y.target.dispatchEvent(x);
									if (x.defaultPrevented === true) {
										y.preventDefault();
									}
									if (x.stopped === true) {
										y.stopPropagation();
									}
									z = 1;
									if (p && Math.abs(A.clientX - p.clientX) < h && Math.abs(A.clientY - p.clientY) < h) {
										z = p.detail + 1;
									}
									E = r("tap", true, true, z, u(A), A.clientX, A.clientY, y.ctrlKey, y.shiftKey, y.altKey, y.metaKey, 0, y.target);
									y.target.dispatchEvent(E);
									v(E);
								}
								o[A.identifier] = undefined;
							}
						}
					}
				};
				s = function (z) {
					var y = z.changedTouches,
					x,
					A = y.length,
					B,
					w;
					k = z.touches.length;
					for (x = 0; x < A; x++) {
						B = y[x];
						w = {
							identifier: B.identifier,
							screenX: B.screenX,
							screenY: B.screenY,
							clientX: B.clientX,
							clientY: B.clientY,
							event: z
						};
						o[B.identifier] = w;
						w.timeStamp = z.timeStamp;
						w.longPressTimeoutID = setTimeout(t(B, o), l);
					}
					n.addEventListener("touchmove", q, true);
					n.addEventListener("touchend", i, true);
				};
				n.addEventListener("touchstart", s, true);
			};
		}
			());
		(function () {
			b.ns("oui.events");
			b.events.addPressNTapSupport = function (e) {
				var f;
				e.onTouchStart(function (g) {
					f = g;
				});
				e.onTouchMove(function () {
					f = undefined;
				});
				e.onTap(function (g) {
					if (f) {
						if (g.identifier !== f.identifier) {
							f.target.dispatchEvent({
								type: b.GestureEvents.PRESS_AND_TAP,
								clientX: f.clientX,
								clientY: f.clientY,
								userX: f.userX,
								userY: f.userY,
								tapClientX: (g.clientX - f.clientX),
								tapClientY: (g.clientX - f.clientY),
								tapUserX: (g.userX - f.userX),
								tapUserY: (g.userY - f.userY),
								ctrlKey: f.ctrlKey,
								shiftKey: f.shiftKey
							});
						}
						f = undefined;
					}
				});
				e.onTouchEnd(function (g) {
					if (f && g.identifier === f.identifier) {
						f = undefined;
					}
				});
			};
		}
			());
		(function () {
			var g = 20,
			e = 0.2;
			function f(j, h) {
				var i = b.geom.centroid(j.touches, "clientX", "clientY");
				b.rootNode.dispatchEvent({
					type: b.GestureEvents.PINCH,
					clientX: i.x,
					clientY: i.y,
					userX: i.x,
					userY: i.y,
					phase: b.GestureEventPhases[h],
					scale: j.scale,
					rotation: j.rotation,
					preventNativeDefault: function () {
						j.preventNativeDefault();
					}
				});
			}
			b.ns("oui.events");
			b.events.addPinchSupport = function (i) {
				var j = false,
				h = false;
				i.onTouchStart(function () {
					j = false;
					h = false;
				});
				i.onTouchMove(function (k) {
					if (!j) {
						if (Math.abs(k.rotation) > g) {
							if (h) {
								f(k, "CANCEL");
							}
							j = true;
						} else {
							if (h) {
								f(k, "CHANGE");
							} else {
								if (Math.abs(k.scale - 1) > e) {
									h = true;
									f(k, "BEGIN");
								}
							}
						}
					}
				});
				i.onTouchEnd(function (k) {
					if (h && !j) {
						if (Math.abs(k.rotation) > g) {
							f(k, "CANCEL");
							j = true;
						} else {
							f(k, "END");
							j = true;
						}
					}
				});
			};
		}
			());
		(function () {
			var g = b.DirectionEnum,
			e = 10,
			k = Math.PI / 4;
			function i(n, p, m, o) {
				var r,
				q = Math.atan2((o - p), (m - n));
				if (Math.abs(q) < k) {
					r = g.RIGHT;
				} else {
					if (Math.abs(q - Math.PI / 2) < k) {
						r = g.DOWN;
					} else {
						if (Math.abs(q + Math.PI / 2) < k) {
							r = g.UP;
						} else {
							r = g.LEFT;
						}
					}
				}
				return r;
			}
			function l(n, o) {
				var m = n.length;
				while (m--) {
					if (o === n[m].identifier) {
						break;
					}
				}
				return n[m];
			}
			function j(t, p, s, n) {
				var o = p.screenX - t.screenX,
				m = p.screenY - t.screenY,
				r = n.screenX - s.screenX,
				q = n.screenY - s.screenY;
				return b.geom.dotprod(o, m, r, q) >= 0;
			}
			function f(p) {
				var t = [],
				o = p.length,
				n,
				u,
				r,
				q,
				s = Number.MAX_VALUE,
				m;
				while (o--) {
					u = p[o].target.getAncestors();
					if (u.length < s) {
						s = u.length;
						m = o;
					}
					t.push(u);
				}
				r = t.splice(m, 1)[0];
				for (o = 0; o < s; o++) {
					q = r[o];
					n = t.length;
					while (n--) {
						if (t[n][o] !== q) {
							break;
						}
					}
					if (n >= 0) {
						break;
					}
				}
				return r[o - 1];
			}
			function h(m, o) {
				var n = f(m);
				if (n) {
					n.dispatchEvent({
						type: b.GestureEvents.SWIPE,
						phase: b.GestureEventPhases[o.phase],
						direction: o.direction,
						translate: o.translate,
						velocity: o.velocity
					});
				}
			}
			b.ns("oui.events");
			b.events.SwipeSupport = {
				_forEachChangedTouch: function (r, q, m) {
					var p = r.changedTouches,
					s = r.timeStamp,
					o,
					t = p.length;
					for (o = 0; o < t && (m === null || !m()); o++) {
						this[q](p[o], s);
					}
				},
				_handleStartedTouch: function (n) {
					var m = this._touchesStarted;
					if (m) {
						if (l(m, n.identifier) === undefined) {
							this._touchesStarted.push(n);
						} else {
							if (this._nTouchesEnded > 0) {
								this._touchesStarted = undefined;
							}
						}
					} else {
						this._touchesStarted = [n];
						this._touchesMoved = {};
						this._nTouchesMoved = 0;
						this._nTouchesEnded = 0;
						this._centroid = undefined;
						this._gestureInfo = undefined;
					}
				},
				_handleMovedTouch: function (w, n) {
					var p = this._gestureInfo,
					u,
					D,
					m,
					o,
					C,
					z,
					s,
					x,
					E,
					q,
					t = 0,
					y = 0,
					B = 0,
					A = true,
					r = w.identifier,
					v = l(this._touchesStarted, r);
					if (v === undefined) {
						if (p) {
							p.phase = "CANCEL";
							h(this._touchesStarted, p);
						}
						this._touchesStarted = undefined;
					} else {
						if (this._touchesMoved[r] === undefined) {
							this._nTouchesMoved++;
						}
						this._touchesMoved[r] = w;
						o = this._touchesStarted.length;
						C = this._nTouchesMoved;
						if (C === o) {
							if (p === undefined) {
								D = {};
								u = this._centroid;
								if (u === undefined) {
									u = b.geom.centroid(this._touchesStarted, "screenX", "screenY");
									this._centroid = u;
								}
								z = this._touchesStarted[0];
								s = this._touchesMoved[z.identifier];
								for (x = 0; x < o; x++) {
									E = this._touchesStarted[x];
									q = this._touchesMoved[E.identifier];
									y += b.geom.dist(E.screenX, E.screenY, u.x, u.y);
									t = b.geom.dist(q.screenX, q.screenY, u.x, u.y);
									B += t;
									A = A && j(z, s, E, q);
									D[E.identifier] = {
										lastMovedTouch: q,
										distanceToCentroid: t
									};
								}
								y /= o;
								B /= C;
								m = Math.abs(y - B);
								if (m > e) {
									this._startGestureTime = n;
									p = {
										phase: "BEGIN",
										centroid: u,
										meanDistances: y,
										newMeanDistances: B,
										touchesInfo: D,
										duration: 1
									};
									if (A) {
										p.direction = i(v.screenX, v.screenY, w.screenX, w.screenY);
										p.translate = m;
										p.velocity = m / p.duration;
										h(this._touchesStarted, p);
									} else {
										this._touchesStarted = undefined;
									}
									this._gestureInfo = p;
								}
							} else {
								this._updateGestureEvent(w, n, false);
							}
						}
					}
				},
				_updateGestureEvent: function (q, p, t) {
					var s = this._gestureInfo,
					o = s.touchesInfo[q.identifier],
					n,
					r,
					m;
					if (o) {
						n = b.geom.dist(q.screenX, q.screenY, this._centroid.x, this._centroid.y);
						r = s.newMeanDistances + (n - o.distanceToCentroid) / this._touchesStarted.length;
						s.newMeanDistances = r;
						s.duration = (p - this._startGestureTime);
						m = Math.abs(s.meanDistances - r);
						if (t || (s.direction === i(o.lastMovedTouch.screenX, o.lastMovedTouch.screenY, q.screenX, q.screenY))) {
							if (t) {
								s.phase = "END";
							} else {
								s.phase = "CHANGE";
							}
							s.translate = m;
							s.velocity = m / s.duration;
							h(this._touchesStarted, s);
						} else {
							s.phase = "CANCEL";
							h(this._touchesStarted, s);
							this._touchesStarted = undefined;
						}
						o.lastMovedTouch = q;
						o.distanceToCentroid = n;
					} else {
						s.phase = "CANCEL";
						h(this._touchesStarted, s);
						this._touchesStarted = undefined;
					}
				},
				_handleEndedTouch: function (n, m) {
					this._nTouchesEnded++;
					if (this._gestureInfo) {
						this._updateGestureEvent(n, m, true);
						if (this._touchesStarted.length === this._nTouchesEnded) {
							this._touchesStarted = undefined;
						}
					} else {
						this._touchesStarted = undefined;
					}
				}
			};
			b.events.addSwipeSupport = function (n) {
				var o = b.events.SwipeSupport,
				m;
				m = function () {
					return (this._touchesStarted === undefined);
				};
				n.onTouchStart(function (p) {
					return o._forEachChangedTouch(p, "_handleStartedTouch", null);
				});
				n.onTouchMove(function (p) {
					return o._forEachChangedTouch(p, "_handleMovedTouch", m);
				});
				n.onTouchEnd(function (p) {
					return o._forEachChangedTouch(p, "_handleEndedTouch", m);
				});
			};
		}
			());
		(function () {
			b.ns("oui.focus");
			b.mixin(b.focus, {
				getFocusableAncestor: function (g) {
					var f = null,
					e = g.parentNode;
					if (e) {
						if (b.focus.isFocusableTarget(e)) {
							f = e;
						} else {
							f = b.focus.getFocusableAncestor(e);
						}
					}
					return f;
				},
				getFocusableDescendant: function (j, i, f) {
					var e = null,
					g = true,
					h,
					k;
					if (i === false) {
						g = false;
					}
					h = g ? "firstChild" : "lastChild";
					k = g ? "nextSibling" : "previousSibling";
					j = f ? f[k] : j[h];
					while (j && !e) {
						if (j._style.display) {
							if (j._style.focusable) {
								e = j;
							} else {
								e = b.focus.getFocusableDescendant(j, g);
							}
						}
						j = j[k];
					}
					return e;
				},
				isFocusableTarget: function (e) {
					return e._style.display && e._style.focusable;
				}
			});
		}
			());
		(function () {
			var f = b.UIEvents.FOCUS_IN,
			e = b.UIEvents.FOCUS_OUT,
			g = {};
			g[f] = function (m) {
				var n = m.target,
				l = n.getLayoutBounds(b.tree.focusLayer),
				h = n.getFocusOutlineOffset(),
				k = l.width + h * 2,
				i = l.height + h * 2,
				j;
				if (k > 0 && i > 0) {
					j = new b.graphics.Rectangle({
						x: l.x - h,
						y: l.y - h,
						width: k,
						height: i,
						fill: b.NO_PAINT,
						stroke: b.focusManager._strokeFocusOutline || b.GRAY
					});
					b.tree.focusLayer.appendChild(j);
				}
			};
			g[e] = function () {
				b.tree.focusLayer.removeChildren();
			};
			b.declare({
				name: "oui.focus.FocusManager",
				mixins: [b.events.EventSupport],
				membersDef: {
					init: function (h) {
						if (!b.isA(h, b.graphics.AbstractGraphicNode)) {
							h = null;
						}
						this._focusRoot = h;
						this._focusOwner = h;
						b.rootNode.addEventListener(b.ViewEvents.FOCUS_COMPONENT, this.handler("_onFocusCmp"));
						b.rootNode.addEventListener(b.ViewEvents.BLUR_COMPONENT, this.handler("_onBlurCmp"));
						b.rootNode.onKeyDown(b.focus.DefaultFocus);
					},
					getFocusOwner: function () {
						return this._focusOwner;
					},
					setFocusOutline: function (h) {
						if (b.isA(h, b.style.Paint)) {
							this._strokeFocusOutline = h;
						}
					},
					requestFocus: function (h, i) {
						if (b.isA(h, b.graphics.AbstractGraphicNode) && h.getFocusable()) {
							this._moveFocus(this._getValidFocusOwner(h), i);
						}
					},
					releaseFocus: function () {
						b.events.dispatchExternalEvent({
							type: b.ViewEvents.RELEASE_FOCUS
						});
					},
					_onFocusCmp: function () {
						if (this._focusOwner !== this._focusRoot) {
							var h = this._focusOwner;
							this._focusOwner = this._focusRoot;
							this._moveFocus(h, undefined, true);
						}
					},
					_onBlurCmp: function () {
						this._fire(e, this._focusOwner, null, null);
					},
					moveFocusDirection: function (i) {
						if (!b.isA(i, Boolean)) {
							i = true;
						}
						var h = this._getValidFocusOwner(this._focusOwner);
						h = this._moveFocusDirection(h, i);
						if (h === null) {
							h = b.focus.getFocusableDescendant(this._focusRoot, i);
						}
						this._moveFocus(h);
					},
					_getValidFocusOwner: function (h) {
						var k = h.getAncestors(),
						n = k.length,
						l = null,
						j,
						m = false;
						for (j = 0; j < n; j++) {
							l = k[j];
							if (l === this._focusRoot) {
								m = true;
							}
							if (!l.getDisplay()) {
								break;
							}
						}
						if (!m) {
							l = null;
						}
						return l;
					},
					_moveFocus: function (h, i, j) {
						var k = this._focusOwner;
						if (h !== null && h !== k) {
							this._fire(e, k, h, i);
							this._fire(f, h, k, i, j);
							this._moveFocusImpl(h);
							this._focusOwner = h;
						}
					},
					_moveFocusImpl: function (h) {},
					reFocus: function () {
						if (this._focusOwner !== null) {
							this._reFocusImpl(this._focusOwner);
						}
					},
					_reFocusImpl: function (h) {},
					_moveFocusDirection: function (k, j) {
						var i = null,
						h;
						if (k !== null) {
							h = k.parentNode;
							i = b.focus.getFocusableDescendant(h, j, k);
							if (i === null) {
								i = this._moveFocusDirection(h, j);
							}
						}
						return i;
					},
					_fire: function (l, m, h, i, k) {
						var j = false,
						n = false;
						if (i) {
							j = (i.shiftKey === true);
							n = (i.ctrlKey === true);
						}
						m.dispatchEvent({
							type: l,
							target: m,
							relatedTarget: h,
							cancelable: true,
							shiftKey: j,
							ctrlKey: n,
							defaultAction: g[l],
							details: k
						});
					}
				}
			});
		}
			());
		(function () {
			b.ns("oui.focus");
			var e = b.KeyCode;
			b.focus.DefaultFocus = {
				handleEvent: function (g) {
					var f = b.focusManager;
					if (b.equalIgnoreCase(b.KeyEvents.KEY_DOWN, g.type)) {
						switch (g.keyCode) {
						case e.TAB:
							f.moveFocusDirection(!g.shiftKey);
							break;
						case e.LEFT_ARROW:
							f.moveFocusDirection(false);
							break;
						case e.RIGHT_ARROW:
							f.moveFocusDirection(true);
							break;
						case e.ESC:
							f.releaseFocus();
							break;
						case e.ENTER:
						case e.SPACEBAR:
							g.target.dispatchEvent({
								type: b.UIEvents.ACTIVATE,
								defaultAction: g.target.getDefaultActivateAction()
							});
							break;
						default:
							break;
						}
					}
				}
			};
		}
			());
		(function () {
			var e = b.KeyCode;
			b.declare({
				name: "oui.focus.FocusRing",
				membersDef: {
					init: function () {},
					handleEvent: function (g) {
						var f = false;
						if (b.equalIgnoreCase(b.KeyEvents.KEY_DOWN, g.type)) {
							this._initFocusRoot(g);
							switch (g.keyCode) {
							case e.TAB:
								f = this.moveFocus(!g.shiftKey, g);
								break;
							case e.LEFT_ARROW:
								f = this.moveFocus(false, g);
								break;
							case e.RIGHT_ARROW:
								f = this.moveFocus(true, g);
								break;
							case e.ESC:
								f = this.moveFocusLevel(true, g);
								break;
							case e.ENTER:
								if ((g.ctrlKey !== true) && (g.shiftKey !== true)) {
									f = this.moveFocusLevel(false, g);
								}
								break;
							}
						}
						if (f) {
							g.stopPropagation();
						}
					},
					moveFocusLevel: function (f, h) {
						var j = false,
						g = b.focusManager.getFocusOwner(),
						i;
						if (g !== null) {
							i = f ? b.focus.getFocusableAncestor(g.parentNode) : b.focus.getFocusableDescendant(g);
							if (i !== null) {
								j = true;
								b.focusManager.requestFocus(i, h);
							}
						}
						return j;
					},
					moveFocus: function (j, i) {
						var m = false,
						f = b.focusManager,
						h = f.getFocusOwner(),
						k = f._moveFocusDirection(h, j),
						l = this._rootFocusNode,
						g;
						if (k === null) {
							k = b.focus.getFocusableDescendant(b.rootNode, j);
						}
						if (h !== l) {
							g = b.focus.getFocusableAncestor(h);
							if (k !== null && k.isDescendant(g) !== true) {
								k = b.focus.getFocusableDescendant(g, j);
							}
						} else {
							k = null;
						}
						if (k !== null) {
							m = true;
							f.requestFocus(k, i);
						}
						return m;
					},
					_initFocusRoot: function (f) {
						var g = f.currentTarget;
						if (!b.focus.isFocusableTarget(g)) {
							g = b.focus.getFocusableDescendant(g);
						}
						this._rootFocusNode = g;
					}
				}
			});
		}
			());
		(function () {
			var j = b.KeyCode,
			i = b.DirectionEnum,
			e = i.UP,
			h = i.DOWN,
			f = i.LEFT,
			g = i.RIGHT;
			function k(m, l) {
				return b.geom.dist(m.x, m.y, l.x, l.y);
			}
			b.declare({
				name: "oui.focus.SpatialFocus",
				mixins: [b.events.EventSupport],
				membersDef: {
					init: function (m, l) {
						this._keyDownFilter = this._defaultKeyDownFilter;
						this._focusContainer = null;
						if (b.isA(m, b.graphics.AbstractGraphicNode)) {
							m.onFocusIn(this.handler("_onFocusIn"));
							this._focusContainer = m;
						}
						if (b.isA(l, Function)) {
							this._keyDownFilter = l;
						}
					},
					_defaultKeyDownFilter: function (l) {
						return ((l.ctrlKey !== true) && (l.shiftKey !== true));
					},
					_onFocusIn: function (l) {
						var m = l.relatedTarget;
						if (m) {
							m._focusPoint = undefined;
						}
					},
					handleEvent: function (m) {
						var l = (m.keyCode === j.TAB);
						if (this._keyDownFilter(m) === true) {
							switch (m.keyCode) {
							case j.LEFT_ARROW:
								this._moveFocus(m, f);
								l = true;
								break;
							case j.RIGHT_ARROW:
								this._moveFocus(m, g);
								l = true;
								break;
							case j.UP_ARROW:
								this._moveFocus(m, e);
								l = true;
								break;
							case j.DOWN_ARROW:
								this._moveFocus(m, h);
								l = true;
								break;
							default:
							}
						}
						if (l) {
							m.stopPropagation();
						}
					},
					_moveFocus: function (l, n) {
						this._cacheFocusableNodes();
						var m = this._getFocusableItem(l.target, n);
						if (m !== null) {
							m._focusPoint = this._newFocusPoint;
							b.focusManager.requestFocus(m, l);
						}
					},
					_cacheFocusableNodes: function () {
						var m = b.focus.getFocusableDescendant(this._focusContainer),
						l;
						this._focusableNodes = [];
						if (m !== null) {
							this._focusableNodes.push(m);
							l = b.focusManager._moveFocusDirection(m, true);
							while (l) {
								this._focusableNodes.push(l);
								l = b.focusManager._moveFocusDirection(l, true);
							}
						}
					},
					_getFocusableItem: function (y, x) {
						var z = null,
						o = this._getNodeInfos(y, x),
						p = o.center,
						u,
						q,
						m,
						l,
						n,
						w,
						s,
						r,
						t,
						v = this._focusableNodes.length;
						this._updateEntryPoint(o);
						for (s = 0; s < v; s++) {
							r = this._focusableNodes[s];
							if (r !== y) {
								u = false;
								switch (x) {
								case e:
									t = this._getNodeInfos(r, h);
									if (t.center.y < p.y) {
										u = true;
									}
									break;
								case h:
									t = this._getNodeInfos(r, e);
									if (t.center.y > p.y) {
										u = true;
									}
									break;
								case f:
									t = this._getNodeInfos(r, g);
									if (t.center.x < p.x) {
										u = true;
									}
									break;
								case g:
									t = this._getNodeInfos(r, f);
									if (t.center.x > p.x) {
										u = true;
									}
									break;
								default:
								}
								if (u) {
									q = this._getNewFocusPoint(this._entryPoint, t.nodeBorder);
									l = this._computeFocusDistance(o, t, q);
									if ((m === undefined) || (l < m)) {
										m = l;
										n = b.geom.dist(p.x, p.y, t.center.x, t.center.y);
										z = r;
										this._newFocusPoint = q;
									} else {
										if (m === l) {
											w = b.geom.dist(p.x, p.y, t.center.x, t.center.y);
											if (w < n) {
												z = r;
												this._newFocusPoint = q;
											}
										}
									}
								}
							}
						}
						return z;
					},
					_getNodeInfos: function (p, s) {
						var q = p.getLayoutBounds(this._focusContainer),
						n = q.x,
						m = q.y,
						t = q.width,
						l = q.height,
						o = {
							x: n + t / 2,
							y: m + l / 2
						},
						r;
						switch (s) {
						case e:
							r = {
								x1: n,
								y1: m,
								x2: n + t,
								y2: m
							};
							break;
						case h:
							r = {
								x1: n,
								y1: m + l,
								x2: n + t,
								y2: m + l
							};
							break;
						case f:
							r = {
								x1: n,
								y1: m,
								x2: n,
								y2: m + l
							};
							break;
						case g:
							r = {
								x1: n + t,
								y1: m,
								x2: n + t,
								y2: m + l
							};
							break;
						default:
						}
						return {
							center: o,
							bounds: q,
							node: p,
							nodeBorder: r
						};
					},
					_updateEntryPoint: function (p) {
						var l = false,
						o = p.node,
						m = p.bounds,
						n;
						if (o._focusPoint) {
							n = o._focusPoint;
							if (n.x >= m.x && n.x <= m.x + m.width && n.y >= m.y && n.y <= m.y + m.height) {
								this._entryPoint = n;
								l = true;
							}
						}
						if (!l) {
							o._focusPoint = p.center;
							this._entryPoint = o._focusPoint;
						}
					},
					_getNewFocusPoint: function (m, n) {
						var l = {};
						if (n.x1 !== n.x2) {
							if (m.x < n.x1) {
								l.x = n.x1;
							} else {
								if (m.x > n.x2) {
									l.x = n.x2;
								} else {
									l.x = m.x;
								}
							}
						} else {
							l.x = n.x1;
						}
						if (n.y1 !== n.y2) {
							if (m.y < n.y1) {
								l.y = n.y1;
							} else {
								if (m.y > n.y2) {
									l.y = n.y2;
								} else {
									l.y = m.y;
								}
							}
						} else {
							l.y = n.y1;
						}
						return l;
					},
					_computeFocusDistance: function (l, r, p) {
						var m = this._getEuclideanDistance(p),
						q = l.nodeBorder,
						v = 0,
						t = 0,
						u = 0,
						o = 0,
						s,
						n;
						if (q.x1 !== q.x2) {
							t = Math.abs(p.y - q.y1);
							u = Math.abs(p.x - this._entryPoint.x);
						} else {
							v = Math.abs(p.x - q.x1);
							o = Math.abs(p.y - this._entryPoint.y);
						}
						s = 0;
						n = b.geom.intersectRect(l.bounds, r.bounds);
						if (n) {
							s = Math.sqrt(n.width * n.height);
						}
						return (m + v + t + u + o - s);
					},
					_getEuclideanDistance: function (l) {
						var n = this._entryPoint,
						m;
						if ((n.x === l.x) || (n.y === l.y)) {
							m = 0;
						} else {
							m = b.geom.dist(n.x, n.y, l.x, l.y);
						}
						return m;
					}
				}
			});
		}
			());
		(function () {
			b.ns("oui.utils");
			var e = 76,
			f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
			b.utils.toBase64 = function (l) {
				var p = 0,
				r = l.length,
				j = "",
				n = 0,
				g = 0,
				m = 0,
				q,
				h,
				k,
				o;
				while (n <= r) {
					if ((n % 3) === 0 && n !== 0) {
						m >>= 8;
						m &= 16777215;
						q = m;
						q >>= 18;
						q &= 63;
						j += f.charAt(q);
						g++;
						q = m;
						q >>= 12;
						q &= 63;
						j += f.charAt(q);
						g++;
						q = m;
						q >>= 6;
						q &= 63;
						j += f.charAt(q);
						g++;
						q = m;
						q &= 63;
						j += f.charAt(q);
						g++;
						m = 0;
						if (g >= e) {
							j += "\r";
							j += "\n";
							g = 0;
						}
						if (r - n < 3) {
							break;
						}
					}
					q = l[p++];
					m |= (256 + q) % 256;
					m <<= 8;
					n++;
				}
				h = (r - n) % 3;
				if (h !== 0) {
					m = 0;
					for (k = 0; k < 3; k++) {
						if (k < h) {
							q = l[p++];
							m |= (256 + q) % 256;
							m <<= 8;
							n++;
						} else {
							m |= 0;
							m <<= 8;
						}
					}
					m >>= 8;
					m &= 16777215;
					q = m;
					if (h >= 1) {
						q >>= 18;
						q &= 63;
						j += f.charAt(q);
						q = m;
						q >>= 12;
						q &= 63;
						j += f.charAt(q);
					}
					if (h >= 2) {
						q = m;
						q >>= 6;
						q &= 63;
						j += f.charAt(q);
					}
					if (h >= 3) {
						q = m;
						q &= 63;
						j += f.charAt(q);
					}
					for (o = 3; o > h; o--) {
						j += "=";
					}
				}
				if (j.length === 0) {
					c.error("ERR__BASE64");
				}
				return j;
			};
		}
			());
		(function () {
			var e;
			function g(q, p, h, r, n) {
				var s,
				m,
				j,
				o,
				l,
				k;
				if (q !== undefined) {
					m = e[q.type];
					if (m !== undefined) {
						s = m.call(null, q, h, r, n);
						j = q.name;
						if (h) {
							if (r === false) {
								if (q.shortcutName !== undefined) {
									o = q.shortcutName;
								}
							} else {
								if (j !== undefined) {
									o = j;
								}
							}
							if (o !== undefined && n !== undefined) {
								o = n + o;
							}
							if (o !== undefined) {
								h[o] = s;
							}
						}
						if (p) {
							if (j !== undefined && p !== h) {
								p[j] = s;
							}
							if (s.constructor === Array) {
								k = s.length;
								for (l = 0; l < k; l++) {
									p.appendChild(s[l]);
								}
							} else {
								p.appendChild(s);
							}
						}
					}
				}
				return s;
			}
			function f(i, h) {
				var k,
				j;
				if (b.isA(h, Function)) {
					k = h;
				} else {
					j = i;
					k = function (l) {
						return new j(l, l.name);
					};
				}
				return k;
			}
			b._CPGL_JSON_FACTORY = e = {
				array: function (k) {
					var h = [],
					j,
					m = k.length,
					l = k.of;
					if (b.isA(m, Number) && l !== undefined) {
						for (j = 0;
							j < m; j++) {
							h[j] = g(l);
						}
					}
					return h;
				}
			};
			b.load = function (l, m, q, j, o) {
				var h = null,
				k,
				p;
				if (l) {
					if (l.constructor === Array) {
						h = m || new b.graphics.Group();
						for (k = 0, p = l.length; k < p; k++) {
							g(l[k], h, q, j, o);
						}
					} else {
						if (l.constructor === Object) {
							if (m) {
								g(l, m, q, j, o);
								h = m;
							} else {
								h = g(l, null, q, j, o);
							}
						}
					}
				}
				return h;
			};
			b.addJSONLoaderSupport = function (h, j) {
				var i = "";
				if (!b.inheritsFrom(h, b.scene.AbstractNode)) {
					c.error("ERR__JSONLOAD__INV_CLASS");
				}
				if (b.isA(j.type, String)) {
					i = j.type;
				}
				if (i.length > 0) {
					if (!e[i]) {
						e[i] = f(h, j.factory);
					} else {
						c.warn("WARN__JSONLOAD__DUP_TYPE");
					}
				} else {
					c.warn("WARN__JSONLOAD__EMPTY_STR");
				}
			};
		}
			());
		(function () {
			var g = new RegExp("^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})\\/\\S+$", ""),
			i = b.config.hasOwnProperty("base") ? b.config.base + "/" : "",
			j = 0;
			function f(k) {
				if (!g.test(k) && k.indexOf("/") !== 0 && k.indexOf("data") !== 0) {
					k = i + k;
				}
				return k;
			}
			function h(k) {
				if (k.indexOf(i) === 0) {
					k = k.substring(i.length);
				}
				return k;
			}
			function e() {
				b.tree.layout();
			}
			b.declare({
				name: "oui.utils.ImageLoader",
				mixins: [b.events.EventSupport],
				eventsDef: {
					COMPLETE: "complete",
					ERROR: "error"
				},
				membersDef: {
					init: function () {},
					load: function (k) {
						var l = this;
						j++;
						if (b.tree.isPlatformAvailable()) {
							this._loadImpl(f(k));
						} else {
							b.tree.addEventListener(b.tree.events.PLATFORM_AVAILABLE, function () {
								l._loadImpl(k);
							});
						}
					},
					_loadImpl: function () {},
					_dispatchCompleteEvent: function (l, n, m, k, o) {
						this.dispatchEvent({
							type: this.events.COMPLETE,
							url: h(l),
							data: n,
							width: m,
							height: k,
							info: o,
							defaultAction: e
						});
						j--;
					},
					_dispatchErrorEvent: function (k, l) {
						this.dispatchEvent({
							type: this.events.ERROR,
							url: h(k),
							message: l
						});
						j--;
					}
				}
			});
			b.hasImagesLoading = function () {
				return (j !== 0);
			};
		}
			());
		(function () {
			b.mixin(b.utils.ImageLoader, {
				_loadImpl: function (e) {
					var f = new Image();
					f.onload = this.handler("svgOnComplete");
					f.onerror = this.handler("svgOnError");
					f.onabort = this.handler("svgOnAbort");
					f.src = e;
				},
				svgOnComplete: function (f) {
					var e = f.target;
					this._dispatchCompleteEvent(e.src, e, e.width, e.height);
				},
				svgOnError: function (e) {
					this._dispatchErrorEvent(e.target.src);
				},
				svgOnAbort: function (e) {
					this._dispatchErrorEvent(e.target.src);
				}
			});
		}
			());
		(function () {
			function f(g, h) {
				if (b.isA(g, Function)) {
					g.call(null, h);
				} else {
					if (g && b.isA(g.resourceUpdate, Function)) {
						g.resourceUpdate(h);
					}
				}
			}
			function e(h) {
				var g = h.observers.pop();
				while (g) {
					f(g, h);
					g = h.observers.pop();
				}
				b.tree.layout();
			}
			b.declare({
				name: "oui.utils.ResourcesManager",
				membersDef: {
					init: function () {
						var g,
						h = b.config.embeddedResourcesMap;
						this._resources = {};
						if (h) {
							for (g in h) {
								if (h.hasOwnProperty(g)) {
									this._initEmbedImpl(g, h[g]);
								}
							}
						}
					},
					requestResource: function (h, g) {
						var i;
						h = this._checkURL(h);
						i = this._resources[h];
						if (!i) {
							this._loadResource(h, h, g);
						} else {
							if (i.data === null) {
								if (g) {
									i.observers.push(g);
								}
							} else {
								f(g, i);
							}
						}
					},
					hasResource: function (h) {
						var g = false;
						if (h.indexOf("@cache;") === 0) {
							g = true;
						} else {
							g = (this._resources[h] !== undefined);
						}
						return g;
					},
					removeObserver: function (h, g) {
						var k,
						l,
						j;
						h = this._checkURL(h);
						k = this._resources[h];
						if (k) {
							l = k.observers;
							j = l.length;
							while (j--) {
								if (l[j] === g) {
									l.splice(j, 1);
									break;
								}
							}
						}
					},
					_checkURL: function (g) {
						if (g.indexOf("@cache;") === 0) {
							g = g.substr(7);
						}
						return g;
					},
					_initEmbedImpl: function () {},
					_loadResource: function (i, l, h) {
						var j = this,
						k,
						g;
						k = {
							url: i,
							data: null,
							width: 0,
							height: 0,
							observers: [h]
						};
						this._resources[i] = k;
						g = new b.utils.ImageLoader();
						g.onComplete(function (m) {
							j._onComplete(m, k);
						});
						g.onError(function () {
							j._onError(k);
						});
						g.load(l);
					},
					_onComplete: function (g, h) {
						h.width = g.width;
						h.height = g.height;
						this._onCompleteImpl(g, h);
						e(h);
					},
					_onCompleteImpl: function (g, h) {
						h.data = g.data;
					},
					_onError: function (g) {
						this._resources[g.url] = undefined;
						c.warn("WARN__RES_MGR__LOAD_FAIL", g.url);
					},
					_getBase64Data: function () {
						return undefined;
					}
				}
			});
		}
			());
		(function () {
			var f = "http://www.w3.org/1999/xlink",
			e = 0,
			g = "Resource";
			b.mixin(b.utils.ResourcesManager, {
				_initEmbedImpl: function (h, i) {
					this._loadResource(h, i.data);
					i.data = null;
				},
				_onCompleteImpl: function (h, j) {
					var l = g + e++,
					k,
					i;
					k = b.tree.svgCreateElt("symbol", {
						id: l
					});
					i = b.tree.svgCreateElt("image", {
						x: "0",
						y: "0",
						width: "100%",
						height: "100%",
						preserveAspectRatio: "none"
					});
					i.setAttributeNS(f, "xlink:href", h.url);
					k.appendChild(i);
					b.tree.svgAddDef(k);
					j.data = l;
				},
				_getBase64Data: function (i) {
					var h,
					k = b.config.embeddedResourcesMap,
					j,
					m,
					l;
					i = this._checkURL(i);
					if (k !== undefined && k[i] !== undefined) {
						j = this._resources[i];
						m = b.tree.svgGetShadowElementById(j.data);
						if (m) {
							l = m.firstChild;
							if (l) {
								h = l.getAttributeNS(f, "href");
							}
						}
					}
					return h;
				}
			});
		}
			());
		(function () {
			var e = "Obj_" + ((b.config && b.config.mapInstanceId !== undefined && b.config.mapInstanceId !== null) ? (b.config.mapInstanceId + "_") : ""),
			f = 0;
			b.declare({
				name: "oui.scene.AbstractNode",
				isAbstract: true,
				mixins: [b.events.EventSupport, b.lang.AspectSupport],
				membersDef: {
					init: function (g) {
						this.dirtyMarkers = {};
						this._id = e + f++;
						this.name = "";
						this.setName(g);
						this._createNodeImpl();
						this._nativeMode = false;
					},
					load: function (h, g) {
						return b.load(h, g || this);
					},
					setName: function (g) {
						if (typeof g === "string") {
							this.name = g;
							this.notifyNative(b.TAGS.NAME);
						}
					},
					getName: function () {
						return this.name;
					},
					getFullName: function () {
						var g = this.name;
						if (this.parentNode) {
							g = this.parentNode.getFullName() + "." + g;
						}
						return g;
					},
					getElementById: function (i) {
						var g = null,
						h;
						if (this._id === i) {
							g = this;
						} else {
							h = this.firstChild;
							while (h && !g) {
								g = h.getElementById(i);
								h = h.nextSibling;
							}
						}
						return g;
					},
					getElementsByName: function (h, g) {
						var i;
						g = g || [];
						i = this.firstChild;
						while (i) {
							if (i.name === h) {
								g.push(i);
							}
							i.getElementsByName(h, g);
							i = i.nextSibling;
						}
						return g;
					},
					getFirstElementByName: function (h) {
						var g,
						i = this.firstChild;
						while (i && !g) {
							if (i.name === h) {
								g = i;
							} else {
								g = i.getFirstElementByName(h);
							}
							i = i.nextSibling;
						}
						return g;
					},
					getId: function () {
						return this._id;
					},
					_isValidChild: function (g) {
						return b.isA(g, b.scene.AbstractNode);
					},
					_onInsertChild: function (i, g, h) {
						if (!g) {
							this._appendChildImpl(i);
						} else {
							this._insertBeforeImpl(i, g);
						}
						if (h !== true) {
							i._onParentChanged();
						}
						this._onChildrenChanged();
					},
					_onRemoveChild: function (i, h, g) {
						i._onParentChanged();
						if (h === false) {
							this._removeChildImpl(i);
							this._onChildrenChanged();
						} else {
							if (g === true) {
								this._removeChildrenImpl();
								this._onChildrenChanged();
							}
						}
					},
					isDescendant: function (h) {
						var g = false;
						if (this.parentNode === h) {
							g = true;
						} else {
							if (this.parentNode) {
								g = this.parentNode.isDescendant(h);
							}
						}
						return g;
					},
					_createNodeImpl: function () {},
					_appendChildImpl: function () {},
					_insertBeforeImpl: function () {},
					_removeChildImpl: function () {},
					_removeChildrenImpl: function () {},
					getAncestors: function () {
						var h = this,
						g = [];
						while (h) {
							g.unshift(h);
							h = h.parentNode;
						}
						return g;
					},
					bringToFront: function () {
						var g = this.parentNode;
						if (g && g.lastChild !== this) {
							g.insertBefore(this, null);
						}
					},
					sendToBack: function () {
						var g = this.parentNode;
						if (g && g.firstChild !== this) {
							g.insertBefore(this, g.firstChild);
						}
					},
					bringForward: function () {
						var g = this.parentNode,
						h = this.nextSibling;
						if (g && h) {
							g.insertBefore(this, h.nextSibling);
						}
					},
					sendBackward: function () {
						var g = this.parentNode,
						h = this.previousSibling;
						if (g && h) {
							g.insertBefore(this, h);
						}
					},
					notifyNative: function (g) {
						if (this._nativeMode) {
							this.notifyNativeImpl(g);
						} else {
							this.dirtyMarkers[g] = true;
						}
					},
					notifyNativeImpl: function (g, h) {},
					_preParentChangedImpl: function () {},
					_onParentChanged: function () {
						var g = false;
						this._preParentChangedImpl();
						if (this.parentNode) {
							g = this.parentNode._nativeMode;
						}
						this._setNativeMode(g);
					},
					_onChildrenChanged: function () {},
					_setNativeMode: function (g, k) {
						var j,
						i,
						h;
						if (this._nativeMode !== g) {
							this._nativeMode = g;
							j = this.firstChild;
							while (j) {
								j._setNativeMode(g, true);
								j = j.nextSibling;
							}
							if (g) {
								i = this.dirtyMarkers;
								for (h in i) {
									if (i[h]) {
										this.notifyNativeImpl(h, k);
									}
								}
								this.dirtyMarkers = {};
							}
						}
					},
					notifyChildren: function (g) {
						var h;
						this.notifyNative(g);
						h = this.firstChild;
						while (h) {
							h.notifyChildren(g);
							h = h.nextSibling;
						}
					}
				}
			});
			b.lang.LinkedListSupport.addLinkedList(b.scene.AbstractNode, b.scene.AbstractNode, "nextSibling", "previousSibling", "parentNode", "firstChild", "lastChild", "appendChild", "removeChild", "removeChildren", "insertBefore", "replaceChild", "hasChildNodes", "_isValidChild", "_onInsertChild", "_onRemoveChild", "childrenCount", "getChildAt", "getChildIndex", "setChildIndex");
		}
			());
		(function () {
			var f = "http://www.oracle.com/oui",
			e = "oui:name";
			b.mixin(b.scene.AbstractNode, {
				svgAttachToNode: function (g) {
					if (b.isA(g.setUserData, Function)) {
						g.setUserData("apiNode", this, null);
					} else {
						g.ecmaScriptNode = this;
					}
				},
				notifyNativeImpl: function (g, h) {
					if (g === b.TAGS.NAME) {
						this.svgNode.setAttributeNS(f, e, this.name);
					}
				},
				svgCreateNode: function () {
					this.svgNode = b.tree.svgCreateElt(this.SVG_TAG, {
						id: this._id
					});
					this.svgAttachToNode(this.svgNode);
					this.svgOnNodeCreated();
				},
				svgOnNodeCreated: function () {},
				svgAppendChild: function (g) {
					this.svgNode.appendChild(g.svgNode);
				},
				svgInsertBefore: function (h, g) {
					this.svgNode.insertBefore(h.svgNode, g.svgNode);
				},
				svgRemoveChild: function (g) {
					this.svgNode.removeChild(g.svgNode);
				},
				svgRemoveChildren: function () {
					while (this.svgNode.childNodes.length !== 0) {
						this.svgNode.removeChild(this.svgNode.lastChild);
					}
				}
			});
		}
			());
		(function () {
			function f(r, s, l, n, h, k, i, j, q, g, p, m, o) {
				return {
					type: r,
					canBubble: s,
					cancelable: l,
					detail: n,
					screenX: h.x,
					screenY: h.y,
					clientX: k,
					clientY: i,
					ctrlKey: j,
					shiftKey: q,
					altKey: g,
					metaKey: p,
					button: m,
					relatedTarget: o,
					preventNativeDefault: b.NO_OP,
					stopNativePropagation: b.NO_OP
				};
			}
			function e(s, u, l, o, h, k, i, j, r, g, q, n, p, t, m, v) {
				return {
					type: s,
					canBubble: u,
					cancelable: l,
					detail: o,
					screenX: h.x,
					screenY: h.y,
					clientX: k,
					clientY: i,
					ctrlKey: j,
					shiftKey: r,
					altKey: g,
					metaKey: q,
					touches: n,
					targetTouches: p,
					changedTouches: t,
					scale: m,
					rotation: v,
					preventNativeDefault: b.NO_OP,
					stopNativePropagation: b.NO_OP
				};
			}
			b.declare({
				name: "oui.scene.Tree",
				mixins: [b.events.EventSupport, b.lang.AspectSupport],
				membersDef: {
					events: {
						PLATFORM_AVAILABLE: "platformAvailable"
					},
					init: function () {
						this.userLayer = this._createLayer("userLayer");
						this.focusLayer = this._createLayer("focusLayer");
						this.tooltipLayer = this._createLayer("tooltipLayer");
						this.layers = [this.userLayer, this.focusLayer, this.tooltipLayer];
						this._isReady = false;
						this.addEventListener(this.events.PLATFORM_AVAILABLE, this.handler("_onReady"));
					},
					destroy: function () {
						b.timer.stop();
						b.events._userEventsSupport.setProperties({
							fromPlatform: {
								keyEvents: false,
								mouseEvents: false,
								wheelEvents: false,
								touchEvents: false,
								gestureEvents: false
							}
						});
						this._destroyImpl();
					},
					layout: function () {
						var g,
						j,
						h = this.layers;
						for (g = 0, j = h.length; g < j; g++) {
							h[g].layout();
						}
					},
					setLayoutDir: function (g) {
						var h,
						k,
						j = this.layers;
						if ((g === b.RTL || g === b.LTR) && g !== b.layoutDir) {
							b.layoutDir = g;
							b.filters._onLayoutDir(g);
							for (h = 0, k = j.length; h < k; h++) {
								j[h].notifyChildren(b.TAGS.LAYOUT_DIR);
							}
							if (typeof this._setLayoutDirImpl === "function") {
								this._setLayoutDirImpl();
							}
						}
					},
					getNodeAt: function (g, m) {
						var j = null,
						h,
						l = this.layers,
						k = l.length;
						for (h = k - 1; h >= 0 && !j; h--) {
							j = this._getChildAtImpl(l[h], g, m);
						}
						return j;
					},
					getElementById: function (l) {
						var h = null,
						g,
						k = this.layers,
						j = k.length;
						for (g = j - 1; g >= 0 && !h; g--) {
							h = k[g].getElementById(l);
						}
						return h;
					},
					isPlatformAvailable: function () {
						return this._isReady;
					},
					getCSSValues: function (h, i) {
						var g = null;
						if (typeof b.config.readCSSValues === "function") {
							g = b.config.readCSSValues(h, i);
						}
						return g;
					},
					_createLayer: function (g) {
						var i = new b.graphics.Group(undefined, g),
						h = b.events;
						h.addDragSupport(i);
						h.addPressNTapSupport(i);
						h.addPinchSupport(i);
						h.addSwipeSupport(i);
						b.addGestureSupport(i, f, e);
						return i;
					},
					_initShadowTree: function (g) {
						g._createNodeImpl();
						var h = g.firstChild;
						while (h !== null) {
							this._initShadowTree(h);
							g._appendChildImpl(h);
							h = h.nextSibling;
						}
						g.invalidateLayout();
					},
					_onReady: function () {
						var j,
						l,
						h,
						k = this.layers,
						g = (b.environment === b.EnvironmentEnum.MOBILE);
						this._enableTreeOpsImpl();
						b.events._userEventsSupport.setProperties({
							fromPlatform: {
								keyEvents: true,
								mouseEvents: g ? false : true,
								wheelEvents: true,
								touchEvents: true,
								gestureEvents: true
							}
						});
						for (j = 0, l = k.length; j < l; j++) {
							h = k[j];
							this._initShadowTree(h);
							this._attachLayerImpl(h);
							h._setNativeMode(true);
						}
						this.layout();
						this._isReady = true;
					},
					_updateViewport: function (i, h) {
						var g = b.viewportWidth,
						j = b.viewportHeight;
						if (g !== i || j !== h) {
							b.viewportWidth = i;
							b.viewportHeight = h;
							b.viewportBounds.width = i;
							b.viewportBounds.height = h;
							this.userLayer.dispatchEvent({
								type: b.ViewEvents.VIEWPORT_RESIZE,
								oldViewportWidth: g,
								oldViewportHeight: j,
								newViewportWidth: i,
								newViewportHeight: h
							});
							this.layout();
						}
					},
					_updateDeviceOrientation: function (g) {
						if (b.deviceOrientation !== g) {
							b.deviceOrientation = g;
							this.userLayer.dispatchEvent({
								type: b.ViewEvents.DEVICE_ORIENTATION,
								orientation: b.deviceOrientation
							});
						}
					},
					_setContainerImpl: function () {},
					_destroyImpl: function () {},
					_getChildAtImpl: function (h, g, i) {
						return h.hitTest(g, i);
					},
					_enableTreeOpsImpl: function () {},
					_attachLayerImpl: function (g) {}
				}
			});
		}
			());
		(function () {
			var g = {},
			f = b.DeviceOrientationEnum,
			e = "http://www.w3.org/2000/svg";
			b.mixin(b.scene.Tree, {
				_setContainerImpl: function (o) {
					var i,
					h,
					j,
					m,
					n,
					k,
					l;
					if (!o || o.nodeType !== 1) {
						c.error("ERR__SVG__INV_CONTAINER");
					}
					this.ownerDocument = o.ownerDocument;
					if (o.nodeName === "svg") {
						i = o;
						i.setAttribute("class", "fortknox");
					} else {
						i = this.svgCreateElt("svg", {
							width: "100%",
							height: "100%",
							"class": "fortknox"
						});
						o.appendChild(i);
					}
					this.svgRootElement = i;
					h = this.svgCreateElt("defs");
					i.appendChild(h);
					this.svgDefs = h;
					j = this.svgCreateElt("g");
					i.appendChild(j);
					this.svgNode = j;
					n = this.handler("_onHTML5DragStart");
					i.addEventListener("dragstart", n, false);
					this.defaultStyle = this.svgCreateElt("style");
					j.appendChild(this.defaultStyle);
					this.svgUpdateDefaults();
					m = this.ownerDocument.defaultView;
					k = this.handler("svgOnWindowResized");
					m.addEventListener("resize", k, false);
					l = this.handler("svgOnDeviceOrientationChanged");
					m.addEventListener("orientationchange", l, false);
					m.addEventListener("resize", l, false);
					this.svgOnWindowResized();
					this.svgOnDeviceOrientationChanged();
					this.dispatchEvent({
						type: this.events.PLATFORM_AVAILABLE
					});
				},
				_setLayoutDirImpl: function () {
					this.svgUpdateDefaults();
				},
				svgUpdateDefaults: function () {
					var l = [],
					m,
					h,
					k,
					j,
					o;
					for (m in g) {
						if (g.hasOwnProperty(m)) {
							h = g[m];
							k = [m, " {"];
							for (j = 0, o = h.length; j < o; j++) {
								h[j](k);
							}
							k.push("}");
							l = l.concat(k);
						}
					}
					this.defaultStyle.textContent = l.join("");
				},
				svgOnWindowResized: function () {
					var l = 0,
					k = 0,
					i = this.svgRootElement.parentNode,
					j,
					h;
					if (i === this.ownerDocument) {
						j = i.defaultView;
						l = j.innerWidth;
						k = j.innerHeight;
					} else {
						h = i.getBoundingClientRect();
						l = h.right - h.left;
						k = h.bottom - h.top;
					}
					this._updateViewport(l, k);
				},
				svgOnDeviceOrientationChanged: function () {
					var h,
					j = this.ownerDocument.defaultView,
					i;
					if (j.orientation !== undefined) {
						h = Math.abs(j.orientation) === 90 ? f.LANDSCAPE : f.PORTRAIT;
					} else {
						i = j.screen;
						h = i.width > i.height ? f.LANDSCAPE : f.PORTRAIT;
					}
					this._updateDeviceOrientation(h);
				},
				_onHTML5DragStart: function (h) {
					h.preventDefault();
				},
				_enableTreeOpsImpl: function () {
					var h = b.scene.AbstractNode.prototype;
					h._createNodeImpl = h.svgCreateNode;
					h._appendChildImpl = h.svgAppendChild;
					h._insertBeforeImpl = h.svgInsertBefore;
					h._removeChildImpl = h.svgRemoveChild;
					h._removeChildrenImpl = h.svgRemoveChildren;
					h = b.graphics.Text.prototype;
					h._getBBoxImpl = h.svgGetBBox;
				},
				_attachLayerImpl: function (h) {
					this.svgNode.appendChild(h.svgNode);
				},
				svgAddDef: function (h) {
					this.svgDefs.appendChild(h);
				},
				svgCreateElt: function (j, h) {
					var i = this.ownerDocument.createElementNS(e, j);
					i.attr = function (l, k) {
						var m;
						if (arguments.length === 2) {
							this.setAttribute(l, k);
						} else {
							for (m in l) {
								this.setAttribute(m, l[m]);
							}
						}
						return this;
					};
					i.rm = i.removeAttribute;
					return i.attr(h);
				},
				svgCreateTextElt: function (h) {
					return this.ownerDocument.createTextNode(h);
				},
				svgGetShadowElementById: function (h) {
					return this.ownerDocument.getElementById(h);
				},
				svgGetRootClientCoords: function () {
					var h = {
						x: 0,
						y: 0
					},
					j,
					i = this.svgRootElement.parentNode;
					if (i !== this.ownerDocument) {
						j = i.getBoundingClientRect();
						h.x = j.left;
						h.y = j.top;
					}
					return h;
				}
			});
			b.registerCSS = function (j, i) {
				var h = ".fortknox ",
				k;
				if (j.indexOf(",") > 0) {
					j = h + j.replace(/,/gi, ", " + h);
				} else {
					if (j === "svg") {
						j = j + h;
					} else {
						j = h + j;
					}
				}
				k = g[j];
				if (!k) {
					k = [];
					g[j] = k;
				}
				k.push(i);
			};
		}
			());
		(function () {
			b.declare({
				name: "oui.timing.Timer",
				mixins: [b.events.EventSupport],
				membersDef: {
					TIMER_EVENT: "TIMER_EVENT",
					DEFAULT_FRAME_RATE: 25,
					init: function (e) {
						if (b.isFinitePositiveNumber(e, true)) {
							this.frameRate = e;
						} else {
							this.frameRate = this.DEFAULT_FRAME_RATE;
						}
					},
					start: function () {
						var f = this;
						function e() {
							f.dispatchEvent({
								type: f.TIMER_EVENT
							});
							b.tree.layout();
						}
						if (this.startImpl) {
							this.startImpl(e);
						} else {
							if (setInterval) {
								this.currentIntervalID = setInterval(e, 1000 / this.frameRate);
							} else {
								c.error("ERR__TIMER__START");
							}
						}
					},
					stop: function () {
						if (this.stopImpl) {
							this.stopImpl();
						} else {
							if (this.currentIntervalID && clearInterval) {
								clearInterval(this.currentIntervalID);
								this.currentIntervalID = undefined;
							} else {
								c.error("ERR__TIMER__STOP");
							}
						}
					}
				}
			});
		}
			());
		(function () {
			var e = b.defs,
			f = "trigger",
			j = 1000,
			h = "begin",
			i = "end",
			g = {
				source: {
					type: Object,
					constraint: b.supportsEvents,
					defaultValue: null
				},
				type: e.String(""),
				offset: e.PositiveNumber(0)
			};
			b.declare({
				name: "oui.timing.TimeInterval",
				mixins: [b.events.EventSupport, b.lang.PropertiesSupport],
				membersDef: {
					init: function (k) {
						this._plugged = true;
						this._active = false;
						this._beginSyncValues = [];
						this._endSyncValues = [];
						this._eventValues = [];
						this._initProperties(k);
						this._timerHandler = this.handler("_onTimer");
					},
					_onTimer: function (n) {
						var m = n.timeStamp,
						k = this._beginTime,
						l = this._endTime;
						if (m >= k && l >= k) {
							if (!this._active) {
								this.dispatchEvent({
									type: this.events.BEGIN,
									bubbles: false,
									syncTime: k
								});
								this._curBegin = k;
								this._curEnd = k + this._simpleDur;
								this._active = true;
								this._start(k);
							}
							this._repeat(m);
							if (m >= l) {
								this._stop(l);
								this._active = false;
								b.timer.removeEventListener(b.timer.TIMER_EVENT, this._timerHandler);
								this.dispatchEvent({
									type: this.events.END,
									bubbles: false,
									syncTime: l,
									scheduled: (l >= this._curEnd)
								});
							} else {
								this._play(m);
							}
						}
					},
					_start: function (k) {},
					_play: function (k) {},
					_stop: function (k) {},
					beginAt: function (k) {
						this._beginSyncAt(b.currentTimeMillis(), k);
					},
					endAt: function (k) {
						this._endSyncAt(b.currentTimeMillis(), k);
					},
					_beginSyncAt: function (m, n) {
						var l = this._properties,
						k;
						if (isFinite(n) && n > 0) {
							m += n * j;
						}
						this._simpleDur = l.dur * j;
						k = this._simpleDur;
						if (l.repeatDur !== 0 && l.repeatCount !== 0) {
							k = Math.min(l.repeatDur * j, l.repeatCount * this._simpleDur);
						} else {
							if (l.repeatDur !== 0) {
								k = l.repeatDur * j;
							} else {
								if (l.repeatCount !== 0) {
									k = l.repeatCount * this._simpleDur;
								}
							}
						}
						this._endTime = m + k;
						this._beginTime = m;
						this._sync(h, this._beginTime);
						this._sync(i, this._endTime);
						b.timer.addEventListener(b.timer.TIMER_EVENT, this._timerHandler);
					},
					_endSyncAt: function (k, l) {
						if (isFinite(l) && l > 0) {
							k += l * j;
						}
						if (k < this._endTime) {
							this._endTime = k;
							this._sync(i, this._endTime);
						}
					},
					_sync: function (l, p) {
						var o = (l === h) ? this._beginSyncValues : this._endSyncValues,
						k,
						n = o.length,
						m;
						for (k = 0;
							k < n; k++) {
							m = o[k];
							m.target[m.funcName](p, m.offset);
						}
					},
					_repeat: function (k) {
						var m = this._beginTime,
						p = this._endTime,
						s = this._simpleDur,
						q = this._curBegin,
						r = this._curEnd,
						l,
						n,
						o;
						if (k >= r && r < p) {
							l = Math.floor((q - m) / s);
							o = Math.floor((k - q) / s);
							for (n = 1; n <= o && r < p; n++) {
								q += s;
								r += s;
								this.dispatchEvent({
									type: this.events.REPEAT,
									bubbles: false,
									syncTime: q,
									detail: l + n
								});
							}
							this._curBegin = q;
							this._curEnd = r;
						}
					},
					onPropChanged: function (k) {
						if (k === f) {
							this.plug();
						}
					},
					addBeginEvent: function (k) {
						this._addEvent(k, "beginEvents", h, []);
					},
					addEndEvent: function (k) {
						this._addEvent(k, "endEvents", i, [true]);
					},
					_addEvent: function (l, p, o, k) {
						var n = this._properties,
						m;
						if (n[p].length === 0) {
							n[p] = [];
						}
						m = n[p];
						if (b.isObjectValid(l, g, true)) {
							m.push(l);
							if (this._plugged) {
								this._plug(l, o, k);
							}
						}
					},
					plug: function () {
						var l,
						k,
						m;
						this.unplug();
						l = this._properties.beginEvents;
						for (k = 0, m = l.length; k < m; k++) {
							this._plug(l[k], h);
						}
						l = this._properties.endEvents;
						for (k = 0, m = l.length; k < m; k++) {
							this._plug(l[k], i);
						}
						this._plugged = true;
					},
					_plug: function (o, l) {
						var k = this,
						n = "_" + l + "SyncAt",
						p = o.offset,
						m;
						if (o.type === h || o.type === i) {
							m = {
								target: k,
								funcName: n,
								offset: p
							};
							o.source._addSyncValue(o.type, m);
						} else {
							m = function (q) {
								k[n](q.timeStamp, p);
							};
							o.source.addEventListener(o.type, m);
						}
						this._eventValues.push({
							desc: o,
							data: m
						});
					},
					unplug: function () {
						var k = this._eventValues,
						l,
						p,
						o,
						m;
						for (l = 0, p = k.length; l < p; l++) {
							o = k[l].desc;
							m = k[l].data;
							if (o.type === h || o.type === i) {
								o.source._removeSyncValue(o.type, m);
							} else {
								o.source.removeEventListener(o.type, m);
							}
						}
						k.length = 0;
						this._plugged = false;
					},
					_addSyncValue: function (k, m) {
						var l = (k === h) ? this._beginSyncValues : this._endSyncValues;
						l.push(m);
					},
					_removeSyncValue: function (l, o) {
						var n = (l === h) ? this._beginSyncValues : this._endSyncValues,
						k,
						m = n.length;
						for (k = 0; k < m; k++) {
							if (n[k] === o) {
								n.splice(k, 1);
							}
						}
					}
				},
				eventsDef: [b.SyncEvents],
				propertiesDef: {
					dur: e.PositiveNumber(0),
					repeatDur: e.PositiveNumber(0),
					repeatCount: e.PositiveNumber(0),
					beginEvents: e.ArrayOfProperties(g, 0, Number.MAX_VALUE, [], f),
					endEvents: e.ArrayOfProperties(g, 0, Number.MAX_VALUE, [], f)
				}
			});
			b.timing.eventTriggerDefinition = g;
		}
			());
		(function () {
			b.ns("oui.anim");
			function e(f) {
				return {
					easeIn: function (g) {
						return g === 0 ? 0 : f(g);
					},
					easeOut: function (g) {
						return 1 - f(1 - g);
					},
					easeInOut: function (g) {
						if (g < 0.5) {
							g = f(2 * g) / 2;
						} else {
							g = 1 - f(2 * (1 - g)) / 2;
						}
						return g;
					}
				};
			}
			b.anim.easing = {
				linear: e(function (f) {
					return f;
				}),
				quadratic: e(function (f) {
					return f * f;
				}),
				cubic: e(function (f) {
					return f * f * f;
				}),
				quartic: e(function (f) {
					return f * f * f * f;
				}),
				quintic: e(function (f) {
					return f * f * f * f * f;
				}),
				exponential: e(function (f) {
					return Math.pow(2, 10 * (f - 1));
				}),
				circular: e(function (f) {
					return 1 - Math.sqrt(1 - f * f);
				}),
				sine: e(function (f) {
					return 1 - Math.cos(f * Math.PI / 2);
				}),
				back: e(function (g, f) {
					f = f || 1.70158;
					return g * g * ((f + 1) * g - f);
				}),
				bounce: e(function (f) {
					f = 1 - f;
					if (f < 1 / 2.75) {
						f = 2.75 * f;
						f = f * f;
					} else {
						if (f < 2 / 2.75) {
							f = 2.75 * f - 1.5;
							f = f * f + 0.75;
						} else {
							if (f < 2.5 / 2.75) {
								f = 2.75 * f - 2.25;
								f = f * f + 0.9375;
							} else {
								f = 2.75 * f - 2.625;
								f = f * f + 0.984375;
							}
						}
					}
					return 1 - f;
				})
			};
		}
			());
		(function () {
			b.ns("oui.anim");
			b.mixin(b.anim, {
				interpolateDiscrete: function (h, f, g) {
					var e;
					if (g <= 0.5) {
						e = h;
					} else {
						e = f;
					}
					return e;
				},
				interpolateNumber: function (g, e, f) {
					return g + (e - g) * f;
				},
				interpolateColor: function (f, e, g) {
					return new b.style.Color(f.red() + (e.red() - f.red()) * g, f.green() + (e.green() - f.green()) * g, f.blue() + (e.blue() - f.blue()) * g, f.alpha() + (e.alpha() - f.alpha()) * g);
				}
			});
		}
			());
		(function () {
			var e = b.defs,
			f = b.FillEnum;
			b.declare({
				name: "oui.anim.AbstractAnimation",
				isAbstract: true,
				extend: b.timing.TimeInterval,
				membersDef: {
					_stop: function (h) {
						var g = this._properties.fill;
						if (g === f.REMOVE || (g === f._LEGACY && h < this._curEnd)) {
							this._play(this._curBegin);
						} else {
							this._play(h);
						}
					},
					_progress: function (h, i, l) {
						var j,
						m = b.anim.easing[this._properties.easeMode],
						g = this._properties.easeIn,
						k = this._properties.easeOut;
						if (l < h) {
							j = 0;
						} else {
							if (l > i || h === i) {
								j = 1;
							} else {
								j = (l - h) / (i - h);
								if (m) {
									if (g && !k) {
										j = m.easeIn(j);
									} else {
										if (!g && k) {
											j = m.easeOut(j);
										} else {
											if (g && k) {
												j = m.easeInOut(j);
											}
										}
									}
								}
							}
						}
						return j;
					}
				},
				propertiesDef: {
					easeMode: e.String("quadratic"),
					easeIn: e.Boolean(false),
					easeOut: e.Boolean(false),
					fill: e.Enum(f, f.FREEZE)
				}
			});
		}
			());
		(function () {
			var j = b.anim.AbstractAnimation.prototype,
			f = b.defs,
			g = b.BASE_VALUE,
			i = b.anim.interpolateDiscrete,
			l = b.anim.interpolateNumber,
			h = b.anim.interpolateColor,
			m = "ANIM_TAG",
			e,
			k;
			e = function (p, n, o) {
				return b.anim.interpolateDiscrete(p, n, o);
			};
			k = {
				interpolator: f.Function(3, e),
				beginValue: f.ObjectOfType(Object, g, true, false),
				endValue: f.ObjectOfType(Object, g, true, false)
			};
			b.declare({
				name: "oui.anim.AnimateStyle",
				extend: b.anim.AbstractAnimation,
				membersDef: {
					onPropChanged: function (n) {
						var o = this._properties.targetNode;
						if (n === m) {
							if (o) {
								this._checkInterpolators(this._properties.animValues, o.StyleDefinition.prototype);
							}
						} else {
							j.onPropChanged.call(this, n);
						}
					},
					_checkInterpolators: function (r, p) {
						var o,
						q,
						n,
						s;
						if (p === undefined) {
							p = {};
						}
						for (o in r) {
							if (r.hasOwnProperty(o)) {
								q = r[o];
								n = p[o];
								if (q.interpolator === undefined) {
									this._checkInterpolators(q, n);
								} else {
									if (q.interpolator !== e) {
										q._interpolate = q.interpolator;
									} else {
										if (n !== undefined) {
											s = n.type;
											if (s === Boolean) {
												q._interpolate = i;
											} else {
												if (s === Number) {
													q._interpolate = l;
												} else {
													if (s === b.style.Color || (s === b.style.Paint && b.isA(q.beginValue, b.style.Color) && b.isA(q.endValue, b.style.Color))) {
														q._interpolate = h;
													} else {
														q._interpolate = e;
													}
												}
											}
										} else {
											if (b.isA(q.beginValue, Boolean) && b.isA(q.endValue, Boolean)) {
												q._interpolate = i;
											} else {
												if (b.isA(q.beginValue, Number) && b.isA(q.endValue, Number)) {
													q._interpolate = l;
												} else {
													if (b.isA(q.beginValue, b.style.Color) && b.isA(q.endValue, b.style.Color)) {
														q._interpolate = h;
													} else {
														q._interpolate = e;
													}
												}
											}
										}
									}
								}
							}
						}
					},
					_start: function () {
						var n = this._properties;
						this._resolveBaseValues(n.animValues, n.targetNode._style);
					},
					_play: function (o) {
						var n = this._properties;
						n.targetNode.applyStyle(this._buildStyleObjectFor(n.animValues, this._progress(this._curBegin, this._curEnd, o)));
					},
					_resolveBaseValues: function (r, p) {
						var n,
						q,
						o;
						for (n in r) {
							q = r[n];
							o = p ? p[n] : null;
							if (q.hasOwnProperty("_interpolate")) {
								if (q.beginValue === g) {
									q._beginVal = o;
								} else {
									q._beginVal = q.beginValue;
								}
								if (q.endValue === g) {
									q._endVal = o;
								} else {
									q._endVal = q.endValue;
								}
							} else {
								this._resolveBaseValues(q, o);
							}
						}
					},
					_buildStyleObjectFor: function (r, o) {
						var n,
						q,
						p = {};
						for (n in r) {
							q = r[n];
							if (q.hasOwnProperty("_interpolate")) {
								p[n] = q._interpolate(q._beginVal, q._endVal, o);
							} else {
								p[n] = this._buildStyleObjectFor(q, o);
							}
						}
						return p;
					}
				},
				propertiesDef: {
					targetNode: {
						type: Object,
						constraint: function (n) {
							return (n === undefined) || (b.isA(n.applyStyle, Function) && b.isA(n.StyleDefinition, Function));
						},
						defaultValue: undefined,
						tag: m
					},
					animValues: f.MapOfProperties(k, {}, false, true, true, m)
				}
			});
		}
			());
		(function () {
			var f = b.anim.AbstractAnimation.prototype,
			h = "t",
			e = "s",
			g = "r";
			b.declare({
				name: "oui.anim.AnimateTransform",
				extend: b.anim.AbstractAnimation,
				membersDef: {
					init: function (j, i) {
						f.init.call(this, j, i);
						this._interpolatedValue = new b.geom.Matrix();
						this._transforms = [];
					},
					translate: function (j, l, i, k) {
						if (isFinite(j) && isFinite(l) && isFinite(i) && isFinite(k)) {
							this._transforms.push({
								type: h,
								x0: j,
								x1: i,
								y0: l,
								y1: k
							});
						}
					},
					rotate: function (l, k, j, i) {
						if (isFinite(l) && isFinite(k)) {
							this._transforms.push({
								type: g,
								a0: l / 180 * Math.PI,
								a1: k / 180 * Math.PI,
								cx: j || 0,
								cy: i || 0
							});
						}
					},
					scale: function (j, l, i, k) {
						if (isFinite(j) && isFinite(l) && isFinite(i) && isFinite(k)) {
							this._transforms.push({
								type: e,
								x0: j,
								x1: i,
								y0: l,
								y1: k
							});
						}
					},
					resetTransforms: function () {
						this._transforms.length = 0;
					},
					_play: function (p) {
						var j = this._progress(this._curBegin, this._curEnd, p),
						n = this._transforms,
						l,
						o = n.length,
						k,
						m = this._interpolatedValue;
						m.init();
						for (l = 0; l < o; l++) {
							k = n[l];
							if (k.type === h) {
								m._safeTranslate(k.x0 + j * (k.x1 - k.x0), k.y0 + j * (k.y1 - k.y0));
							} else {
								if (k.type === g) {
									m._safeRotate(k.a0 + j * (k.a1 - k.a0), k.cx, k.cy);
								} else {
									if (k.type === e) {
										m._safeScale(k.x0 + j * (k.x1 - k.x0), k.y0 + j * (k.y1 - k.y0));
									}
								}
							}
						}
						this._properties.targetNode.setTransformMatrix(m);
					}
				},
				propertiesDef: {
					targetNode: b.defs.ObjectOfType(b.scene.AbstractNode, undefined, false, true)
				}
			});
		}
			());
		(function () {
			b.declare({
				name: "oui.anim.AnimateCallback",
				extend: b.anim.AbstractAnimation,
				membersDef: {
					_play: function (e) {
						this._properties.callback.call(this, this._progress(this._curBegin, this._curEnd, e));
					}
				},
				propertiesDef: {
					callback: {
						type: Function,
						defaultValue: b.NO_OP
					}
				}
			});
		}
			());
		(function () {
			b.ns("oui.anim");
			b.anim.EffectsSupport = {
				_effectOn: function (h, g, k, l, f, j) {
					var i,
					e = h + "Effect";
					if (this[e] === undefined) {
						i = {
							targetNode: this,
							dur: j,
							animValues: {}
						};
						i.animValues[k] = {
							beginValue: l,
							endValue: f
						};
						this[e] = new b.anim.AnimateStyle(i);
					}
					this[e].addBeginEvent(g);
				},
				showOn: function (e) {
					this._effectOn("show", e, "display", false, true, 0);
				},
				hideOn: function (e) {
					this._effectOn("hide", e, "display", true, false, 0);
				},
				fadeOn: function (h, i, g, j, e) {
					var f = null;
					if (b.isA(this, b.graphics.Group) || b.isA(this, b.graphics.Image)) {
						f = new b.anim.AnimateStyle({
							targetNode: this,
							animValues: {
								opacity: {
									beginValue: i,
									endValue: g
								}
							},
							dur: j
						});
					} else {
						f = new b.anim.AnimateStyle({
							targetNode: this,
							animValues: {
								fillOpacity: {
									beginValue: i,
									endValue: g
								},
								strokeOpacity: {
									beginValue: i,
									endValue: g
								}
							},
							dur: j
						});
					}
					f.addBeginEvent(h);
					if (b.isA(e, String)) {
						this[e] = f;
					}
				},
				slideOn: function (i, j, l, k, h, g, f) {
					var e = new b.anim.AnimateTransform({
						targetNode: this,
						dur: j,
						beginEvents: [i]
					});
					e.translate(l, k, h, g);
					if (b.isA(f, String)) {
						this[f] = e;
					}
				},
				scaleOn: function (g, f, i, h, n, k, l) {
					var m,
					j,
					e;
					e = new b.anim.AnimateTransform({
						targetNode: this,
						dur: f,
						beginEvents: [g]
					});
					m = (n !== undefined ? n : 0);
					j = (k !== undefined ? k : 0);
					e.translate(m, j, m, j);
					e.scale(i, i, h, h);
					e.translate(-m, -j, -m, -j);
					if (b.isA(l, String)) {
						this[l] = e;
					}
				}
			};
		}
			());
		(function () {
			var h = b.defs,
			j = h._createDef,
			p = {
				definition: h.ArrayOfProperties({
					type: h.String("image")
				}, 1, undefined, [{
							type: "image"
						}
					]),
				hotspotX: h.FinitePositiveNumber(0),
				hotspotY: h.FinitePositiveNumber(0)
			};
			function k(q) {
				return b.hasOwnValue(b.CursorType, q, true) || b.isValueOfType(q, p, true);
			}
			function l(q) {
				return (q === null) || b.isA(q, b.filters.AbstractFilter);
			}
			function m(r, q) {
				return (r === q) || b.isFinitePositiveNumber(r);
			}
			function f(q) {
				return (q === null) || b.isA(q, b.graphics.PathCommands);
			}
			function i(u, t, q) {
				var w,
				v,
				s,
				r;
				q.value = {};
				for (w in t) {
					if (u[w] !== undefined) {
						v = u[w];
						s = t[w];
						if (s.constructor === Object) {
							r = {
								validValue: false
							};
							i(v, s, r);
							if (r.validValue) {
								q.value[w] = r.value;
							}
						} else {
							if (s === true) {
								q.value[w] = v;
								q.validValue = true;
							}
						}
					}
				}
			}
			function g(u, t, q) {
				var w,
				v,
				s,
				r;
				q.value = {};
				for (w in u) {
					if (u[w] !== undefined) {
						v = u[w];
						s = t[w];
						if (s !== undefined && s.constructor === Object) {
							r = {
								validValue: false
							};
							g(v, s, r);
							if (r.validValue) {
								q.value[w] = r.value;
							}
						} else {
							if (s !== false) {
								q.value[w] = v;
								q.validValue = true;
							}
						}
					}
				}
			}
			function o(s, q) {
				var r = b.style.makeColor(s);
				if (r) {
					q.validValue = true;
					q.value = r;
				}
			}
			function n(s, q) {
				var r;
				if (typeof s === "string") {
					s = s.toUpperCase();
					r = b.filters[s];
					if (r) {
						q.validValue = true;
						q.value = r;
					}
				}
			}
			function e(r, q) {
				if (b.isA(r, String)) {
					try {
						q.value = new b.graphics.PathCommands(r, true);
						q.validValue = true;
					} catch (s) {
						q.value = s.message;
						q.validValue = false;
					}
				}
			}
			b.mixin(h, {
				Paint: function (r, q) {
					if (!b.isA(r, b.style.Paint)) {
						r = b.style.makeColor(r);
					}
					return j("Paint", b.style.Paint, r, q, o);
				},
				Color: function (r, q) {
					r = b.style.makeColor(r);
					return j("Color", b.style.Color, r, q, o);
				},
				Image: function (t, s, r, q) {
					return {
						src: h.String(t, q),
						width: h.FinitePositiveNumber(s, q),
						height: h.FinitePositiveNumber(r, q)
					};
				},
				Cursor: function (r, q) {
					return j("Cursor", Object, r, q, undefined, k);
				},
				FilterEffect: function (r, q) {
					return j("FilterEffect", Object, r, q, n, l);
				},
				Size: function (r, q) {
					return j("Size", Object, r, q, undefined, [m, r]);
				},
				PathData: function (r, q) {
					return j("PathData", b.graphics.PathCommands, r, q, e, f, undefined, true);
				},
				PropertyFilter: function (r, s, q) {
					return {
						type: "PropertyFilter",
						convertor: function (u, t) {
							if (typeof u === "object") {
								if (r === true) {
									g(u, s, t);
								} else {
									i(u, s, t);
								}
							} else {
								t.validValue = false;
							}
						},
						tag: q
					};
				}
			});
			b.mixin(h, {
				FontStyle: function (t, z, u, y) {
					var x = 255,
					q = 0,
					s = 0,
					v = 0,
					w;
					if (b.isA(y, b.style.Paint)) {
						w = y;
					} else {
						if (b.isA(y, Array) && y.length >= 3) {
							q = y[0];
							s = y[1];
							v = y[2];
							if (y.length > 3) {
								x = y[3];
							}
							w = new b.style.Color(q, s, v, x);
						} else {
							w = b.black;
						}
					}
					return {
						fontFamily: h.String(t),
						fontSize: h.FinitePositiveNumber(z),
						fontWeight: h.Enum(b.FontWeightEnum, u),
						fill: h.Paint(w)
					};
				},
				Padding: function (u, t, s, r, q) {
					return {
						top: h.PositiveNumber(u, q),
						bottom: h.PositiveNumber(r, q),
						lineBegin: h.PositiveNumber(t, q),
						lineEnd: h.PositiveNumber(s, q)
					};
				},
				Marker: function (v, x, w, q, y, s, r, t, A, u, z) {
					return {
						d: h.String(v, u || A),
						refX: h.FiniteNumber(x, A),
						refY: h.FiniteNumber(w, A),
						width: h.FinitePositiveNumber(q, A),
						height: h.FinitePositiveNumber(y, A),
						orient: {
							type: Object,
							constraint: function (B) {
								return B === b.AUTO || b.isNumberInRange(B, [0, 360], false);
							},
							defaultValue: s,
							tag: A
						},
						strokeUnits: h.Boolean(r, A),
						paint: {
							type: Object,
							defaultValue: t,
							tag: z || A
						}
					};
				}
			});
		}
			());
		(function () {
			b.declare({
				name: "oui.style.Paint",
				membersDef: {
					init: function () {},
					getOpacity: function () {
						return 1;
					}
				}
			});
			b.NO_PAINT = new b.style.Paint();
		}
			());
		(function () {
			b.mixin(b.style.Paint, {
				svgGetPaint: function () {
					return "none";
				}
			});
		}
			());
		(function () {
			var h = b.defs,
			i = [0, 255],
			m = "([0-9a-f])",
			l = "([0-9a-f]{2})",
			j = "([0-9]{1,3})",
			k = "\\s*,\\s*",
			e = new RegExp("^#?" + l + l + l + l + "?$|^#?" + m + m + m + "$"),
			f = new RegExp("^rgba\\(" + j + k + j + k + j + k + j + "\\)$|^rgb\\(" + j + k + j + k + j + "\\)$");
			function g(n) {
				var o = "";
				if (n < 16) {
					o = "0";
				}
				return o + n.toString(16);
			}
			b.declare({
				name: "oui.style.Color",
				extend: b.style.Paint,
				mixins: [b.lang.PropertiesSupport],
				membersDef: {
					init: function (q, o, n, p) {
						this._initProperties({
							red: q,
							green: o,
							blue: n,
							alpha: p
						});
						this.onPropChanged();
					},
					onPropChanged: function () {
						var p = this._properties,
						o,
						n,
						q,
						r;
						p.red = Math.round(p.red);
						p.green = Math.round(p.green);
						p.blue = Math.round(p.blue);
						p.alpha = Math.round(p.alpha);
						o = g(p.red);
						n = g(p.green);
						q = g(p.blue);
						r = g(p.alpha);
						this.hexRGB = o + n + q;
						this.hexRGBA = o + n + q + r;
						this.hexARGB = r + o + n + q;
						this._onPropChangedImpl();
					},
					_onPropChangedImpl: function () {},
					modify: function (o) {
						var p = 0,
						n = this._properties;
						if (b.isA(o, Number)) {
							if (o < 0) {
								p = 0;
							} else {
								if (o > 1) {
									p = 1;
								} else {
									p = o;
								}
							}
						}
						return new b.style.Color(n.red * p, n.green * p, n.blue * p, n.alpha);
					},
					setColor: function (o) {
						if (b.isA(o, b.style.Color)) {
							var n = o._properties;
							this.setProperties({
								red: n.red,
								green: n.green,
								blue: n.blue,
								alpha: n.alpha
							});
						}
					},
					setARGB: function (q, p, o, n) {
						this.setProperties({
							red: p,
							green: o,
							blue: n,
							alpha: q
						});
					},
					setOpacity: function (n) {
						this.setAlpha(n * 255);
					},
					getOpacity: function () {
						return this._properties.alpha / 255;
					},
					toString: function () {
						var n,
						o = this._properties;
						if (o.alpha === 255) {
							n = "#" + this.hexRGB;
						} else {
							n = "rgba(".concat(o.red, ",", o.green, ",", o.blue, ",", o.alpha / 255, ")");
						}
						return n;
					}
				},
				propertiesDef: {
					red: h.NumberInRange(i, 0),
					green: h.NumberInRange(i, 0),
					blue: h.NumberInRange(i, 0),
					alpha: h.NumberInRange(i, 255)
				}
			});
			b.style.makeColor = function (q) {
				var n = null,
				p,
				o,
				t,
				s,
				r;
				if (b.isA(q, String)) {
					q = b.trim(q).toLowerCase();
					if (b.style.CSS_COLORS.hasOwnProperty(q)) {
						n = b[q];
					}
					if ((r = e.exec(q)) !== null) {
						p = parseInt(r[1] || r[5] + r[5], 16);
						o = parseInt(r[2] || r[6] + r[6], 16);
						t = parseInt(r[3] || r[7] + r[7], 16);
						s = 255;
						if (r[4]) {
							s = parseInt(r[4], 16);
						}
						n = new b.style.Color(p, o, t, s);
					}
					if ((r = f.exec(q)) !== null) {
						p = parseInt(r[1] || r[5], 10);
						o = parseInt(r[2] || r[6], 10);
						t = parseInt(r[3] || r[7], 10);
						s = 255;
						if (r[4]) {
							s = parseInt(r[4], 10);
						}
						n = new b.style.Color(p, o, t, s);
					}
				} else {
					if (b.isA(q, Array) && (q.length === 3 || q.length === 4)) {
						p = q[0];
						o = q[1];
						t = q[2];
						s = 255;
						if (q.length === 4) {
							s = q[3];
						}
						if (b.isNumberInRange(p, i) && b.isNumberInRange(o, i) && b.isNumberInRange(t, i) && b.isNumberInRange(s, i)) {
							n = new b.style.Color(p, o, t, s);
						}
					} else {
						if (b.isA(q, b.style.Color)) {
							n = q;
						}
					}
				}
				return n;
			};
		}
			());
		(function () {
			b.mixin(b.style.Color, {
				_onPropChangedImpl: function () {
					this.svgColor = "#" + this.hexRGB;
				},
				svgGetPaint: function () {
					return this.svgColor;
				}
			});
		}
			());
		b.style = b.style || {};
		(function () {
			var f,
			e;
			b.style.CSS_COLORS = f = {
				aliceBlue: "F0F8FF",
				antiqueWhite: "FAEBD7",
				aqua: "0FF",
				aquamarine: "7FFFD4",
				azure: "F0FFFF",
				beige: "F5F5DC",
				bisque: "FFE4C4",
				black: "000",
				blanchedAlmond: "FFEBCD",
				blue: "00F",
				blueViolet: "8A2BE2",
				brown: "A52A2A",
				burlyWood: "DEB887",
				cadetBlue: "5F9EA0",
				chartreuse: "7FFF00",
				chocolate: "D2691E",
				coral: "FF7F50",
				cornflowerBlue: "6495ED",
				cornsilk: "FFF8DC",
				crimson: "DC143C",
				cyan: "0FF",
				darkBlue: "00008B",
				darkCyan: "008B8B",
				darkGoldenRod: "B8860B",
				darkGray: "A9A9A9",
				darkGreen: "006400",
				darkKhaki: "BDB76B",
				darkMagenta: "8B008B",
				darkOliveGreen: "556B2F",
				darkOrange: "FF8C00",
				darkOrchid: "9932CC",
				darkRed: "8B0000",
				darkSalmon: "E9967A",
				darkSeaGreen: "8FBC8F",
				darkSlateBlue: "483D8B",
				darkSlateGray: "2F4F4F",
				darkTurquoise: "00CED1",
				darkViolet: "9400D3",
				deepPink: "FF1493",
				deepSkyBlue: "00BFFF",
				dimGray: "696969",
				dodgerBlue: "1E90FF",
				fireBrick: "B22222",
				floralWhite: "FFFAF0",
				forestGreen: "228B22",
				fuchsia: "F0F",
				gainsboro: "DCDCDC",
				ghostWhite: "F8F8FF",
				gold: "FFD700",
				goldenRod: "DAA520",
				gray: "808080",
				green: "008000",
				greenYellow: "ADFF2F",
				honeyDew: "F0FFF0",
				hotPink: "FF69B4",
				indianRed: "CD5C5C",
				indigo: "4B0082",
				ivory: "FFFFF0",
				khaki: "F0E68C",
				lavender: "E6E6FA",
				lavenderBlush: "FFF0F5",
				lawnGreen: "7CFC00",
				lemonChiffon: "FFFACD",
				lightBlue: "ADD8E6",
				lightCoral: "F08080",
				lightCyan: "E0FFFF",
				lightGoldenRodYellow: "FAFAD2",
				lightGrey: "D3D3D3",
				lightGreen: "90EE90",
				lightPink: "FFB6C1",
				lightSalmon: "FFA07A",
				lightSeaGreen: "20B2AA",
				lightSkyBlue: "87CEFA",
				lightSlateGray: "789",
				lightSteelBlue: "B0C4DE",
				lightYellow: "FFFFE0",
				lime: "0F0",
				limeGreen: "32CD32",
				linen: "FAF0E6",
				magenta: "FF00FF",
				maroon: "800000",
				mediumAquaMarine: "66CDAA",
				mediumBlue: "0000CD",
				mediumOrchid: "BA55D3",
				mediumPurple: "9370D8",
				mediumSeaGreen: "3CB371",
				mediumSlateBlue: "7B68EE",
				mediumSpringGreen: "00FA9A",
				mediumTurquoise: "48D1CC",
				mediumVioletRed: "C71585",
				midnightBlue: "191970",
				mintCream: "F5FFFA",
				mistyRose: "FFE4E1",
				moccasin: "FFE4B5",
				navajoWhite: "FFDEAD",
				navy: "000080",
				oldLace: "FDF5E6",
				olive: "808000",
				oliveDrab: "6B8E23",
				orange: "FFA500",
				orangeRed: "FF4500",
				orchid: "DA70D6",
				paleGoldenRod: "EEE8AA",
				paleGreen: "98FB98",
				paleTurquoise: "AFEEEE",
				paleVioletRed: "D87093",
				papayaWhip: "FFEFD5",
				peachPuff: "FFDAB9",
				peru: "CD853F",
				pink: "FFC0CB",
				plum: "DDA0DD",
				powderBlue: "B0E0E6",
				purple: "800080",
				red: "F00",
				rosyBrown: "BC8F8F",
				royalBlue: "4169E1",
				saddleBrown: "8B4513",
				salmon: "FA8072",
				sandyBrown: "F4A460",
				seaGreen: "2E8B57",
				seaShell: "FFF5EE",
				sienna: "A0522D",
				silver: "C0C0C0",
				skyBlue: "87CEEB",
				slateBlue: "6A5ACD",
				slateGray: "708090",
				snow: "FFFAFA",
				springGreen: "00FF7F",
				steelBlue: "4682B4",
				tan: "D2B48C",
				teal: "008080",
				thistle: "D8BFD8",
				tomato: "FF6347",
				transparent: "FFFFFF00",
				turquoise: "40E0D0",
				violet: "EE82EE",
				wheat: "F5DEB3",
				white: "FFF",
				whiteSmoke: "F5F5F5",
				yellow: "FF0",
				yellowGreen: "9ACD32"
			};
			if (typeof b.style.makeColor === "function") {
				for (e in f) {
					if (f.hasOwnProperty(e)) {
						b[e.replace(/(.)([A-Z])/g, "$1_$2").toUpperCase()] = b[e.toLowerCase()] = b[e] = b.style.makeColor(f[e]);
					}
				}
			}
			for (e in f) {
				if (f.hasOwnProperty(e)) {
					f[e] = "#" + f[e];
					f[e.toLowerCase()] = f[e];
				}
			}
		}
			());
		(function () {
			b.declare({
				name: "oui.style.GradientStop",
				mixins: [b.lang.PropertiesSupport],
				membersDef: {
					init: function (e) {
						this._initProperties(e);
					}
				},
				propertiesDef: {
					color: b.defs.Color(b.black),
					offset: b.defs.NumberInRange([0, 1], 0)
				}
			});
		}
			());
		(function () {
			b.mixin(b.style.GradientStop, {
				svgWriteStopNode: function (e) {
					var f = this._properties;
					e.appendChild(b.tree.svgCreateElt("stop", {
							offset: f.offset,
							"stop-color": "#" + f.color.hexRGB,
							"stop-opacity": f.color.getOpacity()
						}));
				}
			});
		}
			());
		(function () {
			b.declare({
				name: "oui.style.GradientPaint",
				isAbstract: true,
				extend: b.style.Paint,
				mixins: [b.lang.PropertiesSupport],
				membersDef: {
					init: function (e) {
						this._initImpl();
						this._initProperties(e);
					},
					onPropChanged: function () {
						this._onPropChangedImpl();
					},
					addGradientStop: function (i, e) {
						if (this._properties.stops.length === 0) {
							this._properties.stops = [];
						}
						var h = new b.style.GradientStop({
							offset: i,
							color: e
						}),
						g = this._properties.stops,
						j = g.length,
						f = 0;
						while (f <= j - 1 && i >= g[f].getOffset()) {
							f++;
						}
						g.splice(f, 0, h);
						this.onPropChanged();
					},
					_initImpl: function () {},
					_onPropChangedImpl: function () {}
				},
				propertiesDef: {
					useObjectBoundingBox: b.defs.Boolean(true),
					stops: b.defs.ArrayOfType({
						type: b.style.GradientStop,
						convertor: function (h, e, g, k) {
							var j,
							f = null;
							if (typeof h === "object" && typeof h.offset === "number") {
								j = h.offset;
								f = b.style.makeColor(h.color);
							} else {
								if (k > 1) {
									j = g / (k - 1);
									f = b.style.makeColor(h);
								}
							}
							if (f) {
								e.validValue = true;
								e.value = new b.style.GradientStop({
									offset: j,
									color: f
								});
							}
						}
					}, 0, undefined, [], undefined, false, true)
				}
			});
		}
			());
		(function () {
			b.mixin(b.style.GradientPaint, {
				_initImpl: function () {
					var e = this.svgGetGradID(),
					f = b.tree.svgCreateElt(this.SVG_TAG, {
						id: e
					});
					b.tree.svgAddDef(f);
					this.svgID = e;
					this.svgNode = f;
				},
				_onPropChangedImpl: function () {
					var h = this.svgNode,
					g,
					e,
					f,
					j;
					while (h.childNodes.length !== 0) {
						h.removeChild(h.lastChild);
					}
					g = this._properties.stops;
					for (f = 0, j = g.length;
						f < j; f++) {
						g[f].svgWriteStopNode(h);
					}
					e = this._properties.useObjectBoundingBox ? "objectBoundingBox" : "userSpaceOnUse";
					h.attr("gradientUnits", e);
				},
				svgGetPaint: function () {
					return "url(#" + this.svgID + ")";
				},
				svgGetGradID: function () {}
			});
		}
			());
		(function () {
			var e = b.defs;
			b.declare({
				name: "oui.style.LinearGradient",
				extend: b.style.GradientPaint,
				propertiesDef: {
					x1: e.FiniteNumber(0),
					y1: e.FiniteNumber(0),
					x2: e.FiniteNumber(1),
					y2: e.FiniteNumber(0)
				}
			});
			b.mixin(b.style, {
				deriveGradient: function (i, j, f) {
					var k,
					h,
					g;
					if (f === undefined) {
						f = 0.8;
					}
					k = i.modify(f);
					if (j === true) {
						h = i;
						g = k;
					} else {
						h = k;
						g = i;
					}
					return new b.style.LinearGradient({
						x1: 0,
						y1: 0,
						x2: 0,
						y2: 1,
						stops: [h, g]
					});
				}
			});
		}
			());
		(function () {
			var f = b.style.GradientPaint.prototype,
			e = 0,
			g = "LinearGradient";
			b.mixin(b.style.LinearGradient, {
				SVG_TAG: "linearGradient",
				_onPropChangedImpl: function () {
					f._onPropChangedImpl.call(this);
					var h = this._properties;
					this.svgNode.attr({
						x1: h.x1,
						x2: h.x2,
						y1: h.y1,
						y2: h.y2
					});
				},
				svgGetGradID: function () {
					return g + e++;
				}
			});
		}
			());
		(function () {
			var e = b.defs;
			b.declare({
				name: "oui.style.RadialGradient",
				extend: b.style.GradientPaint,
				propertiesDef: {
					cx: e.FiniteNumber(0.5),
					cy: e.FiniteNumber(0.5),
					radius: e.FiniteNumber(0.5)
				}
			});
		}
			());
		(function () {
			var g = b.style.GradientPaint.prototype,
			e = 0,
			f = "RadialGradient";
			b.mixin(b.style.RadialGradient, {
				SVG_TAG: "radialGradient",
				_onPropChangedImpl: function () {
					g._onPropChangedImpl.call(this);
					var h = this._properties;
					this.svgNode.attr({
						cx: h.cx,
						cy: h.cy,
						r: h.radius
					});
				},
				svgGetGradID: function () {
					return f + e++;
				}
			});
		}
			());
		(function () {
			b.declare({
				name: "oui.style.PatternPaint",
				extend: b.style.Paint,
				mixins: [b.lang.PropertiesSupport, b.events.EventSupport],
				eventsDef: {
					PATTERN_READY: "patternReady"
				},
				membersDef: {
					init: function (e) {
						this._srcW = 0;
						this._srcH = 0;
						this._initImpl();
						this._initProperties(e);
					},
					onPropChanged: function () {
						var e = this._properties.src;
						if (this.prevRequest) {
							b.resourcesManager.removeObserver(this.prevRequest, this);
							this.prevRequest = null;
						} else {
							if (this.imageLoader) {
								this.imageLoader.offComplete(this);
								this.imageLoader = null;
							}
						}
						this._onPropChangedImpl();
						if (e.length > 0) {
							if (b.resourcesManager.hasResource(e)) {
								b.resourcesManager.requestResource(e, this);
								this.prevRequest = e;
							} else {
								this.imageLoader = new b.utils.ImageLoader();
								this.imageLoader.onComplete(this);
								this.imageLoader.load(e);
							}
						}
					},
					handleEvent: function (e) {
						this._srcW = e.width;
						this._srcH = e.height;
						this._patternReadyImpl(e);
						this.dispatchEvent({
							type: this.events.PATTERN_READY
						});
					},
					resourceUpdate: function (e) {
						this.handleEvent(e);
					},
					_initImpl: function () {},
					_onPropChangedImpl: function () {},
					_patternReadyImpl: function (e) {}
				},
				propertiesDef: {
					src: b.defs.String("")
				}
			});
		}
			());
		(function () {
			var g = 0,
			f = "Pattern",
			h = "pattern",
			e = "http://www.w3.org/1999/xlink";
			b.mixin(b.style.PatternPaint, {
				_initImpl: function () {
					var i = f + g++,
					j = b.tree.svgCreateElt(h, {
						id: i,
						patternUnits: "userSpaceOnUse"
					});
					b.tree.svgAddDef(j);
					this.svgID = i;
					this.svgNode = j;
				},
				_onPropChangedImpl: function () {
					var j = this.svgNode,
					i,
					k = this._properties.src;
					if (this.svgImgNode) {
						this.svgNode.removeChild(this.svgImgNode);
						this.svgImgNode = undefined;
					}
					if (k.length > 0) {
						i = b.tree.svgCreateElt(b.resourcesManager.hasResource(k) ? "use" : "image");
						j.appendChild(i);
						this.svgImgNode = i;
					}
				},
				_patternReadyImpl: function (j) {
					var i = b.isA(j.data, String) ? ("#" + j.data) : j.url;
					this.svgImgNode.setAttributeNS(e, "xlink:href", i);
					this.svgImgNode.attr({
						width: j.width,
						height: j.height
					});
					this.svgNode.attr({
						width: j.width,
						height: j.height
					});
				},
				svgGetPaint: function () {
					return "url(#" + this.svgID + ")";
				}
			});
		}
			());
		(function () {
			b.ns("oui.style");
			var t = b.GENERIC_FONTS.SANS_SERIF,
			q = b.GENERIC_FONTS.SERIF,
			e = b.GENERIC_FONTS.MONOSPACE,
			g = b.GENERIC_FONTS.CURSIVE,
			o,
			p,
			h,
			l,
			k,
			r,
			s,
			f;
			o = [["Arial", "'Helvetica Neue'", "Helvetica", t], ["'Arial Black'", "Gadget", t], ["'Comic Sans MS'", "'Comic Sans'", "Textile", g], ["'Courier New'", "Courier", e], ["Georgia", q], ["Impact", "Charcoal", t], ["'Lucida Console'", "Monaco", e], ["'Lucida Sans Unicode'", "'Lucida Grande'", t], ["'Palatino Linotype'", "'Book Antiqua'", "Palatino", q], ["Tahoma", "Geneva", "'Liberation Sans'", "'Nimbus Sans L'", "FreeSans", t], ["'Times New Roman'", "Times", q], ["'Trebuchet MS'", "Trebuchet", t], ["Verdana", "Geneva", t], ["'MS Sans Serif'", "Geneva", t], ["'MS Serif'", "'New York'", q]];
			b.cssFonts = {};
			for (p = 0, h = o.length; p < h; p++) {
				r = o[p];
				for (l = 0, k = r.length - 1; l < k; l++) {
					f = r[l].replace(/'/gi, "").toLowerCase();
					if (b.cssFonts.hasOwnProperty(f) === false) {
						s = r.slice();
						s.splice(l, 1);
						s.unshift(r[l]);
						b.cssFonts[f] = s.join(",");
					}
				}
			}
		}
			());
		(function () {
			b.ns("oui.text.locales");
			b.text.locales.en_US = {
				eras: ["BC", "AD"],
				months: [{
						l: "January",
						s: "Jan"
					}, {
						l: "February",
						s: "Feb"
					}, {
						l: "March",
						s: "Mar"
					}, {
						l: "April",
						s: "Apr"
					}, {
						l: "May",
						s: "May"
					}, {
						l: "June",
						s: "Jun"
					}, {
						l: "July",
						s: "Jul"
					}, {
						l: "August",
						s: "Aug"
					}, {
						l: "September",
						s: "Sep"
					}, {
						l: "October",
						s: "Oct"
					}, {
						l: "November",
						s: "Nov"
					}, {
						l: "December",
						s: "Dec"
					}
				],
				days: [{
						l: "Sunday",
						s: "Sun"
					}, {
						l: "Monday",
						s: "Mon"
					}, {
						l: "Tuesday",
						s: "Tue"
					}, {
						l: "Wednesday",
						s: "Wed"
					}, {
						l: "Thursday",
						s: "Thu"
					}, {
						l: "Friday",
						s: "Fri"
					}, {
						l: "Saturday",
						s: "Sat"
					}
				],
				ampm: ["AM", "PM"],
				timezones: {
					0: {
						std: {
							l: "Greenwich Mean Time",
							s: "GMT"
						},
						dst: {
							l: "Greenwich Mean Time",
							s: "GMT"
						}
					},
					480: {
						std: {
							l: "Pacific Standard Time",
							s: "PST"
						},
						dst: {
							l: "Pacific Daylight Time",
							s: "PDT"
						}
					},
					420: {
						std: {
							l: "Mountain Standard Time",
							s: "MST"
						},
						dst: {
							l: "Mountain Daylight Time",
							s: "MDT"
						}
					},
					360: {
						std: {
							l: "Central Standard Time",
							s: "CST"
						},
						dst: {
							l: "Central Daylight Time",
							s: "CDT"
						}
					},
					300: {
						std: {
							l: "Eastern Standard Time",
							s: "EST"
						},
						dst: {
							l: "Eastern Daylight Time",
							s: "EDT"
						}
					},
					600: {
						std: {
							l: "Hawaii Standard Time",
							s: "HST"
						},
						dst: {
							l: "Hawaii Standard Time",
							s: "HST"
						}
					},
					540: {
						std: {
							l: "Alaska Standard Time",
							s: "AKST"
						},
						dst: {
							l: "Alaska Standard Time",
							s: "AKST"
						}
					},
					240: {
						std: {
							l: "Atlantic Standard Time",
							s: "AST"
						},
						dst: {
							l: "Atlantic Daylight Time",
							s: "ADT"
						}
					},
					210: {
						std: {
							l: "Newfoundland Standard Time",
							s: "NST"
						},
						dst: {
							l: "Newfoundland Daylight Time",
							s: "NDT"
						}
					}
				},
				shortDate: "M/d/yy",
				medDate: "d-MMM-yy",
				longDate: "MMMM d, yyyy",
				fullDate: "EEEE MMMM d, yyyy G",
				date: "d-MMMM-yy",
				shortTime: "h:mm a",
				medTime: "h:mm:ss a",
				longTime: "h:mm:ss a z",
				fullTime: "h:mm:ss;S 'o''clock' a z",
				time: "h:mm:ss a"
			};
		}
			());
		b.text = b.text || {};
		(function () {
			var t,
			e = "0",
			s = "#",
			i = "0",
			j = "E",
			p = "+",
			k = "-",
			v = "\u221E";
			t = function () {};
			t.prototype = {
				tempMinIntegerDigits: 0,
				minDecimalPlaces: 0,
				maxDecimalPlaces: 0,
				minIntegerPlaces: 1,
				maxIntegerPlaces: 1,
				prefix: "",
				suffix: "",
				integerPattern: "",
				decimalPattern: "",
				grouping: 3,
				percentMode: false,
				permilleMode: false,
				color: null
			};
			function f(y) {
				var B,
				z = 0,
				A = y.length,
				x = false;
				if (y.charAt(z) === j && A > 1) {
					x = true;
					z += 1;
					B = y.charAt(z);
					if (B === p || B === k) {
						z += 1;
					}
					while (z < A) {
						if (y.charAt(z) === e) {
							z++;
						} else {
							x = false;
							break;
						}
					}
				}
				return x;
			}
			function l(D, x, y) {
				var z = false,
				A = false,
				F = D.length > 0,
				E,
				C,
				B;
				for (C = 0, B = D.length; C < B; C++) {
					E = D.charAt(C);
					if (E === s || E === e) {
						continue;
					} else {
						if (E === x) {
							if (z) {
								F = false;
								break;
							} else {
								z = true;
							}
						} else {
							if (E === y) {
								if (A) {
									F = false;
									break;
								} else {
									if (z) {
										F = false;
										break;
									} else {
										A = true;
									}
								}
							} else {
								if (E === j) {
									F = f(D.substring(C, B));
									break;
								} else {
									F = false;
									break;
								}
							}
						}
					}
				}
				return F;
			}
			function h(A, y) {
				var B,
				x,
				z;
				B = A.indexOf("[");
				x = A.indexOf("]");
				if (B > -1 && x > B) {
					z = A.substring(B + 1, x).toLowerCase();
					if (b.style.CSS_COLORS.hasOwnProperty(z)) {
						y.color = b.style.CSS_COLORS[z];
					} else {
						if (z.match(/^(0x)?[0-9a-fA-F]{6}$/)) {
							y.color = "#" + z.replace("0x", "");
						}
					}
					if (y.color !== null) {
						A = A.substring(0, B) + A.substring(x + 1);
					}
				}
				return A;
			}
			function q(I, D, x) {
				var y = I.length,
				L = I.indexOf(s),
				z = I.indexOf(e),
				C = I.indexOf(x),
				H = I.indexOf("%"),
				B = I.indexOf("\u2030"),
				M,
				E,
				F,
				G,
				K,
				A,
				J;
				if (L < 0) {
					L = y - 1;
				}
				if (z < 0) {
					z = y - 1;
				}
				if (C < 0) {
					C = y - 1;
				}
				F = I.lastIndexOf(s);
				G = I.lastIndexOf(e);
				K = I.lastIndexOf(x);
				A = Math.min(L, C, z);
				A = A < 0 ? 0 : A;
				J = Math.max(F, G, K);
				D.prefix = I.substring(0, A);
				D.suffix = I.substring(J + 1, y);
				if (A > J + 1 || (H >= 0 && B >= 0) || (H >= 0 && H !== I.lastIndexOf("%")) || (B >= 0 && B !== I.lastIndexOf("\u2030"))) {
					I = "";
				} else {
					I = I.substring(A, J + 1);
					if (H > 0) {
						D.percentMode = true;
						M = H;
						E = "%";
					} else {
						if (B > 0) {
							D.permilleMode = true;
							M = B;
							E = "\u2030";
						}
					}
					if (M >= A && M <= J) {
						I = I.replace(E, "");
						D.suffix = E + D.suffix;
					}
				}
				return I;
			}
			function g(A, y, x) {
				var z = A.lastIndexOf(x);
				if (z > 0) {
					y.grouping = A.length - z - 1;
				} else {
					y.grouping = -1;
				}
			}
			function m(y, x) {
				x.minDecimalPlaces = 0;
				x.maxDecimalPlaces = 0;
				if (y.length > 0) {
					x.minDecimalPlaces = y.lastIndexOf(e) > -1 ? y.lastIndexOf(e) + 1 : 0;
					x.maxDecimalPlaces = y.length;
				}
			}
			function w(B, y, x) {
				var A,
				D,
				z,
				C;
				y.minIntegerPlaces = 0;
				y.maxIntegerPlaces = 0;
				for (z = 0, C = B.length; z < C; z++) {
					D = B.charAt(z);
					if (D === e) {
						y.minIntegerPlaces++;
						y.maxIntegerPlaces++;
					}
					if (D === s) {
						y.maxIntegerPlaces++;
					}
				}
				A = B.lastIndexOf(x);
				y.tempMinIntegerDigits = A;
				if (y.tempMinIntegerDigits === -1) {
					y.tempMinIntegerDigits = y.minIntegerPlaces;
				}
			}
			function o(D, A, z, y) {
				var x = D.split(j),
				C,
				E,
				B;
				A.exponent = 0;
				if (x.length === 2) {
					C = x[1];
					B = 0;
					E = C.charAt(B);
					if (E === p) {
						B += 1;
					}
					A.exponent = C.length - B;
				} else {
					A.exponent = 0;
				}
				C = x[0].split(z);
				if (z === y && C.length === 3) {
					A.intPattern = C[0];
					A.intPattern += y;
					A.intPattern += C[1];
					A.decPattern = C[2];
				} else {
					if (C.length === 2) {
						A.intPattern = C[0];
						A.decPattern = C[1];
					} else {
						A.intPattern = x[0];
						A.decPattern = "";
					}
				}
			}
			function u(A, z, y) {
				var x = new t();
				A = h(A, x);
				A = q(A, x, z);
				if (l(A, z, y)) {
					o(A, x, z, y);
					g(x.intPattern, x, y);
					m(x.decPattern, x);
					w(x.intPattern, x, y);
				} else {
					x = null;
				}
				return x;
			}
			function n(E, A, z, y) {
				var F = "",
				x = "",
				B,
				C = 0,
				D = 0;
				if (E > 0) {
					x = E.toString();
				}
				A -= x.length;
				if (A > 0) {
					for (C = 0; C < A; C++) {
						F += i;
					}
					x = F + x;
				}
				if (z > 0 && x.length > z) {
					B = [];
					for (C = x.length - 1; C >= 0; C--) {
						if (D === z - 1 && C > 0) {
							B.unshift(y, x.charAt(C));
							D = 0;
						} else {
							B.unshift(x.charAt(C));
							D++;
						}
					}
					x = B.join("");
				}
				return x;
			}
			function r(D, C, y, x) {
				var E = "",
				z = 0,
				B = "",
				A;
				if (D > 0) {
					A = C - Math.floor(C);
					for (z = 0; z < x; z++) {
						A *= 10;
						if (Math.floor(A) === 0) {
							B += i;
						} else {
							break;
						}
					}
					if (z < x) {
						B += D.toString();
					}
					z = B.length - 1;
					while (B.charAt(z) === i && z >= y) {
						z--;
					}
					B = B.substring(0, z + 1);
				}
				y -= B.length;
				if (y > 0) {
					for (z = 0; z < y;
						z++) {
						E += i;
					}
					B += E;
				}
				return B;
			}
			b.text.NumberFormatter = function (B) {
				var z = ".",
				D = ",",
				y = null,
				x = null,
				A,
				C = null;
				this.applyPattern = function (K) {
					var G,
					J,
					F = "",
					I = 0,
					H = "",
					L = "",
					E;
					if (typeof K === "string" && K.length > 0 && K !== A) {
						G = K.indexOf("{");
						J = K.indexOf("}");
						if (G === 0 && J >= 2) {
							F = K.substring(G + 1, J);
							I = F.length;
							if (J > 2) {
								H = F.charAt(I - 1);
								L = F.charAt(I - 2);
							} else {
								H = "\uFFFF";
								L = F.charAt(I - 1);
							}
							if (H !== L && !H.match(/[0-9a-zA-Z]/) && !L.match(/[0-9a-zA-Z]/)) {
								z = H;
								D = L;
								K = K.substring(J + 1);
							}
						}
						E = K.split(";");
						if (E && E.length > 0) {
							y = u(E[0], z, D);
							if (E.length > 1 && E[1] && E[1].length > 0) {
								x = u(E[1], z, D);
							} else {
								x = y;
							}
						} else {
							y = null;
							x = null;
						}
						A = K;
					}
				};
				this.format = function (L) {
					var U,
					G,
					H = "",
					R,
					N,
					I,
					O,
					S,
					T,
					K,
					P,
					Q,
					J,
					F,
					E,
					M;
					if (typeof L !== "number" || y === null) {
						U = "";
					} else {
						G = L < 0 ? x : y;
						C = G.color;
						R = G.exponent;
						N = G.tempMinIntegerDigits;
						I = G.minIntegerPlaces;
						O = G.minDecimalPlaces;
						S = G.maxDecimalPlaces;
						if (L < 0 && y === x) {
							H += k;
						}
						if (L < 0) {
							L = -L;
						}
						if (G.percentMode) {
							L *= 100;
						} else {
							if (G.permilleMode) {
								L *= 1000;
							}
						}
						T = 0;
						K = 0;
						if (R > 0) {
							K = Math.floor(Math.log(L) / Math.log(10));
							if (K !== Infinity) {
								P = K;
								if (I !== 0) {
									K -= I - 1;
								}
								T = (L / Math.pow(10, K));
								K = P - (N - 1);
							} else {
								T = L;
							}
						} else {
							T = L;
						}
						T += 5 * Math.pow(10, -S - 1);
						Q = Math.floor(T);
						J = T - Q;
						F = Math.pow(10, -S);
						E = Math.floor(J / F);
						U = n(Q, I, G.grouping, D);
						if (O > 0 || E > 0) {
							U += z;
						}
						U += r(E, T, O, S);
						if (R > 0) {
							if (K === Infinity || K === -Infinity) {
								if (Math.abs(L) < 1) {
									U = i;
								} else {
									U = v;
								}
							} else {
								U += j;
								if (K < 0) {
									U += k;
								} else {
									U += p;
								}
								for (M = 1; M < R; M++) {
									U += i;
								}
								U += Math.abs(K).toString();
							}
						}
						if (U.length > 0 && D === U.charAt(0)) {
							U = U.substring(1, U.length);
						}
						if (U.length === 0) {
							U = i;
						}
						U = (G.prefix + H + U + G.suffix);
					}
					return U;
				};
				this.getColor = function () {
					return C;
				};
				this.hasColor = function () {
					return C !== null;
				};
				this.applyPattern(B);
			};
			b.formatNumber = function (y, x) {
				return new b.text.NumberFormatter(y).format(x);
			};
		}
			());
		(function () {
			var e = /\|/,
			f = /(?:#|<)/;
			b.declare({
				name: "oui.text.ChoiceFormatter",
				membersDef: {
					init: function (g) {
						this.applyPattern(g);
					},
					applyPattern: function (q) {
						var h = q.split(e),
						m,
						j,
						r,
						g,
						s,
						k,
						l,
						p,
						o;
						if (h && h.length > 0) {
							o = [];
							for (m = 0, j = h.length;
								m < j; m++) {
								r = h[m];
								g = r.match(f);
								if (g) {
									s = r.indexOf(g);
									k = r.substring(0, s);
									l = r.substring(s + 1);
									p = {
										format: l,
										open: (g[0] === "<"),
										min: parseInt(k, 10),
										max: Number.POSITIVE_INFINITY
									};
									if (o.length > 0) {
										o[o.length - 1].max = p.min;
									}
									o.push(p);
								}
							}
						}
						this.choiceElements = o;
					},
					format: function (m) {
						var g,
						l = this.choiceElements,
						h,
						j,
						p = l.length,
						k = l[0],
						o = l[p - 1];
						if (isNaN(m) || m <= k.min) {
							g = k.format;
						} else {
							if (m >= o.max) {
								g = o.format;
							} else {
								for (j = 0; j < p; j++) {
									h = l[j];
									if ((h.open === false && h.min === m) || (h.min < m && m < h.max)) {
										g = h.format;
										break;
									}
								}
							}
						}
						return g;
					}
				}
			});
			b.formatChoice = function (h, g) {
				return new b.text.ChoiceFormatter(h).format(g);
			};
		}
			());
		(function () {
			var y = b.text.locales.en_US,
			n = "G",
			f = "y",
			F = "M",
			z = "w",
			i = "W",
			u = "D",
			p = "d",
			D = "F",
			m = "E",
			C = "a",
			A = "H",
			j = "k",
			E = "K",
			v = "h",
			o = "m",
			s = "s",
			k = "S",
			l = "z",
			x = "Z",
			B = "short",
			r = "medium",
			h = "long",
			t = "full",
			g = 24 * 60 * 60 * 1000,
			q = 1,
			w = 4;
			function e(J, I) {
				var G = "",
				H = J.toString();
				for (I -= H.length; I > 0; I--) {
					G += "0";
				}
				return G + H;
			}
			b.declare({
				name: "oui.text.DateFormatter",
				membersDef: {
					init: function (G, H) {
						this.applyPattern(G, H);
					},
					applyPattern: function (I, K) {
						var H,
						N,
						M,
						G,
						L,
						J;
						I = this._fixPattern(I, K);
						this.dateElements = [];
						if (I) {
							for (H = 0, N = I.length;
								H < N; H++) {
								M = I.charAt(H);
								if (!this._isSupportedToken(M)) {
									J = undefined;
									if (M === "'") {
										G = "";
										L = H + 1;
										while (L < N) {
											M = I.charAt(L);
											if (M === "'") {
												if (I.charAt(L + 1) === "'") {
													G += M;
													L += 2;
												} else {
													break;
												}
											} else {
												G += M;
												L += 1;
											}
										}
										if (L >= N) {
											L = H;
										} else {
											this.dateElements.push(G);
										}
										H = L;
									} else {
										if ((M < "a" || M > "z") && (M < "A" || M > "Z")) {
											this.dateElements.push(M);
										}
									}
								} else {
									if (J && (M === J.type)) {
										J.size++;
									} else {
										J = {
											type: M,
											size: 1
										};
										this.dateElements.push(J);
									}
								}
							}
						}
					},
					_fixPattern: function (H, I) {
						var G;
						if (H) {
							switch (H) {
							case B:
								G = I ? y.shortTime : y.shortDate;
								break;
							case r:
								G = I ? y.medTime : y.medDate;
								break;
							case h:
								G = I ? y.longTime : y.longDate;
								break;
							case t:
								G = I ? y.fullTime : y.fullDate;
								break;
							default:
								G = H;
								break;
							}
						} else {
							G = I ? y.time : y.date;
						}
						return G;
					},
					_isSupportedToken: function (G) {
						return (G === n || G === f || G === F || G === z || G === i || G === u || G === p || G === D || G === m || G === C || G === A || G === j || G === E || G === v || G === o || G === s || G === k || G === l || G === x);
					},
					format: function (N) {
						var L = "",
						I,
						H,
						J,
						G,
						K,
						M,
						O;
						if (b.isA(N, Date)) {
							I = N;
						} else {
							I = new Date();
							I.setDate(N);
						}
						for (J = 0, G = this.dateElements.length;
							J < G; J++) {
							H = this.dateElements[J];
							if (b.isA(H, Object)) {
								switch (H.type) {
								case n:
									L += y.eras[I.getFullYear() > 0 ? 1 : 0];
									break;
								case f:
									K = I.getFullYear().toString();
									if (H.size < 4) {
										L += K.substring(K.length - 2);
									} else {
										L += K;
									}
									break;
								case F:
									K = I.getMonth();
									if (H.size < 3) {
										L += e(K + 1, H.size);
									} else {
										if (H.size < 4) {
											L += y.months[K].s;
										} else {
											L += y.months[K].l;
										}
									}
									break;
								case z:
									L += e(this._getWeekOfYear(I), H.size);
									break;
								case i:
									L += e(this._getWeekOfMonth(I), H.size);
									break;
								case u:
									L += e(this._getDayOfYear(I), H.size);
									break;
								case p:
									L += e(I.getDate(), H.size);
									break;
								case D:
									L += e(I.getDay(), H.size);
									break;
								case m:
									K = I.getDay();
									if (H.size < 4) {
										L += y.days[K].s;
									} else {
										L += y.days[K].l;
									}
									break;
								case C:
									L += y.ampm[I.getHours() < 12 ? 0 : 1];
									break;
								case A:
									L += e(I.getHours(), H.size);
									break;
								case j:
									L += e(((I.getHours() + 23) % 24) + 1, H.size);
									break;
								case E:
									L += e(I.getHours() % 12, H.size);
									break;
								case v:
									L += e(((I.getHours() + 11) % 12) + 1, H.size);
									break;
								case o:
									L += e(I.getMinutes(), H.size);
									break;
								case s:
									L += e(I.getSeconds(), H.size);
									break;
								case k:
									L += e(I.getMilliseconds(), H.size);
									break;
								case l:
									K = I.getTimezoneOffset();
									if (this._isDST(I)) {
										M = (K + 60).toString();
										O = "dst";
									} else {
										M = K.toString();
										O = "std";
									}
									if (y.timezones.hasOwnProperty(M)) {
										K = y.timezones[M];
										if (H.size < 4) {
											L += K[O].s;
										} else {
											L += K[O].l;
										}
									} else {
										L += "GMT" + (K > 0 ? "-" : "+") + Math.floor(K / 60) + ":" + e((K % 60), 2);
									}
									break;
								case x:
									K = I.getTimezoneOffset();
									L += (K > 0 ? "-" : "+") + e(Math.floor(K / 60), 2) + e((K % 60), 2);
									break;
								default:
									c.error("ERR__FORMAT__ILLEGAL_DATE_PATTERN", H);
								}
							} else {
								L += H.toString();
							}
						}
						return L;
					},
					_getWeekOfYear: function (H, G, L) {
						var K,
						I,
						J,
						M;
						if (!isFinite(G)) {
							G = q;
						}
						if (!isFinite(L)) {
							L = w;
						}
						K = (7 + H.getDay() - G) % 7;
						I = (this._getDayOfYear(H) - K + 6) / 7;
						J = new Date(H.getFullYear(), 0, L);
						M = (7 + J.getDay() - G) % 7;
						if (L - M < 1) {
							I++;
						}
						return Math.floor(I);
					},
					_getWeekOfMonth: function (I, H, L) {
						var K,
						G,
						J,
						M;
						if (!isFinite(H)) {
							H = q;
						}
						if (!isFinite(L)) {
							L = w;
						}
						K = (7 + I.getDay() - H) % 7;
						G = (I.getDate() - K + 6) / 7;
						J = new Date(I.getFullYear(), I.getMonth(), L);
						M = (7 + J.getDay() - H) % 7;
						if (L - M < 1) {
							G++;
						}
						return Math.floor(G);
					},
					_getDayOfYear: function (I) {
						var J = I.getFullYear(),
						M = I.getMonth(),
						G = I.getDate(),
						H = new Date(J, 0, 1, 12, 0, 0),
						L = new Date(J, M, G, 12, 0, 0),
						K = (L.getTime() - H.getTime()) / g;
						return (Math.round(K) + 1);
					},
					_isDST: function (H) {
						var G = new Date(H.getFullYear(), 0, 1, H.getHours(), H.getMinutes(), H.getSeconds(), H.getMilliseconds());
						return (H.getTimezoneOffset() !== G.getTimezoneOffset());
					}
				}
			});
			b.text.DateFormatter.setLocale = function (G) {
				if (typeof G === "string" && b.text.locales.hasOwnProperty(G) === true) {
					y = b.text.locales[G];
				}
			};
			b.formatDate = function (H, G) {
				return new b.text.DateFormatter(H).format(G);
			};
		}
			());
		(function () {
			var e = {
				NUMBER: "number",
				CHOICE: "choice",
				DATE: "date",
				TIME: "time"
			};
			b.declare({
				name: "oui.text.FormatElement",
				membersDef: {
					init: function (k, j, i) {
						var h,
						f,
						g;
						if (b.isFinitePositiveNumber(k)) {
							this.argIndex = k;
						} else {
							c.error("ERR__FORMAT__ILLEGAL_ARG_INDEX");
						}
						h = b.isA(j, String);
						f = b.isA(i, String);
						if (h && f) {
							switch (j) {
							case e.NUMBER:
								g = new b.text.NumberFormatter(i);
								break;
							case e.CHOICE:
								g = new b.text.ChoiceFormatter(i);
								break;
							case e.DATE:
								g = new b.text.DateFormatter(i);
								break;
							case e.TIME:
								g = new b.text.DateFormatter(i, true);
								break;
							default:
								c.error("ERR__FORMAT__ILLEGAL_ARG_TYPE", j);
							}
							this.type = j;
						} else {
							if (h && !f) {
								c.error("ERR__FORMAT__ILLEGAL_ARG_NO_STYLE");
							} else {
								if (!h && f) {
									c.error("ERR__FORMAT__ILLEGAL_ARG_NO_TYPE");
								}
							}
						}
						this.format = function (m) {
							var l;
							if (this.accepts(m)) {
								if (g) {
									l = g.format(m);
								} else {
									l = (m === null ? "null" : m.toString());
								}
							} else {
								c.error("ERR__FORMAT__ILLEGAL_ARG_VALUE");
							}
							return l;
						};
					},
					accepts: function (h) {
						var g = true,
						f = this.type;
						if (f) {
							if (f === e.NUMBER || f === e.CHOICE) {
								g = b.isA(h, Number);
							} else {
								if (f === e.DATE || f === e.TIME) {
									g = b.isA(h, Date);
								}
							}
						}
						return g;
					},
					toString: function () {
						return "{" + this.argIndex + "}";
					}
				}
			});
			b.text.FormatElement.TypeEnum = e;
		}
			());
		(function () {
			var e = /\{\d+(?:\,(?:choice|number|date|time)\,(?:[^\{]|\{[^\{]+\})+)?\}/g;
			b.declare({
				name: "oui.text.MessageFormatter",
				membersDef: {
					init: function (f) {
						this.applyPattern(f);
					},
					applyPattern: function (q) {
						var h = q.match(e),
						p = q.split(e),
						o,
						j,
						m,
						t,
						l,
						r,
						s,
						g,
						f,
						k,
						u = [];
						if (h && h.length > 0 && p && p.length > 0) {
							for (o = 0, j = h.length;
								o < j; o++) {
								m = undefined;
								l = undefined;
								r = undefined;
								s = h[o];
								g = s.indexOf(",");
								if (g < 0) {
									t = s.substring(1, s.length - 1);
									m = parseInt(t, 10);
								} else {
									m = parseInt(s.substring(1, g), 10);
									f = s.indexOf(",", g + 1);
									l = s.substring(g + 1, f);
									r = s.substring(f + 1, s.length - 1);
								}
								k = new b.text.FormatElement(m, l, r);
								u.push(p[o]);
								u.push(k);
							}
							u.push(p[h.length]);
						} else {
							u.push(q);
						}
						this.parsedPattern = u;
					},
					format: function () {
						var g = "",
						k,
						j = this.parsedPattern.length,
						m,
						f,
						h,
						l;
						for (k = 0; k < j; k++) {
							m = this.parsedPattern[k];
							if (b.isA(m, b.text.FormatElement)) {
								f = arguments[m.argIndex];
								if (f !== undefined) {
									h = m.format(f);
									if (m.type === b.text.FormatElement.TypeEnum.CHOICE) {
										l = new b.text.MessageFormatter(h);
										h = l.format.apply(l, arguments);
									}
									g += h;
								} else {
									g += m.toString();
								}
							} else {
								if (b.isA(m, String)) {
									g += m;
								}
							}
						}
						return g;
					}
				}
			});
			b.formatMessage = function (h, g) {
				var f = new b.text.MessageFormatter(h);
				return f.format.apply(f, g);
			};
		}
			());
		(function () {
			var f = new RegExp("\\S+", "g");
			function e(k) {
				var i = [],
				g,
				j,
				h = 0;
				while ((g = f.exec(k)) !== null) {
					j = g[0];
					i.push({
						beginIndex: g.index,
						endIndex: g.index + (j.length - 1),
						length: j.length,
						value: j,
						wordIndex: h
					});
					h++;
				}
				return i;
			}
			b.declare({
				name: "oui.text.WordIterator",
				membersDef: {
					init: function (g) {
						this._words = e(g);
						this._wordCount = this._words.length;
						this._currWord = null;
					},
					first: function () {
						var g = null;
						if (this._wordCount > 0) {
							g = this._words[0];
						}
						this._currWord = g;
						return g;
					},
					last: function () {
						var g = null;
						if (this._wordCount > 0) {
							g = this._words[this._wordCount - 1];
						}
						this._currWord = g;
						return g;
					},
					next: function () {
						var i = null,
						j = this._wordCount,
						h,
						g;
						if (j > 0) {
							h = this._currWord;
							g = 0;
							if (h) {
								g = h.wordIndex + 1;
							}
							if (g < j) {
								i = this._words[g];
							}
						}
						this._currWord = i;
						return i;
					},
					previous: function () {
						var i = null,
						h = this._wordCount,
						g,
						j;
						if (h > 0) {
							g = this._currWord;
							j = h - 1;
							if (g) {
								j = g.wordIndex - 1;
							}
							if (j >= 0) {
								i = this._words[j];
							}
						}
						this._currWord = i;
						return i;
					},
					current: function () {
						return this._currWord;
					},
					wordAt: function (n) {
						var m = this._words,
						h = this._wordCount,
						k = null,
						l = 0,
						j,
						g = null;
						if (this._currWord) {
							l = this._currWord.wordIndex;
						}
						for (j = l; j < h; j++) {
							g = m[j];
							if (n < g.beginIndex) {
								break;
							} else {
								if (n <= g.endIndex) {
									k = g;
									break;
								}
							}
						}
						this._currWord = g;
						return k;
					}
				}
			});
		}
			());
		(function () {
			var e = "\n";
			b.declare({
				name: "oui.text.LineBreakMeasurer",
				membersDef: {
					init: function (f) {
						this._textValue = f.textValue();
						this._position = 0;
						this._wordIterator = new b.text.WordIterator(this._textValue);
						this._wordIterator.first();
						this._initOffsetLimits();
						this._initImpl(f);
					},
					nextLine: function (g) {
						var f = this._nextLineImpl(g);
						if (f && f.leading === undefined) {
							f.leading = this._computeLeadingApproximation(f);
						}
						return f;
					},
					replaceText: function (g, j, i) {
						var h = this._textValue,
						f = h.length;
						if (g < 0 || j > f || g > j) {
							c.error("ERR__LINEBREAK__ILLEGAL_REPLACE_ARG");
						}
						this._textValue = "";
						if (g !== 0) {
							this._textValue += h.slice(0, g);
						}
						if (i !== null) {
							this._textValue += i;
						}
						if (j !== f) {
							this._textValue += h.slice(j);
						}
						this._position = 0;
						this._wordIterator.init(this._textValue);
						this._wordIterator.first();
						this._initOffsetLimits();
						this._replaceTextImpl(g, j, i);
					},
					getRawText: function () {
						return this._textValue;
					},
					getTextLength: function () {
						return this._textValue.length;
					},
					_initImpl: function (f) {},
					_nextLineImpl: function (l) {
						var k = this._getCurrentOffsetLimit(),
						n = null,
						i = this._wordIterator,
						j = this._position,
						g = j,
						f = i.current(),
						m,
						h;
						if (f) {
							m = f.endIndex + 1;
							if (m > k || this._measureImpl(j, m) > l) {
								g = this._fitChars(l, k);
								h = true;
							} else {
								g = this._fitWords(l, k);
								h = false;
							}
							this._updateOffsetLimit(g);
							if (g > j) {
								n = this._createLineObjImpl(j, g, h);
								this._position = g;
							}
						}
						return n;
					},
					_measureImpl: function (g, f) {
						return 0;
					},
					_createLineObjImpl: function (h, f, g) {
						return {
							textValue: this._textValue.substring(h, f),
							textBlockBeginIndex: h,
							lastWordTruncated: g,
							lineWidth: 0,
							lineHeight: 0,
							ascent: 0,
							descent: 0,
							userData: null
						};
					},
					_replaceTextImpl: function (f, h, g) {},
					_initOffsetLimits: function () {
						this._offsetLimits = this._findOffsetLimits(this._textValue);
						this._offsetLimitsCount = this._offsetLimits.length;
						this._currOffsetLimit = 0;
					},
					_findOffsetLimits: function (g) {
						var f = [],
						j = 0,
						h = g.length;
						for (j = 0; j < h; j++) {
							if (e === g.charAt(j)) {
								f.push(j + 1);
							}
						}
						return f;
					},
					_getCurrentOffsetLimit: function () {
						var f = this._textValue.length;
						if (this._currOffsetLimit < this._offsetLimitsCount) {
							f = this._offsetLimits[this._currOffsetLimit];
						}
						return f;
					},
					_updateOffsetLimit: function (f) {
						if (f === this._offsetLimits[this._currOffsetLimit]) {
							this._currOffsetLimit++;
						}
					},
					_fitChars: function (h, g) {
						var j = this._position,
						i = this._position + 1,
						f = i;
						while (i < g && this._measureImpl(j, i) <= h) {
							f = i;
							i++;
						}
						return f;
					},
					_fitWords: function (g, f) {
						var h = this._wordIterator.current(),
						j = this._position,
						i = j;
						while (h && (h.endIndex + 1) <= f && this._measureImpl(j, h.endIndex + 1) <= g) {
							i = h.endIndex + 1;
							h = this._wordIterator.next();
						}
						if (h && i !== j && i !== f) {
							if (h.beginIndex > f) {
								i = f;
							} else {
								i = h.beginIndex;
							}
						}
						return i;
					},
					_computeLeadingApproximation: function (f) {
						return (f.ascent + f.descent) * 0.2;
					}
				}
			});
		}
			());
		(function () {
			b.mixin(b.text.LineBreakMeasurer, {
				_initImpl: function (e) {
					var f = b.tree.svgCreateElt("text"),
					g = b.tree.svgCreateTextElt("");
					e.svgSetTextFormat(f);
					f.appendChild(g);
					b.tree.svgAddDef(f);
					this.svgTextMeasurer = f;
				},
				_measureImpl: function (g, e) {
					var f = this.svgTextMeasurer;
					f.firstChild.nodeValue = this._textValue.substring(g, e);
					return f.getComputedTextLength();
				},
				_createLineObjImpl: function (e, i, j) {
					var g = this._textValue.substring(e, i),
					f = this.svgTextMeasurer,
					h = f.firstChild,
					k = f.parentNode,
					l = h.nodeValue,
					m;
					h.nodeValue = g;
					b.tree.svgNode.appendChild(f);
					m = f.getBBox();
					b.tree.svgNode.removeChild(f);
					h.nodeValue = l;
					k.appendChild(f);
					return {
						textValue: g,
						textBlockBeginIndex: e,
						textBlockEndIndex: i,
						lastWordTruncated: j,
						lineWidth: m.width,
						lineHeight: m.height,
						ascent: (-m.y),
						descent: (m.height + m.y),
						userData: null
					};
				}
			});
		}
			());
		(function () {
			var e = "FILTER_EVENT";
			b.declare({
				name: "oui.filters.AbstractFilter",
				isAbstract: true,
				mixins: [b.events.EventSupport],
				membersDef: {
					init: function (f) {
						this._style = new this.Style();
						this.applyStyle(f);
					},
					applyStyle: function (f) {
						var g = this._style.updateObject(f),
						h;
						if (this.shadowFilter) {
							for (h in g) {
								if (g.hasOwnProperty(h)) {
									this._updateShadowFilter(h);
								}
							}
						}
						this.dispatchEvent({
							type: e
						});
					},
					_getFilteredBounds: function (f) {
						return f;
					},
					_getShadowFilter: function () {
						if (!this.shadowFilter) {
							this.shadowFilter = this._createShadowFilter();
						}
						return this.shadowFilter;
					},
					_createShadowFilter: function () {},
					_updateShadowFilter: function (f) {}
				}
			});
			b.filters.FILTER_EVENT = e;
		}
			());
		(function () {
			var f = 0,
			e = 3 * Math.sqrt(2 * Math.PI);
			b.mixin(b.filters.AbstractFilter, {
				_createShadowFilter: function () {
					var g = this.svgGetFilterID(),
					j,
					k,
					h,
					l;
					j = b.tree.svgCreateElt("filter", {
						id: g,
						x: "-50%",
						y: "-50%",
						width: "200%",
						height: "200%"
					});
					k = this.svgGetFilterPrimitives();
					for (h = 0, l = k.length; h < l; h++) {
						j.appendChild(k[h]);
					}
					b.tree.svgAddDef(j);
					return "url(#" + g + ")";
				},
				svgGetFilterID: function () {
					if (!this._id) {
						this._id = this.SVG_FILTER_ID + f++;
					}
					return this._id;
				},
				svgGetFilterPrimitives: function () {
					return [];
				},
				svgGetStdDev: function (g) {
					return (g * 4 - 2) / e;
				}
			});
		}
			());
		(function () {
			var e = {
				RADIUS: "RADIUS"
			};
			b.declare({
				name: "oui.filters.Blur",
				extend: b.filters.AbstractFilter,
				membersDef: {
					_getFilteredBounds: function (g) {
						var f = this._style.radius;
						return {
							x: g.x - f,
							y: g.y - f,
							width: g.width + 2 * f,
							height: g.height + 2 * f
						};
					},
					_styleTags: e
				}
			});
			b.addStyleSupport(b.filters.Blur, {
				radius: b.defs.FinitePositiveNumber(3, e.RADIUS)
			});
		}
			());
		(function () {
			b.mixin(b.filters.Blur, {
				SVG_FILTER_ID: "Blur",
				svgGetFilterPrimitives: function () {
					this.svgBlur = b.tree.svgCreateElt("feGaussianBlur", {
						"in": "SourceGraphic",
						stdDeviation: this.svgGetStdDev(this._style.radius)
					});
					return [this.svgBlur];
				},
				_updateShadowFilter: function (e) {
					if (e === this._styleTags.RADIUS) {
						this.svgBlur.attr("stdDeviation", this.svgGetStdDev(this._style.radius));
					}
				}
			});
		}
			());
		(function () {
			var e = b.defs,
			f = {
				COLOR: "COLOR",
				OPACITY: "OPACITY",
				RADIUS: "RADIUS",
				ANGLE: "ANGLE",
				OFFSET: "OFFSET",
				KNOCKOUT: "KNOCKOUT"
			};
			b.declare({
				name: "oui.filters.DropShadow",
				extend: b.filters.AbstractFilter,
				membersDef: {
					_getFilteredBounds: function (i) {
						var h = this._style,
						k = h.angle * Math.PI / 180,
						j = h.offset,
						g = h.radius;
						return b.geom.unionRect(i, {
							x: i.x + j * Math.cos(k) - g,
							y: i.y + j * Math.sin(k) - g,
							width: i.width + 2 * g,
							height: i.height + 2 * g
						});
					},
					_styleTags: f
				},
				styleDef: {
					color: e.Color(b.black, f.COLOR),
					opacity: e.NumberInRange([0, 1], 0.5, f.OPACITY),
					radius: e.FinitePositiveNumber(2, f.RADIUS),
					angle: e.NumberInRange([0, 360], 45, f.ANGLE),
					offset: e.FinitePositiveNumber(2, f.OFFSET),
					knockout: e.Boolean(false, f.KNOCKOUT)
				}
			});
		}
			());
		(function () {
			var e = b.geom.DEG_TO_RAD;
			b.mixin(b.filters.DropShadow, {
				SVG_FILTER_ID: "DropShadow",
				svgGetFilterPrimitives: function () {
					var f = this._style,
					l = f.color,
					n = f.opacity,
					j = f.angle * e,
					m = f.offset,
					h,
					i,
					o,
					q,
					r,
					g,
					p,
					k;
					h = b.tree.svgCreateElt("feComponentTransfer", {
						"in": "SourceAlpha",
						result: "compTransfer"
					});
					i = b.tree.svgCreateElt("feFuncR", {
						type: "linear",
						slope: 0,
						intercept: l.getRed() / 255
					});
					h.appendChild(i);
					o = b.tree.svgCreateElt("feFuncG", {
						type: "linear",
						slope: 0,
						intercept: l.getGreen() / 255
					});
					h.appendChild(o);
					q = b.tree.svgCreateElt("feFuncB", {
						type: "linear",
						slope: 0,
						intercept: l.getBlue() / 255
					});
					h.appendChild(q);
					r = b.tree.svgCreateElt("feFuncA", {
						type: "linear",
						slope: l.getOpacity() * n,
						intercept: 0
					});
					h.appendChild(r);
					g = b.tree.svgCreateElt("feGaussianBlur", {
						"in": "compTransfer",
						result: "blur",
						stdDeviation: this.svgGetStdDev(f.radius)
					});
					p = b.tree.svgCreateElt("feOffset", {
						"in": "blur",
						result: "castShadow",
						dx: m * Math.cos(j),
						dy: m * Math.sin(j)
					});
					k = b.tree.svgCreateElt("feComposite");
					this.svgBlur = g;
					this.svgOffset = p;
					this.svgFuncR = i;
					this.svgFuncG = o;
					this.svgFuncB = q;
					this.svgFuncA = r;
					this.svgComposite = k;
					this.svgUpdateKnockout();
					return [h, g, p, k];
				},
				_updateShadowFilter: function (f) {
					var i = this._styleTags,
					j = this._style,
					h = j.opacity,
					g = j.color,
					l,
					k;
					if (f === i.COLOR) {
						this.svgFuncR.attr("intercept", g.getRed() / 255);
						this.svgFuncG.attr("intercept", g.getGreen() / 255);
						this.svgFuncB.attr("intercept", g.getBlue() / 255);
						this.svgFuncA.attr("slope", h * g.getOpacity());
					} else {
						if (f === i.OPACITY) {
							this.svgFuncA.attr("slope", h * g.getOpacity());
						} else {
							if (f === i.RADIUS) {
								this.svgBlur.attr("stdDeviation", this.svgGetStdDev(this._style.radius));
							} else {
								if (f === i.ANGLE || f === i.OFFSET) {
									l = this._style.angle * e;
									k = this._style.offset;
									this.svgOffset.attr({
										dx: k * Math.cos(l),
										dy: k * Math.sin(l)
									});
								} else {
									if (f === i.KNOCKOUT) {
										this.svgUpdateKnockout();
									}
								}
							}
						}
					}
				},
				svgUpdateKnockout: function () {
					var f = this.svgComposite;
					if (this._style.knockout) {
						f.attr({
							"in": "castShadow",
							in2: "SourceGraphic",
							operator: "out"
						});
					} else {
						f.attr({
							"in": "SourceGraphic",
							in2: "castShadow",
							operator: "over"
						});
					}
				}
			});
		}
			());
		(function () {
			var e = b.defs,
			f = {
				STRENGTH: "STRENGTH",
				COLOR: "COLOR",
				OPACITY: "OPACITY"
			};
			b.declare({
				name: "oui.filters.Glow",
				extend: b.filters.AbstractFilter,
				membersDef: {
					_getFilteredBounds: function (g) {
						var h = this._style.strength;
						return {
							x: g.x - h,
							y: g.y - h,
							width: g.width + 2 * h,
							height: g.height + 2 * h
						};
					},
					_styleTags: f
				}
			});
			b.addStyleSupport(b.filters.Glow, {
				color: e.Color(b.white, f.COLOR),
				strength: e.FinitePositiveNumber(3, f.STRENGTH)
			});
		}
			());
		(function () {
			b.mixin(b.filters.Glow, {
				SVG_FILTER_ID: "Glow",
				svgGetFilterPrimitives: function () {
					var f = this._style,
					g,
					h,
					i,
					e;
					g = b.tree.svgCreateElt("feFlood", {
						"flood-color": f.color.svgGetPaint(),
						result: "highlightColor"
					});
					h = b.tree.svgCreateElt("feComposite", {
						"in": "highlightColor",
						in2: "SourceAlpha",
						operator: "in",
						result: "coloredMask"
					});
					i = b.tree.svgCreateElt("feGaussianBlur", {
						stdDeviation: this.svgGetStdDev(this._style.strength),
						result: "glow"
					});
					e = b.tree.svgCreateElt("feComposite", {
						"in": "SourceGraphic",
						in2: "glow",
						operator: "over"
					});
					this.svgFlood = g;
					this.svgBlur = i;
					return [g, h, i, e];
				},
				_updateShadowFilter: function (e) {
					var f = this._styleTags,
					g = this._style;
					if (e === f.COLOR) {
						this.svgFlood.attr("flood-color", g.color.svgGetPaint());
					} else {
						if (e === f.STRENGTH) {
							this.svgBlur.attr("stdDeviation", this.svgGetStdDev(g.strength));
						}
					}
				}
			});
		}
			());
		(function () {
			b.mixin(b.filters, {
				NONE: null,
				BLUR: new b.filters.Blur(),
				DROP_SHADOW: new b.filters.DropShadow(),
				DROP_SHADOW_KNOCKED_OUT: new b.filters.DropShadow({
					knockout: true
				}),
				_onLayoutDir: function (e) {
					var f = e === b.LTR ? 45 : 135;
					b.filters.DROP_SHADOW.setAngle(f);
					b.filters.DROP_SHADOW_KNOCKED_OUT.setAngle(f);
				}
			});
		}
			());
		(function () {
			var f = b.scene.AbstractNode.prototype,
			e = b.defs,
			g = b.TAGS;
			b.declare({
				name: "oui.graphics.AbstractGraphicNode",
				isAbstract: true,
				extend: b.scene.AbstractNode,
				mixins: [b.lang.BindingSupport, b.anim.EffectsSupport],
				membersDef: {
					init: function (h, i) {
						f.init.call(this, i);
						this._globalTxf = undefined;
						this._globalTxfInv = undefined;
						this._layoutDirty = true;
						this._layoutPosDirty = true;
						this._layoutBox = undefined;
						this._prevLayoutBox = undefined;
						this._filterFX = null;
						this._ctrlPts = [];
						this._style = new this.Style();
						this._style.transform = new b.geom.Matrix();
						this._txf = this._style.transform;
						if (h) {
							this.styleBinding = h.styleBinding;
							this.dataBinding = h.dataBinding;
							this.resourcesBinding = h.resourcesBinding;
						}
						this.applyStyle(h);
					},
					notifyNative: function (i) {
						var h = this.parentNode;
						if (i === g.TRANSFO) {
							this.clearGlobalTransformMatrix();
							if (h && this.preventParentInvalidateLayout !== true) {
								h._clearCtrlPts();
								h.invalidateLayout();
							}
						} else {
							if (i === g.LAYOUT_DIR) {
								this._onLayoutDirChanged();
								if (b.isA(this._style.tooltip, b.graphics.AbstractGraphicNode)) {
									this._style.tooltip.notifyChildren(i);
								}
							}
						}
						f.notifyNative.call(this, i);
					},
					_onParentChanged: function () {
						this.clearGlobalTransformMatrix();
						f._onParentChanged.call(this);
					},
					_onChildrenChanged: function () {
						this._clearCtrlPts();
						this.invalidateLayout();
						f._onChildrenChanged.call(this);
					},
					onPropertyChanged: function () {},
					onStyleChanged: function (h) {
						if (h === b.DEFAULT_TAG) {
							this.onPropertyChanged();
						} else {
							if (h === g.VISIBILITY || h === g.SENSITIVITY || h === g.DESC) {
								this.notifyNative(h);
							} else {
								if (h === g.LAYOUT || h === g.PREF_SIZE) {
									this.invalidateLayout();
								} else {
									if (h === g.DISPLAY || h === g.CLIP) {
										this._clearCtrlPts();
										this.invalidateLayout();
										this.notifyNative(h);
									} else {
										if (h === g.FILTER) {
											this._updateFilterFX();
											this.notifyNative(h);
										} else {
											if (h === g.CURSOR) {
												this._onCursorChanged();
												this.notifyNative(h);
											} else {
												if (h === g.TRANSFO_SET) {
													this._style.transform = this._style.transform.clone();
													this._txf = this._style.transform;
													this.notifyNative(g.TRANSFO);
												}
											}
										}
									}
								}
							}
						}
					},
					applyStyle: function (h) {
						var i,
						j;
						if (h && this._style && this._style.updateObject) {
							i = this._style.updateObject(h);
							for (j in i) {
								if (i[j] === true) {
									this.onStyleChanged(j);
								}
							}
						}
					},
					applyStyleBinding: function (j, i, h) {
						this._applyBinding(j, i, "styleBinding", "styleBindingScope", this.applyStyle, h);
					},
					applyDataBinding: function (j, i, h) {
						this._applyBinding(j, i, "dataBinding", "dataBindingScope", this.applyStyle, h);
					},
					applyResourcesBinding: function (j, i, h) {
						this._applyBinding(j, i, "resourcesBinding", "resourcesBindingScope", this.applyStyle, h);
					},
					requestFocus: function () {
						if (b.focusManager) {
							b.focusManager.requestFocus(this);
						}
					},
					getDefaultDragAction: function () {
						return function (h) {
							var i = h.target;
							if (i && i.draggable()) {
								i.translate(h.dragUserX, h.dragUserY);
							}
						};
					},
					translate: function (i, h) {
						if (i !== 0 || h !== 0) {
							this._txf.translate(i, h);
							this.notifyNative(g.TRANSFO);
						}
						return this;
					},
					scale: function (i, h) {
						this._txf.scale(i, h);
						this.notifyNative(g.TRANSFO);
						return this;
					},
					rotate: function (j, h, k) {
						var i = j / 180 * Math.PI;
						this._txf.rotate(i, h, k);
						this.notifyNative(g.TRANSFO);
						return this;
					},
					setTranslation: function (h, i) {
						if (b.isFiniteNumber(h) && b.isFiniteNumber(i)) {
							this._setTranslation(h, i);
						}
					},
					_setTranslation: function (h, j) {
						var i = this._txf;
						if (i && (i.tx !== h || i.ty !== j)) {
							i.tx = h;
							i.ty = j;
							this.notifyNative(g.TRANSFO);
						}
					},
					getTranslation: function () {
						return {
							x: this._txf.tx,
							y: this._txf.ty
						};
					},
					resetTransform: function () {
						this._style.transform = b.geom.Matrix.IDENTITY.clone();
						this._txf = this._style.transform;
						this.notifyNative(g.TRANSFO);
					},
					getTransformMatrix: function () {
						return this._txf.clone();
					},
					setTransformMatrix: function (h) {
						this._txf.set(h);
						this.notifyNative(g.TRANSFO);
					},
					getGlobalTransformMatrix: function () {
						return this._safeGetGlobalTxf().clone();
					},
					getGlobalTransformMatrixInv: function () {
						return this._safeGetGlobalTxfInv().clone();
					},
					_safeGetGlobalTxfInv: function () {
						if (!this._globalTxfInv) {
							this._globalTxfInv = this._safeGetGlobalTxf().inv();
						}
						return this._globalTxfInv;
					},
					_safeGetGlobalTxf: function () {
						var h = this._globalTxf;
						if (!h) {
							if (this.parentNode) {
								h = this.parentNode._safeGetGlobalTxf();
								if (!this._txf.isIdentity()) {
									h = h.clone();
									h._concat(this._txf);
								}
							} else {
								h = this._txf;
							}
							this._globalTxf = h;
						}
						return h;
					},
					clearGlobalTransformMatrix: function (h) {
						var i;
						if (this._globalTxf || this._globalTxfInv) {
							this._globalTxf = undefined;
							this._globalTxfInv = undefined;
							i = this.firstChild;
							while (i) {
								i.clearGlobalTransformMatrix(true);
								i = i.nextSibling;
							}
						}
						this._clearGlobalTxfImpl(h);
					},
					_clearGlobalTxfImpl: function (h) {},
					_transformCtrlPts: function (i, j) {
						var h = this._getCtrlPts(j);
						if (h.length > 0) {
							if (j === b._BoundsType.RENDER) {
								h = this._filterCtrlPts(h);
							}
							h = this._clipCtrlPts(h);
							if (i && !i.isIdentity()) {
								h = i.transformAll(h, []);
							}
						}
						return h;
					},
					_filterCtrlPts: function (i) {
						var h = i,
						k = this._filterFX,
						j;
						if (k) {
							if (k.isInGlobalSpace) {
								h = this._safeGetGlobalTxf().transformAll(i, []);
							}
							j = b.geom.computeBounds(h);
							j = this._filterFX._getFilteredBounds(j);
							h = b.geom.getBoxCtrlPts(j.x, j.y, j.width, j.height);
							if (k.isInGlobalSpace) {
								h = this._safeGetGlobalTxfInv().transformAll(h);
							}
						}
						return h;
					},
					_clipCtrlPts: function (i) {
						var h = i,
						k = this._style.clip,
						j;
						if (k[2] >= 0 && k[3] >= 0) {
							j = b.geom.computeBounds(h);
							j = b.geom.intersectRect(j, {
								x: k[0],
								y: k[1],
								width: k[2],
								height: k[3]
							});
							if (j) {
								h = b.geom.getBoxCtrlPts(j.x, j.y, j.width, j.height);
							} else {
								h = [];
							}
						}
						return h;
					},
					getLayoutBounds: function (i) {
						this.layout();
						var h = this._txf;
						if (i && i.getGlobalTransformMatrixInv) {
							h = i.getGlobalTransformMatrixInv();
							h._concat(this._safeGetGlobalTxf());
						}
						return this._getBoundsImpl(h, b._BoundsType.LAYOUT);
					},
					getLocalBounds: function () {
						if (!this._localBoundsCache) {
							this._localBoundsCache = b.geom.computeBounds(this._clipCtrlPts(this._getCtrlPts(b._BoundsType.RENDER)));
						}
						return this._localBoundsCache;
					},
					_getBoundsImpl: function (h, i) {
						return b.geom.computeBounds(this._transformCtrlPts(h, i));
					},
					getTransformToNode: function (k) {
						var i = new b.geom.Matrix(),
						j,
						h;
						if (b.isA(k, b.graphics.AbstractGraphicNode)) {
							j = this.getGlobalTransformMatrix();
							h = k.getGlobalTransformMatrixInv();
							i.concat(h);
							i.concat(j);
						}
						return i;
					},
					_getCtrlPts: function (j) {
						var h,
						i = this._ctrlPts;
						if (j !== b._BoundsType.LAYOUT || this._style.display) {
							j = this._fixBoundsType(j);
							if (!i[j]) {
								i[j] = this._computeCtrlPts(j);
							}
							h = i[j];
						} else {
							h = [];
						}
						return h;
					},
					_fixBoundsType: function (h) {
						return h;
					},
					_clearCtrlPts: function () {
						this._ctrlPts = [];
						this._localBoundsCache = undefined;
						var h = this.parentNode;
						if (h && h._ctrlPts.length > 0) {
							h._clearCtrlPts();
						}
					},
					localToGlobal: function (h, i) {
						return this._safeGetGlobalTxf().transform(h, i);
					},
					globalToLocal: function (h, i) {
						return this._safeGetGlobalTxfInv().transform(h, i);
					},
					hitTest: function (i, l, j) {
						var h = null,
						k = this._style;
						if (k.display && k.visibility && k.pointerSensitivity) {
							h = this._hitTest(i, l, j);
						}
						return h;
					},
					_hitTest: function (h, j) {
						var i = this.globalToLocal(h, j);
						return this._isWithinBounds(i.x, i.y) ? this : null;
					},
					_isWithinBounds: function (i, h, k) {
						var j = this.getLocalBounds();
						if (typeof k !== "number") {
							k = 0;
						}
						return j !== undefined && i >= j.x - k && i <= j.x + j.width + k && h >= j.y - k && h <= j.y + j.height + k;
					},
					_updateFilterFX: function () {
						if (!this._filterFXListener) {
							this._filterFXListener = this._getFilterFXListener();
						}
						var h = this._style.filter,
						i = this._filterFX;
						if (i) {
							i.removeEventListener(this._filterFXListener);
						}
						if (h) {
							h.addEventListener(b.filters.FILTER_EVENT, this._filterFXListener);
						}
						this._filterFX = h;
					},
					_getFilterFXListener: function () {
						var h = this;
						return function () {
							h.notifyNative(g.FILTER);
						};
					},
					_onCursorChanged: function () {
						var i = this,
						j = this._style.cursor,
						h;
						if (typeof j === "object") {
							this._customCursor = b.load(j.definition);
						} else {
							this._customCursor = null;
						}
						if (this._customCursor) {
							this._customCursor.setPointerSensitivity(false);
							if (!this._showCustomCursor) {
								h = function (k) {
									i._customCursor._setTranslation(k.clientX - j.hotspotX, k.clientY - j.hotspotY);
								};
								this._showCustomCursor = function (k) {
									b.tree.userLayer.appendChild(i._customCursor);
									h(k);
									i.onMouseMove(h);
								};
								this._hideCustomCursor = function () {
									i.offMouseMove(h);
									b.tree.userLayer.removeChild(i._customCursor);
								};
							}
							this.onMouseOver(this._showCustomCursor);
							this.onMouseOut(this._hideCustomCursor);
						} else {
							this.offMouseOver(this._showCustomCursor);
							this.offMouseOut(this._hideCustomCursor);
						}
					},
					getPreferredLayoutBox: function (j) {
						var i,
						l = this._style.display,
						h = this._style.layout,
						k;
						j = j || {};
						if (l) {
							k = h.padding;
							if (h.preferredWidth >= 0) {
								j.width = h.preferredWidth;
							}
							if (h.preferredHeight >= 0) {
								j.height = h.preferredHeight;
							}
							if (j.width === undefined || j.height === undefined) {
								i = this._getContentPreferredLayoutBox();
								if (j.width === undefined) {
									j.width = i.width + k.lineBegin + k.lineEnd;
								}
								if (j.height === undefined) {
									j.height = i.height + k.top + k.bottom;
								}
							}
						} else {
							j.width = 0;
							j.height = 0;
						}
						return j;
					},
					_getContentPreferredLayoutBox: function () {
						this.layout();
						var i = {
							width: 0,
							height: 0
						},
						h = this._getBoundsImpl(this._txf, b._BoundsType.LAYOUT);
						if (h) {
							i.width = h.width;
							i.height = h.height;
						}
						return i;
					},
					setLayoutBox: function (i, m, l, h) {
						var k = this._style.layout.padding.lineBegin,
						j = this._style.layout.padding.top;
						if (b.layoutDir === b.RTL) {
							k = this._style.layout.padding.lineEnd;
						}
						this._layoutBox = {
							x: i + k,
							y: m + j,
							width: l - this._style.layout.padding.lineBegin - this._style.layout.padding.lineEnd,
							height: h - j - this._style.layout.padding.bottom
						};
						if (this._layoutBox.width < 0) {
							this._layoutBox.width = 0;
						}
						if (this._layoutBox.height < 0) {
							this._layoutBox.height = 0;
						}
						if (!this._layoutDirty) {
							if (!this._prevLayoutBox) {
								this._layoutDirty = true;
							} else {
								if (this._prevLayoutBox.width !== this._layoutBox.width || this._prevLayoutBox.height !== this._layoutBox.height) {
									this._layoutDirty = true;
								} else {
									if (this._prevLayoutBox.x !== this._layoutBox.x || this._prevLayoutBox.y !== this._layoutBox.y) {
										this._layoutPosDirty = true;
									}
								}
							}
						}
						this._prevLayoutBox = this._layoutBox;
						this.layout();
					},
					layout: function () {
						if (!this._layingOut) {
							if (this._layoutDirty) {
								this._layingOut = true;
								if (this._style.display) {
									this._safeLayout();
								}
								this._layoutDirty = false;
								this._layoutPosDirty = false;
								this._layingOut = false;
							} else {
								if (this._layoutPosDirty) {
									this._layingOut = true;
									if (this._style.display) {
										this._positionInLayoutBox();
									}
									this._layoutPosDirty = false;
									this._layingOut = false;
								}
							}
						}
					},
					_safeLayout: function () {},
					_positionInLayoutBox: function () {
						var l = this._txf,
						j = this._layoutBox,
						k = this._style.layout,
						o,
						n,
						m,
						p,
						i,
						h;
						if (j) {
							m = k.hAlign;
							i = l.tx;
							h = l.ty;
							p = this._getBoundsImpl(l, b._BoundsType.LAYOUT) || {
								x: i,
								y: h,
								width: 0,
								height: 0
							};
							if (k.xAnchor < 0) {
								o = k.hAlign;
							} else {
								o = k.xAnchor;
							}
							if (b.layoutDir === b.RTL) {
								o = 1 - o;
								m = 1 - m;
							}
							o *= p.width;
							if (k.yAnchor < 0) {
								n = k.vAlign;
							} else {
								n = k.yAnchor;
							}
							n *= p.height;
							this._setTranslation(i - o - p.x + j.x + m * j.width, h - n - p.y + j.y + k.vAlign * j.height);
						}
					},
					invalidateLayout: function () {
						if (this._layingOut !== true && this._layoutDirty !== true) {
							this._layoutDirty = true;
							this._layoutPosDirty = true;
							this._layoutBox = undefined;
							this._prevLayoutBox = undefined;
							if (this._ctrlPts.length > 0) {
								this._clearCtrlPts();
							}
							if (this.parentNode && this.preventParentInvalidateLayout !== true) {
								this.parentNode.invalidateLayout();
							}
						}
					},
					_onLayoutDirChanged: function () {
						this.invalidateLayout();
					}
				},
				eventsDef: [b.MouseEvents, b.KeyEvents, b.DragEvents, b.TouchEvents, b.GenericGestureEvents, b.GestureEvents, b.UIEvents]
			});
			b.addStyleSupport(b.graphics.AbstractGraphicNode, {
				transform: e.Matrix(b.geom.Matrix.IDENTITY, g.TRANSFO_SET),
				clip: e.ArrayOfType({
					type: Number
				}, 4, 4, [0, 0, -1, -1], g.CLIP, true),
				cursor: e.Cursor(b.CursorType.AUTO, g.CURSOR),
				description: e.String("", g.DESC),
				display: e.Boolean(true, g.DISPLAY),
				draggable: e.Boolean(false),
				filter: e.FilterEffect(null, g.FILTER),
				focusable: e.Boolean(false, g.FOCUSABLE),
				focusOutlineOffset: e.Number(2),
				layout: {
					hAlign: e.NumberInRange([0, 1], b.NodeAlign.CENTER, g.LAYOUT),
					vAlign: e.NumberInRange([0, 1], b.NodeAlign.CENTER, g.LAYOUT),
					hWeight: e.FinitePositiveNumber(0, g.LAYOUT),
					vWeight: e.FinitePositiveNumber(0, g.LAYOUT),
					xAnchor: e.FiniteNumber(-1, g.LAYOUT),
					yAnchor: e.FiniteNumber(-1, g.LAYOUT),
					padding: e.Padding(0, 0, 0, 0, g.LAYOUT),
					preferredWidth: e.FiniteNumber(-1, g.PREF_SIZE),
					preferredHeight: e.FiniteNumber(-1, g.PREF_SIZE),
					isLayoutChild: e.Boolean(true, g.LAYOUT)
				},
				pointerSensitivity: e.Boolean(true, g.SENSITIVITY),
				tooltip: e.ObjectOfConstraint([function (h) {
							return b.isA(h, String) || b.isA(h, b.graphics.AbstractGraphicNode);
						}
					], null, true, false),
				visibility: e.Boolean(true, g.VISIBILITY),
				cacheAsBitmap: e.Boolean(false)
			});
		}
			());
		(function () {
			var e = b.scene.AbstractNode.prototype,
			f = b.TAGS;
			b.mixin(b.graphics.AbstractGraphicNode, {
				notifyNativeImpl: function (g, h) {
					if (g === f.TRANSFO) {
						this.svgSetTransfo();
					} else {
						if (g === f.DISPLAY || g === f.VISIBILITY) {
							this.svgSetDisplay();
						} else {
							if (g === f.SENSITIVITY) {
								this.svgSetPointerEvents();
							} else {
								if (g === f.CLIP) {
									this.svgSetClip();
								} else {
									if (g === f.CURSOR) {
										this.svgSetCursor();
									} else {
										if (g === f.FILTER) {
											this.svgSetFilter();
										} else {
											e.notifyNativeImpl.call(this, g, h);
										}
									}
								}
							}
						}
					}
				},
				svgSetDisplay: function () {
					this.svgNode.attr("display", (this._style.display && this._style.visibility) ? "inline" : "none");
				},
				svgSetPointerEvents: function () {
					this.svgNode.attr("pointer-events", this._style.pointerSensitivity ? "visiblePainted" : "none");
				},
				svgSetTransfo: function () {
					var h = this._txf,
					g = ",";
					this.svgNode.attr("transform", ["matrix(", h.a, g, h.b, g, h.c, g, h.d, g, h.tx, g, h.ty, ")"].join(""));
				},
				svgSetClip: function () {
					var n,
					g,
					k = this._clipNode,
					j,
					o,
					h,
					m,
					l = this._style.clip;
					if (l[2] >= 0 && l[3] >= 0) {
						if (!k) {
							g = this._id + "_clip";
							this._clipNode = k = b.tree.svgCreateElt("clipPath", {
								id: g
							});
							n = b.tree.svgCreateElt("rect");
							k.appendChild(n);
							b.tree.svgAddDef(this._clipNode);
							this.svgNode.attr("clip-path", "url(#" + g + ")");
						} else {
							h = k.childNodes;
							m = h.length;
							for (j = 0; j < m; j++) {
								o = h.item(j);
								if (o.nodeName === "rect") {
									n = o;
								}
							}
						}
						if (n) {
							n.attr({
								x: l[0],
								y: l[1],
								width: l[2],
								height: l[3]
							});
						}
					} else {
						if (k) {
							this.svgNode.attr("clip-path", "none");
							k.parentNode.removeChild(k);
						}
					}
				},
				svgSetCursor: function () {
					var g = this._style.cursor;
					this.svgNode.attr("cursor", typeof g === "object" ? "none" : g);
				},
				svgSetFilter: function () {
					if (this._filterFX) {
						this.svgNode.attr("filter", this._filterFX._getShadowFilter());
					} else {
						this.svgNode.rm("filter");
					}
				}
			});
		}
			());
		(function () {
			var f = b.graphics.AbstractGraphicNode.prototype,
			e = b.defs,
			g = b.TAGS;
			b.declare({
				name: "oui.graphics.AbstractShape",
				isAbstract: true,
				extend: b.graphics.AbstractGraphicNode,
				membersDef: {
					onStyleChanged: function (h) {
						if (h === g.PAINT) {
							this.notifyNative(h);
						} else {
							if (h === g.GEOM) {
								this._clearCtrlPts();
								this.invalidateLayout();
								this.notifyNative(h);
							} else {
								f.onStyleChanged.call(this, h);
							}
						}
					},
					_fixBoundsType: function (i) {
						var h = this._style;
						if (i === b._BoundsType.LAYOUT || (i === b._BoundsType.RENDER && (h.stroke === b.NO_PAINT || h.strokeThickness === 0))) {
							i = b._BoundsType.DEFAULT;
						}
						return i;
					},
					getFillBounds: function () {
						return b.geom.computeBounds(this._clipCtrlPts(this._getCtrlPts(b._BoundsType.DEFAULT)));
					},
					_isValidChild: function () {
						return false;
					},
					_safeLayout: function () {
						this._positionInLayoutBox();
					},
					_hitTest: function (i, o, j) {
						var h = null,
						k = this._style,
						n = true,
						m;
						try {
							if (j && j.tolerance && !isNaN(j.tolerance)) {
								this.tolerance = j.tolerance;
							}
						} catch (l) {
							this.tolerance = 0;
						}
						if (k.fill !== b.NO_PAINT) {
							m = this.globalToLocal(i, o);
							if (this.hitTestOnFill(m.x, m.y)) {
								h = this;
							} else {
								n = false;
							}
						}
						if (!h && k.stroke !== b.NO_PAINT && k.strokeThickness > 0) {
							m = m || this.globalToLocal(i, o);
							if (this.hitTestOnStroke(m.x, m.y, n)) {
								h = this;
							}
						}
						return h;
					},
					hitTestOnFill: function (i, h) {
						return false;
					},
					hitTestOnStroke: function (j, i, h) {
						return false;
					}
				},
				styleDef: {
					htmlExportClassName: e.String(""),
					fill: e.Paint(b.black, g.PAINT),
					fillOpacity: e.NumberInRange([0, 1], 1, g.PAINT),
					fixedStrokeWidth: e.Boolean(false, g.PAINT),
					snapToGrid: e.Boolean(true, g.PAINT),
					stroke: e.Paint(b.NO_PAINT, g.PAINT),
					strokeOpacity: e.NumberInRange([0, 1], 1, g.PAINT),
					strokeThickness: e.FinitePositiveNumber(1, g.PAINT),
					strokeLineJoin: e.Enum(b.LineJoin, b.LineJoin.MITER, g.PAINT),
					strokeLineCap: e.Enum(b.LineCap, b.LineCap.BUTT, g.PAINT),
					strokeMiterLimit: e.FinitePositiveNumber(3, g.PAINT),
					strokeDashArray: e.ArrayOfType(e.StrictlyPositiveNumber(1), undefined, undefined, [], g.PAINT)
				}
			});
		}
			());
		(function () {
			var K = b.graphics.AbstractGraphicNode.prototype,
			f = "fill",
			H = "fill-opacity",
			G = "stroke",
			l = "stroke-opacity",
			x = "stroke-width",
			F = "stroke-linecap",
			g = "stroke-linejoin",
			i = "stroke-miterlimit",
			A = "stroke-dasharray",
			r = f + ":",
			q = H + ":",
			v = G + ":",
			D = l + ":",
			h = x + ":",
			s = F + ":",
			u = g + ":",
			z = i + ":",
			C = A + ":",
			e = "shape-rendering:",
			J = "outline-style:",
			y = b.graphics.AbstractShape.prototype.StyleDefinition.prototype,
			m = y.fill.defaultValue,
			E = y.fillOpacity.defaultValue,
			o = y.stroke.defaultValue,
			p = y.strokeOpacity.defaultValue,
			j = y.strokeThickness.defaultValue,
			t = y.strokeLineCap.defaultValue,
			B = y.strokeLineJoin.defaultValue,
			k = y.strokeMiterLimit.defaultValue,
			I = y.strokeDashArray.defaultValue.length === 0 ? "none" : y.strokeDashArray.defaultValue.join(","),
			w = y.snapToGrid.defaultValue ? "crispEdges" : "auto",
			n = "none";
			b.mixin(b.graphics.AbstractShape, {
				svgGetCSS: function (N) {
					var L = this._style,
					U = L.fill,
					V = L.stroke,
					T = L.fillOpacity * L.fill.getOpacity(),
					Q,
					W = L.strokeThickness,
					P = L.strokeLineJoin,
					X = L.strokeLineCap,
					M = L.strokeMiterLimit,
					R = L.strokeDashArray.length === 0 ? "none" : L.strokeDashArray.join(","),
					S = L.snapToGrid ? "crispEdges" : "auto",
					O = [];
					if (U !== m) {
						O.push(r, U.svgGetPaint(N), ";");
					}
					if (T !== E) {
						O.push(q, T, ";");
					}
					if (V !== o) {
						O.push(v, L.stroke.svgGetPaint(N), ";");
						Q = L.strokeOpacity * L.stroke.getOpacity();
						if (Q !== p) {
							O.push(D, Q, ";");
						}
						if (W !== j) {
							O.push(h, W, ";");
						}
						if (P !== B) {
							O.push(u, P, ";");
						}
						if (X !== t) {
							O.push(s, X, ";");
						}
						if (M !== k) {
							O.push(z, M, ";");
						}
						if (R !== I) {
							O.push(C, R, ";");
						}
					}
					if (S !== w) {
						O.push(e, S, ";");
					}
					return O.join("");
				},
				notifyNativeImpl: function (L, M) {
					if (L === b.TAGS.LAYOUT_DIR || L === b.TAGS.GEOM) {
						this.svgSetGeom();
					} else {
						if (L === b.TAGS.PAINT) {
							this.svgNode.attr("style", this.svgGetCSS(this.svgNode));
						} else {
							K.notifyNativeImpl.call(this, L, M);
						}
					}
				}
			});
			b.registerCSS("rect,ellipse,path,line,text", function (L) {
				L.push(r, m.svgGetPaint(b.rootNode), ";", q, E, ";", v, o.svgGetPaint(b.rootNode), ";", D, p, ";", h, j, "px;", u, B, ";", s, t, ";", z, k, ";", C, I, ";", J, n, ";");
			});
		}
			());
		(function () {
			var h = "move",
			k = "close",
			o = "line",
			l = "curve",
			j = "quad",
			q = b.geom.DEG_TO_RAD,
			m = Math.PI / 2,
			s = {
				M: "moveTo",
				L: "lineTo",
				H: "horizontalLineTo",
				V: "verticalLineTo",
				Q: "quadTo",
				T: "smoothQuadTo",
				C: "curveTo",
				S: "smoothCurveTo",
				Z: "closePath",
				A: "arc",
				aM: "arcMoveTo",
				aL: "arcLineTo"
			},
			n,
			i = {},
			f,
			g;
			b.graphics.PathType = {
				MOVE_TO: h,
				CLOSE: k,
				LINE_TO: o,
				CURVE_TO: l,
				QUAD_TO: j
			};
			b.declare({
				name: "oui.graphics.PathCommands",
				mixins: [b.events.EventSupport],
				eventsDef: {
					DATA_UPDATE: "dataUpdate"
				},
				membersDef: {
					init: function (t, p) {
						this._preventEvents = false;
						this.set(t, p);
					},
					_dispatchDataUpdate: function () {
						if (!this._preventEvents) {
							this.dispatchEvent({
								type: this.events.DATA_UPDATE
							});
						}
					},
					set: function (t, p) {
						this._preventEvents = true;
						this.resetPath();
						this._preventEvents = false;
						if (b.isA(t, String)) {
							this._parseString(t, p);
						}
						this._dispatchDataUpdate();
					},
					resetPath: function () {
						this.dataTypes = [];
						this.dataValues = [];
						this.x = 0;
						this.y = 0;
						this.lastMX = 0;
						this.lastMY = 0;
						this.lastQX = 0;
						this.lastQY = 0;
						this.lastCX = 0;
						this.lastCY = 0;
						this._hasCubics = false;
						this._hasQuads = false;
						this._dispatchDataUpdate();
					},
					toString: function (A, D, v) {
						var u = this.dataTypes,
						t = this.dataValues,
						C,
						w = u.length,
						E = [],
						B = 0,
						I = (A === true) ? " " : "",
						H,
						G = "Z",
						x = "M",
						y = "L",
						p = "Q",
						F = "C";
						if (typeof D === "function") {
							H = D;
						} else {
							if (typeof D === "number") {
								H = function (z) {
									return z.toFixed(D);
								};
							} else {
								H = function (z) {
									return z;
								};
							}
						}
						if (v) {
							G = v.CLOSE;
							x = v.MOVE_TO;
							y = v.LINE_TO;
							p = v.QUAD_TO;
							F = v.CURVE_TO;
						}
						for (C = 0; C < w; C++) {
							switch (u[C]) {
							case k:
								B += 2;
								E.push(G, I);
								break;
							case h:
								E.push(x, I, H(t[B++]), ",", H(t[B++]), I);
								break;
							case o:
								E.push(y, I, H(t[B++]), ",", H(t[B++]), I);
								break;
							case j:
								E.push(p, I, H(t[B++]), ",", H(t[B++]), " ", H(t[B++]), ",", H(t[B++]), I);
								break;
							case l:
								E.push(F, I, H(t[B++]), ",", H(t[B++]), " ", H(t[B++]), ",", H(t[B++]), " ", H(t[B++]), ",", H(t[B++]), I);
								break;
							default:
								break;
							}
						}
						return b.trim(E.join(""));
					},
					isPointInPath: function (t, v, u) {
						var p = this._countXings(t, v);
						if (u === b.WindingRuleEnum.NON_ZERO) {
							p = (p !== 0);
						} else {
							p = (p % 2) !== 0;
						}
						return p;
					},
					_isPointOnStrokedPath: function (I, G, F) {
						var E = false,
						H = this.flatten(),
						A = H.dataTypes,
						u = H.dataValues,
						D,
						B = A.length,
						C = 0,
						K = F * F,
						z = b.geom.ptSegDistSq,
						J,
						w,
						t,
						v,
						p;
						for (D = 0; D < B && !E; D++) {
							J = A[D];
							if (J === h) {
								v = u[C++];
								p = u[C++];
								E = (I === v && G === p);
							} else {
								w = u[C++];
								t = u[C++];
								E = z(v, p, w, t, I, G) < K;
								v = w;
								p = t;
							}
						}
						return E;
					},
					_getStrokeCtrlPts: function (V, D) {
						var ai = [],
						H = this.flatten(),
						A = H.dataTypes,
						z = H.dataValues,
						ad,
						ac = A.length,
						K,
						G = 0,
						al,
						ak,
						C,
						B,
						ag,
						af,
						ae,
						v,
						p,
						Z,
						Y,
						aj,
						ab,
						ah,
						aa,
						Q,
						M,
						P,
						L,
						w,
						an,
						t,
						am,
						X,
						T,
						W,
						R,
						O,
						J,
						N,
						I,
						F,
						x,
						E,
						u;
						var y;
						var S;
						var U;
						for (ad = 0; ad < ac; ad++) {
							K = A[ad];
							if (K === h) {
								w = an = t = am = X = T = W = R = O = J = N = I = F = x = E = u = undefined;
								C = ag = z[G++];
								B = af = z[G++];
								if (ad < ac - 1 && D) {
									v = z[G] - C;
									p = z[G + 1] - B;
									y = Math.atan2(p, v);
									S = Math.round(V * Math.sin(y));
									U = Math.round(V * Math.cos(y));
									C -= U;
									B -= S;
								} else {
									U = 0;
									S = 0;
								}
								ai.push(C - U, B - S);
							} else {
								if (K === k) {
									al = ag;
									ak = af;
								} else {
									al = z[G++];
									ak = z[G++];
								}
								v = al - C;
								p = ak - B;
								Z = V;
								if (v !== 0 || p !== 0) {
									if (D) {
										y = Math.atan2(p, v);
										S = Math.round(V * Math.sin(y));
										U = Math.round(V * Math.cos(y));
									} else {
										S = 0;
										U = 0;
									}
									Y = v !== 0 ? p / v : Number.POSITIVE_INFINITY;
									Y = Y > 0 ? 1 : -1;
									Z = Z / Math.sqrt(v * v + p * p);
									v = Y * v * Z;
									p = Y * p * Z;
									aj = C - p - U;
									ab = B + v - S;
									ah = al - p + U;
									aa = ak + v + S;
									Q = al + p + U;
									M = ak - v + S;
									P = C + p - U;
									L = B - v - S;
									ai.push(aj, ab, ah, aa, Q, M, P, L);
									if (w !== undefined) {
										ai.push.apply(ai, b.geom.intersectLine(aj, ab, ah, aa, w, an, t, am));
										ai.push.apply(ai, b.geom.intersectLine(aj, ab, ah, aa, X, T, W, R));
										ai.push.apply(ai, b.geom.intersectLine(Q, M, P, L, w, an, t, am));
										ai.push.apply(ai, b.geom.intersectLine(Q, M, P, L, X, T, W, R));
									}
									w = aj;
									an = ab;
									t = ah;
									am = aa;
									X = Q;
									T = M;
									W = P;
									R = L;
								}
								if (K === k && O !== undefined) {
									ai.push.apply(ai, b.geom.intersectLine(w, an, t, am, O, J, N, I));
									ai.push.apply(ai, b.geom.intersectLine(w, an, t, am, F, x, E, u));
									ai.push.apply(ai, b.geom.intersectLine(X, T, W, R, O, J, N, I));
									ai.push.apply(ai, b.geom.intersectLine(X, T, W, R, F, x, E, u));
								}
								C = al;
								B = ak;
								if (ae === h) {
									O = aj;
									J = ab;
									N = ah;
									I = aa;
									F = Q;
									x = M;
									E = P;
									u = L;
								}
							}
							ae = K;
						}
						return ai;
					},
					flatten: function (x, t) {
						var C,
						u,
						p,
						B,
						v,
						z,
						w,
						y,
						A;
						if (this._hasCubics || this._hasQuads) {
							C = new b.graphics.PathCommands();
							if (typeof x !== "number") {
								x = 5;
							}
							u = this.dataTypes;
							p = this.dataValues;
							v = u.length;
							for (B = 0, y = 0, A = []; B < v; B++) {
								switch (u[B]) {
								case k:
									y += 2;
									C.closePath();
									break;
								case h:
									C._M(p[y++], p[y++]);
									break;
								case o:
									C._L(p[y++], p[y++]);
									break;
								case j:
									b.geom.flattenQuad(p[y - 2], p[y - 1], p[y++], p[y++], p[y++], p[y++], A, x, t);
									z = 0;
									w = A.length;
									while (z < w) {
										C._L(A[z++], A[z++]);
									}
									A.length = 0;
									break;
								case l:
									b.geom.flattenCubic(p[y - 2], p[y - 1], p[y++], p[y++], p[y++], p[y++], p[y++], p[y++], A, x, t);
									z = 0;
									w = A.length;
									while (z < w) {
										C._L(A[z++], A[z++]);
									}
									A.length = 0;
									break;
								default:
									break;
								}
							}
						} else {
							C = this;
						}
						return C;
					},
					snap: function (D, v, E) {
						var w = this.dataTypes,
						t = this.dataValues,
						I,
						H,
						u,
						p,
						G,
						F,
						C,
						J,
						B,
						A,
						z = w.length;
						if (typeof E !== "number") {
							E = 0;
						}
						if (v) {
							C = v.inv();
						}
						for (B = 0, A = 0; B < z; B++) {
							switch (w[B]) {
							case h:
							case k:
								u = t[A++];
								p = t[A++];
								break;
							case o:
								I = G = t[A++];
								H = F = t[A++];
								if (v) {
									J = v.transform(u, p);
									u = J.x;
									p = J.y;
									J = v.transform(I, H);
									I = J.x;
									H = J.y;
								}
								if (Math.abs(I - u) <= E) {
									if (D === true) {
										u = Math.floor(u) + 0.5;
									} else {
										if (Math.floor(u) !== u) {
											u = Math.round(u);
										}
									}
									if (C) {
										t[A - 4] = C.a * u + C.c * p + C.tx;
										t[A - 2] = C.a * u + C.c * H + C.tx;
									} else {
										t[A - 4] = t[A - 2] = u;
									}
								}
								if (Math.abs(H - p) <= E) {
									if (D === true) {
										p = Math.floor(p) + 0.5;
									} else {
										if (Math.floor(p) !== p) {
											p = Math.round(p);
										}
									}
									if (C) {
										t[A - 3] = C.b * u + C.d * p + C.ty;
										t[A - 1] = C.b * I + C.d * p + C.ty;
									} else {
										t[A - 3] = t[A - 1] = p;
									}
								}
								u = G;
								p = F;
								break;
							case j:
								A += 2;
								u = t[A++];
								p = t[A++];
								break;
							case l:
								A += 4;
								u = t[A++];
								p = t[A++];
								break;
							default:
								break;
							}
						}
						this._dispatchDataUpdate();
					},
					cubicify: function () {
						var v = this.dataTypes,
						t = this.dataValues,
						p,
						w = 0,
						x = v.length,
						u;
						if (this._hasQuads) {
							for (p = 0; p < x; p++) {
								switch (v[p]) {
								case h:
								case k:
								case o:
									w += 2;
									break;
								case j:
									u = b.geom.quad2Cubic(t[w - 2], t[w - 1], t[w], t[w + 1], t[w + 2], t[w + 3]);
									v[p] = l;
									t.splice(w, 2, u[0], u[1], u[2], u[3]);
									w += 6;
									break;
								case l:
									w += 6;
									break;
								}
							}
							this._hasQuads = false;
							this._dispatchDataUpdate();
						}
					},
					closePath: function () {
						this.dataTypes.push(k);
						this.dataValues.push(this.lastMX, this.lastMY);
						this.x = this.lastMX;
						this.y = this.lastMY;
						this._dispatchDataUpdate();
						return this;
					},
					_safeMoveTo: function (p, u, t) {
						if (t === true) {
							p += this.x;
							u += this.y;
						}
						this.dataTypes.push(h);
						this.dataValues.push(p, u);
						this.x = p;
						this.y = u;
						this.lastMX = p;
						this.lastMY = u;
						this.lastQX = p;
						this.lastQY = u;
						this.lastCX = p;
						this.lastCY = u;
						return this;
					},
					_safeLineTo: function (p, u, t) {
						if (t === true) {
							p += this.x;
							u += this.y;
						}
						this.dataTypes.push(o);
						this.dataValues.push(p, u);
						this.x = p;
						this.y = u;
						this.lastQX = p;
						this.lastQY = u;
						this.lastCX = p;
						this.lastCY = u;
						return this;
					},
					_safeHorizontalLineTo: function (p, t) {
						if (t === true) {
							p += this.x;
						}
						return this._safeLineTo(p, this.y, false);
					},
					_safeVerticalLineTo: function (t, p) {
						if (p === true) {
							t += this.y;
						}
						return this._safeLineTo(this.x, t, false);
					},
					_safeQuadTo: function (t, v, p, u, w) {
						if (w === true) {
							t += this.x;
							v += this.y;
							p += this.x;
							u += this.y;
						}
						this.dataTypes.push(j);
						this.dataValues.push(t, v, p, u);
						this.x = p;
						this.y = u;
						this.lastQX = t;
						this.lastQY = v;
						this.lastCX = p;
						this.lastCY = u;
						this._hasQuads = true;
						return this;
					},
					_safeSmoothQuadTo: function (p, u, w) {
						var t,
						v;
						if (w === true) {
							p += this.x;
							u += this.y;
						}
						t = 2 * this.x - this.lastQX;
						v = 2 * this.y - this.lastQY;
						return this._safeQuadTo(t, v, p, u, false);
					},
					_safeCurveTo: function (v, x, t, w, p, u, y) {
						if (y === true) {
							v += this.x;
							x += this.y;
							t += this.x;
							w += this.y;
							p += this.x;
							u += this.y;
						}
						this.dataTypes.push(l);
						this.dataValues.push(v, x, t, w, p, u);
						this.x = p;
						this.y = u;
						this.lastQX = p;
						this.lastQY = u;
						this.lastCX = t;
						this.lastCY = w;
						this._hasCubics = true;
						return this;
					},
					_safeSmoothCurveTo: function (t, w, p, v, y) {
						var u,
						x;
						if (y === true) {
							t += this.x;
							w += this.y;
							p += this.x;
							v += this.y;
						}
						u = 2 * this.x - this.lastCX;
						x = 2 * this.y - this.lastCY;
						return this._safeCurveTo(u, x, t, w, p, v, false);
					},
					_safeArc: function (t, y, u, p, x, w, v) {
						if (v === true) {
							t += this.x;
							y += this.y;
						}
						u = u * q;
						p = p * q;
						this._arcImpl(t, y, u, p, x, w);
						return this;
					},
					_arcImpl: function (x, w, v, t, u, p) {
						var A,
						z = 0.523598775598,
						y = 0.506145483078356;
						if (t > v) {
							while (t - v > z) {
								A = v + y;
								this._smallArcACW(x, w, v, A, u, p);
								v = A;
							}
							this._smallArcACW(x, w, v, t, u, p);
						} else {
							if (v > t) {
								while (v - t > z) {
									A = v - y;
									this._smallArcCW(x, w, v, A, u, p);
									v = A;
								}
								this._smallArcCW(x, w, v, t, u, p);
							}
						}
					},
					_smallArcACW: function (z, y, x, u, w, t) {
						var B = w * Math.cos(u),
						A = t * Math.sin(u),
						C = Math.tan((u - x) / 2),
						D = u - m,
						v = B + w * C * Math.cos(D),
						p = A + t * C * Math.sin(D);
						this._safeQuadTo(v + z, p + y, B + z, A + y);
					},
					_smallArcCW: function (B, A, z, w, y, v) {
						var D = y * Math.cos(w),
						C = v * Math.sin(w),
						u = y * Math.cos(z),
						p = v * Math.sin(z),
						E = Math.tan((z - w) / 2),
						F = (z - m),
						x = u + y * E * Math.cos(F),
						t = p + v * E * Math.sin(F);
						this._safeQuadTo(x + B, t + A, D + B, C + A);
					},
					_safeArcMoveTo: function (p, y, x, w, v, u) {
						var t = x * q;
						return this._safeMoveTo(p + w * Math.cos(t), y + v * Math.sin(t), u);
					},
					_safeArcLineTo: function (p, y, x, w, v, u) {
						var t = x * q;
						return this._safeLineTo(p + w * Math.cos(t), y + v * Math.sin(t), u);
					},
					_countXings: function (G, F) {
						var E = b.geom,
						v = this.dataTypes,
						t = this.dataValues,
						w = v.length,
						A,
						B = 0,
						u = 0,
						p = 0,
						I = 0,
						H = 0,
						z = 0,
						D = false,
						C;
						for (C = 0; C < w; C++) {
							A = v[C];
							switch (A) {
							case h:
								if (C > 0 && v[C - 1] !== k) {
									z += E.crossLine(u, p, I, H, G, F);
								}
								I = u = t[B++];
								H = p = t[B++];
								break;
							case k:
							case o:
								z += E.crossLine(u, p, t[B++], t[B++], G, F);
								u = t[B - 2];
								p = t[B - 1];
								break;
							case j:
								z += E.crossQuad(u, p, t[B++], t[B++], t[B++], t[B++], G, F);
								u = t[B - 2];
								p = t[B - 1];
								break;
							case l:
								z += E.crossCubic(u, p, t[B++], t[B++], t[B++], t[B++], t[B++], t[B++], G, F);
								u = t[B - 2];
								p = t[B - 1];
								break;
							}
							if (u === G && p === F) {
								z = 0;
								D = true;
								break;
							}
						}
						if (!D && A !== k) {
							z += E.crossLine(u, p, I, H, G, F);
						}
						return z;
					},
					_parseString: function (u, v) {
						var t = 0,
						y,
						x,
						z,
						w,
						p = Number;
						y = u.replace(/^\s+|\s+$/g, "").replace(/([mlhvcsqtz])/gi, ",$1,").replace(/\s+/g, ",").replace(/,{2,}/g, ",").replace(/^,|,$/g, "").split(",");
						x = y.length;
						if (v === true) {
							p = function (B) {
								var A = Number(B);
								if (isNaN(A)) {
									c.error("ERR__PATH__MALFORMED_DATA", y.slice(0, t).join(" "));
								}
								return A;
							};
						}
						while (t < x) {
							z = y[t++];
							w = false;
							switch (z) {
							case "m":
								w = true;
							case "M":
								this._safeMoveTo(p(y[t++]), p(y[t++]), w);
								while (!isNaN(Number(y[t])) && t < x) {
									this._safeLineTo(p(y[t++]), p(y[t++]), w);
								}
								break;
							case "l":
								w = true;
							case "L":
								do {
									this._safeLineTo(p(y[t++]), p(y[t++]), w);
								} while (!isNaN(Number(y[t])) && t < x);
								break;
							case "h":
								w = true;
							case "H":
								do {
									this._safeHorizontalLineTo(p(y[t++]), w);
								} while (!isNaN(Number(y[t])) && t < x);
								break;
							case "v":
								w = true;
							case "V":
								do {
									this._safeVerticalLineTo(p(y[t++]), w);
								} while (!isNaN(Number(y[t])) && t < x);
								break;
							case "q":
								w = true;
							case "Q":
								do {
									this._safeQuadTo(p(y[t++]), p(y[t++]), p(y[t++]), p(y[t++]), w);
								} while (!isNaN(Number(y[t])) && t < x);
								break;
							case "t":
								w = true;
							case "T":
								do {
									this._safeSmoothQuadTo(p(y[t++]), p(y[t++]), w);
								} while (!isNaN(Number(y[t])) && t < x);
								break;
							case "c":
								w = true;
							case "C":
								do {
									this._safeCurveTo(p(y[t++]), p(y[t++]), p(y[t++]), p(y[t++]), p(y[t++]), p(y[t++]), w);
								} while (!isNaN(Number(y[t])) && t < x);
								break;
							case "s":
								w = true;
							case "S":
								do {
									this._safeSmoothCurveTo(p(y[t++]), p(y[t++]), p(y[t++]), p(y[t++]), w);
								} while (!isNaN(Number(y[t])) && t < x);
								break;
							case "a":
								w = true;
							case "A":
								if (v === true) {
									c.error("ERR__PATH__NO_ARCTO");
								}
								break;
							case "z":
							case "Z":
								this.closePath();
								break;
							default:
								if (v === true) {
									c.error("ERR__PATH__UNKNOWN_CMD", [z, t]);
								}
							}
						}
					}
				}
			});
			function e(t) {
				var p = t.length - 1;
				return function () {
					var v = p - 1,
					u = true;
					do {
						u = b.isFiniteNumber(arguments[v]);
					} while (v-- && u);
					if (u) {
						t.apply(this, arguments);
						this._dispatchDataUpdate();
					}
					return this;
				};
			}
			n = b.graphics.PathCommands.prototype;
			for (g in n) {
				if (n.hasOwnProperty(g) && g.indexOf("_safe") === 0) {
					i[g.charAt(5).toLowerCase() + g.substr(6)] = e(n[g]);
				}
			}
			b.mixin(b.graphics.PathCommands, i);
			function r(t, p) {
				return function () {
					var u = [];
					u.push.apply(u, arguments);
					u[t.length - 1] = p;
					return t.apply(this, u);
				};
			}
			for (g in s) {
				if (s.hasOwnProperty(g)) {
					i = s[g];
					f = n[i];
					n[g] = r(f, false);
					n[g.toLowerCase()] = r(f, true);
					g = "_" + g;
					i = "_safe" + i.charAt(0).toUpperCase() + i.substr(1);
					f = n[i] || f;
					n[g] = r(f, false);
					n[g.toLowerCase()] = r(f, true);
				}
			}
		}
			());
		(function () {
			var e = b.graphics.AbstractShape.prototype;
			b.declare({
				name: "oui.graphics.AbstractPath",
				isAbstract: true,
				extend: b.graphics.AbstractShape,
				membersDef: {
					init: function (f, g) {
						this._flattenedPathCache = null;
						e.init.call(this, f, g);
					},
					onStyleChanged: function (f) {
						if (f === b.TAGS.GEOM) {
							this._flattenedPathCache = null;
						}
						e.onStyleChanged.call(this, f);
					},
					_computeCtrlPts: function (i) {
						var h = this.getFlattenedPathCommands(),
						g = [];
						if (h) {
							var f = false;
							if (this._style && this._style.strokeLineCap && (this._style.strokeLineCap === b.LineCap.ROUND || this._style.strokeLineCap === b.LineCap.SQUARE)) {
								f = true;
							}
							g = b.geom.computeConvexHull(i ? h._getStrokeCtrlPts(this._style.strokeThickness / 2, f) : h.dataValues);
						}
						return g;
					},
					hitTestOnFill: function (h, g) {
						var f = false,
						i = this.getFlattenedPathCommands();
						if (i && this._isWithinBounds(h, g)) {
							f = i.isPointInPath(h, g, this.getWindingRule());
						}
						return f;
					},
					hitTestOnStroke: function (i, h, g) {
						var f = false,
						k = this._style.strokeThickness / 2,
						j = this.getFlattenedPathCommands();
						if (this.tolerance) {
							k = Math.max(k, this.tolerance);
						}
						if (j && this._isWithinBounds(i, h, k)) {
							f = j._isPointOnStrokedPath(i, h, k);
						}
						return f;
					},
					getPathCommands: function () {
						c.warn("WARN__PATH__NO_OVERRIDE");
						return null;
					},
					getFlattenedPathCommands: function () {
						var f;
						if (!this._flattenedPathCache) {
							f = this.getPathCommands();
							if (f) {
								this._flattenedPathCache = f.flatten(10);
							}
						}
						return this._flattenedPathCache;
					},
					getWindingRule: function () {
						return b.WindingRuleEnum.EVEN_ODD;
					}
				}
			});
		}
			());
		(function () {
			var f = {},
			g = "fill-rule",
			e = g + ":";
			f[b.WindingRuleEnum.NON_ZERO] = "nonzero";
			f[b.WindingRuleEnum.EVEN_ODD] = "evenodd";
			b.mixin(b.graphics.AbstractPath, {
				SVG_TAG: "path",
				svgSetGeom: function () {
					var i = this.svgNode,
					h = this.getPathCommands();
					i.attr(g, f[this.getWindingRule()]);
					i.attr("d", h ? h.toString() : "");
				}
			});
			b.registerCSS("svg", function (h) {
				h.push(e, "evenodd", ";");
			});
		}
			());
		(function () {
			var h = b.graphics.AbstractPath.prototype,
			e = b.defs,
			i = b.TAGS,
			g = {
				markerStart: 0,
				markerEnd: 1,
				markerMid: 2
			},
			f = "pathData";
			b.declare({
				name: "oui.graphics.Path",
				extend: b.graphics.AbstractPath,
				jsonDef: {
					type: "path"
				},
				membersDef: {
					init: function (j, k) {
						var l = this;
						this._markers = [];
						this._initImpl();
						this._oldPC = null;
						this._dataUpdateHandler = function () {
							l._updateMarkerTxf("markerStart", g.markerStart);
							l._updateMarkerTxf("markerEnd", g.markerEnd);
							l.onStyleChanged(b.TAGS.GEOM);
						};
						h.init.call(this, j, k);
					},
					_initImpl: function () {},
					_computeCtrlPts: function (m) {
						var k = h._computeCtrlPts.call(this, m),
						o = this._markers,
						j,
						l,
						p = 0;
						if (k.length > 0) {
							for (l = 0, p = o.length; l < p; l++) {
								j = o[l];
								if (j) {
									k.push.apply(k, j._transformCtrlPts(j._txf, m));
								}
							}
						}
						return p > 0 ? b.geom.computeConvexHull(k) : k;
					},
					onStyleChanged: function (k) {
						var p = this._style,
						m = p.pathCommands,
						l,
						q = this._markers,
						o,
						r,
						j;
						if (k === f) {
							l = this._oldPC;
							if (l) {
								l.offDataUpdate(this._dataUpdateHandler);
							}
							if (m) {
								m.onDataUpdate(this._dataUpdateHandler);
							}
							this._oldPC = m;
							this._updateMarker("markerStart", g.markerStart);
							this._updateMarker("markerEnd", g.markerEnd);
							h.onStyleChanged.call(this, i.GEOM);
						} else {
							if (k === i.PAINT) {
								for (o = 0, r = q.length; o < r; o++) {
									if (q[o]) {
										q[o].applyStyle({
											fill: p.stroke,
											fillOpacity: p.strokeOpacity
										});
									}
								}
								h.onStyleChanged.call(this, k);
							} else {
								if (k === i.MARKER_START_DATA || k === i.MARKER_END_DATA) {
									j = k.substring(0, k.length - 4);
									this._updateMarker(j, g[j]);
									this.notifyNative(k);
								} else {
									if (k === i.MARKER_START || k === i.MARKER_END) {
										this._updateMarkerTxf(k, g[k]);
										this.notifyNative(k);
									} else {
										if (k === i.MARKER_START_PAINT || k === i.MARKER_END_PAINT) {
											j = k.substring(0, k.length - 5);
											this._updateMarkerPaint(j, g[j]);
											this.notifyNative(k);
										} else {
											h.onStyleChanged.call(this, k);
										}
									}
								}
							}
						}
					},
					_updateMarker: function (k, j) {
						var n = this._style,
						m = n[k],
						l = this._markers[j];
						if (m.d.length === 0) {
							this._markers[j] = undefined;
						} else {
							if (!l) {
								this._markers[j] = new b.graphics.Path({
									pathCommands: m.d
								});
							} else {
								l.applyStyle({
									pathCommands: m.d
								});
							}
							this._updateMarkerPaint(k, j);
							this._updateMarkerTxf(k, j);
						}
					},
					_updateMarkerTxf: function (o, w) {
						var k = this._style[o],
						m = this._markers[w],
						t = this._style.pathCommands,
						j,
						l,
						v,
						r,
						q = 0,
						p = 0,
						z = k.strokeUnits ? this._style.strokeThickness : 1,
						u = k.orient;
						if (m && t && t.dataValues.length >= 2) {
							j = t.dataValues;
							l = j.length;
							if (w === g.markerStart) {
								v = j[0];
								r = j[1];
								if (l >= 4) {
									q = j[2] - v;
									p = j[3] - r;
								}
							} else {
								if (w === g.markerEnd) {
									v = j[l - 2];
									r = j[l - 1];
									if (l >= 4) {
										q = v - j[l - 4];
										p = r - j[l - 3];
									}
								}
							}
							if (u === b.AUTO) {
								u = Math.atan2(p, q);
							} else {
								u *= b.geom.DEG_TO_RAD;
							}
							m.setTransform(new b.geom.Matrix().translate(v, r).rotate(u).scale(z * k.width, z * k.height).translate(-k.refX, -k.refY));
						}
						this._clearCtrlPts();
					},
					_updateMarkerPaint: function (k, j) {
						var m = this._style,
						n = {
							fill: m.stroke,
							fillOpacity: m.strokeOpacity,
							stroke: b.NO_PAINT
						},
						l = this._markers[j];
						if (l) {
							b.merge(n, m[k].paint, true);
							l.applyStyle(n);
						}
					}
				},
				styleDef: {
					pathCommands: e.PathData(null, f),
					windingRule: e.Enum(b.WindingRuleEnum, b.WindingRuleEnum.EVEN_ODD, i.GEOM),
					markerStart: e.Marker("", 0, 0, 1, 1, b.AUTO, true, {}, i.MARKER_START, i.MARKER_START_DATA, i.MARKER_START_PAINT),
					markerEnd: e.Marker("", 0, 0, 1, 1, b.AUTO, true, {}, i.MARKER_END, i.MARKER_END_DATA, i.MARKER_END_PAINT)
				}
			});
		}
			());
		(function () {
			var f = b.graphics.AbstractPath.prototype,
			g = b.TAGS,
			e = {
				markerStart: 0,
				markerEnd: 1,
				markerMid: 2
			},
			h = {
				markerStart: "marker-start",
				markerEnd: "marker-end",
				markerMid: "marker-mid"
			};
			b.mixin(b.graphics.Path, {
				_initImpl: function () {
					this.svgMarkers = [];
				},
				notifyNativeImpl: function (j, k) {
					var i;
					if (j === g.MARKER_START_DATA || j === g.MARKER_END_DATA) {
						i = j.substring(0, j.length - 4);
						this.svgUpdateMarkerData(i, e[i]);
					} else {
						if (j === g.MARKER_START || j === g.MARKER_END) {
							this.svgUpdateMarkerProps(j, e[j]);
						} else {
							if (j === g.MARKER_START_PAINT || j === g.MARKER_END_PAINT) {
								i = j.substring(0, j.length - 5);
								this.svgUpdateMarkerPaint(i, e[i]);
							} else {
								if (j === g.GEOM) {
									this.svgUpdateMarkerData("markerStart", e.markerStart);
									this.svgUpdateMarkerData("markerEnd", e.markerEnd);
								} else {
									if (j === g.PAINT) {
										this.svgUpdateMarkerPaint("markerStart", e.markerStart);
										this.svgUpdateMarkerPaint("markerEnd", e.markerEnd);
									}
								}
								f.notifyNativeImpl.call(this, j, k);
							}
						}
					}
				},
				svgUpdateMarkerData: function (m, p) {
					var l = this._markers[p],
					i,
					q,
					o = h[m],
					j = this.svgMarkers[p],
					k = this.svgNode,
					n;
					if (l) {
						i = this._style[m];
						if (!j) {
							n = this._id + "_" + m;
							j = b.tree.svgCreateElt("marker", {
								id: n
							});
							j.appendChild(b.tree.svgCreateElt("path"));
							b.tree.svgAddDef(j);
							k.attr(o, "url(#" + n + ")");
							this.svgMarkers[p] = j;
							this.svgUpdateMarkerPaint(m, p);
							this.svgUpdateMarkerProps(m, p);
						}
						q = l.getLocalBounds();
						j.attr({
							markerWidth: q.width * i.width,
							markerHeight: q.height * i.height,
							viewBox: q.x + " " + q.y + " " + q.width + " " + q.height
						});
						j.firstChild.attr("d", l._style.pathCommands.toString());
					} else {
						if (j) {
							k.attr(o, "none");
							j.parentNode.removeChild(j);
							this.svgMarkers[p] = undefined;
						}
					}
				},
				svgUpdateMarkerProps: function (j, i) {
					var l = this._markers[i],
					n = this._style[j],
					k,
					p = n.strokeUnits,
					m = n.orient,
					o = this.svgMarkers[i];
					if (o) {
						k = l.getLocalBounds();
						o.attr({
							refX: n.refX,
							refY: n.refY,
							markerWidth: k.width * n.width,
							markerHeight: k.height * n.height,
							markerUnits: p ? "strokeWidth" : "userSpaceOnUse",
							orient: m === b.AUTO ? "auto" : m
						});
					}
				},
				svgUpdateMarkerPaint: function (j, i) {
					var k = this.svgMarkers[i];
					if (k) {
						k.firstChild.attr("style", this._markers[i].svgGetCSS(this.svgNode));
					}
				}
			});
		}
			());
		(function () {
			var g = b.graphics.AbstractPath.prototype,
			e = b.defs,
			h = b.TAGS.GEOM,
			f;
			f = function (j, i) {
				if (j > i) {
					j = i;
				}
				return j;
			};
			b.declare({
				name: "oui.graphics.HalfRoundedRectangle",
				extend: b.graphics.AbstractPath,
				jsonDef: {
					type: "hrrect"
				},
				membersDef: {
					init: function (i, j) {
						this._d = new b.graphics.PathCommands();
						g.init.call(this, i, j);
					},
					onStyleChanged: function (i) {
						if (i === h) {
							this._updatePath();
						}
						g.onStyleChanged.call(this, i);
					},
					getPathCommands: function () {
						return this._d;
					},
					_onLayoutDirChanged: function () {
						this._updatePath();
						g._onLayoutDirChanged.call(this);
					},
					_updatePath: function () {
						var p = this._style,
						s = p.x,
						q = p.y,
						t = p.width,
						B = p.height,
						o = p.rx,
						m = p.ry,
						z = p.rounded,
						D = this._d,
						C = (b.layoutDir === b.LTR),
						n = !C,
						l = (C && z.topLineBegin) || (n && z.topLineEnd),
						i = (C && z.topLineEnd) || (n && z.topLineBegin),
						j = (C && z.bottomLineBegin) || (n && z.bottomLineEnd),
						E = (C && z.bottomLineEnd) || (n && z.bottomLineBegin),
						k = f(o, (l && i) ? t / 2 : t),
						A = f(m, (l && j) ? B / 2 : B),
						v = f(o, (j && E) ? t / 2 : t),
						u = f(m, (i && E) ? B / 2 : B);
						D.resetPath();
						if (l) {
							D._M(s, q + A)._Q(s, q, s + k, q);
						} else {
							D._M(s, q);
						}
						if (i) {
							D._L(s + t - k, q)._Q(s + t, q, s + t, q + u);
						} else {
							D._L(s + t, q);
						}
						if (E) {
							D._L(s + t, q + B - u)._Q(s + t, q + B, s + t - v, q + B);
						} else {
							D._L(s + t, q + B);
						}
						if (j) {
							D._L(s + v, q + B)._Q(s, q + B, s, q + B - A);
						} else {
							D._L(s, q + B);
						}
						D._Z();
					},
					hitTestOnFill: function (i, M) {
						var I = this._style,
						z = i,
						v = M,
						B = I.width,
						H = I.height,
						t = I.rx,
						q = I.ry,
						p = I.x,
						E = I.y,
						u = E + H,
						K = p + B,
						A = false,
						F,
						J,
						s,
						o,
						k,
						j,
						L,
						m,
						G,
						D,
						C,
						n,
						l;
						if (z >= p && z <= K && v >= E && v <= u) {
							F = I.rounded;
							J = (b.layoutDir === b.LTR);
							s = !J;
							o = (J && F.topLineBegin) || (s && F.topLineEnd);
							k = (J && F.topLineEnd) || (s && F.topLineBegin);
							j = (J && F.bottomLineBegin) || (s && F.bottomLineEnd);
							L = (J && F.bottomLineEnd) || (s && F.bottomLineBegin);
							m = f(t, (o && k) ? B / 2 : B);
							G = f(q, (o && j) ? H / 2 : H);
							D = f(t, (j && L) ? B / 2 : B);
							C = f(q, (k && L) ? H / 2 : H);
							if (o && (z < p + m) && (v < E + G)) {
								n = p + m;
								l = E + G;
								t = m;
								q = G;
							} else {
								if (k && (z > K - m) && (v < E + C)) {
									n = K - m;
									l = E + C;
									t = m;
									q = C;
								} else {
									if (L && (z > K - D) && (v > u - C)) {
										n = K - D;
										l = u - C;
										t = D;
										q = C;
									} else {
										if (j && (z < p + D) && (v > u - G)) {
											n = p + D;
											l = u - G;
											t = D;
											q = G;
										}
									}
								}
							}
							if (n !== undefined && l !== undefined) {
								z = (i - n) / t;
								v = (M - l) / q;
								A = ((z * z + v * v) <= 1);
							} else {
								A = true;
							}
						}
						return A;
					}
				},
				styleDef: {
					x: e.FiniteNumber(0, h),
					y: e.FiniteNumber(0, h),
					width: e.PositiveNumber(0, h),
					height: e.PositiveNumber(0, h),
					rx: e.PositiveNumber(10, h),
					ry: e.PositiveNumber(10, h),
					rounded: {
						topLineBegin: e.Boolean(true, h),
						topLineEnd: e.Boolean(true, h),
						bottomLineBegin: e.Boolean(false, h),
						bottomLineEnd: e.Boolean(false, h)
					}
				}
			});
		}
			());
		(function () {
			var h = b.graphics.AbstractPath.prototype,
			e = b.defs,
			i = b.TAGS.GEOM,
			f = b.geom.DEG_TO_RAD;
			function g(j) {
				if (j < 0) {
					j = 360 + j;
				}
				return j;
			}
			b.declare({
				name: "oui.graphics.DiskSector",
				extend: b.graphics.AbstractPath,
				jsonDef: {
					type: "diskSector"
				},
				membersDef: {
					init: function (j, k) {
						this._d = new b.graphics.PathCommands();
						h.init.call(this, j, k);
					},
					onStyleChanged: function (j) {
						if (j === i) {
							this._updatePath();
						}
						h.onStyleChanged.call(this, j);
					},
					getPathCommands: function () {
						return this._d;
					},
					_updatePath: function () {
						var k = this._style,
						o = this._d,
						j = k.cx,
						q = k.cy,
						n = k.minAngle,
						p = k.maxAngle,
						m = k.minRadius,
						l = k.maxRadius;
						o.resetPath();
						o._aM(j, q, n, l, l);
						o._A(j, q, n, p, l, l);
						if ((p - n) < 360) {
							o._aL(j, q, p, m, m);
							if (m > 0) {
								o._A(j, q, p, n, m, m);
							}
						} else {
							if (m > 0) {
								o._Z();
								o._aM(j, q, p, m, m);
								o._A(j, q, p, n, m, m);
							}
						}
						o._Z();
					},
					hitTestOnFill: function (o, n) {
						var k = this._style,
						s = false,
						r = o - k.cx,
						q = n - k.cy,
						p = Math.sqrt(r * r + q * q),
						l,
						j,
						m;
						if (p >= k.minRadius && p <= k.maxRadius) {
							l = k.minAngle;
							j = k.maxAngle;
							if (Math.abs(j - l) === 360) {
								s = true;
							} else {
								m = Math.atan2(q, r) * 180 / Math.PI;
								m = (m + 360) % 360;
								if (l > j) {
									l = j;
									j = k.minAngle;
								}
								if (l < 0 && j >= 0) {
									l = (l + 360) % 360;
									s = (m <= 360 && m >= l) || m <= j;
								} else {
									if (l < 0 && j < 0) {
										l = (l + 360) % 360;
										j = (j + 360) % 360;
										s = m >= l && m <= j;
									} else {
										l = (l + 360) % 360;
										j = (j + 360) % 360;
										s = m >= l && m <= j;
									}
								}
							}
						}
						return s;
					},
					getInsideGeomPath: function (M) {
						var N = this._style,
						V = new b.graphics.PathCommands(),
						H = M / 2,
						I = N.minAngle,
						O = N.maxAngle,
						n = N.minRadius,
						C = N.maxRadius,
						q,
						Z,
						l,
						w,
						u,
						v,
						B,
						T,
						k,
						K,
						Q,
						P,
						A,
						r,
						J,
						D,
						j,
						m,
						z,
						E,
						W,
						U,
						S,
						R,
						p,
						o,
						Y,
						X,
						G,
						F,
						L,
						y,
						x;
						if (n > C) {
							n = C;
							C = N.minRadius;
						}
						if (I > O) {
							I = N.maxAngle;
							O = N.minAngle;
						}
						q = f * (O - I);
						Z = Math.cos(q / 2);
						l = Math.sin(q);
						w = N.cx;
						u = N.cy;
						v = Math.sin(f * I);
						B = Math.cos(f * I);
						T = Math.sin(f * O);
						k = Math.cos(f * O);
						K = 0;
						if (l !== 0) {
							K = M * Z / l;
						}
						Q = f * (I + (O - I) / 2);
						P = w + K * Math.cos(Q);
						A = u + K * Math.sin(Q);
						r = n - K * Z + H;
						J = r + C - n - M;
						D = (J + r) / 2;
						C -= H;
						n += H;
						if (r < J) {
							R = {
								x: P + r * B,
								y: A + r * v
							};
							S = {
								x: P + J * B,
								y: A + J * v
							};
							U = {
								x: P + J * k,
								y: A + J * T
							};
							W = {
								x: P + r * k,
								y: A + r * T
							};
							j = g(Math.atan2(R.y - u, R.x - w) / f);
							m = g(Math.atan2(W.y - u, W.x - w) / f);
							z = g(Math.atan2(S.y - u, S.x - w) / f);
							E = g(Math.atan2(U.y - u, U.x - w) / f);
							if (j > m) {
								m += 360;
							}
							if (z > E) {
								E += 360;
							}
							if ((E - j) < q / f) {
								if ((m - j) > q / f) {
									p = (U.x - W.x);
									o = (U.y - W.y);
									Y = (R.x - S.x);
									X = (R.y - S.y);
									G = (W.x - S.x);
									F = (W.y - S.y);
									L = (p * F - o * G) / (p * X - o * Y);
									y = S.x + L * Y;
									x = S.y + L * X;
									V._M(S.x, S.y)._L(y, x)._L(U.x, U.y);
									V._A(w, u, E, z, C, C);
									V._Z();
								} else {
									if (O - I < 360) {
										V._aM(P, A, O, D, D);
										V._aL(P, A, O, J, J);
										V._A(w, u, E, z, C, C);
										V._aL(P, A, I, r, r);
										if (n > H) {
											V._A(w, u, j, m, n, n);
										}
										V._aL(P, A, O, D, D);
										V._Z();
									} else {
										V._aM(w, u, 0, C, C);
										V._A(w, u, 0, 360, C, C);
										if (n > H) {
											V._aM(w, u, 360, n, n);
											V._A(w, u, 360, 0, n, n);
										}
									}
								}
							}
						}
						return V;
					}
				},
				styleDef: {
					minAngle: e.FiniteNumber(0, i),
					maxAngle: e.FiniteNumber(360, i),
					minRadius: e.FinitePositiveNumber(0, i),
					maxRadius: e.FinitePositiveNumber(100, i),
					cx: e.Number(0, i),
					cy: e.Number(0, i)
				}
			});
		}
			());
		(function () {
			var e = b.graphics.AbstractGraphicNode.prototype;
			b.declare({
				name: "oui.graphics.Group",
				extend: b.graphics.AbstractGraphicNode,
				jsonDef: {
					type: "group",
					factory: function (h, j, g, i) {
						var f = new b.graphics.Group(h, h.name);
						b.load(h.children, f, j, g, i);
						return f;
					}
				},
				membersDef: {
					onStyleChanged: function (f) {
						if (f === b.TAGS.OPACITY) {
							this.notifyNative(f);
						} else {
							e.onStyleChanged.call(this, f);
						}
					},
					_computeCtrlPts: function (h) {
						var f,
						i,
						g;
						if (h === b._BoundsType.LAYOUT) {
							f = this._computeLayoutCtrlPts(h);
						} else {
							f = [];
							i = this.firstChild;
							while (i) {
								g = i._transformCtrlPts(i._txf, h);
								f.push.apply(f, g);
								i = i.nextSibling;
							}
							f = b.geom.computeConvexHull(f);
						}
						return f;
					},
					_computeLayoutCtrlPts: function (h) {
						var f = [],
						i = this.firstChild,
						g;
						while (i) {
							if (i._style.layout.isLayoutChild) {
								g = i._transformCtrlPts(i._txf, h);
								f.push.apply(f, g);
							}
							i = i.nextSibling;
						}
						return b.geom.computeConvexHull(f);
					},
					_safeLayout: function () {
						var f = this.firstChild;
						while (f) {
							f.layout();
							f = f.nextSibling;
						}
						this._positionInLayoutBox();
					},
					_hitTest: function (g, l, i) {
						var f = null,
						j = this.globalToLocal(g, l),
						k;
						var h = i ? this._isWithinBounds(j.x, j.y, i.tolerance) : this._isWithinBounds(j.x, j.y);
						if (h) {
							k = this.lastChild;
							while (k && !f) {
								f = k.hitTest(g, l, i);
								k = k.previousSibling;
							}
						}
						return f;
					}
				},
				styleDef: {
					opacity: b.defs.NumberInRange([0, 1], 1, b.TAGS.OPACITY)
				}
			});
		}
			());
		(function () {
			var i = b.graphics.AbstractGraphicNode.prototype,
			h = "opacity:",
			e = "outline-style:",
			g = b.graphics.Group.prototype.StyleDefinition.prototype,
			j = g.opacity.defaultValue,
			f = "none";
			b.mixin(b.graphics.Group, {
				SVG_TAG: "g",
				svgSetOpacity: function () {
					var k = this._style.opacity;
					if (k !== j) {
						this.svgNode.attr("style", h + k + ";");
						this._styleSet = true;
					} else {
						if (this._styleSet) {
							this.svgNode.rm("style");
							this._styleSet = false;
						}
					}
				},
				notifyNativeImpl: function (k, l) {
					if (k === b.TAGS.OPACITY) {
						this.svgSetOpacity();
					} else {
						i.notifyNativeImpl.call(this, k, l);
					}
				}
			});
			b.registerCSS("g", function (k) {
				k.push(h, j, ";", e, f, ";");
			});
		}
			());
		(function () {
			var f = b.graphics.AbstractGraphicNode.prototype,
			e = b.defs,
			g = b.TAGS;
			b.declare({
				name: "oui.graphics.Image",
				extend: b.graphics.AbstractGraphicNode,
				jsonDef: {
					type: "image"
				},
				membersDef: {
					init: function (h, i) {
						this._srcWidth = 0;
						this._srcHeight = 0;
						this._actualWidth = 0;
						this._actualHeight = 0;
						f.init.call(this, h, i);
					},
					onStyleChanged: function (h) {
						if (h === g.SRC) {
							var i = this._style.src;
							if (this.prevRequest) {
								b.resourcesManager.removeObserver(this.prevRequest, this);
								this.prevRequest = null;
							} else {
								if (this.imageLoader) {
									this.imageLoader.offComplete(this);
									this.imageLoader = null;
								}
							}
							if (b.resourcesManager.hasResource(i)) {
								b.resourcesManager.requestResource(i, this);
								this.prevRequest = i;
							} else {
								this.imageLoader = new b.utils.ImageLoader();
								this.imageLoader.onComplete(this);
								this.imageLoader.load(i);
							}
						} else {
							if (h === g.GEOM) {
								this._updateActualDimensions();
								this._clearCtrlPts();
								this.invalidateLayout();
								this.notifyNative(h);
							} else {
								if (h === g.OPACITY) {
									this.notifyNative(h);
								} else {
									f.onStyleChanged.call(this, h);
								}
							}
						}
					},
					resourceUpdate: function (h) {
						this._srcWidth = h.width;
						this._srcHeight = h.height;
						this._updateActualDimensions();
						this._resourceUpdateImpl(h);
					},
					handleEvent: function (h) {
						this.resourceUpdate(h);
					},
					_resourceUpdateImpl: function (h) {},
					_fixBoundsType: function () {
						return b._BoundsType.DEFAULT;
					},
					_computeCtrlPts: function () {
						var h = this._style;
						return b.geom.getBoxCtrlPts(h.x, h.y, this._actualWidth, this._actualHeight);
					},
					_safeLayout: function () {
						this._positionInLayoutBox();
					},
					toDataURL: function () {
						var i,
						h = this._style.src;
						if (b.resourcesManager.hasResource(h)) {
							i = b.resourcesManager._getBase64Data(h);
						}
						if (i === undefined) {
							i = this._toDataURLImpl();
						}
						if (i === undefined) {
							i = h;
						}
						return i;
					},
					_toDataURLImpl: function () {},
					_isValidChild: function () {
						return false;
					},
					_updateActualDimensions: function () {
						var h = this._style,
						j = h.preserveAspectRatio,
						n = this._srcWidth,
						q = this._srcHeight,
						l = h.width,
						k = h.height,
						i = (l === b.AUTO) ? n : l,
						p = (k === b.AUTO) ? q : k,
						o,
						m;
						o = n > 0 ? i / n : 1;
						m = q > 0 ? p / q : 1;
						if (j === b.PreserveAspectRatioEnum.MIN) {
							if (o < m) {
								if (n > 0) {
									p = q * o;
								}
							} else {
								if (q > 0) {
									i = n * m;
								}
							}
						} else {
							if (j === b.PreserveAspectRatioEnum.MAX) {
								if (o < m) {
									if (q > 0) {
										i = n * m;
									}
								} else {
									if (n > 0) {
										p = q * o;
									}
								}
							}
						}
						if (this._actualWidth !== i || this._actualHeight !== p) {
							this._actualWidth = i;
							this._actualHeight = p;
							this._clearCtrlPts();
							this.invalidateLayout();
						}
					}
				},
				styleDef: {
					src: {
						type: String,
						constraint: b.isStringNotEmpty,
						defaultValue: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAEklEQVR4nGNgGAWjYBSMAggAAAQQAAFVN1rQAAAAAElFTkSuQmCC",
						tag: g.SRC
					},
					x: e.FiniteNumber(0, g.GEOM),
					y: e.FiniteNumber(0, g.GEOM),
					width: e.Size(b.AUTO, g.GEOM),
					height: e.Size(b.AUTO, g.GEOM),
					opacity: e.NumberInRange([0, 1], 1, g.OPACITY),
					preserveAspectRatio: e.Enum(b.PreserveAspectRatioEnum, b.PreserveAspectRatioEnum.NONE, g.GEOM)
				}
			});
		}
			());
		(function () {
			var m = b.graphics.AbstractGraphicNode.prototype,
			g = "http://www.w3.org/1999/xlink",
			f = "opacity:",
			h = b.graphics.Image.prototype.StyleDefinition.prototype,
			n = h.opacity.defaultValue,
			e = h.x.defaultValue,
			p = h.y.defaultValue,
			j = "x",
			i = "y",
			o = "width",
			k = "height",
			l = "preserveAspectRatio";
			b.mixin(b.graphics.Image, {
				SVG_TAG: "g",
				_resourceUpdateImpl: function (t) {
					var r = b.isA(t.data, String),
					q = r ? ("#" + t.data) : t.url,
					s = this.svgGetImgNode(r);
					s.setAttributeNS(g, "xlink:href", q);
					this.svgSetGeom();
				},
				notifyNativeImpl: function (q, r) {
					if (q === b.TAGS.GEOM) {
						this.svgSetGeom();
					} else {
						if (q === b.TAGS.OPACITY) {
							this.svgSetOpacity();
						} else {
							m.notifyNativeImpl.call(this, q, r);
						}
					}
				},
				svgSetGeom: function () {
					var r = this._style,
					s = this.svgImgNode,
					q = r.x,
					t = r.y;
					if (s !== undefined) {
						if (q !== e) {
							s.attr(j, q);
							this._xSet = true;
						} else {
							if (this._xSet) {
								s.rm(j);
								this._xSet = false;
							}
						}
						if (t !== p) {
							s.attr(i, t);
							this._ySet = true;
						} else {
							if (this._ySet) {
								s.rm(i);
								this._ySet = false;
							}
						}
						this.svgNode.removeChild(this.svgImgNode);
						s.attr(o, this._actualWidth);
						s.attr(k, this._actualHeight);
						this.svgNode.appendChild(this.svgImgNode);
					}
				},
				svgSetOpacity: function () {
					var q = this._style.opacity;
					if (q !== n) {
						this.svgNode.attr("style", f + q + ";");
						this._styleSet = true;
					} else {
						if (this._styleSet) {
							this.svgNode.rm("style");
							this._styleSet = false;
						}
					}
				},
				svgGetImgNode: function (s) {
					var r = this.svgNode,
					q = this.svgImgNode,
					t = s ? "use" : "image";
					if (!q || q.nodeName !== t) {
						if (q) {
							r.removeChild(q);
						}
						q = b.tree.svgCreateElt(t);
						if (!s) {
							q.attr(l, "none");
						}
						r.appendChild(q);
						this.svgAttachToNode(q);
						this.svgImgNode = q;
					}
					return this.svgImgNode;
				}
			});
			b.registerCSS("image", function (q) {
				q.push(f, n, ";");
			});
		}
			());
		(function () {
			var e = b.defs,
			f = b.TAGS.GEOM;
			b.declare({
				name: "oui.graphics.Line",
				extend: b.graphics.AbstractShape,
				jsonDef: {
					type: "line"
				},
				membersDef: {
					_computeCtrlPts: function (k) {
						var i = [],
						j = this._style,
						h = j.x1,
						g = j.x2,
						n = j.y1,
						l = j.y2,
						q = j.strokeThickness,
						s = j.strokeLineCap,
						r,
						p,
						o,
						m;
						if (k) {
							o = q / 2;
							if (s === b.LineCap.SQUARE) {
								m = Math.atan2(l - n, g - h);
								r = o * Math.cos(m);
								p = o * Math.sin(m);
								h -= r;
								g += r;
								n -= p;
								l += p;
							}
							r = g - h;
							p = l - n;
							if (s !== b.LineCap.ROUND) {
								if (r !== 0 || p !== 0) {
									o = o / Math.sqrt(r * r + p * p);
									r = r * o;
									p = p * o;
									i.push(h - p, n + r, g - p, l + r, g + p, l - r, h + p, n - r);
								} else {
									if (s === b.LineCap.SQUARE) {
										i.push(h - o, n - o, h + o, n - o, h + o, n + o, h - o, n + o);
									} else {
										if (s === b.LineCap.BUTT) {
											i.push(h, n);
										}
									}
								}
							} else {
								i.push(h - o, n - o, h + o, n + o, h + o, n + o, h + o, n - o, g - o, l - o, g + o, l + o, g + o, l + o, g + o, l - o);
							}
						} else {
							i.push(h, n);
							if (h !== g || n !== l) {
								i.push(g, l);
							}
						}
						return i;
					},
					hitTestOnStroke: function (k, j, q) {
						var r = k,
						n = j,
						h = this._style,
						t = h.strokeLineCap,
						l = h.strokeThickness / 2,
						s = l * l,
						i = h.x1,
						p = h.y1,
						g = h.x2,
						m = h.y2,
						w = false,
						o,
						v,
						u;
						if (t === b.LineCap.SQUARE) {
							o = Math.atan2(m - p, g - i);
							v = l * Math.cos(o);
							u = l * Math.sin(o);
							i -= v;
							g += v;
							p -= u;
							m += u;
						}
						w = b.geom.ptSegDistSq(i, p, g, m, r, n) <= s;
						if (t !== b.LineCap.ROUND) {
							w = w && b.geom.dotprod(g - i, m - p, r - i, n - p) >= 0 && b.geom.dotprod(g - i, m - p, g - r, m - n) >= 0;
						}
						return w;
					}
				},
				styleDef: {
					x1: e.FiniteNumber(0, f),
					y1: e.FiniteNumber(0, f),
					x2: e.FiniteNumber(0, f),
					y2: e.FiniteNumber(0, f)
				}
			});
		}
			());
		(function () {
			var g = b.graphics.Line.prototype.StyleDefinition.prototype,
			j = g.x1.defaultValue,
			f = g.y1.defaultValue,
			i = g.x2.defaultValue,
			e = g.y2.defaultValue,
			h = "shape-rendering:";
			b.mixin(b.graphics.Line, {
				SVG_TAG: "line",
				svgSetGeom: function () {
					var o = this._style,
					p = this.svgNode,
					l = o.x1,
					n = o.y1,
					k = o.x2,
					m = o.y2;
					if (l !== j) {
						p.attr("x1", l);
						this._x1Set = true;
					} else {
						if (this._x1Set) {
							p.rm("x1");
							this._x1Set = false;
						}
					}
					if (n !== f) {
						p.attr("y1", n);
						this._y1Set = true;
					} else {
						if (this._y1Set) {
							p.rm("y1");
							this._y1Set = false;
						}
					}
					if (k !== i) {
						p.attr("x2", k);
						this._x2Set = true;
					} else {
						if (this._x2Set) {
							p.rm("x2");
							this._x2Set = false;
						}
					}
					if (m !== e) {
						p.attr("y2", m);
						this._y2Set = true;
					} else {
						if (this._y2Set) {
							p.rm("y2");
							this._y2Set = false;
						}
					}
				}
			});
			b.registerCSS("line", function (k) {
				k.push(h, "crispEdges", ";");
			});
		}
			());
		(function () {
			var f = b.geom.isPointInEllipse,
			g = (Math.sqrt(2) - 1) / 2,
			e = b.defs,
			h = b.TAGS.GEOM;
			b.declare({
				name: "oui.graphics.Ellipse",
				extend: b.graphics.AbstractShape,
				jsonDef: {
					type: "ellipse"
				},
				membersDef: {
					_computeCtrlPts: function (p) {
						var l,
						m = this._style,
						o = m.cx,
						n = m.cy,
						j = m.width,
						s = m.height,
						q,
						i,
						k,
						r,
						u,
						t;
						if (p) {
							j += m.strokeThickness;
							s += m.strokeThickness;
						}
						q = n - s / 2;
						i = n + s / 2;
						k = o - j / 2;
						r = o + j / 2;
						if (j === 0 && s === 0) {
							l = [o, n];
						} else {
							if (j === 0) {
								l = [o, q, o, i];
							} else {
								if (s === 0) {
									l = [k, n, r, n];
								} else {
									u = j * g;
									t = s * g;
									l = [k, n - t, o - u, q, o + u, q, r, n - t, r, n + t, o + u, i, o - u, i, k, n + t];
								}
							}
						}
						return l;
					},
					hitTestOnFill: function (j, i) {
						var k = this._style,
						l = k.width / 2,
						m = k.height / 2;
						if (this.tolerance) {
							l = Math.max(l, this.tolerance);
							m = Math.max(m, this.tolerance);
						}
						return f(j, i, k.cx, k.cy, l, m);
					},
					hitTestOnStroke: function (n, m, q) {
						var j = this._style,
						r = n,
						p = m,
						o = j.cx,
						l = j.cy,
						k = j.width / 2,
						i = j.height / 2,
						s = j.strokeThickness / 2;
						q = (q !== false);
						return f(r, p, o, l, k + s, i + s) && !(q && f(r, p, o, l, k - s, i - s));
					}
				},
				styleDef: {
					cx: e.FiniteNumber(0, h),
					cy: e.FiniteNumber(0, h),
					width: e.FinitePositiveNumber(0, h),
					height: e.FinitePositiveNumber(0, h)
				}
			});
		}
			());
		(function () {
			var f = b.graphics.Ellipse.prototype.StyleDefinition.prototype,
			e = f.cx.defaultValue,
			g = f.cy.defaultValue;
			b.mixin(b.graphics.Ellipse, {
				SVG_TAG: "ellipse",
				svgSetGeom: function () {
					var i = this._style,
					j = this.svgNode,
					h = i.cx,
					k = i.cy;
					j.attr("rx", i.width / 2);
					j.attr("ry", i.height / 2);
					if (h !== e) {
						j.attr("cx", h);
						this._cxSet = true;
					} else {
						if (this._cxSet) {
							this._cxSet = false;
							j.rm("cx");
						}
					}
					if (k !== g) {
						j.attr("cy", k);
						this._cySet = true;
					} else {
						if (this._cySet) {
							this._cySet = false;
							j.rm("cy");
						}
					}
				}
			});
		}
			());
		(function () {
			var g = b.geom.isPointInEllipse,
			f = b.geom.isPointInTriangle,
			e = b.defs,
			h = b.TAGS.GEOM;
			b.declare({
				name: "oui.graphics.Rectangle",
				extend: b.graphics.AbstractShape,
				jsonDef: {
					type: "rect"
				},
				membersDef: {
					_computeCtrlPts: function (n) {
						var l = this._style,
						k = l.strokeThickness,
						j = l.x,
						o = l.y,
						m = l.width,
						i = l.height;
						if (n) {
							j -= k / 2;
							o -= k / 2;
							m += k;
							i += k;
						}
						return b.geom.getBoxCtrlPts(j, o, m, i);
					},
					hitTestOnFill: function (s, o) {
						var k = this._style,
						w = s,
						u = o,
						p = k.x,
						z = k.y,
						v = z + k.height,
						i = p + k.width,
						m = k.rx,
						j = k.ry,
						q,
						n,
						A;
						A = (w >= p && w <= i && u >= z && u <= v);
						if (A && m !== 0 && j !== 0) {
							if (w < p + m) {
								q = p + m;
							} else {
								if (w > i - m) {
									q = i - m;
								}
							}
							if (u < z + j) {
								n = z + j;
							} else {
								if (u > v - j) {
									n = v - j;
								}
							}
							if (q !== undefined && n !== undefined) {
								A = g(w, u, q, n, m, j);
							}
						}
						return A;
					},
					hitTestOnStroke: function (i, K, J) {
						var v = false,
						s = i,
						p = K,
						E = this._style,
						I = E.strokeThickness / 2,
						C = E.x,
						w = E.y,
						H = w + E.height,
						z = C + E.width,
						n = E.rx,
						m = E.ry,
						G = (n !== 0 && m !== 0),
						o = E.strokeLineJoin,
						k,
						j,
						B = (G && n > I) ? n : I,
						A = (G && m > I) ? m : I,
						u,
						q,
						F,
						D;
						J = (J !== false);
						v = (s >= C - I && s <= z + I && p >= w - I && p <= H + I);
						v = v && !(J && ((s >= C + B && s <= z - B && p >= w + I && p <= H - I) || (G && s >= C + I && s <= z - I && p >= w + A && p <= H - A)));
						if (v) {
							if (G || o === b.LineJoin.ROUND) {
								if (s < C + n) {
									k = C + n;
								} else {
									if (s > z - n) {
										k = z - n;
									}
								}
								if (p < w + m) {
									j = w + m;
								} else {
									if (p > H - m) {
										j = H - m;
									}
								}
								if (k !== undefined && j !== undefined) {
									v = g(s, p, k, j, n + I, m + I);
									if (v && J && G && n > I && m > I) {
										v = !g(s, p, k, j, n - I, m - I);
									}
								}
							} else {
								if (o === b.LineJoin.BEVEL) {
									if (s < C) {
										u = C - I;
										F = C;
										k = C;
									} else {
										if (s > z) {
											u = z + I;
											F = z;
											k = z;
										}
									}
									if (p < w) {
										q = w;
										D = w - I;
										j = w;
									} else {
										if (p > H) {
											q = H;
											D = H + I;
											j = H;
										}
									}
									if (k !== undefined && j !== undefined) {
										v = f(s, p, u, q, F, D, k, j);
									}
								}
							}
						}
						return v;
					}
				},
				styleDef: {
					x: e.FiniteNumber(0, h),
					y: e.FiniteNumber(0, h),
					width: e.FinitePositiveNumber(0, h),
					height: e.FinitePositiveNumber(0, h),
					rx: e.FinitePositiveNumber(0, h),
					ry: e.FinitePositiveNumber(0, h)
				}
			});
		}
			());
		(function () {
			var j = b.graphics.Rectangle.prototype.StyleDefinition.prototype,
			f = j.x.defaultValue,
			q = j.y.defaultValue,
			i = j.rx.defaultValue,
			h = j.ry.defaultValue,
			l = "x",
			k = "y",
			n = "width",
			m = "height",
			e = "rx",
			p = "ry",
			o = "shape-rendering:",
			g;
			b.mixin(b.graphics.Rectangle, {
				SVG_TAG: "rect",
				svgSetGeom: function () {
					var s = this._style,
					t = this.svgNode,
					r = s.x,
					w = s.y,
					v = s.rx,
					u = s.ry;
					if (r !== f) {
						t.attr(l, r);
						this._xSet = true;
					} else {
						if (this._xSet) {
							t.rm(l);
							this._xSet = false;
						}
					}
					if (w !== q) {
						t.attr(k, w);
						this._ySet = true;
					} else {
						if (this._ySet) {
							t.rm(k);
							this._ySet = false;
						}
					}
					t.attr(n, s.width);
					t.attr(m, s.height);
					if (v !== i || u !== h) {
						t.attr(e, v);
						t.attr(p, u);
						this._rSet = true;
					} else {
						if (this._rSet) {
							t.rm(e);
							t.rm(p);
							this._rSet = false;
						}
					}
				}
			});
			b.registerCSS("rect", function (r) {
				r.push(o, "crispEdges", ";");
			});
			g = function (r) {
				r.push(o, "auto", ";");
			};
			b.registerCSS("rect[rx]", g);
			b.registerCSS("rect[ry]", g);
		}
			());
		(function () {
			var e = b.defs,
			i = b.TAGS.GEOM,
			g = b.TextAlignEnum,
			f = b.GENERIC_FONTS;
			function h(j) {
				j = j.toLowerCase();
				return j.indexOf(" ") >= 0 && j[0] !== "'" && j !== f.SERIF && j !== f.SANS_SERIF && j !== f.CURSIVE && j !== f.MONOSPACE;
			}
			b.declare({
				name: "oui.graphics.Text",
				extend: b.graphics.AbstractShape,
				jsonDef: {
					type: "text"
				},
				membersDef: {
					_computeCtrlPts: function () {
						var k = this._style,
						l,
						o,
						n,
						m,
						j,
						p;
						if (k.textValue.length > 0) {
							p = this._getBBoxImpl();
							if (!p) {
								m = k.fontSize * k.textValue.length / 2;
								j = k.fontSize;
								o = k.x;
								if (k.textAlign === g.CENTER) {
									o -= m / 2;
								} else {
									if ((b.layoutDir === b.LTR && k.textAlign === g.LINE_END) || (b.layoutDir === b.RTL && k.textAlign === g.LINE_BEGIN)) {
										o -= m;
									}
								}
								n = k.y - j;
							} else {
								m = p.width;
								j = p.height;
								o = p.x;
								n = p.y;
							}
							l = b.geom.getBoxCtrlPts(o, n, m, j);
						} else {
							l = [k.x, k.y];
						}
						return l;
					},
					hitTestOnFill: function (k, j) {
						return this._isWithinBounds(k, j);
					},
					getBaselineYAnchor: function () {
						var k = this._style,
						j = k.layout.yAnchor,
						l = this._getBBoxImpl();
						if (l) {
							j = (k.y - l.y) / l.height;
						}
						return j;
					},
					_getXAlignOffset: function (l) {
						var k = 0,
						j = (b.layoutDir === b.LTR);
						switch (this._style.textAlign) {
						case g.JUSTIFY:
							c.warn("WARN__TEXT__NO_JUSTIFY");
						case g.LINE_BEGIN:
							k = j ? 0 : -l;
							break;
						case g.CENTER:
							k = -l / 2;
							break;
						case g.LINE_END:
							k = j ? -l : 0;
							break;
						}
						return k;
					},
					_getCSSFontFamily: function (l) {
						var j = this._style.fontFamily,
						m,
						p,
						k,
						o;
						j = j.replace(/\s+/g, " ").replace(/\s*,\s*/g, ",").replace(/"/g, "'").replace(/^\s+|\s+$/g, "");
						if (j.indexOf(",") > 0) {
							if (l === true) {
								p = j.split(",");
								for (k = 0, o = p.length; k < o; k++) {
									if (h(p[k])) {
										p[k] = "'" + p[k] + "'";
									}
								}
								j = p.join(",");
							}
						} else {
							m = j.replace(/'/g, "").toLowerCase();
							if (b.cssFonts.hasOwnProperty(m)) {
								j = b.cssFonts[m];
							} else {
								if (l === true && h(j)) {
									j = "'" + j + "'";
								}
							}
						}
						if (l !== true) {
							j = j.replace(/'/g, "");
						}
						return j;
					},
					_getBBoxImpl: function () {
						return null;
					}
				},
				styleDef: {
					textValue: e.String("", i),
					x: e.FiniteNumber(0, i),
					y: e.FiniteNumber(0, i),
					fontFamily: e.String("Verdana", i),
					fontSize: e.FinitePositiveNumber(12, i),
					fontWeight: e.Enum(b.FontWeightEnum, b.FontWeightEnum.NORMAL, i),
					fontStyle: e.Enum(b.FontStyleEnum, b.FontStyleEnum.NORMAL, i),
					underline: e.Boolean(false, i),
					textAlign: e.Enum(g, g.LINE_BEGIN, i)
				}
			});
		}
			());
		(function () {
			var y = b.graphics.AbstractShape.prototype,
			h = b.TextAlignEnum,
			k = "text-anchor:",
			v = "font-size:",
			n = "font-family:",
			u = "font-weight:",
			x = "font-style:",
			w = "text-decoration:",
			m = "text-rendering:",
			r = "x",
			q = "y",
			s = b.graphics.Text.prototype.StyleDefinition.prototype,
			o = s.textAlign.defaultValue,
			p = s.fontSize.defaultValue,
			i = s.fontFamily.defaultValue,
			l = s.fontWeight.defaultValue,
			f = s.fontStyle.defaultValue,
			j = s.underline.defaultValue,
			g = s.x.defaultValue,
			e = s.y.defaultValue,
			t = (j ? "none" : "underline");
			b.mixin(b.graphics.Text, {
				SVG_TAG: "text",
				svgOnNodeCreated: function () {
					y.svgOnNodeCreated.call(this);
					this.svgTextNode = b.tree.svgCreateTextElt("");
					this.svgNode.appendChild(this.svgTextNode);
				},
				svgGetCSS: function (C) {
					var z = this._style,
					F = z.fontFamily,
					H = z.fontSize,
					G = z.fontWeight,
					D = z.fontStyle,
					A = z.textAlign,
					B = z.underline,
					E = [];
					if (F !== i) {
						E.push(n, this._getCSSFontFamily(true), ";");
					}
					if (H !== p) {
						E.push(v, H, "px;");
					}
					if (G !== l) {
						E.push(u, G, ";");
					}
					if (D !== f) {
						E.push(x, D, ";");
					}
					if (A !== o) {
						E.push(k, this.svgToAlign(A), ";");
					}
					if (B !== j) {
						E.push(w, t, ";");
					}
					return y.svgGetCSS.call(this, C) + E.join("");
				},
				svgSetGeom: function () {
					var A = this._style,
					B = this.svgNode,
					z = A.x,
					C = A.y;
					if (z !== g) {
						B.attr(r, z);
						this._xSet = true;
					} else {
						if (this._xSet) {
							this._xSet = false;
							B.rm(r);
						}
					}
					if (C !== e) {
						B.attr(q, C);
						this._ySet = true;
					} else {
						if (this._ySet) {
							this._ySet = false;
							B.rm(q);
						}
					}
					this.svgSetTextFormat(B);
					this.svgSetTextContent(this.svgTextNode);
				},
				svgSetTextFormat: function (z) {
					z.attr("style", this.svgGetCSS(z));
				},
				svgSetTextContent: function (z) {
					z.nodeValue = this._style.textValue;
				},
				svgGetBBox: function () {
					var E,
					A = this.svgNode,
					z = this.svgTextNode,
					D,
					C;
					try {
						this.svgCreateNode();
						this.svgSetGeom();
						D = this.svgNode;
						b.tree.svgNode.appendChild(D);
						C = D.getBBox();
						if (C) {
							E = {
								x: C.x,
								y: C.y,
								width: C.width,
								height: C.height
							};
						}
						b.tree.svgNode.removeChild(D);
					} catch (B) {
						c.warn("WARN__SVG__BBOX_FAIL", B);
					} finally {
						this.svgNode = A;
						this.svgTextNode = z;
					}
					return E;
				},
				svgToAlign: function (A) {
					var z = (b.layoutDir === b.LTR);
					switch (A) {
					case h.CENTER:
						A = "middle";
						break;
					case h.LINE_END:
						A = z ? "end" : "start";
						break;
					default:
						A = z ? "start" : "end";
						break;
					}
					return A;
				}
			});
			b.registerCSS("text", function (C) {
				var z = "geometricPrecision",
				B = j ? "underline" : "none",
				A = (b.layoutDir === b.RTL) ? "rtl" : "ltr";
				C.push(n, i, ";", v, p, "px;", u, l, ";", x, f, ";", k, b.graphics.Text.prototype.svgToAlign(o), ";", w, B, ";", m, z, ";", "unicode-bidi", ":", "embed", ";", "direction", ":", A, ";");
			});
		}
			());
		(function () {
			var e = b.defs,
			f = b.TAGS.GEOM;
			b.declare({
				name: "oui.graphics.TextBlock",
				extend: b.graphics.Text,
				jsonDef: {
					type: "textBlock"
				},
				membersDef: {
					convertToText: function () {
						var o = [],
						h = new b.text.LineBreakMeasurer(this),
						n = this._breakText(h),
						q = n.length,
						p,
						g,
						k = this._style,
						j = k.y,
						m = k.x,
						l;
						for (l = 0; l < q; l++) {
							g = n[l];
							if (l !== 0) {
								j += g.leading + g.ascent;
							}
							p = new b.graphics.Text(k);
							p.applyStyle({
								textValue: g.textValue,
								x: m + this._getXAlignOffset(g.lineWidth),
								y: j
							});
							o.push(p);
							j += g.descent;
						}
						return o;
					},
					_breakText: function (g) {
						var h = this._style,
						i = h.textValue,
						p = h.maxWidth,
						m = h.maxLines,
						j = h.autoTooltip,
						l = h.useEllipsis,
						n = h.ellipsis,
						o = false,
						r = [],
						q = g.getTextLength(),
						k;
						g.replaceText(0, q, i);
						if (l) {
							q = g.getTextLength();
							k = this._fitText(g, r, p, m, true);
							while (k >= 1 && k < q) {
								g.replaceText(k - 1, q, n);
								q = g.getTextLength();
								k = this._fitText(g, r, p, m, true);
							}
							o = (k !== i.length);
						} else {
							this._fitText(g, r, p, m, false);
						}
						if (j && o) {
							this.setTooltip(i);
						} else {
							this.setTooltip(null);
						}
						return r;
					},
					_fitText: function (g, o, m, l, k) {
						var n = 0,
						j = 0,
						h = this._style.minChar,
						i = g.nextLine(m);
						o.length = 0;
						while (i) {
							o.push(i);
							n++;
							j = i.textBlockEndIndex;
							if (n === l || (k && i.lastWordTruncated)) {
								break;
							}
							i = g.nextLine(m);
						}
						if (k) {
							h++;
						}
						if (n > 0 && o[0].lastWordTruncated && o[0].textValue.length < h) {
							o.length = 0;
							j = 0;
						}
						return j;
					}
				},
				styleDef: {
					maxWidth: e.PositiveNumber(Number.POSITIVE_INFINITY, f),
					maxLines: e.NumberInRange([1, Number.POSITIVE_INFINITY], Number.POSITIVE_INFINITY, f),
					minChar: e.FinitePositiveNumber(0, f),
					useEllipsis: e.Boolean(false),
					ellipsis: e.Char("\u2026"),
					autoTooltip: e.Boolean(false)
				}
			});
		}
			());
		(function () {
			b.mixin(b.graphics.TextBlock, {
				svgOnNodeCreated: function () {
					b.graphics.AbstractShape.prototype.svgOnNodeCreated.call(this);
				},
				svgSetTextContent: function () {
					var j = this._style,
					o = j.x,
					h = j.y,
					l = this.svgNode,
					f,
					k,
					e,
					q,
					p,
					m,
					g;
					while (l.hasChildNodes()) {
						l.removeChild(this.svgNode.firstChild);
					}
					e = new b.text.LineBreakMeasurer(this);
					q = this._breakText(e);
					g = q.length;
					if (g === 1) {
						k = b.tree.svgCreateTextElt("");
						l.appendChild(k);
						k.nodeValue = q[0].textValue;
					} else {
						for (m = 0; m < g; m++) {
							p = q[m];
							f = b.tree.svgCreateElt("tspan");
							this.svgAttachToNode(f);
							l.appendChild(f);
							k = b.tree.svgCreateTextElt(p.textValue);
							f.appendChild(k);
							if (m !== 0) {
								h += q[m - 1].descent + p.leading + p.ascent;
							}
							f.attr({
								x: o,
								y: h
							});
						}
					}
				}
			});
		}
			());
		(function () {
			var e = b.graphics.Group.prototype,
			f = "background";
			b.declare({
				name: "oui.layout.AbstractLayoutBox",
				isAbstract: true,
				extend: b.graphics.Group,
				membersDef: {
					_computeLayoutCtrlPts: function () {
						var g = this._box;
						return b.geom.getBoxCtrlPts(g.x, g.y, g.width, g.height);
					},
					invalidateLayout: function () {
						var g;
						if (!this._layingOut && !this._layoutDirty) {
							g = this.getFirstContentChild();
							this.invalidateLayout = b.NO_OP;
							while (g) {
								if ((g.getLayoutHWeight() !== 0) || (g.getLayoutVWeight() !== 0)) {
									g.invalidateLayout();
								}
								g = g.nextSibling;
							}
							delete this.invalidateLayout;
							e.invalidateLayout.call(this);
						}
					},
					_getLayoutInformation: function () {
						var j,
						g,
						h,
						o,
						l,
						i,
						m,
						p,
						k,
						n;
						j = {
							maxChildWidth: 0,
							maxChildHeight: 0,
							maxLayoutWidth: Number.MAX_VALUE,
							maxLayoutHeight: Number.MAX_VALUE,
							totalChildWidth: 0,
							totalChildHeight: 0,
							totalChildHWeight: 0,
							totalChildVWeight: 0,
							children: [],
							spacingsCount: 0
						};
						h = this.getFirstContentChild();
						while (h) {
							o = h._style;
							l = h.getPreferredLayoutBox();
							i = o.layout.hWeight;
							m = o.layout.vWeight;
							n = o.display;
							j.totalChildWidth += l.width;
							j.totalChildHWeight += i;
							j.totalChildHeight += l.height;
							j.totalChildVWeight += m;
							if (l.height > j.maxChildHeight) {
								j.maxChildHeight = l.height;
							}
							if (l.width > j.maxChildWidth) {
								j.maxChildWidth = l.width;
							}
							j.children.push({
								node: h,
								layoutBox: l,
								hWeight: i,
								vWeight: m,
								needSpace: n
							});
							if (n) {
								j.spacingsCount++;
							}
							h = h.nextSibling;
						}
						if (j.spacingsCount > 0) {
							j.spacingsCount--;
						}
						g = this._layoutBox;
						if (g) {
							if (j.maxChildHeight > g.height) {
								j.maxChildHeight = g.height;
							}
							if (j.maxChildWidth > g.width) {
								j.maxChildWidth = g.width;
							}
							j.maxLayoutWidth = g.width;
							j.maxLayoutHeight = g.height;
						}
						p = this._style.layout.preferredWidth;
						k = this._style.layout.preferredHeight;
						if (p >= 0 && j.maxLayoutWidth > p) {
							j.maxLayoutWidth = p;
						}
						if (k >= 0 && j.maxLayoutHeight > k) {
							j.maxLayoutHeight = k;
						}
						return j;
					},
					onStyleChanged: function (g) {
						if (g === f) {
							this._updateBackground();
						} else {
							e.onStyleChanged.call(this, g);
						}
					},
					_updateBackground: function () {
						var g = this._style,
						h = {
							fill: g.background
						};
						if (this._background) {
							this._background.applyStyle(h);
						} else {
							this._background = new b.graphics.Rectangle(h);
							this.insertBefore(this._background, this.firstChild);
						}
					},
					getFirstContentChild: function () {
						return this._background ? this._background.nextSibling : this.firstChild;
					},
					hasBackground: function () {
						return (this._background !== undefined);
					}
				},
				styleDef: {
					background: b.defs.Paint(b.NO_PAINT, f)
				}
			});
		}
			());
		(function () {
			var h = b.defs,
			n = b.DirectionEnum,
			o = b.LTR,
			g = b.RTL,
			i = b.OrientationEnum.VERTICAL,
			f = b.OrientationEnum.HORIZONTAL,
			q = n.UP,
			p = n.DOWN,
			e = n.LEFT,
			m = n.RIGHT,
			k = n.TO_LINE_BEGIN,
			l = n.TO_LINE_END,
			j = b.TAGS.LAYOUT;
			b.declare({
				name: "oui.layout.FlowBox",
				extend: b.layout.AbstractLayoutBox,
				jsonDef: {
					type: "flowbox",
					factory: function (t, v, s, u) {
						var r = new b.layout.FlowBox(t, t.name);
						b.load(t.children, r, v, s, u);
						return r;
					}
				},
				membersDef: {
					_safeLayout: function () {
						var r = this._style.orientation;
						if (r === f) {
							this._hFlowLayout();
						} else {
							this._vFlowLayout();
						}
						if (this._background) {
							this._background.applyStyle(this._box);
						}
						this._positionInLayoutBox();
					},
					_vFlowLayout: function () {
						var r = this._style,
						t = 0,
						s = 0,
						A = [],
						D = 0,
						F = r.wrapLength,
						z = r.hSpacing,
						G = r.vSpacing,
						C,
						u = this.firstChild,
						x = 0,
						w = 0,
						E = 1,
						v = 0,
						B = 0,
						y = 1;
						if (this._isRTLLayout()) {
							v = 1;
							E = -1;
						}
						if (r.vDirection === q) {
							B = 1;
							y = -1;
						}
						while (u) {
							C = u.getPreferredLayoutBox();
							if (y * s + C.height > F) {
								this._layoutColumn(A, D, v * E * D);
								if (x > 0) {
									x += z;
								}
								x += D;
								s = 0;
								t += E * (D + z);
								A = [];
								D = 0;
							}
							A.push({
								node: u,
								x: t,
								y: s + B * y * C.height,
								width: C.width,
								height: C.height
							});
							if (D < C.width) {
								D = C.width;
							}
							if (y * s + C.height > w) {
								w = y * s + C.height;
							}
							s += y * (C.height + (u._style.display ? G : 0));
							u = u.nextSibling;
						}
						if (A.length > 0) {
							this._layoutColumn(A, D, v * E * D);
							if (x > 0) {
								x += z;
							}
							x += D;
						}
						this._box = {
							x: v * E * x,
							y: B * y * w,
							width: x,
							height: w
						};
					},
					_layoutColumn: function (r, u, t) {
						var s,
						w,
						v;
						for (s = 0, w = r.length; s < w; s++) {
							v = r[s];
							v.node.setLayoutBox(v.x + t, v.y, u, v.height);
						}
					},
					_hFlowLayout: function () {
						var r = this._style,
						t = 0,
						s = 0,
						w = [],
						C = 0,
						F = r.wrapLength,
						y = r.hSpacing,
						G = r.vSpacing,
						B,
						u = this.firstChild,
						z = 0,
						E = 0,
						D = 1,
						v = 0,
						A = 0,
						x = 1;
						if (this._isRTLLayout()) {
							v = 1;
							D = -1;
						}
						if (r.vDirection === q) {
							A = 1;
							x = -1;
						}
						while (u) {
							B = u.getPreferredLayoutBox();
							if (D * t + B.width > F) {
								this._layoutRow(w, C, A * x * C);
								if (z > 0) {
									z += G;
								}
								z += C;
								t = 0;
								s += x * (C + G);
								w = [];
								C = 0;
							}
							w.push({
								node: u,
								x: t + v * D * B.width,
								y: s,
								width: B.width,
								height: B.height
							});
							if (C < B.height) {
								C = B.height;
							}
							if (D * t + B.width > E) {
								E = D * t + B.width;
							}
							t += D * (B.width + (u._style.display ? y : 0));
							u = u.nextSibling;
						}
						if (w.length > 0) {
							this._layoutRow(w, C, A * x * C);
							if (z > 0) {
								z += G;
							}
							z += C;
						}
						this._box = {
							x: v * D * E,
							y: A * x * z,
							width: E,
							height: z
						};
					},
					_layoutRow: function (u, s, t) {
						var r,
						w,
						v = u.length;
						for (r = 0; r < v; r++) {
							w = u[r];
							w.node.setLayoutBox(w.x, w.y + t, w.width, s);
						}
					},
					_isRTLLayout: function () {
						var r = this._style.hDirection;
						return r === e || (r === k && b.layoutDir === o) || (r === l && b.layoutDir === g);
					}
				},
				styleDef: {
					orientation: h.Enum(b.OrientationEnum, i, j),
					wrapLength: h.PositiveNumber(100, j),
					hDirection: {
						type: [e, m, k, l],
						defaultValue: l,
						tag: j
					},
					vDirection: {
						type: [q, p],
						defaultValue: p,
						tag: j
					},
					hSpacing: h.FinitePositiveNumber(5, j),
					vSpacing: h.FinitePositiveNumber(5, j)
				}
			});
		}
			());
		(function () {
			var f = b.LTR,
			k = b.RTL,
			i = b.DirectionEnum,
			g = i.LEFT,
			h = i.RIGHT,
			l = i.TO_LINE_BEGIN,
			e = i.TO_LINE_END,
			j = b.TAGS.LAYOUT;
			b.declare({
				name: "oui.layout.HBox",
				extend: b.layout.AbstractLayoutBox,
				jsonDef: {
					type: "hbox",
					factory: function (n, q, m, p) {
						var o = new b.layout.HBox(n, n.name);
						b.load(n.children, o, q, m, p);
						return o;
					}
				},
				membersDef: {
					_safeLayout: function () {
						var y,
						A,
						s,
						m,
						E,
						o,
						u,
						B,
						p,
						w,
						C,
						v = this._style,
						q = 0,
						D = 0,
						z,
						t = 1,
						n = 0,
						x = v.direction,
						r = v.spacing;
						A = this._getLayoutInformation();
						m = A.maxChildHeight;
						if (A.maxLayoutHeight !== Number.MAX_VALUE && ((A.totalChildVWeight !== 0) || (A.maxLayoutHeight < A.maxChildHeight))) {
							m = A.maxLayoutHeight;
						}
						p = A.maxLayoutWidth;
						s = A.children;
						w = 0;
						E = p;
						o = s.length;
						D = A.maxLayoutWidth - A.totalChildWidth - A.spacingsCount * r;
						if (D < 0 || A.maxLayoutWidth === Number.MAX_VALUE) {
							D = 0;
						}
						z = A.totalChildHWeight;
						if (z === 0) {
							z = 1;
						}
						if (x === g || (x === l && b.layoutDir === f) || (x === e && b.layoutDir === k)) {
							n = 1;
							t = -1;
						}
						for (C = 0; C < o; C++) {
							u = s[C];
							B = u.node;
							y = u.layoutBox.width + D * u.hWeight / z;
							if (y > p) {
								y = p;
							}
							B.setLayoutBox(w + n * t * y, 0, y, m);
							q = t * w + y;
							w += t * (y + (u.needSpace ? r : 0));
							if (t * w > E) {
								w = t * E;
							}
							p = A.maxLayoutWidth - t * w;
							if (p < 0) {
								p = 0;
							}
						}
						this._box = {
							x: n * t * q,
							y: 0,
							width: q,
							height: m
						};
						if (this._background) {
							this._background.applyStyle(this._box);
						}
						this._positionInLayoutBox();
					}
				},
				styleDef: {
					spacing: b.defs.FinitePositiveNumber(5, j),
					direction: {
						type: [g, h, l, e],
						defaultValue: e,
						tag: j
					}
				}
			});
		}
			());
		(function () {
			var g = b.DirectionEnum,
			e = g.UP,
			f = g.DOWN,
			h = b.TAGS.LAYOUT;
			b.declare({
				name: "oui.layout.VBox",
				extend: b.layout.AbstractLayoutBox,
				jsonDef: {
					type: "vbox",
					factory: function (j, m, i, l) {
						var k = new b.layout.VBox(j, j.name);
						b.load(j.children, k, m, i, l);
						return k;
					}
				},
				membersDef: {
					_safeLayout: function () {
						var p,
						u,
						m,
						n,
						z,
						j,
						o,
						v,
						y,
						r,
						w,
						q = this._style,
						A = 0,
						t = 0,
						k,
						x = 0,
						s = 1,
						l = q.spacing;
						u = this._getLayoutInformation();
						n = u.maxChildWidth;
						if (u.maxLayoutWidth !== Number.MAX_VALUE && ((u.totalChildHWeight !== 0) || (u.maxLayoutWidth < u.maxChildWidth))) {
							n = u.maxLayoutWidth;
						}
						y = u.maxLayoutHeight;
						m = u.children;
						r = 0;
						z = y;
						j = m.length;
						t = u.maxLayoutHeight - u.totalChildHeight - u.spacingsCount * l;
						if (t < 0 || u.maxLayoutHeight === Number.MAX_VALUE) {
							t = 0;
						}
						k = u.totalChildVWeight;
						if (k === 0) {
							k = 1;
						}
						if (q.direction === e) {
							x = 1;
							s = -1;
						}
						for (w = 0; w < j; w++) {
							o = m[w];
							v = o.node;
							p = o.layoutBox.height + t * o.vWeight / k;
							if (p > y) {
								p = y;
							}
							v.setLayoutBox(0, r + x * s * p, n, p);
							A = s * r + p;
							r += s * (p + (o.needSpace ? l : 0));
							if (s * r > z) {
								r = s * z;
							}
							y = u.maxLayoutHeight - s * r;
							if (y < 0) {
								y = 0;
							}
						}
						this._box = {
							x: 0,
							y: x * s * A,
							width: n,
							height: A
						};
						if (this._background) {
							this._background.applyStyle(this._box);
						}
						this._positionInLayoutBox();
					}
				},
				styleDef: {
					spacing: b.defs.FinitePositiveNumber(5, h),
					direction: {
						type: [e, f],
						defaultValue: f,
						tag: h
					}
				}
			});
		}
			());
		(function () {
			var f = b.graphics.Group.prototype,
			e = b.defs;
			b.declare({
				name: "oui.layout.Box",
				extend: b.graphics.Group,
				jsonDef: {
					type: "box",
					factory: function (h, k, g, j) {
						var i = new b.layout.Box(h, h.name);
						b.load(h.children, i, k, g, j);
						return i;
					}
				},
				membersDef: {
					init: function (g, h) {
						f.init.call(this, g, h);
						this._updateBackground();
					},
					onPropertyChanged: function () {
						this._updateBackground();
					},
					_updateBackground: function () {
						var j = this._style,
						i = j.border,
						h = i.rounded,
						g,
						k;
						if ((h.topLineBegin === h.topLineEnd && h.topLineEnd === h.bottomLineBegin && h.bottomLineBegin === h.bottomLineEnd)) {
							k = {
								stroke: i.stroke,
								strokeThickness: i.strokeThickness,
								rx: h.topLineBegin ? i.rx : 0,
								ry: h.topLineBegin ? i.ry : 0,
								fill: j.background,
								filter: j.backgroundFilter
							};
							if (!this._rect) {
								this._rect = new b.graphics.Rectangle(k);
							} else {
								this._rect.applyStyle(k);
							}
							g = this._rect;
						} else {
							k = {
								stroke: i.stroke,
								strokeThickness: i.strokeThickness,
								rx: i.rx,
								ry: i.ry,
								rounded: i.rounded,
								fill: j.background,
								filter: j.backgroundFilter
							};
							if (!this._hrrect) {
								this._hrrect = new b.graphics.HalfRoundedRectangle(k);
							} else {
								this._hrrect.applyStyle(k);
							}
							g = this._hrrect;
						}
						if (g !== this._background) {
							if (this._background) {
								this.removeChild(this._background);
							}
							this.insertBefore(g, this.firstChild);
							this._background = g;
						}
					},
					_safeLayout: function () {
						var l,
						h = null,
						k,
						g,
						i,
						j;
						if (!this._layoutBox) {
							l = this.getPreferredLayoutBox();
							this.setLayoutBox(0, 0, l.width, l.height);
						}
						k = this._layoutBox.width;
						g = this._layoutBox.height;
						i = this._style.layout.preferredWidth;
						j = this._style.layout.preferredHeight;
						if (i >= 0 && i < k) {
							k = i;
						}
						if (j >= 0 && j < g) {
							g = j;
						}
						if (this._background) {
							h = this._background.nextSibling;
							this._background.applyStyle({
								width: k,
								height: g
							});
						} else {
							h = this.firstChild;
						}
						while (h) {
							h.setLayoutBox(0, 0, k, g);
							h = h.nextSibling;
						}
						this._positionInLayoutBox();
					},
					_getContentPreferredLayoutBox: function () {
						var g = null,
						i,
						h = {
							width: 0,
							height: 0
						};
						if (this._background) {
							g = this._background.nextSibling;
						}
						while (g) {
							i = g.getPreferredLayoutBox();
							h.width = Math.max(h.width, i.width);
							h.height = Math.max(h.height, i.height);
							g = g.nextSibling;
						}
						return h;
					}
				},
				styleDef: {
					border: {
						strokeThickness: e.FinitePositiveNumber(1),
						stroke: e.Paint(b.NO_PAINT),
						rx: e.PositiveNumber(3),
						ry: e.PositiveNumber(3),
						rounded: {
							topLineBegin: e.Boolean(true),
							topLineEnd: e.Boolean(true),
							bottomLineBegin: e.Boolean(false),
							bottomLineEnd: e.Boolean(false)
						}
					},
					background: e.Paint(b.NO_PAINT),
					backgroundFilter: e.FilterEffect(null)
				}
			});
		}
			());
		(function () {
			var f = b.graphics.Group.prototype,
			e = b.defs,
			g;
			g = {
				name: "content",
				type: "box",
				children: [{
						name: "shadow",
						type: "box",
						background: b.black,
						border: {
							stroke: b.black
						},
						styleBinding: {
							display: function (h) {
								return h.shadow !== null;
							},
							filter: "@shadow",
							border: {
								strokeThickness: "@border.strokeThickness",
								rx: "@border.rx",
								ry: "@border.ry",
								rounded: "@border.rounded"
							}
						}
					}, {
						name: "background",
						type: "box",
						styleBinding: {
							border: "@border",
							background: "@background"
						}
					}, {
						name: "data",
						type: "box",
						background: b.NO_PAINT,
						border: {
							stroke: b.NO_PAINT
						},
						styleBinding: {
							layout: {
								padding: "@padding"
							}
						},
						children: [{
								name: "text",
								type: "textBlock",
								useEllipsis: true,
								autoTooltip: false,
								styleBinding: {
									fontFamily: "@text.fontFamily",
									fontSize: "@text.fontSize",
									fontWeight: "@text.fontWeight",
									fill: "@text.fill",
									maxLines: "@text.maxLines",
									maxWidth: "#_computeMaxWidth"
								}
							}, {
								name: "graphics",
								type: "group"
							}
						]
					}
				]
			};
			b.declare({
				name: "oui.tooltip.Tooltip",
				extend: b.graphics.Group,
				membersDef: {
					init: function (h, i) {
						f.init.call(this, h, i);
						this.isShown = false;
						this._isTextBased = false;
						this.content = b.load(g);
						this.appendChild(this.content);
						this.onPropertyChanged();
						this.setPointerSensitivity(false);
						this._viewportResizeHandler = this.handler("_computeMaxWidth");
					},
					setContent: function (h) {
						this.content.data.text.setDisplay(false);
						this.content.data.graphics.setDisplay(false);
						if (b.isA(h, String)) {
							this._setTextContent(h);
						} else {
							if (b.isA(h, b.graphics.AbstractGraphicNode)) {
								this._setGraphicContent(h);
							} else {
								if (b.isA(h, Number)) {
									this._setTextContent(h.toString(10));
								} else {
									if (b.isA(h, Date)) {
										this._setTextContent(h.toLocaleString());
									}
								}
							}
						}
					},
					show: function () {
						this.appendChild(this.content);
						this.isShown = true;
					},
					hide: function () {
						this.isShown = false;
						if (this.firstChild) {
							this.removeChild(this.content);
						}
					},
					onPropertyChanged: function () {
						if (this.content !== undefined) {
							this.content.applyStyleBinding(this._style, this);
						}
					},
					_setTextContent: function (h) {
						this.content.data.text.applyStyle({
							display: true,
							textValue: h,
							maxWidth: this._computeMaxWidth()
						});
						if (!this._isTextBased) {
							b.rootNode.addEventListener(b.ViewEvents.VIEWPORT_RESIZE, this._viewportResizeHandler);
							this._isTextBased = true;
						}
					},
					_setGraphicContent: function (i) {
						var h = this.content.data.graphics;
						h.removeChildren();
						h.appendChild(i);
						h.setDisplay(true);
						if (this._isTextBased) {
							b.rootNode.removeEventListener(b.ViewEvents.VIEWPORT_RESIZE, this._viewportResizeHandler);
							this._isTextBased = false;
						}
					},
					_computeMaxWidth: function () {
						var h = this._style,
						i = h.padding,
						j = b.viewportWidth - (i.lineBegin + i.lineEnd);
						return Math.min(h.text.maxWidth, j);
					}
				},
				styleDef: {
					border: {
						strokeThickness: e.FinitePositiveNumber(1),
						stroke: e.Paint(new b.style.Color(204, 204, 204)),
						rx: e.PositiveNumber(4),
						ry: e.PositiveNumber(4),
						rounded: {
							topLineBegin: e.Boolean(true),
							topLineEnd: e.Boolean(true),
							bottomLineBegin: e.Boolean(true),
							bottomLineEnd: e.Boolean(true)
						}
					},
					background: e.Paint(new b.style.Color(0, 0, 0, 191)),
					text: {
						fontFamily: e.String("Trebuchet MS"),
						fontSize: e.FinitePositiveNumber(11),
						fontWeight: e.Enum(b.FontWeightEnum, b.FontWeightEnum.NORMAL),
						fill: e.Paint(b.white),
						maxLines: e.NumberInRange([1, Number.POSITIVE_INFINITY], Number.POSITIVE_INFINITY),
						maxWidth: e.PositiveNumber(Number.POSITIVE_INFINITY, b.TAGS.GEOM)
					},
					padding: e.Padding(5, 5, 5, 5),
					shadow: e.ObjectOfType(b.filters.DropShadow, b.filters.DROP_SHADOW_KNOCKED_OUT, true)
				}
			});
		}
			());
		(function () {
			var e = b.defs;
			b.declare({
				name: "oui.tooltip.TooltipManager",
				mixins: [b.lang.PropertiesSupport],
				membersDef: {
					events: {
						SHOW_TOOLTIP: "showTooltip",
						HIDE_TOOLTIP: "hideTooltip"
					},
					init: function () {
						var g = this,
						f = b.tree;
						this._initProperties();
						this._initCallbacks();
						this._initMouseListeners();
						this._style = new this.Style();
						this._tooltip = new b.tooltip.Tooltip(this._style);
						this._ttTarget = null;
						this._ttX = 0;
						this._ttY = 0;
						if (f.isPlatformAvailable()) {
							this.enableAutoTooltips();
						} else {
							f.addEventListener(f.events.PLATFORM_AVAILABLE, function () {
								f._initShadowTree(g._tooltip);
								g.enableAutoTooltips();
							});
						}
					},
					enableAutoTooltips: function () {
						b.tree.tooltipLayer.appendChild(this._tooltip);
						this._tooltip.hide();
						b.rootNode.onMouseOver(this._mouseOverListener);
					},
					disableAutoTooltips: function () {
						b.tree.tooltipLayer.removeChild(this._tooltip);
						b.rootNode.offMouseOver(this._mouseOverListener);
					},
					applyStyle: function (f) {
						this._tooltip.applyStyle(f);
					},
					showTooltip: function (h, g, f, i) {
						this.cancelDismissTooltip();
						this.cancelHideTooltip();
						if (g !== this._tooltipContent) {
							this._tooltip.setContent(g);
						}
						this._tooltip.show();
						this._positionTooltipTo(f, i);
						this.scheduleDismissTooltip();
						this._tooltipContent = g;
					},
					hideTooltip: function () {
						this._tooltip.hide();
					},
					_initMouseListeners: function () {
						var j = this,
						f,
						i,
						g;
						function h(k) {
							var l = null;
							while (k) {
								l = k.getTooltip();
								if (l === null || l === "") {
									k = k.parentNode;
								} else {
									break;
								}
							}
							return k;
						}
						f = function (l) {
							var k = h(l.relatedTarget),
							m = h(l.target);
							if (m && m !== k) {
								m.onMouseMove(g);
								m.onMouseOut(i);
							}
						};
						i = function (k) {
							var l = k.currentTarget,
							m = h(k.relatedTarget);
							if (m !== l) {
								j.cancelShowTooltip();
								j.cancelDismissTooltip();
								j.scheduleHideTooltip();
								l.offMouseMove(g);
								l.offMouseOut(i);
							}
						};
						g = function (k) {
							j._ttTarget = k.currentTarget;
							j._ttX = k.clientX;
							j._ttY = k.clientY;
							j.cancelShowTooltip();
							j.scheduleShowTooltip();
						};
						this._mouseOverListener = f;
					},
					_initCallbacks: function () {
						var f = this;
						this._showTooltipDefaultAction = function (g) {
							var h = g.target.getTooltip();
							f.showTooltip(g.target, h, g.tooltipX, g.tooltipY);
						};
						this._dispatchShowTooltip = function () {
							f._ttTarget.dispatchEvent({
								type: f.events.SHOW_TOOLTIP,
								tooltipX: f._ttX,
								tooltipY: f._ttY,
								cancelable: true,
								defaultAction: f._showTooltipDefaultAction
							});
						};
						this._hideTooltipDefaultAction = function () {
							f.hideTooltip();
						};
						this._dispatchHideTooltip = function () {
							if (f._ttTarget) {
								f._ttTarget.dispatchEvent({
									type: f.events.HIDE_TOOLTIP,
									defaultAction: f._hideTooltipDefaultAction
								});
							}
						};
					},
					scheduleShowTooltip: function () {
						var f = this._properties.showDelay;
						if (f === 0) {
							this._dispatchShowTooltip();
						} else {
							this._showTooltipTimeoutID = setTimeout(this._dispatchShowTooltip, f);
						}
					},
					cancelShowTooltip: function () {
						if (this._showTooltipTimeoutID) {
							clearTimeout(this._showTooltipTimeoutID);
							this._showTooltipTimeoutID = undefined;
						}
					},
					scheduleHideTooltip: function () {
						var f = this._properties.hideDelay;
						if (f === 0) {
							this._dispatchHideTooltip();
						} else {
							this._hideTooltipTimeoutID = setTimeout(this._dispatchHideTooltip, f);
						}
					},
					cancelHideTooltip: function () {
						if (this._hideTooltipTimeoutID) {
							clearTimeout(this._hideTooltipTimeoutID);
							this._hideTooltipTimeoutID = undefined;
						}
					},
					scheduleDismissTooltip: function () {
						var f = this._properties.dismissDelay;
						if (f === 0) {
							this._dispatchHideTooltip();
						} else {
							if (isFinite(f)) {
								this._dismissTooltipTimeoutID = setTimeout(this._dispatchHideTooltip, f);
							}
						}
					},
					cancelDismissTooltip: function () {
						if (this._dismissTooltipTimeoutID) {
							clearTimeout(this._dismissTooltipTimeoutID);
							this._dismissTooltipTimeoutID = undefined;
						}
					},
					_positionTooltipTo: function (f, k) {
						var j = this._tooltip,
						i = this._properties,
						g = {
							x: f,
							y: k
						},
						h;
						j._setTranslation(f + i.cursorOffset, k + i.cursorOffset);
						h = j.getLayoutBounds();
						g = b.geom.getBoundedXY(h, b.viewportBounds, undefined, g);
						if (g.x !== h.x || g.y !== h.y) {
							j._setTranslation(g.x, g.y);
						}
					}
				},
				propertiesDef: {
					showDelay: e.FinitePositiveNumber(200),
					hideDelay: e.FinitePositiveNumber(250),
					dismissDelay: e.PositiveNumber(5000),
					cursorOffset: e.Number(12),
					followCursor: e.Boolean(false)
				},
				styleDef: b.tooltip.Tooltip.StyleDefinition
			});
		}
			());
		(function () {
			b.declare({
				name: "oui.io.JSONExporter",
				membersDef: {
					init: function () {
						this._resources = {};
						this._root = {
							type: "group"
						};
						this._containerHierarchy = [this._root];
						this._curContainer = this._root;
					},
					snapshotNodes: function (p, s, m, o) {
						var r,
						q,
						t;
						if (b.isA(p, Array)) {
							for (q = 0, t = p.length; q < t; q++) {
								this.captureNode(p[q]);
							}
							r = {
								type: "snapshot",
								width: m,
								height: o,
								viewBox: b.geom.isValidRect(s) ? [s.x, s.y, s.width, s.height] : undefined,
								resources: this._captureResources(),
								content: this._root
							};
						}
						return r;
					},
					captureNode: function (m) {
						if (m.jsonNodeExporter !== undefined) {
							m.jsonNodeExporter.captureNode(m, this);
						}
					},
					startNodeExport: function (m) {
						if (this._curContainer.children === undefined) {
							this._curContainer.children = [m];
						} else {
							this._curContainer.children.push(m);
						}
						this._containerHierarchy.push(m);
						this._curContainer = m;
					},
					endNodeExport: function () {
						var m;
						this._containerHierarchy.pop();
						m = this._containerHierarchy.length;
						this._curContainer = this._containerHierarchy[m - 1];
					},
					_DEFAULT_RESOURCE_COMPARE: function (n, m) {
						return n === m;
					},
					getResourceId: function (p, o, t, s) {
						var r = 0,
						m = 0,
						q;
						if (t === undefined) {
							t = this._DEFAULT_RESOURCE_COMPARE;
						}
						if (this._resources[o] === undefined) {
							q = [];
							this._resources[o] = q;
						} else {
							q = this._resources[o];
							for (m = 0, r = q.length; m < r; m++) {
								if (t(q[m], p) === true) {
									break;
								}
							}
						}
						if (m === r) {
							if (typeof s === "function") {
								s(p);
							}
							q.push(p);
						}
						return o.concat(m);
					},
					getImgResourceId: function (m, n) {
						return this.getResourceId({
							type: "imageResource",
							src: m
						}, "image_", function (p, o) {
							return p.src === o.src;
						}, n);
					},
					_captureResources: function () {
						var r = this._resources,
						m = {},
						o,
						s,
						q;
						for (q in r) {
							if (r.hasOwnProperty(q) === true) {
								m[q] = {};
								for (o = 0, s = r[q].length; o < s; o++) {
									m[q][q + o] = this._resourceToJSON(r[q][o]);
								}
							}
						}
						return m;
					},
					_resourceToJSON: function (n) {
						var m = n;
						if (b.isA(n.exportValueToJSON, Function)) {
							m = n.exportValueToJSON(this);
						}
						return m;
					}
				}
			});
			b.graphics.AbstractGraphicNode.prototype.jsonNodeExporter = {
				exportNode: function (u, o, q) {
					var m,
					p = u._style,
					r = u.StyleDefinition.prototype,
					s = u.jsonExportConfig.styleExporter,
					t = u.jsonExportConfig.propertiesExporter;
					for (m in p) {
						if (s.hasOwnProperty(m)) {
							s[m](m, p[m], r[m].defaultValue, o, u, q);
						}
					}
					if (t !== undefined) {
						t(o, u, q);
					}
				},
				captureNode: function (p, o) {
					var m;
					if (p.shouldCapture()) {
						m = {
							type: p.jsonExportConfig.type,
							__node: p
						};
						this.exportNode(p, m, o);
						o.startNodeExport(m);
						this.exportChildren(p, o);
						o.endNodeExport(m);
					}
				},
				exportChildren: function (m, n) {
					var o = m.firstChild;
					while (o) {
						n.captureNode(o);
						o = o.nextSibling;
					}
				}
			};
			var f,
			l,
			j,
			h,
			e,
			k,
			g,
			i;
			f = function (n, m) {
				n.prototype.exportToJSON = m;
			};
			l = function (n, m) {
				n.prototype.exportValueToJSON = m;
			};
			j = function (n, m) {
				var o = n.prototype.jsonExportConfig;
				n.prototype.jsonExportConfig = m;
				if (o !== undefined) {
					b.mixin(m.styleExporter, o.styleExporter);
				}
			};
			b.graphics.AbstractGraphicNode.prototype.shouldCapture = function () {
				return this._style.display && this._style.visibility;
			};
			b.graphics.AbstractPath.prototype.shouldCapture = function () {
				var m = this.getPathCommands();
				return this._style.display && this._style.visibility && m !== null && m.dataTypes.length > 0;
			};
			h = function (o, r, m, p, s, q) {
				if (r !== m) {
					p[o] = r;
				}
			};
			e = function (o, r, m, p, s, q) {
				if (r !== m) {
					p[o] = r.concat();
				}
			};
			k = function (o, r, m, p, s, q) {
				if (r !== m) {
					p[o] = r.exportToJSON(q);
				}
			};
			g = function (r) {
				var o = [],
				m,
				q,
				p,
				s = r.length;
				for (p = 0; p < s; p++) {
					q = r[p];
					m = q.getColor();
					o.push({
						type: "stop",
						offset: q.getOffset(),
						color: m.exportToJSON(),
						opacity: m.getOpacity(),
						origColor: m
					});
				}
				return o;
			};
			i = function (n, m) {
				return n === m || (n._style.color === m._style.color && n._style.opacity === m._style.opacity && n._style.radius === m._style.radius && n._style.angle === m._style.angle && n._style.offset === m._style.offset && n._style.knockout === m._style.knockout);
			};
			j(b.graphics.AbstractGraphicNode, {
				styleExporter: {
					clip: e,
					transform: function (o, r, m, p, s, q) {
						if (!r.isIdentity()) {
							p[o] = r.exportToJSON(q);
						}
					},
					filter: function (o, r, m, p, s, q) {
						if (r !== m) {
							s._updateFilterFX();
							k(o, s._filterFX, m, p, s, q);
						}
					}
				}
			});
			j(b.graphics.Group, {
				type: "group",
				styleExporter: {
					opacity: h
				}
			});
			j(b.graphics.AbstractShape, {
				styleExporter: {
					fill: k,
					fillOpacity: h,
					stroke: k,
					strokeOpacity: h,
					strokeThickness: h,
					strokeLineJoin: h,
					strokeLineCap: h,
					strokeMiterLimit: h,
					htmlExportClassName: h
				}
			});
			j(b.graphics.Ellipse, {
				type: "ellipse",
				styleExporter: {
					cx: h,
					cy: h,
					width: h,
					height: h
				}
			});
			j(b.graphics.Image, {
				type: "image",
				styleExporter: {
					src: function (o, r, m, p, t, q) {
						var s = q.getImgResourceId(r, function (n) {
							n.href = t.toDataURL();
						});
						p[o] = "#" + s;
					},
					x: h,
					y: h,
					width: h,
					height: h
				}
			});
			j(b.graphics.Line, {
				type: "line",
				styleExporter: {
					x1: h,
					y1: h,
					x2: h,
					y2: h
				}
			});
			j(b.graphics.AbstractPath, {
				type: "path",
				propertiesExporter: function (m, o, n) {
					m.pathCommands = o.getPathCommands().exportToJSON(n);
				},
				styleExporter: {}
			});
			j(b.graphics.Rectangle, {
				type: "rect",
				styleExporter: {
					x: h,
					y: h,
					width: h,
					height: h,
					rx: h,
					ry: h
				}
			});
			j(b.graphics.Text, {
				type: "text",
				styleExporter: {
					x: h,
					y: h,
					fontSize: h,
					fontWeight: h,
					fontFamily: h,
					underline: h,
					textAlign: h,
					textValue: h
				}
			});
			j(b.graphics.TextBlock, {
				type: "textBlock",
				styleExporter: {}
			});
			f(b.style.Color, function () {
				return "#".concat(this.hexRGBA);
			});
			f(b.style.GradientPaint, function (m) {
				return "url(#" + m.getResourceId(this, "gradient_") + ")";
			});
			f(b.style.PatternPaint, function (m) {
				m.getImgResourceId(this._properties.src, function (n) {
					var o = n.src;
					n.href = b.resourcesManager._getBase64Data(o) || o;
				});
				return "url(#" + m.getResourceId(this, "pattern_") + ")";
			});
			f(b.style.Paint, function () {
				return "none";
			});
			f(b.filters.AbstractFilter, function (m) {
				return "url(#" + m.getResourceId(this, "filter_") + ")";
			});
			f(b.filters.DropShadow, function (m) {
				return "url(#" + m.getResourceId(this, "filter_", i) + ")";
			});
			l(b.style.LinearGradient, function () {
				var m = this._properties;
				return {
					type: "linearGradient",
					x1: m.x1,
					y1: m.y1,
					x2: m.x2,
					y2: m.y2,
					useObjectBoundingBox: m.useObjectBoundingBox,
					stops: g(m.stops)
				};
			});
			l(b.style.RadialGradient, function () {
				var m = this._properties;
				return {
					type: "radialGradient",
					cx: m.cx,
					cy: m.cy,
					r: m.radius,
					useObjectBoundingBox: m.useObjectBoundingBox,
					stops: g(m.stops)
				};
			});
			l(b.style.PatternPaint, function (m) {
				return {
					type: "pattern",
					width: this._srcW,
					height: this._srcH,
					src: "#" + m.getImgResourceId(this._properties.src),
					origSrc: this._properties.src
				};
			});
			l(b.filters.DropShadow, function () {
				var m = this._style;
				return {
					type: "dropShadow",
					color: m.color.hexRGBA,
					opacity: m.opacity,
					radius: m.radius,
					angle: m.angle,
					offset: m.offset,
					knockout: m.knockout
				};
			});
			l(b.filters.Blur, function () {
				return {
					type: "blur",
					radius: this._style.radius
				};
			});
			f(b.geom.Matrix, function () {
				return [this.a, this.b, this.c, this.d, this.tx, this.ty];
			});
			f(b.graphics.PathCommands, function () {
				return {
					dataTypes: this.dataTypes.concat(),
					dataValues: this.dataValues.concat()
				};
			});
		}
			());
		(function () {
			b.ns("oui.io");
			b.io.XMLConverter = {
				convert: function (f, l) {
					var g,
					j,
					h,
					k,
					e = l;
					if (typeof f === "string") {
						e = e.concat(b.xmlSpecialChars(f));
					} else {
						e = e.concat("<", f.__type);
						g = [];
						if (f.hasOwnProperty("__style")) {
							for (j in f.__style) {
								if (f.__style.hasOwnProperty(j) === true) {
									g.push("".concat(j, ":", f.__style[j], ";"));
								}
							}
							f.style = g.join("");
						}
						g = [];
						for (j in f) {
							if (j !== "children" && j !== "__type" && j !== "__style" && f.hasOwnProperty(j) === true) {
								g.push(" ".concat(j, "='", f[j], "'"));
							}
						}
						if (g.length > 0) {
							g.sort();
							e = String.prototype.concat.apply(e, g);
						}
						if (f.children !== undefined) {
							e = e.concat(">");
							k = f.children.length;
							for (h = 0; h < k; h++) {
								e = b.io.XMLConverter.convert(f.children[h], e);
							}
							e = e.concat("</" + f.__type + ">");
						} else {
							if (f.__type === "div" || f.__type === "style") {
								e = e.concat("></" + f.__type + ">");
							} else {
								e = e.concat(" />");
							}
						}
					}
					return e;
				}
			};
		}
			());
		(function () {
			var u,
			e = 3 * Math.sqrt(2 * Math.PI),
			v = {
				LTR: {
					LINE_BEGIN: "start",
					LINE_END: "end",
					CENTER: "middle",
					JUSTIFY: "start"
				},
				RTL: {
					LINE_BEGIN: "end",
					LINE_END: "start",
					CENTER: "middle",
					JUSTIFY: "start"
				}
			},
			s = {},
			f = {};
			function h(y) {
				if (s[y] === undefined) {
					s[y] = 0;
				} else {
					s[y]++;
				}
				return y + s[y];
			}
			function q(y) {
				return y.substring(0, 7);
			}
			function w(z) {
				var y = z;
				if (z && z.charAt(0) === "#") {
					y = q(z);
				}
				return y;
			}
			function p(z) {
				var y = z.substr(7),
				A = 1;
				if (y !== "FF") {
					A = parseInt(y, 16) / 255;
				}
				return A;
			}
			function m(z) {
				var y = 1;
				if (z && z.charAt(0) === "#") {
					y = p(z);
				}
				return y;
			}
			function r(y) {
				return [parseInt(y.substr(0, 2), 16), parseInt(y.substr(2, 2), 16), parseInt(y.substr(4, 2), 16), parseInt(y.substr(6, 2), 16)];
			}
			function k(z, y) {
				if (z) {
					if (!y.children) {
						y.children = [];
					}
					y.children.push(z);
				}
			}
			function x(y) {
				return (y * 4 - 2) / e;
			}
			function o(z, y, A) {
				return {
					__type: "feFunc" + z,
					type: "linear",
					slope: y,
					intercept: A
				};
			}
			function l(z) {
				var A = {},
				y;
				for (y in z) {
					if (z.hasOwnProperty(y) === true && y !== "children" && y !== "type" && y !== "__node") {
						A[y] = z[y];
					}
				}
				if (z.hasOwnProperty("type") === true) {
					A.__type = z.type;
				}
				return A;
			}
			function t(z) {
				var A = l(z),
				y = A.color;
				A["stop-color"] = q(y);
				delete A.color;
				A["stop-opacity"] = p(y);
				return A;
			}
			function n(z) {
				var B = l(z),
				A = B.stops,
				y,
				C;
				B.gradientUnits = B.useObjectBoundingBox ? "objectBoundingBox" : "userSpaceOnUse";
				delete B.useObjectBoundingBox;
				delete B.stops;
				if (A) {
					for (y = 0, C = A.length; y < C; y++) {
						k(t(A[y]), B);
					}
				}
				return B;
			}
			function j(y) {
				return {
					__type: "filter",
					id: y.id,
					x: "-50%",
					y: "-50%",
					width: "200%",
					height: "200%",
					children: []
				};
			}
			function i(A) {
				var D = l(A),
				z = D.transform,
				C = D.clip,
				B,
				y;
				delete D.clip;
				if (C && C[2] !== -1) {
					y = h("clipPath_");
					B = {
						__type: "clipPath",
						id: y,
						children: [{
								__type: "rect",
								x: C[0],
								y: C[1],
								width: C[2],
								height: C[3]
							}
						]
					};
					D["clip-path"] = "url(#" + y + ")";
					k(B, D);
				}
				if (z) {
					D.transform = "matrix(" + z.join(",") + ")";
				}
				return D;
			}
			function g(A) {
				var B = i(A),
				E = w(B.fill),
				F = m(B.fill),
				y = B.fillOpacity,
				D = w(B.stroke),
				z = B.strokeOpacity,
				C = m(B.stroke);
				if (y === undefined) {
					y = 1;
				}
				y *= F;
				if (z === undefined) {
					z = 1;
				}
				z *= C;
				if (E) {
					B.fill = E;
				}
				if (y !== 1) {
					B["fill-opacity"] = y;
				}
				if (D) {
					B.stroke = D;
				}
				if (z !== 1) {
					B["stroke-opacity"] = z;
				}
				if (B.strokeThickness !== undefined) {
					B["stroke-width"] = B.strokeThickness;
				}
				if (B.strokeLineJoin !== undefined) {
					B["stroke-linejoin"] = B.strokeLineJoin.toLowerCase();
				}
				if (B.strokeLineCap !== undefined) {
					B["stroke-linecap"] = B.strokeLineCap.toLowerCase();
				}
				if (B.strokeMiterLimit !== undefined) {
					B["stroke-miter-limit"] = B.strokeMiterLimit;
				}
				delete B.strokeOpacity;
				delete B.fillOpacity;
				delete B.strokeThickness;
				delete B.strokeLineJoin;
				delete B.strokeLineCap;
				delete B.strokeMiterLimit;
				return B;
			}
			u = {
				radialGradient: n,
				linearGradient: n,
				pattern: function (y) {
					var z = {
						__type: "pattern",
						id: y.id,
						patternUnits: "userSpaceOnUse",
						width: y.width,
						height: y.height,
						children: []
					};
					k({
						__type: "use",
						"xlink:href": y.src,
						width: y.width,
						height: y.height
					}, z);
					return z;
				},
				blur: function (y) {
					var z = j(y);
					k({
						__type: "feGaussianBlur",
						"in": "SourceGraphic",
						stdDeviation: x(y.radius)
					}, z);
					return z;
				},
				dropShadow: function (F) {
					var y = j(F),
					B,
					z,
					D,
					G,
					E,
					A,
					C;
					z = {
						__type: "feComponentTransfer",
						"in": "SourceAlpha",
						result: "compTransfer"
					};
					k(z, y);
					B = r(F.color);
					k(o("R", 0, B[0] / 255), z);
					k(o("G", 0, B[1] / 255), z);
					k(o("B", 0, B[2] / 255), z);
					k(o("A", F.opacity * B[3] / 255, 0), z);
					D = {
						__type: "feGaussianBlur",
						"in": "compTransfer",
						result: "blur",
						stdDeviation: x(F.radius)
					};
					k(D, y);
					A = F.angle * Math.PI / 180;
					C = F.offset;
					G = {
						__type: "feOffset",
						"in": "blur",
						result: "castShadow",
						dx: C * Math.cos(A),
						dy: C * Math.sin(A)
					};
					k(G, y);
					E = {
						__type: "feComposite"
					};
					if (F.knockout === true) {
						E["in"] = "castShadow";
						E.in2 = "SourceGraphic";
						E.operator = "out";
					} else {
						E["in"] = "SourceGraphic";
						E.in2 = "castShadow";
						E.operator = "over";
					}
					k(E, y);
					return y;
				},
				group: function (A) {
					var B = i(A),
					z = A.children,
					y,
					C;
					B.__type = "g";
					if (z !== undefined) {
						for (y = 0, C = z.length; y < C; y++) {
							k(u[z[y].type](z[y]), B);
						}
					} else {
						B = undefined;
					}
					return B;
				},
				ellipse: function (z) {
					var B = g(z),
					A = B.width,
					y = B.height;
					B.rx = A / 2;
					B.ry = y / 2;
					delete B.width;
					delete B.height;
					return B;
				},
				image: function (z) {
					var B = i(z),
					y,
					A;
					y = {
						__type: "use",
						"xlink:href": B.src
					};
					B.__type = "g";
					A = z.__node.getLocalBounds();
					if (B.x !== undefined) {
						y.x = B.x;
					}
					if (B.y !== undefined) {
						y.y = B.y;
					}
					if (A) {
						y.width = A.width;
						y.height = A.height;
					}
					B.children = [y];
					delete B.src;
					delete B.x;
					delete B.y;
					delete B.width;
					delete B.height;
					return B;
				},
				imageResource: function (y) {
					return {
						__type: "symbol",
						id: y.id,
						children: [{
								__type: "image",
								width: "100%",
								height: "100%",
								preserveAspectRatio: "none",
								"xlink:href": y.href
							}
						]
					};
				},
				line: g,
				path: function (z) {
					var A = g(z),
					y = A.pathCommands;
					delete A.pathCommands;
					if (y) {
						A.d = b.graphics.PathCommands.prototype.toString.call(y);
					}
					return A;
				},
				rect: g,
				text: function (z) {
					var A = g(z),
					y = b.layoutDir;
					if (A.fontSize !== undefined) {
						A["font-size"] = A.fontSize;
					}
					if (A.fontWeight === b.FontWeightEnum.BOLD) {
						A["font-weight"] = "bold";
					}
					if (A.underline === true) {
						A["text-decoration"] = "underline";
					}
					delete A.underline;
					if (A.textAlign !== undefined) {
						A["text-anchor"] = v[y][A.textAlign];
					}
					if (A.textValue !== undefined) {
						k(A.textValue, A);
						delete A.textValue;
					}
					if (A.fontFamily !== undefined) {
						A["font-family"] = A.fontFamily;
					}
					A.direction = (y === b.RTL) ? "rtl" : "ltr";
					A["unicode-bidi"] = "embed";
					delete A.fontSize;
					delete A.fontWeight;
					delete A.textAlign;
					delete A.fontFamily;
					return A;
				},
				textBlock: function (B) {
					var y = (B.x !== undefined) ? B.x : 0,
					D,
					A,
					F,
					C,
					E,
					z;
					delete B.textValue;
					delete B.x;
					delete B.y;
					C = B.__node.convertToText();
					F = C.length;
					if (F === 1) {
						D = u.text(B);
						D.__type = "text";
						D.x = y;
						D.y = C[0]._style.y;
						k(C[0]._style.textValue, D);
					} else {
						if (f.noTspan === true) {
							D = {
								__type: "g"
							};
							if (B.transform) {
								D.transform = "matrix(" + B.transform.join(",") + ")";
								delete B.transform;
							}
							for (A = 0; A < F; A++) {
								E = C[A];
								z = u.text(B);
								z.__type = "text";
								z.x = E._style.x;
								z.y = E._style.y;
								k(E._style.textValue, z);
								k(z, D);
							}
						} else {
							D = u.text(B);
							D.__type = "text";
							for (A = 0; A < F; A++) {
								E = C[A];
								z = {
									__type: "tspan",
									x: y,
									y: E._style.y
								};
								k(E._style.textValue, z);
								k(z, D);
							}
						}
					}
					return D;
				}
			};
			b.declare({
				name: "oui.io.svg.SVGExporter",
				membersDef: {
					init: function () {},
					snapshotNodes: function (A, D, y, z, C) {
						var B = new b.io.JSONExporter().snapshotNodes(A, D, y, z);
						s = {};
						f = {
							noTspan: C
						};
						return this._toSVG(B);
					},
					_getSVGBoilerPlate: function () {
						return {
							__type: "svg",
							xmlns: "http://www.w3.org/2000/svg",
							"xmlns:xlink": "http://www.w3.org/1999/xlink",
							stroke: "none",
							fill: "black",
							"fill-rule": "evenodd",
							"font-size": 12,
							"font-family": "Verdana",
							"text-anchor": v[b.layoutDir].LINE_BEGIN,
							children: [{
									__type: "style",
									type: "text/css",
									children: ["text {stroke: none;}"]
								}
							]
						};
					},
					_toSVG: function (I) {
						var H = I.viewBox,
						C,
						G,
						B = I.resources,
						z = I.content.children,
						D,
						A = z ? z.length : 0,
						y,
						F,
						E;
						E = this._getSVGBoilerPlate();
						E.width = I.width;
						E.height = I.height;
						E.viewBox = H.join(" ");
						C = {
							__type: "defs"
						};
						E.children.push(C);
						for (G in B) {
							if (B.hasOwnProperty(G) === true) {
								F = B[G];
								for (y in F) {
									if (F.hasOwnProperty(y)) {
										F[y].id = y;
										this._toSVGNode(F[y], C);
									}
								}
							}
						}
						for (D = 0; D < A; D++) {
							this._toSVGNode(z[D], E);
						}
						return E;
					},
					_toSVGNode: function (z, y) {
						var A = u[z.type];
						if (A) {
							k(A(z), y);
						}
					}
				}
			});
		}
			());
		(function () {
			var j,
			o = "px",
			e = [1, 0, 0, 1, 0, 0];
			function p(q) {
				c.warn("WARN__IO__HTML_FAIL", q.hasOwnProperty("type") ? q.type : q);
			}
			function f(q) {
				return q ? q.y : 0;
			}
			function h(q) {
				return q.substring(0, 7);
			}
			function i(r) {
				var q = r;
				if (r && r.charAt(0) === "#") {
					q = h(r);
				}
				return q;
			}
			function n(r, q) {
				if (r) {
					if (!q.children) {
						q.children = [];
					}
					q.children.push(r);
				}
			}
			function m(r) {
				var s = {},
				q;
				for (q in r) {
					if (r.hasOwnProperty(q) === true && q !== "children" && q !== "type" && q !== "__node") {
						s[q] = r[q];
					}
				}
				if (r.hasOwnProperty("type") === true) {
					s.__type = r.type;
				}
				s.__style = {};
				return s;
			}
			function l(D) {
				var F = D.stops,
				v,
				s,
				r = "",
				B,
				t = "",
				z = "to ",
				y,
				x,
				E,
				A,
				u,
				w,
				C,
				G,
				q;
				if (F && F.length > 1) {
					for (v = 0, s = F.length; v < s; v++) {
						B = F[v];
						r += B.origColor.toString() + " " + Math.round(B.offset * 100) + "%";
						if (v < s - 1) {
							r += ", ";
						}
					}
					x = "background-image: ";
					E = ");";
					if (D.type === "linearGradient") {
						A = "linear-gradient(";
						if (D.x1 < D.x2) {
							t += "left";
							z += "right";
							C = F[0].color;
							G = F[s - 1].color;
							q = 1;
						} else {
							if (D.x1 > D.x2) {
								t += "right";
								z += "left";
								C = F[s - 1].color;
								G = F[0].color;
								q = 1;
							}
						}
						if (D.y1 < D.y2) {
							t += " top";
							z += " bottom";
							C = F[0].color;
							G = F[s - 1].color;
							q = 0;
						} else {
							if (D.y1 > D.y2) {
								t += " bottom";
								z += " top";
								C = F[s - 1].color;
								G = F[0].color;
								q = 0;
							}
						}
					} else {
						A = "radial-gradient(";
						t = "center, ellipse cover";
						z = "ellipse at center";
						C = F[0].color;
						G = F[s - 1].color;
						q = 1;
					}
					w = "progid:DXImageTransform.Microsoft.gradient(";
					u = A + t + ", " + r + E;
					y = x + "-webkit-" + u;
					y += x + "-moz-" + u;
					y += x + "-ms-" + u;
					y += x + "-o-" + u;
					y += '-ms-filter: "' + w + "startColorstr='" + h(C) + "', endColorstr='" + h(G) + "', GradientType=" + q + ')";';
					y += "filter: " + w + "startColorstr='" + h(C) + "', endColorstr='" + h(G) + "', GradientType=" + q + E;
					y += x + A + z + ", " + r + E;
				} else {
					y = "background-color: black;";
				}
				return "." + D.id + "{" + y + "}";
			}
			function k(r) {
				var t = m(r),
				q = t.transform,
				s = t.clip;
				t["class"] = "ouiNodes";
				delete t.clip;
				if (s && s[2] !== -1) {
					p("clip");
				}
				if (q) {
					t.__style.left = q[4] + o;
					t.__style.top = q[5] + o;
				}
				delete t.transform;
				return t;
			}
			function g(q) {
				var r = k(q),
				t,
				s;
				if (q.htmlExportClassName) {
					r["class"] += " " + q.htmlExportClassName;
				} else {
					t = i(r.fill);
					if (t) {
						if (t.indexOf("url(#") === 0) {
							r["class"] += " " + t.substring(5, t.length - 1);
						} else {
							if (q.type === "text" || q.type === "textBlock") {
								r.__style.color = t;
							} else {
								r.__style["background-color"] = t;
							}
						}
					}
					if (r.fillOpacity) {
						p("fill-opacity");
					}
					s = i(r.stroke);
					if (s) {
						r.__style["border-color"] = s;
					}
					if (r.strokeOpacity) {
						p("stroke-opacity");
					}
					if (r.strokeThickness !== undefined) {
						r.__style["border-width"] = r.strokeThickness;
					}
					if (r.strokeLineJoin !== undefined) {
						p("stroke-linejoin");
					}
					if (r.strokeLineCap !== undefined) {
						p("stroke-linecap");
					}
					if (r.strokeMiterLimit !== undefined) {
						p("stroke-miterlimit");
					}
				}
				delete r.htmlExportClassName;
				delete r.fill;
				delete r.stroke;
				delete r.strokeOpacity;
				delete r.fillOpacity;
				delete r.strokeThickness;
				delete r.strokeLineJoin;
				delete r.strokeLineCap;
				delete r.strokeMiterLimit;
				return r;
			}
			j = {
				radialGradient: l,
				linearGradient: l,
				pattern: function (r) {
					var q = "." + r.id + "{ ",
					s = r.origSrc;
					if (b.resourcesManager.hasResource(s)) {
						q += "background-image: url(" + b.resourcesManager._getBase64Data(s) + ");";
					} else {
						p(r);
					}
					q += " }";
					return q;
				},
				blur: p,
				dropShadow: p,
				group: function (s) {
					var t = k(s),
					r = s.children,
					q,
					u;
					t.__type = "div";
					if (r !== undefined) {
						for (q = 0, u = r.length; q < u; q++) {
							n(j[r[q].type](r[q]), t);
						}
					} else {
						t = undefined;
					}
					return t;
				},
				ellipse: p,
				image: function (r) {
					var s = k(r),
					q = r.transform || e;
					s.__type = "img";
					s.src = r.__node.toDataURL();
					if (s.width) {
						s.__style.width = s.width + o;
					}
					if (s.height) {
						s.__style.height = s.height + o;
					}
					if (s.x) {
						s.__style.left = (s.x + q[4]) + o;
					}
					if (s.y) {
						s.__style.top = (s.y + q[5]) + o;
					}
					delete s.x;
					delete s.y;
					delete s.width;
					delete s.height;
					return s;
				},
				imageResource: function () {},
				line: g,
				path: p,
				rect: function (r) {
					var s = g(r),
					q = r.transform || e;
					s.__type = "div";
					s.__style.overflow = "hidden";
					if (s.width) {
						s.__style.width = s.width + o;
					}
					if (s.height) {
						s.__style.height = s.height + o;
					}
					if (s.x) {
						s.__style.left = (s.x + q[4]) + o;
					}
					if (s.y) {
						s.__style.top = (s.y + q[5]) + o;
					}
					delete s.width;
					delete s.height;
					delete s.x;
					delete s.y;
					return s;
				},
				text: function (t) {
					var v = g(t),
					s = b.layoutDir,
					r = t.transform || e,
					u = t.__node._getBBoxImpl(),
					q = (v.x !== undefined) ? v.x : 0,
					w = f(u);
					v.__type = "div";
					v.__style["white-space"] = "pre";
					q += r[4];
					if (s === b.RTL && u) {
						q -= u.width;
					}
					if (q) {
						v.__style.left = q + o;
					}
					if (w) {
						v.__style.top = (w + r[5]) + o;
					}
					if (v.fontFamily !== undefined) {
						v.__style["font-family"] = v.fontFamily;
					}
					if (v.fontSize !== undefined) {
						v.__style["font-size"] = v.fontSize + o;
					}
					if (v.fontWeight === b.FontWeightEnum.BOLD) {
						v.__style["font-weight"] = "bold";
					}
					if (v.underline === true) {
						v.__style["text-decoration"] = "underline";
					}
					if (v.textAlign !== undefined) {
						p("textAlign");
					}
					if (v.textValue !== undefined) {
						n(v.textValue, v);
					}
					v.dir = (s === b.RTL) ? "rtl" : "ltr";
					delete v.x;
					delete v.y;
					delete v.fontFamily;
					delete v.fontSize;
					delete v.fontWeight;
					delete v.underline;
					delete v.textAlign;
					delete v.textValue;
					return v;
				},
				textBlock: function (B) {
					var A = (B.x !== undefined) ? B.x : 0,
					w,
					s,
					y,
					u,
					z,
					v,
					r,
					q = B.transform || e,
					C;
					delete B.textValue;
					delete B.x;
					delete B.y;
					z = B.__node.convertToText();
					u = z.length;
					if (u === 1) {
						w = j.text(B);
						s = z[0]._getBBoxImpl();
						A += q[4];
						if (b.layoutDir === b.RTL && s) {
							A -= s.width;
						}
						w.__style.left = A + o;
						w.__style.top = (f(s) + q[5]) + o;
						n(z[0]._style.textValue, w);
					} else {
						w = {
							__type: "div",
							__style: {
								position: "absolute"
							}
						};
						w.__style.left = q[4] + o;
						w.__style.top = q[5] + o;
						for (y = 0; y < u; y++) {
							v = z[y];
							C = j.text(B);
							r = v._getBBoxImpl();
							C.__style.left = v._style.x + o;
							C.__style.top = f(r) + o;
							n(v._style.textValue, C);
							n(C, w);
						}
					}
					return w;
				}
			};
			b.declare({
				name: "oui.io.html.HTMLExporter",
				membersDef: {
					init: function () {},
					snapshotNodes: function (s, u, q, r) {
						var t = new b.io.JSONExporter().snapshotNodes(s, u, q, r);
						return this._toHTML(t);
					},
					_getHTMLBoilerPlate: function () {
						return {
							__type: "div",
							__style: {
								"font-size": 12,
								"font-family": "Verdana"
							},
							children: [{
									__type: "style",
									type: "text/css",
									children: [".ouiNodes { position: absolute; left: 0px; }"]
								}
							]
						};
					},
					_toHTML: function (A) {
						var v,
						z,
						u = A.resources,
						s = A.content.children,
						w,
						t = s ? s.length : 0,
						q,
						y,
						x;
						x = this._getHTMLBoilerPlate();
						x.__style = {
							width: A.width + o,
							height: A.height + o,
							position: "relative"
						};
						x.dir = (b.layoutDir === b.RTL) ? "rtl" : "ltr";
						v = {
							__type: "style",
							type: "text/css"
						};
						x.children.push(v);
						for (z in u) {
							if (u.hasOwnProperty(z) === true) {
								y = u[z];
								for (q in y) {
									if (y.hasOwnProperty(q)) {
										y[q].id = q;
										this._toHTMLNode(y[q], v);
									}
								}
							}
						}
						for (w = 0; w < t; w++) {
							this._toHTMLNode(s[w], x);
						}
						return x;
					},
					_toHTMLNode: function (r, q) {
						var s = j[r.type];
						if (s) {
							n(s(r), q);
						}
					}
				}
			});
		}
			());
		(function () {
			function e(j, f, i) {
				if (j) {
					if (f === undefined) {
						c.info(i ? "INFO__I18N__MISSING" : "INFO__I18N__INVALID", i);
					} else {
						var g,
						h;
						for (g in f) {
							if (f.hasOwnProperty(g) && f[g]) {
								h = i ? i + "." + g : g;
								if (!j[g]) {
									c.info("INFO__I18N__UNSUPP", h);
								} else {
									if (b.isA(j[g], String)) {
										j[g] = f[g];
									} else {
										e(j[g], f[g], h);
									}
								}
							}
						}
						for (g in j) {
							if (j.hasOwnProperty(g) && (!f.hasOwnProperty(g) || f[g] === undefined)) {
								h = i ? i + "." + g : g;
								c.info("INFO__I18N__MISSING", h);
							}
						}
					}
				}
			}
			b.addI18nSupport = function (g, f) {
				g.Resources = f;
				g.prototype.Resources = f;
				g.updateResources = function (h) {
					var j = this.Resources,
					i = this.prototype;
					if (i !== undefined && i.Resources !== undefined) {
						j = i.Resources;
					}
					if (h !== undefined) {
						e(j, h);
					}
				};
			};
		}
			());
		(function () {
			b.ns("oui.net");
			b.mixin(b.net, {
				goToURL: function (e, f) {
					c.warn("WARN__NET__UNSUPP");
				}
			});
		}
			());
		(function () {
			b.mixin(b.net, {
				goToURL: function (e, f) {
					window.open(e, f);
				}
			});
		}
			());
		return b;
	}
	ouilib = {
		createLiveGraphics: function (b, d) {
			var c = {};
			c.aboutInfo = "FortKnox1.0#8348/SVG (c)2008-2014, Oracle Corp.";
			if (d !== undefined && d !== null) {
				c.config = d;
				if (d.name && c.aboutInfo) {
					c.aboutInfo = d.name + " _ " + c.aboutInfo;
				}
			}
			a(c);
			c.setUp(b);
			return c;
		}
	};
}
	());
(function (h, c) {
	var a = {
		version: "23.1.0",
		build: "23.1.0-1379-g0592a852"
	};
	a.$ = a.$ || jQuery;
	a.RTree = a.RTree || RTree;
	a.Hammer = a.Hammer || Hammer;
	a.layer = a.layer || {};
	a.filter = a.filter || {};
	a.style = a.style || {};
	a.util = a.util || {};
	a.wmts = a.wmts || {};
	a.proj = a.proj || {};
	a.event = a.event || {};
	a.geometry = a.geometry || {};
	a.universe = a.universe || {};
	a.visualfilter = a.visualfilter || {};
	a.infowindow = a.infowindow || {};
	a.tool = a.tool || {};
	a.control = a.control || {};
	a.template = a.template || {};
	a.lbs = a.lbs || {};
	a.edit = a.edit || {};
	a.server = a.server || {};
	a.Class = a.Class || function () {};
	(function () {
		if (!a.Class.extend) {
			var d = !1;
			a.Class.extend = function (e) {
				function f() {
					!d && this.initialize && this.initialize.apply(this, arguments)
				}
				var g = this.prototype;
				d = !0;
				var k = new this;
				d = !1;
				e.mixin && (a.util.MiscUtil.mixin(k, e.mixin), delete e.mixin);
				var n = null,
				u = null,
				C;
				for (C in e)
					n = e[C], u = g[C], "function" === typeof n && "function" === typeof u && n !== u && (n.base = u), k[C] = n;
				f.prototype = k;
				f.prototype.constructor = f;
				f.extend = arguments.callee;
				return f
			}
		}
	})();
	a.setJQuery = function (d) {
		d &&
		(a.$ = d)
	};
	a.setRTree = function (d) {
		a.RTree = d
	};
	a.setHammer = function (d) {
		a.Hammer = d
	};
	a.notNull = function (a) {
		return "undefined" !== typeof a && null !== a
	};
	a.isNotNull = a.notNull;
	a.isNull = function (a) {
		return "undefined" === typeof a || null === a
	};
	a.isUndefined = a.isNull;
	(function (a) {
		var e = navigator.userAgent.toLowerCase(),
		f = /webkit/.test(e),
		g = "undefined" !== typeof orientation ? !0 : !1,
		k = /android/.test(e),
		n = /chrome/.test(e),
		u = /firefox/.test(e),
		C = /(mozilla)(?:.*? rv:([\w.]+))?/.test(e),
		L = /(opera)(?:.*version)?[ \/]([\w.]+)/.test(e),
		P = /(msie) ([\w.]+)/.test(e);
		a.browser = {
			msie: P,
			msie6: P && !h.XMLHttpRequest,
			mozilla: C,
			webkit: f,
			safari: f,
			firefox: u,
			webkit3d: f && "WebKitCSSMatrix" in h && "m11" in new h.WebKitCSSMatrix,
			chrome: n,
			gecko: -1 !== e.indexOf("gecko"),
			opera: L,
			android: k,
			mobileWebkit: g && f,
			mobileOpera: g && L,
			mobile: g,
			touchSupported: "ontouchstart" in h || h.DocumentTouch && document instanceof DocumentTouch
		};
		a.browser.android && (a.browser.androidVersion = parseFloat((e.match(/.+(?:android)[\/: ]([\d.]+)/) || [0, 0])[1]))
	})(a);
	a.MapContext = function (d) {
		var e =
			d.getMapContextToken();
		return {
			getUniverse: function () {
				return e.universe
			},
			getPreviousZoomLevel: function () {
				return e.previousZoomLevel
			},
			getZoomLevel: function () {
				return e.zoomLevel ? e.zoomLevel : 0
			},
			getPreviousCenterPoint: function () {
				return e.previousCenterPoint
			},
			getCenterPoint: function () {
				return e.centerPoint
			},
			getTransform: function () {
				if (!e.transform) {
					var d = e.universe.getZoomLevels()[e.zoomLevel],
					g = this.getDeviceWidth() * d.resolution,
					d = this.getDeviceHeight() * d.resolution * d.stretchRatio,
					g = {
						x: e.centerPoint.getX() -
						g / 2,
						y: e.centerPoint.getY() - d / 2,
						w: g,
						h: d
					},
					d = {
						x: 0,
						y: 0,
						w: this.getDeviceWidth(),
						h: this.getDeviceHeight()
					};
					e.transform = new a.util.ScreenTransform(g, d)
				}
				return e.transform
			},
			getDeviceWindow: function () {
				return e.deviceWindow
			},
			getDeviceWidth: function () {
				return e.deviceWindow.w
			},
			getDeviceHeight: function () {
				return e.deviceWindow.h
			},
			getQueryWindow: function () {
				var d = e.universe.getZoomLevels()[e.zoomLevel],
				g = e.centerPoint.getX(),
				k = e.centerPoint.getY();
				return new a.geometry.Rectangle(g - e.deviceWindow.w * d.resolution / 2,
					k - e.deviceWindow.h * d.resolution * d.stretchRatio / 2, g + e.deviceWindow.w * d.resolution / 2, k + e.deviceWindow.h * d.resolution * d.stretchRatio / 2, e.universe.getSRID())
			},
			getGraphics: function () {
				return e.graphics
			},
			getRoundMapCenterPoint: function () {
				return e.roundMapCenterPoint
			},
			getWholeMapNum: function () {
				var a = e.universe.getZoomLevels()[e.zoomLevel],
				g = e.centerPoint.getX(),
				k = e.universe.getMapBounds().getWidth(),
				a = Math.ceil((g + e.deviceWindow.w / 2 * a.resolution - (g - e.deviceWindow.w / 2 * a.resolution)) / k) + 1;
				!1 === d.wraparound &&
				(a = 1);
				return a
			},
			getBaseWholeMapIndex: function () {
				var a = e.universe.getZoomLevels()[e.zoomLevel],
				d = e.centerPoint.getX(),
				k = e.universe.getMapBounds().getWidth(),
				a = d - e.deviceWindow.w / 2 * a.resolution,
				d = this.getWholeMapNum();
				if (1 == d)
					return 0;
				for (var n = 0, u = 0; u < d; u++)
					a + k * u >= -k / 2 && a + k * u <= k / 2 && (n = u);
				return n
			}
		}
	};
	a.Messages = a.Messages || {};
	a.Messages.map = {};
	a.Messages.getErrorMessage = function (d) {
		var e = a.Messages.map[d];
		return e ? d + ": " + e : d
	};
	a.Messages.getString = function (d) {
		return (d = a.Messages.map[d]) ? d : ""
	};
	var b =
		a.Messages.map;
	b.MAPVIEWER_9001 = "Map tile layer not found. Check map tile layer name and/or data source name.";
	b.MAPVIEWER_9002 = "Register theme failed.";
	b.MAPVIEWER_9002 = "Failed to register a theme.";
	b.MAPVIEWER_9003 = "Error when loading Nokia map lib.";
	b.MAPVIEWER_9004 = "Please provide TomTom map API key.";
	b.MAPVIEWER_9005 = "Feature ID is already used, please pick a new ID.";
	b.MAPVIEWER_9006 = "Error occurred when sending request to data server.";
	b.MAPVIEWER_9007 = "Cannot get data from data server.";
	b.MAPVIEWER_9008 =
		"Error occurred when getting RSS feed";
	b.MAPVIEWER_9009 = "Error occurred when sending request to map cache server.";
	b.MAPVIEWER_9010 = "Unsupported editing geometry.";
	b.MAPVIEWER_9011 = "A line needs at least 2 shape points.";
	b.MAPVIEWER_9012 = "A polygon needs at least 3 shape points.";
	b.MAPVIEWER_9013 = "Error occurred when parsing JSON format data.";
	b.MAPVIEWER_9014 = "Error occurred when sending HTTP request.";
	b.MAPVIEWER_9015 = "Not a valid line or polygon type.";
	b.MAPVIEWER_9016 = "Error occurred when calculating length in server side.";
	b.MAPVIEWER_9017 = "Not a geodetic point.";
	b.MAPVIEWER_9018 = "One or more parameter is missing or invalid.";
	b.MAPVIEWER_9019 = "Geometry SRID is null.";
	b.MAPVIEWER_9020 = "Invalid URL.";
	b.MAPVIEWER_9021 = "Cannot undo.";
	b.MAPVIEWER_9022 = "Cannot redo.";
	b.MAPVIEWER_9023 = "Cannot load style.";
	b.MAPVIEWER_9024 = "Either a base marker or a set of marker styles must be specified.";
	b.MAPVIEWER_9025 = "Must specify either a baseColor or a pair of fromColor and toColor.";
	b.MAPVIEWER_9026 = "Invalid classification specified.";
	b.MAPVIEWER_9027 = "Generating buckets.";
	b.MAPVIEWER_9028 = "Buckets exist, but classification is not 'custom'.";
	b.MAPVIEWER_9029 = "No styles found in the options.";
	b.MAPVIEWER_9030 = "Styles and buckets must be arrays of the same length.";
	b.MAPVIEWER_9031 = "Cannot switch tile layer.";
	b.MAPVIEWER_9032 = "Error when calling event listener.";
	b.MAPVIEWER_9033 = "SRID is different.";
	b.MAPVIEWER_9034 = "No valid URL in selected text.";
	b.MAPVIEWER_9036 = "A subclass must implement the method: start";
	b.MAPVIEWER_9037 = "A subclass must implement the method: clear";
	b.MAPVIEWER_9038 = "Please select exactly one polygon feature first.";
	b.MAPVIEWER_9039 = "Invalid zoom level number.";
	b.MAPVIEWER_9040 = "You are running in SVG mode. To get map image, please include canvg.js(http://code.google.com/p/canvg/), or switch to canvas mode.";
	b.MAPVIEWER_9041 = "localStorage is not supported in your browser.";
	b.MAPVIEWER_9042 = "Must specify style attributes for bucket style.";
	b.MAPVIEWER_9043 = "Cannot load NSDP data from the specified URL.";
	b.MAPVIEWER_9044 = "Cannot find the tiles folder. ";
	b.MAPVIEWER_9045 = "The end point should not be the same with the start point.";
	b.MAPVIEWER_9046 = "Not a valid geometry for this method.";
	b.MAPVIEWER_9047 = "Error occurred when calculating area in server side.";
	b.MAPVIEWER_9048 = "Toolbar ID is already used, please pick a new ID.";
	b.MAPVIEWER_9049 = "Cannot load bounding box from vector layer.";
	b.MAPVIEWER_9050 = "Invalid map container div size encountered.";
	b.MAPVIEWER_9051 = "Invalid binding: missing instance of Formatter.";
	b.MAPVIEWER_9052 = "JDBC or predefined layer must define key column, base table and geomerty column for editing.";
	b.MAPVIEWER_9053 = "JDBC or predefined layer cannot have ROWID as key column for editing.";
	b.MAPVIEWER_9054 = "Tool operation requires an editable feature.";
	b.MAPVIEWER_9055 = "Invalid feature geometry type for this operation.";
	b.MAPVIEWER_9056 = "Save option not available for this type of Vector layer. Implement your own save method.";
	b.MAPVIEWER_9057 = "Unable to save vector layer changes.";
	b.MAPVIEWER_9058 = "Vector layer changes have been saved.";
	b.MAPVIEWER_9059 = "Invalid number.";
	b.MAPVIEWER_9060 = "Attribute value is null.";
	b.MAPVIEWER_9061 = "Unable to find geometry element.";
	b.MAPVIEWER_9062 = "Unable to remove geometry element.";
	b.MAPVIEWER_9063 = "Unable to clone geometry element.";
	b.MAPVIEWER_9064 = "UTFGrid's URL not specified.";
	b.MAPVIEWER_9065 = "Failed fetching UTFGrid data.";
	b.MAPVIEWER_9066 = "WMSTileLayer's wmsServer URL not specified.";
	b.MAPVIEWER_9067 = "WMSTileLayer's layers not specified.";
	b.MAPVIEWER_9068 = "WMSTileLayer's WMS version not specified.";
	b.MAPVIEWER_9069 = "WMSTileLayer's additional parameters need to be specified in 'options' property.";
	b.MAPVIEWER_9070 = "DynamicTileLayer's additional parameters need to be specified in 'options' property.";
	b.MAPVIEWER_9071 = "No themes were found in the 'options' property for DynamicTileLayer.";
	b.MAPVIEWER_9072 = "DynamicTileLayer has no universe defined; Elocation universe is assigned.";
	b.MAPVIEWER_9073 = "Map marker position (x,y) is invalid.";
	b.MAPVIEWER_9074 = "HRER map or default layer instance is not defined.";
	b.MAPVIEWER_9075 = "Dynamic tile layer 'tileServerURL' value needs to end with '/omserver'.";
	b.MAPVIEWER_9076 = "Dynamic tile layer 'tileServerURL' substring '/mcserver' is replaced by '/omserver'.";
	b.MAPVIEWER_9077 = "Failed to create 'H.service.Platform' instance.";
	b.MAPVIEWER_9078 = "Failed to create 'H.Map' instance.";
	b.MAPVIEWER_9079 = "Failed to create 'H.mapevents.MapEvents' or 'H.mapevents.Behavior' instance.";
	b.MAPVIEWER_9080 = "Failed to retrieve UTFGrid data.";
	b.MAPVIEWER_9081 = "Failed to get all UTFGrid and info window enabled layer attributes.";
	b.MAPVIEWER_9082 = "Error occurred when parsing XMLMapRequest string into JSON object.";
	b.MAPVIEWER_9083 = "ServerJDBCTheme will send a large number of non-reusable SQL queries to the database. It is recommended to use ServerPredefinedTheme instead.";
	b.MAPVIEWER_9084 = "Failed to get map context.";
	b.MAPVIEWER_9085 = "A theme already existed.";
	b.MAPVIEWER_9086 = "A style already existed.";
	b.MAPVIEWER_9087 = "The input is not a JSON theme object.";
	b.MAPVIEWER_9088 = "The parameter is not a JSON array.";
	b.MAPVIEWER_9089 = "The input style is not a JSON object.";
	b.MAPVIEWER_9090 = "The parameter is not a string.";
	b.MAPVIEWER_9091 = "The requested theme not found.";
	b.MAPVIEWER_9092 = "The theme name is not specified.";
	b.MAPVIEWER_9093 = "Binding parameter's 'value' or 'type' is not defined.";
	b.MAPVIEWER_9094 = "The input parameter is empty or invalid.";
	b.MAPVIEWER_9095 = "Failed to retrieve theme's name.";
	b.MAPVIEWER_9096 = "Buckets are not provided for the given 'custom' classification (classification\x3d'custom') option.";
	b.MAPVIEWER_9097 = "A tile URL template must contain {z}, {x}, {y} to be replaced by tile's zoom level and tile coordinates (x,y).";
	b.MAPVIEWER_9098 = "A valid template array should have two elements. For example, ['http://my.com/a/b/{z}/{x}/{y}.png?foo\x3d{foo}', {foo: 'bar'}]";
	b.MAPVIEWER_9099 = "Data source not specified.";
	b.MAPVIEWER_9100 = "Tile server URL not specified.";
	b.MAPVIEWER_9101 = "Error occurred when parsing geoJson data.";
	b.MAPVIEWER_9102 = "Layer name is already used, please pick a different name.";
	b.MAPVIEWER_9103 = "The utfgrid html array has not be instantiated.";
	b.MAPVIEWER_9104 = "No valid datasource was found.";
	b.MAPVIEWER_9105 =
		"Map is displayed in 'wraparound' mode. It does not allow editing.";
	b.MAPVIEWER_9106 = "Marker path definition has too few points.";
	b.MAPVIEWER_9107 = "Failed to get the base URL.";
	b.MAPVIEWER_9200 = "Sub string not found.";
	b.MAPVIEWER_9201 = "This type of tile layer is no longer supported.";
	b.MAPVIEWER_WB_TTILE = "Add Text";
	b.MAPVIEWER_WB_TEXT = "Text";
	b.MAPVIEWER_WB_X = "Orientation value X axis";
	b.MAPVIEWER_WB_Y = "Y axis";
	b.MAPVIEWER_WB_BOLD = "Bold";
	b.MAPVIEWER_WB_ITALIC = "Italic";
	b.MAPVIEWER_WB_ALIGN_LEFT = "left align format";
	b.MAPVIEWER_WB_ALIGN_CENTER = "center align format";
	b.MAPVIEWER_WB_ALIGN_RIGHT = "right align format";
	b.MAPVIEWER_WB_VALIGN_TOP = "top align vertical format";
	b.MAPVIEWER_WB_VALIGN_CENTER = "center align vertical format";
	b.MAPVIEWER_WB_VALIGN_BOTTOM = "bottom align vertical format";
	b.MAPVIEWER_WB_OK = "OK";
	b.MAPVIEWER_WB_PREVIEW = "Preview";
	b.MAPVIEWER_LC_TITLE = "Vector Layer List";
	b.MAPVIEWER_TB_TIP_CLEAR = "clear";
	b.MAPVIEWER_TB_TIP_CIRCLE = "circle";
	b.MAPVIEWER_TB_TIP_RECTANGLE = "rectangle";
	b.MAPVIEWER_TB_TIP_REDLINE =
		"redline";
	b.MAPVIEWER_TB_TIP_DISTANCE = "distance";
	b.MAPVIEWER_TB_TIP_ZOOM = "zoom";
	b.MAPVIEWER_SB_KILOMETERS = "km";
	b.MAPVIEWER_SB_METERS = "m";
	b.MAPVIEWER_SB_MILES = "mi";
	b.MAPVIEWER_SB_FEET = "ft";
	b.MAPVIEWER_SB_CENTIMETER = "cm";
	b.MAPVIEWER_SB_YARD = "yd";
	b.MAPVIEWER_SB_TOTAL_DISTANCE = "Total Distance";
	b.MAPVIEWER_SB_SUB_DISTANCE = "Sub Distance";
	b.MAPVIEWER_WB_UPDATE = "Update";
	b.MAPVIEWER_WB_CANCEL = "Cancel";
	b.MAPVIEWER_WB_PROPERTIES = "Properties";
	b.MAPVIEWER_WB_GEOM_PROPERTIES = "Geometry Properties";
	b.MAPVIEWER_WB_DIMENSION =
		"Dimension";
	b.MAPVIEWER_WB_ORIENTATION = "Orientation";
	b.MAPVIEWER_WB_DELETE = "Delete";
	b.MAPVIEWER_WB_DELETE_ELEMENT = "Delete Element";
	b.MAPVIEWER_WB_UNGROUP_ELEMENT = "Ungroup Element";
	a.CursorTypes = {
		AUTO: "AUTO",
		MOVE: "MOVE",
		POINTER: "POINTER",
		DEFAULT: "DEFAULT",
		TEXT: "TEXT",
		WAIT: "WAIT",
		NONE: "NONE",
		CUSTOM: "CUSTOM"
	};
	a.LayerTypes = {
		TILE: 0,
		VECTOR: 1,
		EXTERNAL: 2,
		DYNAMIC_TILE: 3,
		WMTS_TILE: 4
	};
	a.LineCaps = {
		BUTT: "BUTT",
		ROUND: "ROUND",
		SQUARE: "SQUARE"
	};
	a.LineJoins = {
		MITER: "MITER",
		ROUND: "ROUND",
		BEVEL: "BEVEL"
	};
	a.GeomTypes = {
		POINT: "Point",
		MULTIPOINT: "MultiPoint",
		ORIENTEDPOINT: "OrientedPoint",
		ORIENTEDMULTIPOINT: "OrientedMultiPoint",
		LINESTRING: "LineString",
		MULTILINESTRING: "MultiLineString",
		POLYGON: "Polygon",
		MULTIPOLYGON: "MultiPolygon",
		CIRCLE: "Circle",
		RECTANGLE: "Rectangle",
		GEOMETRYCOLLECTION: "GeometryCollection"
	};
	a.Text = {
		FONTSTYLE_NORMAL: "NORMAL",
		FONTSTYLE_ITALIC: "ITALIC",
		FONTWEIGHT_NORMAL: "NORMAL",
		FONTWEIGHT_BOLD: "BOLD",
		HORIZONTALALIGN_LEFT: "LEFT",
		HORIZONTALALIGN_CENTER: "CENTER",
		HORIZONTALALIGN_RIGHT: "RIGHT",
		VERTICALALIGN_TOP: "TOP",
		VERTICALALIGN_CENTER: "CENTERV",
		VERTICALALIGN_BOTTOM: "BOTTOM"
	};
	a.PaintTypes = {
		NO_PAINT: 0
	};
	a.gv = a.gv || {};
	a.gv.proxyPath = "/mapviewer/proxy";
	a.gv.setProxyPath = function (d) {
		d && (a.gv.proxyPath = d)
	};
	a.gv.getProxyPath = function () {
		return a.gv.proxyPath
	};
	a.gv.setCoordinateDecimals = function (d) {
		a.gv.decimals = d
	};
	a.gv.getCoordinateDecimals = function () {
		return a.gv.decimals
	};
	a.gv.proxyEnabled = !1;
	a.gv.enableProxy = function (d) {
		null !== d && (a.gv.proxyEnabled = d)
	};
	a.gv.isProxyEnabled = function () {
		return a.gv.proxyEnabled
	};
	a.gv._baseURL =
		document.location.protocol + "//" + document.location.host + "/mapviewer";
	a.gv.localbaseURL = function () {
		return a.gv._baseURL
	};
	a.gv.setBaseMapViewerURL = function (d) {
		a.gv._baseURL = d
	};
	a.gv.getBaseMapViewerURL = function () {
		return a.gv._baseURL
	};
	a.gv.defaultDataSource = null;
	a.gv._resPath = document.location.protocol + "//" + document.location.host + "/mapviewer/jslib/v2/images/";
	a.gv._cssResPath = document.location.protocol + "//" + document.location.host + "/mapviewer/jslib/v2/css/";
	a.gv._protoPath = document.location.protocol + "//" +
		document.location.host + "/mapviewer/jslib/v2/protobuf/";
	a.gv.getImgResourcePath = function () {
		return a.gv._resPath
	};
	a.gv.resourcePath = a.gv.getImgResourcePath;
	a.gv.getCSSResourcePath = function () {
		return a.gv._cssResPath
	};
	a.gv.getProtoResourcePath = function () {
		return a.gv._protoPath
	};
	a.gv.cssResourcePath = a.gv.getCSSResourcePath;
	a.gv.setResourcePath = function (d) {
		d && (0 > d.indexOf("/", d.length - 1) && (d += "/"), a.gv._cssResPath = d + "css/", a.gv._resPath = d + "images/", a.gv._protoPath = d + "protobuf/", a.gv.messagePath = d + "messages/",
			a.control.MapDecoration.setIconsPath(), a.tool.WhiteBoardTool && a.tool.WhiteBoardTool.setIconsPath())
	};
	a.gv._secureHttp = document.location.protocol;
	"file:" === a.gv._secureHttp && (a.gv._secureHttp = "http:");
	a.gv.secureHttp = function () {
		return a.gv._secureHttp
	};
	a.gv.setSecureHttp = function (d) {
		a.gv._secureHttp = d ? "https:" : "http:"
	};
	a.gv.useSecureHTTP = function (d) {
		a.gv._secureHttp = d ? "https:" : "http:"
	};
	a.gv.isSecureHTTPEnabled = function () {
		return "https:" === a.gv._secureHttp
	};
	a.gv.disableServerMessageFiles = function () {};
	a.gv.anonymousTileImages = !1;
	a.gv.setAnonymousTileImages = function (d) {
		var e = a.gv.anonymousTileImages;
		a.gv.anonymousTileImages = d;
		return e
	};
	a.gv.isAnonymousTileImages = function () {
		return a.gv.anonymousTileImages
	};
	a.gv.CacheConfig = Array(30);
	a.gv.infoWindowWidth = 180;
	a.gv.infoWindowHeight = 100;
	a.gv.infoWindowTabsWidth = 240;
	a.gv.infoWindowTabsHeight = 130;
	a.gv.decorationCollapseButtonSizeTouch = 24;
	a.gv.decorationCollapseButtonSizeNoTouch = 18;
	a.gv.searchTolerance = {
		value: 5,
		unit: "px"
	};
	a.gv.snapTolerance = {
		value: 5,
		unit: "px"
	};
	a.gv.unitFactors = {
		SQ_MM: 1E-6,
		SQ_KILOMETER: 1E6,
		SQ_CENTIMETER: 1E-4,
		SQ_MILLIMETER: 1E-6,
		SQ_CH: 404.6856,
		SQ_FT: .09290304,
		SQ_IN: 6.4516E-4,
		SQ_LI: .04046856,
		SQ_CHAIN: 404.6856,
		SQ_FOOT: .09290304,
		SQ_INCH: 6.4516E-4,
		SQ_LINK: .04046856,
		SQ_MILE: 2589988,
		SQ_ROD: 25.29285,
		SQ_SURVEY_FOOT: .09290341,
		SQ_YARD: .8361274,
		ACRE: 4046.856,
		HECTARE: 1E4,
		PERCH: 25.29285,
		ROOD: 1011.714,
		M: 1,
		METER: 1,
		METRE: 1,
		KM: 1E3,
		KILOMETER: 1E3,
		CM: .01,
		CENTIMETER: .01,
		MM: .001,
		MILLIMETER: .001,
		MILE: 1609.344,
		NAUT_MILE: 1852,
		SURVEY_FOOT: .3048006096012,
		FOOT: .3048,
		"U.S FOOT": .3048,
		FEET: .3048,
		INCH: .0254,
		YARD: .9144,
		CHAIN: 20.1168,
		ROD: 5.0292,
		LINK: .201166195,
		MOD_USFT: .304812253,
		CL_FT: .304797265,
		IND_FT: .304799518,
		LINK_BEN: .201167651,
		LINK_SRS: .201167651,
		CHN_BEN: 20.1167825,
		CHN_SRS: 20.1167651,
		IND_YARD: .914398554,
		SRS_YARD: .914398415,
		FATHOM: 1.8288,
		SQ_M: 1,
		SQ_METER: 1,
		SQ_KM: 1E6,
		SQ_CM: 1E-4
	};
	a.gv.toolButtonW = 14;
	a.gv.toolButtonH = 14;
	a.gv.DPI = 96;
	a.gv.getUnitFactor = function (d) {
		if (d)
			d = d.toUpperCase();
		else
			return 0;
		return a.gv.unitFactors[d] ? a.gv.unitFactors[d] : 0
	};
	a.gv.defaultMarkerStyleWidth =
		15;
	a.gv.defaultMarkerStyleHeight = 15;
	a.gv.defaultMarkerStyle = {
		fill: "#ff2244",
		stroke: "#ff2244",
		strokeThickness: 1,
		fillOpacity: .5
	};
	a.gv.loadingIcon = "o_loading.gif";
	a.gv.defaultTextStyleConfig = {
		fontSize: 12,
		fill: "#ff0000"
	};
	a.gv.labelDisplayOrder = ["R", "L", "B", "T"];
	a.gv.orientedLabelDisplayOrder = ["R", "L"];
	a.gv.mapInstanceId = 0;
	a.gv.enableSelfDestroy = !0;
	a.gv.mapInstances = [];
	a.gv.mvKeyMap = [];
	a.gv.clearMapInstanceByDiv = function (d) {
		for (var e = a.gv.mapInstances, f = e.length, g = 0; g < f; g++) {
			var k = e[g];
			if (k && k.$containerDiv) {
				var n =
					k.$containerDiv[0];
				if (n === d)
					k.destroyMap();
				else {
					for (var u = !1; n && n.parentNode; )
						if (n = n.parentNode, n === document.body) {
							u = !0;
							break
						}
					u || k.destroyMap()
				}
			}
		}
	};
	a.gv.addMapInstance = function (d, e) {
		a.gv.enableSelfDestroy && a.gv.clearMapInstanceByDiv(e);
		a.gv.mapInstances.push(d)
	};
	a.gv.addCSTransformFunction = function (d, e, f) {
		a.util.CSTransformUtil.addCSTransformFunction(d, e, f)
	};
	a.gv.srs = {};
	a.gv.addSRS = function (d, e, f) {
		a.gv.srs[f] = {
			type: d,
			unit: e,
			srid: f
		}
	};
	a.gv.getSRS = function (d) {
		return a.gv.srs[d]
	};
	a.gv.clearAllMapInstance =
	function () {
		if (a.notNull(a.gv.mapInstances))
			for (var d = a.gv.mapInstances; 0 < d.length; ) {
				var e = d.pop();
				e.over || e.destroyMap()
			}
	};
	a.gv.messagePath = "/mapviewer/jslib/v2/messages/";
	a.gv.msgLoaded = !1;
	a.gv.loadMessage = function () {
		a.gv.msgLoaded = !0
	};
	a.$(h).on("unload", function () {
		a.gv.clearAllMapInstance()
	});
	a.browser.msie && (document.msCSSOMElementFloatMetrics = !0);
	a.gv.getLabel = function (d, e) {
		var f = a.Messages.getString(d);
		e && (f = f.replace(/\s/g, "\x26nbsp;"));
		return f
	};
	a.gv.setHttpMethod = function (d) {
		d && "GET" === d.toUpperCase() ?
		a.gv._httpMethod = "GET" : a.gv._httpMethod = "POST"
	};
	a.gv.setHttpMethod("POST");
	a.gv.isWin8Touch = !1;
	h.navigator.msMaxTouchPoints && h.navigator.msPointerEnabled && (a.gv.isWin8Touch = !0);
	a.gv.setLogLevel = function (d) {
		a.isNull(d) || (d = d.toLowerCase(), d = a.util.Logger.LEVELS[d], a.isNull(d) ? a.util.Logger.warning(null, "OM.gv.setLogLevel", "Invalid log level specified.") : a.util.Logger.currentLevel = d)
	};
	a.gv.getLogLevel = function () {
		return a.isNull(a.util.Logger.currentLevel) ? "" : a.util.Logger.LEVELS_TEXT[a.util.Logger.currentLevel]
	};
	a.gv.showManipulator = !0;
	a.gv.setShowManipulator = function (d) {
		a.gv.showManipulator = d ? !0 : !1
	};
	a.gv.featureDrag = !0;
	a.gv.enableFeatureDragging = function (d) {
		a.gv.featureDrag = d ? !0 : !1
	};
	a.gv.progressBarDisabled = !1;
	a.gv.disableProgressBar = function (d) {
		a.gv.progressBarDisabled = !0 === d ? !0 : !1
	};
	a.gv.featureDragDisabled = function (d) {
		var e = "Point" === d.geo.type || "OrientedPoint" === d.geo.type;
		return a.isNull(d.parentFeature) && !e && !a.gv.featureDrag
	};
	a.gv.internalLayersEnabled = !0;
	a.gv.useRTree = !0;
	a.gv.setUseRTree = function (d) {
		d &&
		(a.gv.useRTree = d)
	};
	a.gv.getUseRTree = function () {
		return a.gv.useRTree
	};
	a.gv.touchMoveThreshold = 5;
	a.gv.setTouchMoveThreshold = function (d) {
		0 <= d && (a.gv.touchMoveThreshold = d)
	};
	a.gv.allowFeaturePointsInteraction = !0;
	a.gv.MAX_ZOOM = "MAX_ZOOM";
	a.gv.MID_ZOOM = "MID_ZOOM";
	a.gv.pointZoomLevel = a.gv.MID_ZOOM;
	a.gv.isTestEnvironment = !1;
	a.gv.decimals = 6;
	String.prototype.replaceAll || (String.prototype.replaceAll = function (a, e) {
		return this.split(a).join(e)
	});
	a.Graphics = function (d, e) {
		this.div = d;
		var f = a.$(this.div);
		this.width =
			f.width();
		this.height = f.height();
		a.notNull(e) && (this.hiDPI = e.hiDPI, this.mapInstanceId = e.mapInstanceId);
		this.oui = ouilib.createLiveGraphics(this.div, {
			defaultViewportWidth: this.width,
			defaultViewportHeight: this.height,
			hiDPI: this.hiDPI,
			mapInstanceId: this.mapInstanceId,
			frameRate: 60
		});
		this.oui.tooltipManager._properties.cursorOffset = 14;
		this.oui.tooltipManager._properties.dismissDelay = 5E3;
		this.oui.tooltipManager.setHideDelay(0);
		this.setDefaultTooltipStyle()
	};
	a.Graphics.EVENT_CLICK = "click";
	a.Graphics.EVENT_DOUBLE_CLICK =
		"doubleClick";
	a.Graphics.EVENT_MOUSE_DOWN = "mouseDown";
	a.Graphics.EVENT_MOUSE_UP = "mouseUp";
	a.Graphics.EVENT_MOUSE_OVER = "mouseOver";
	a.Graphics.EVENT_MOUSE_OUT = "mouseOut";
	a.Graphics.EVENT_MOUSE_LEAVE = "mouseLeave";
	a.Graphics.EVENT_MOUSE_MOVE = "mouseMove";
	a.Graphics.EVENT_MOUSE_DRAG = "drag";
	a.Graphics.TYPE_GROUP = 1;
	a.Graphics.TYPE_IMAGE = 2;
	a.Graphics.TYPE_IMAGE_MARKER = 3;
	a.Graphics.TYPE_SIMPLE_VECTOR_MARKER = 4;
	a.Graphics.TYPE_COMPOUND_VECTOR_MARKER = 5;
	a.Graphics.TYPE_PATH = 6;
	a.Graphics.TYPE_RECTANGLE = 7;
	a.Graphics.TYPE_ELLIPSE =
		8;
	a.Graphics.prototype.createGroup = function (d) {
		d = new this.oui.graphics.Group(d);
		d.vtype = a.Graphics.TYPE_GROUP;
		return d
	};
	a.Graphics.prototype.setTooltipStyle = function (a) {
		this.oui.tooltipManager.applyStyle(a)
	};
	a.Graphics.prototype.getTooltipManager = function () {
		return this.oui.tooltipManager
	};
	a.Graphics.prototype.setDefaultTooltipStyle = function () {
		var d = new a.style.Text({
			styleName: "title",
			fill: "#000000",
			fontStyle: a.Text.FONTSTYLE_NORMAL,
			fontWeight: a.Text.FONTWEIGHT_BOLD,
			fontFamily: "Helvetica Neue",
			fontSize: 11,
			hAlign: 0,
			vAlign: .5
		}),
		e = new a.style.Text({
			styleName: "header",
			fill: "#B5B5B5",
			fontStyle: a.Text.FONTSTYLE_NORMAL,
			fontFamily: "Helvetica Neue",
			fontSize: 10,
			hAlign: 1,
			vAlign: .5
		}),
		f = new a.style.Text({
			styleName: "txt",
			fill: "#000000",
			fontStyle: a.Text.FONTSTYLE_NORMAL,
			fontFamily: "Helvetica Neue",
			fontSize: 10,
			hAlign: 0,
			vAlign: .5
		});
		this.defaultTooltipStyle = {
			background: this.oui.WHITE,
			border: {
				stroke: "#3B3B3B",
				rx: 0,
				ry: 0,
				thickness: 4
			},
			text: {
				fill: this.oui.BLACK,
				fontSize: 11
			},
			shadow: this.getGraphicFilter({
				type: "DROPSHADOW",
				offset: 5
			})
		};
		this.currentTooltipStyle = {
			titleStyle: d,
			headerStyle: e,
			contentStyle: f,
			padding: {
				top: 9,
				lineBegin: 9,
				bottom: 9,
				lineEnd: 9
			}
		};
		this.setTooltipStyle(this.defaultTooltipStyle)
	};
	a.Graphics.prototype.getInnerTooltipStyle = function () {
		return this.currentTooltipStyle
	};
	a.Graphics.prototype.storeCustomTooltipTextStyle = function (d) {
		a.notNull(d) && (a.notNull(d.titleStyle) && 0 < Object.getOwnPropertyNames(d.titleStyle).length && (this.currentTooltipStyle.titleStyle = d.titleStyle), a.notNull(d.headerStyle) && 0 < Object.getOwnPropertyNames(d.headerStyle).length &&
			(this.currentTooltipStyle.headerStyle = d.headerStyle), a.notNull(d.contentStyle) && 0 < Object.getOwnPropertyNames(d.contentStyle).length && (this.currentTooltipStyle.contentStyle = d.contentStyle))
	};
	a.Graphics.prototype.addGroup = function (d, e) {
		a.notNull(e) ? e.appendChild(d) : this.oui.rootNode.appendChild(d)
	};
	a.Graphics.prototype.setCursor = function (d, e) {
		if (a.notNull(this.oui.tree.canvas)) {
			for (var f = this.oui.tree.canvas, g = "AUTO"; d && "AUTO" === g; )
				g = e, d = d.parentNode;
			f.style.cursor = "object" === typeof e ? "none" : g
		} else
			a.notNull(this.oui.tree.svgNode) &&
			this.oui.tree.svgNode.attr("cursor", "object" === typeof e ? "none" : e)
	};
	a.Graphics.prototype.drawImage = function (d, e, f) {
		if (!d)
			return null;
		var g = f.group;
		g || (g = this.oui.rootNode);
		this.setId(g, f);
		e.x = d.x;
		e.y = d.y;
		e.width && e.height && (e.preserveAspectRatio = !0);
		if (f && f.angle) {
			var k = d.x + e.width / 2;
			d = d.y + e.height / 2;
			f = (new this.oui.geom.Matrix).rotate(f.angle, k, d);
			e.transform = f
		}
		e = new this.oui.graphics.Image(e);
		g.appendChild(e);
		e.vtype = a.Graphics.TYPE_IMAGE;
		return e
	};
	a.Graphics.prototype.drawImageMarker = function (a,
		e, f) {
		f.xOffset && (a.x += f.xOffset);
		f.yOffset && (a.y += f.yOffset);
		return e && e.src ? (e.width && (a.x -= e.width / 2), e.height && (a.y -= e.height / 2), a = this.drawImage(a, e, f)) : null
	};
	a.Graphics.prototype.drawVectorMarker = function (d, e, f) {
		f.xOffset && (d.x += f.xOffset);
		f.yOffset && (d.y += f.yOffset);
		f.width && (d.x -= f.width / 2);
		f.height && (d.y -= f.height / 2);
		f.transform = (new this.oui.geom.Matrix).translate(d.x, d.y);
		d = f.xScale ? f.xScale : 1;
		var g = f.yScale ? f.yScale : 1;
		if (1 != d || 1 != g)
			f.transform = f.transform.scale(d, g);
		f.angle && f.transform.rotate(f.angle,
			f.width / 2 / d, f.height / 2 / g);
		if (e && 0 < e.length) {
			var k,
			n;
			d = f.group;
			1 <= e.length && (f.group = this.createGroup({
					transform: f.transform
				}), f.transform = null);
			k = null;
			for (g = 0; g < e.length; g++) {
				k = e[g].shape;
				n = e[g].style;
				n.transform = f.transform;
				a.isNull(n.fill) && (n.fill = "#ffffff", n.fillOpacity = 0);
				a.notNull(f.gradient) && (n.fill = f.gradient);
				var u = k.type;
				k = "path" === u ? this.drawPath(k.coords, n, f) : "svg" === u ? this.drawSVGPath(k.svgPath, n, f) : "rectangle" === u ? this.drawRectangle(k, n, f) : this.drawEllipse(k, n, f)
			}
			if (d === f.group)
				return k.vtype =
					a.Graphics.TYPE_SIMPLE_VECTOR_MARKER, k;
			this.addGroup(f.group, d);
			f.group.vtype = a.Graphics.TYPE_COMPOUND_VECTOR_MARKER;
			e = f.group;
			f.group = d;
			return e
		}
		return null
	};
	a.Graphics.prototype.drawRectangle = function (d, e, f) {
		if (!d || a.isNull(d.x) || a.isNull(d.y) || a.isNull(d.width) && a.isNull(d.rx) || a.isNull(d.height) && a.isNull(d.ry))
			return null;
		var g = f.group;
		g || (g = this.oui.rootNode);
		this.setId(g, f);
		a.isNull(e.fill) && (e.fill = this.oui.NO_PAINT);
		e.x = d.x;
		e.y = d.y;
		a.notNull(d.width) && (e.width = d.width);
		a.notNull(d.rx) && (e.rx =
				d.rx);
		a.notNull(d.height) && (e.height = d.height);
		a.notNull(d.ry) && (e.ry = d.ry);
		d = new this.oui.graphics.Rectangle(e);
		d.vtype = a.Graphics.TYPE_RECTANGLE;
		g.appendChild(d);
		return d
	};
	a.Graphics.prototype.drawEllipse = function (d, e, f) {
		if (!d || a.isNull(d.cx) || a.isNull(d.cy) || a.isNull(d.width) || a.isNull(d.height))
			return null;
		var g = f.group;
		g || (g = this.oui.rootNode);
		this.setId(g, f);
		a.isNull(e.fill) && (e.fill = this.oui.NO_PAINT);
		e.cx = d.cx;
		e.cy = d.cy;
		e.width = d.width;
		e.height = d.height;
		var k;
		e.dash && e.dash_gap ? (k = a.$.extend({},
					e), k.strokeOpacity = 0, e.strokeThickness && (k.width -= e.strokeThickness, k.height -= e.strokeThickness), k = new this.oui.graphics.Ellipse(k)) : k = new this.oui.graphics.Ellipse(e);
		k.vtype = a.Graphics.TYPE_ELLIPSE;
		g.appendChild(k);
		if (e.dash && e.dash_gap) {
			var g = e.cx,
			n = e.cy,
			u = e.width / 2,
			C = e.height / 2,
			L = e.dash,
			P = e.dash_gap,
			X = {
				stroke: e.stroke,
				strokeOpacity: e.strokeOpacity,
				strokeThickness: e.strokeThickness,
				fill: "#ffffff",
				fillOpacity: 0
			},
			V = new this.oui.graphics.PathCommands,
			ca;
			ca = f && f.width && f.height ? (f.width + f.height) /
				2 / 2 : (u + C) / 2;
			e.in_deg || (L = L / ca * 180 / Math.PI, P = P / ca * 180 / Math.PI);
			for (ca = 0; 360 > ca; ) {
				V._safeArcMoveTo(g, n, ca, u, C);
				if (360 <= ca + L) {
					V._safeArc(g, n, ca, 360, u, C);
					break
				} else
					V._safeArc(g, n, ca, ca + L, u, C);
				ca += L + P
			}
			X.pathCommands = V;
			g = f.group;
			g || (g = this.oui.rootNode);
			X = new this.oui.graphics.Path(X);
			g.appendChild(X)
		}
		a.notNull(e.inset) && (k = a.isNull(e.insetThickness) ? 1.25 / f.xScale : e.insetThickness, f = a.isNull(e.strokeThickness) ? 1.75 / f.xScale : e.strokeThickness, k = new this.oui.graphics.Ellipse({
				fill: this.oui.NO_PAINT,
				cx: d.cx,
				cy: d.cy,
				width: d.width - 2 * f - k,
				height: d.height - 2 * f - k,
				stroke: e.inset,
				strokeThickness: k
			}), k.vtype = a.Graphics.TYPE_ELLIPSE, g.appendChild(k));
		return k
	};
	a.Graphics.prototype.drawPath = function (d, e, f) {
		for (var g = new this.oui.graphics.PathCommands, k = 0, n = d.length; k < n; k++)
			this.drawSegment(g, d[k], f);
		d = f.group;
		d || (d = this.oui.rootNode);
		this.setId(d, f);
		a.isNull(e.fill) && (e.fill = this.oui.NO_PAINT);
		e.pathCommands = g;
		e = new this.oui.graphics.Path(e);
		d.appendChild(e);
		e.vtype = a.Graphics.TYPE_PATH;
		return e
	};
	a.Graphics.prototype.drawSVGPath =
	function (d, e, f) {
		var g = new this.oui.graphics.PathCommands(d, !0);
		d = f.group;
		d || (d = this.oui.rootNode);
		this.setId(d, f);
		a.isNull(e.fill) && (e.fill = this.oui.NO_PAINT);
		e.pathCommands = g;
		e = new this.oui.graphics.Path(e);
		d.appendChild(e);
		e.vtype = a.Graphics.TYPE_PATH;
		return e
	};
	a.Graphics.prototype.drawText = function (a, e) {
		var f = e.group;
		f || (f = this.oui.rootNode);
		var g = new this.oui.graphics.Text(a);
		f.appendChild(g);
		g.vtype = "TEXT";
		return g
	};
	a.Graphics.prototype.attachEventListener = function (d, e, f) {
		a.isNull(f) && (f = this.oui.rootNode);
		f.addEventListener(d, e)
	};
	a.Graphics.prototype.detachEventListener = function (d, e, f) {
		a.isNull(f) && (f = this.oui.rootNode);
		f.removeEventListener(d, e)
	};
	a.Graphics.prototype.getLeftTop = function (a) {
		return a.getTranslation()
	};
	a.Graphics.prototype.setLeftTop = function (a, e, f) {
		return a.setTranslation(e, f)
	};
	a.Graphics.prototype.setImageMarker = function (a, e, f) {
		if (f) {
			if (e) {
				var g = a.getWidth(),
				k = a.getHeight();
				f.width && (g = f.width);
				f.height && (k = f.height);
				f.x = e.x - g / 2;
				f.y = e.y - k / 2
			} else
				f.width && (f.x = a.getX() - (f.width - a.getWidth()) /
						2), f.height && (f.y = a.getY() - (f.height - a.getHeight()) / 2);
			a.applyStyle(f)
		} else
			e && (e.x -= a.getWidth() / 2, e.y -= a.getHeight() / 2, a.applyStyle(e))
	};
	a.Graphics.prototype.setImage = function (a, e, f) {
		f ? (e && (f.x = e.x, f.y = e.y), f.width && f.height && (f.preserveAspectRatio = !0), a.applyStyle(f)) : e && a.applyStyle(e)
	};
	a.Graphics.prototype.setRectangle = function (d, e, f) {
		d.vtype == a.Graphics.TYPE_RECTANGLE && (f ? (e && (f.x = e.x, f.y = e.y, a.notNull(e.width) ? f.width = e.width : f.rx = e.rx, a.notNull(e.height) ? f.height = e.height : f.ry = e.ry), d.applyStyle(f)) :
			d.applyStyle(e))
	};
	a.Graphics.prototype.setEllipse = function (d, e, f) {
		d.vtype === a.Graphics.TYPE_ELLIPSE && (f ? (e && (a.notNull(e.cx) && (f.cx = e.cx), a.notNull(e.cy) && (f.cy = e.cy), a.notNull(e.width) && (f.width = e.width), a.notNull(e.height) && (f.height = e.height)), d.applyStyle(f)) : e && d.applyStyle(e))
	};
	a.Graphics.prototype.setPath = function (d, e, f) {
		if (d.vtype === a.Graphics.TYPE_PATH) {
			var g = null;
			if (e)
				for (var g = new this.oui.graphics.PathCommands, k = 0, n = e.length; k < n; k++)
					this.drawSegment(g, e[k]);
			f ? (f.pathCommands = g, d.applyStyle(f)) :
			g && d.applyStyle({
				pathCommands: g
			})
		}
	};
	a.Graphics.prototype.remove = function (a) {
		a && a.parentNode && a.parentNode.removeChild(a)
	};
	a.Graphics.prototype.destroy = function (d) {
		for (var e in d)
			d.hasOwnProperty(e) && a.notNull(d[e]) && delete d[e]
	};
	a.Graphics.prototype.removeAll = function () {
		this.oui.rootNode.removeChildren();
		this.oui.tree && this.oui.tree.destroy()
	};
	a.Graphics.prototype.bringForward = function (a) {
		a.bringForward()
	};
	a.Graphics.prototype.bringToTop = function (a) {
		a.bringToFront()
	};
	a.Graphics.prototype.sendBackward =
	function (a) {
		a.sendBackward()
	};
	a.Graphics.prototype.sendToBottom = function (a) {
		a.sendToBack()
	};
	a.Graphics.prototype.getDisplayIndex = function (a) {
		return a.parentNode ? a.parentNode.getChildIndex(a) : -1
	};
	a.Graphics.prototype.setDisplayIndex = function (a, e) {
		a.parentNode && a.parentNode.setChildIndex(a, e)
	};
	a.Graphics.prototype.applyStyle = function (a, e) {
		a.applyStyle(e)
	};
	a.Graphics.prototype.drawSegment = function (a, e, f) {
		if (e && e.length && !(2 > e.length) && !isNaN(e[0]) && !isNaN(e[1]))
			if (f && f.scTransform)
				f.genThreshold || (f.genThreshold =
						1), this.drawSegmentWithTransform(a, e, f);
			else {
				a._safeMoveTo(Math.round(e[0]), Math.round(e[1]));
				f = 2;
				for (var g = e.length; f < g; f += 2)
					a._safeLineTo(Math.round(e[f]), Math.round(e[f + 1]));
				e[0] == e[g - 2] && e[1] == e[g - 1] && a.closePath()
			}
	};
	a.Graphics.prototype.drawSegmentWithTransform = function (a, e, f) {
		var g = f.scTransform,
		k = g.transformPoint(e[0], e[1]),
		n = k.x,
		u = k.y;
		a._safeMoveTo(Math.round(k.x), Math.round(k.y));
		f = f.genThreshold;
		for (var C = 2, L = e.length - 2; C < L; C += 2) {
			var k = g.transformPoint(e[C], e[C + 1]),
			P = Math.round(k.x),
			k = Math.round(k.y),
			X = P - n,
			V = k - u;
			X > f || X < -f || V > f || V < -f || a._safeLineTo(P, k)
		}
		k = g.transformPoint(e[L - 2], e[L - 1]);
		a._safeLineTo(Math.round(k.x), Math.round(k.y))
	};
	a.Graphics.prototype.setId = function (d, e) {
		a.isNull(e.id) && (e.id = d.length);
		e.name = e.id ? "path_" + e.id : "path_" + d.length
	};
	a.Graphics.prototype.setImageStyleLocation = function (a, e) {
		a.x = e.x;
		a.y = e.y;
		a.width && a.height && (a.preserveAspectRatio = !0)
	};
	a.Graphics.prototype.setImageStyle = function (a) {
		a.width && a.height && (a.preserveAspectRatio = !0)
	};
	a.Graphics.prototype.zoom = function (d,
		e) {
		d.curScaleX = e.beginValue;
		d.curScaleY = e.beginValue;
		d.zoomPointXOffset = e.zoomPointXOffset;
		d.zoomPointYOffset = e.zoomPointYOffset;
		var f = new this.oui.anim.AnimateStyle({
			targetNode: d,
			beginValue: e.beginValue,
			endValue: e.endValue,
			dur: e.duration,
			interpolator: function (f, k, n) {
				f = (k - f) * n + f;
				n = k = 1;
				var u = 0,
				C = 0;
				a.notNull(e.zoomPointXOffset) && (u =  - (d.zoomPointXOffset / f * d.curScaleX) + d.zoomPointXOffset, k = f / d.curScaleX);
				a.notNull(e.zoomPointYOffset) && (C =  - (d.zoomPointYOffset / f * d.curScaleY) + d.zoomPointYOffset, n = f / d.curScaleX);
				d.scale(k, n);
				d.translate(-u, -C);
				d.curScaleX = f;
				d.curScaleY = f
			}
		});
		e.endListener && f.addEventListener(this.oui.EventTypes.END, function (a) {
			e.endListener(a)
		});
		f.beginAt(0)
	};
	a.Graphics.prototype.setVisible = function (a, e) {
		a.setVisibility(e)
	};
	a.Graphics.prototype.isVisible = function (a) {
		return a.getVisibility()
	};
	a.Graphics.prototype.clearGroup = function (a) {
		a && a.removeChildren()
	};
	a.Graphics.prototype.getGraphicFilter = function (a) {
		if (a && "DROPSHADOW" == a.type)
			return new this.oui.filters.DropShadow({
				opacity: a.opacity,
				color: a.color,
				offset: a.offset,
				radius: a.radius,
				knockout: a.knockout,
				angle: a.angle
			});
		if (a && "BLUR" == a.type)
			return new this.oui.filters.Blur;
		if (a && "GLOW" == a.type)
			return new this.oui.filters.Glow({
				color: "#ffff00",
				strength: 10
			})
	};
	a.Graphics.prototype.setRotationTransform = function (d, e) {
		if (d && e) {
			a.isNull(d.width) && (d.width = 0);
			a.isNull(d.height) && (d.height = 0);
			var f = d.x + d.width / 2,
			g = d.y + d.height / 2,
			f = (new this.oui.geom.Matrix).rotate(e, f, g);
			d.transform = f
		}
		return d
	};
	a.Graphics.prototype.getWidthHeight = function (d) {
		if (a.isNull(d))
			return null;
		d = d.getLocalBounds();
		return {
			w: d.width,
			h: d.height
		}
	};
	a.Graphics.prototype.setOpacity = function (a, e) {
		a && a.setOpacity(e)
	};
	a.Graphics.prototype.getTextSize = function (a, e) {
		var f;
		f = 0 < a.indexOf("\n") ? this.createTextBlock(a, e, 0, 0).node : this.createTextNode(a, e, 0, 0);
		this.oui.rootNode.appendChild(f);
		f.setDisplay(!1);
		var g = this.getWidthHeight(f);
		this.remove(f);
		return g
	};
	a.Graphics.prototype.createTextNode = function (a, e, f, g) {
		return e ? this.oui.load({
			type: "text",
			textValue: a,
			fontFamily: e.fontFamily,
			fontSize: e.fontSize,
			fontStyle: e.fontStyle,
			fontWeight: e.fontWeight,
			fill: e.fill,
			x: f,
			y: g,
			textAlign: e.textAlign
		}) : this.oui.load({
			type: "text",
			textValue: a,
			x: f,
			y: g
		})
	};
	a.Graphics.prototype.drawPieChart = function (d, e, f, g) {
		if (!d || a.isNull(d.cx) || a.isNull(d.cy) || a.isNull(d.width) || a.isNull(d.height) || a.isNull(e) || 0 === e.length || a.isNull(f) || f.length !== e.length)
			return null;
		var k = g.offsetAngle ? g.offsetAngle : 0,
		n = [];
		n.push(0);
		var u = 0,
		C = d.width / 2,
		L = d.height / 2,
		P = g.group;
		P || (P = this.oui.rootNode);
		this.setId(P, g);
		var X = this.createGroup();
		this.addGroup(X, P);
		for (P = 0; P < e.length; P++)
			u += e[P], n.push(u);
		for (P = 0; P < e.length; P++) {
			var V = Math.round(e[P] / u * 1E4) / 100 + "%",
			V = this.drawSector(d.cx, d.cy, g.orientation && 2 == g.orientation ? n[P] / u * 360 + k :  - (n[P] / u * 360 + k), g.orientation && 2 == g.orientation ? n[P + 1] / u * 360 + k :  - (n[P + 1] / u * 360 + k), C, L, {
				fill: f[P],
				stroke: g.stroke,
				strokeThickness: g.strokeThickness
			}, g.plugable, g.description && g.description[P] ? g.description[P] + " \n value:" + e[P] + " \n percent:" + V : null);
			X.appendChild(V);
			V.vtype = a.Graphics.TYPE_PATH
		}
		X.applyStyle({
			filter: g.filter
		});
		return X
	};
	a.Graphics.prototype.drawSector = function (d, e, f, g, k, n, u, C, L) {
		a.isNull(u.fill) && (u.fill = this.oui.NO_PAINT);
		u.cx = d;
		u.cy = e;
		u.maxAngle = g;
		u.minAngle = f;
		u.minRadius = 0;
		u.maxRadius = k;
		d = new this.oui.graphics.DiskSector(u);
		if (!C || C && !0 === C)
			this.attachEventListener(a.Graphics.EVENT_MOUSE_OVER, function (a) {
				a.target.parentNode.bringToFront();
				a.target.bringToFront();
				a.target.applyStyle({
					maxRadius: 1.1 * k
				});
				for (var d = a.target.parentNode.childrenCount, e = 0; e < d; e++)
					a.target.parentNode.getChildAt(e) !== a.target &&
					a.target.parentNode.getChildAt(e).applyStyle({
						fillOpacity: .5
					})
			}, d), this.attachEventListener(a.Graphics.EVENT_MOUSE_OUT, function (a) {
				a.target.applyStyle({
					maxRadius: k
				});
				for (var d = a.target.parentNode.childrenCount, e = 0; e < d; e++)
					a.target.parentNode.getChildAt(e).applyStyle({
						fillOpacity: 1
					})
			}, d), d.applyStyle({
				tooltip: L
			});
		return d
	};
	a.Graphics.prototype.drawBarChart = function (d, e, f, g) {
		if (!d || a.isNull(d.cx) || a.isNull(d.cy) || a.isNull(d.width) || a.isNull(d.height) || a.isNull(e) || 0 === e.length || a.isNull(f) || f.length !==
			e.length)
			return null;
		var k = g.group;
		k || (k = this.oui.rootNode);
		this.setId(k, g);
		var n = this.createGroup();
		this.addGroup(n, k);
		for (var u = k = 0, C = 0; C < e.length; C++)
			u += Math.abs(e[C]), k < Math.abs(e[C]) && (k = Math.abs(e[C]));
		for (var C = d.height, L = d.width / e.length, P, X = function (a) {
			a.target.parentNode.bringToFront();
			a.target.bringToFront();
			a.target.scale(1.1, 1.1);
			for (var d = a.target.parentNode.childrenCount, e = 0; e < d; e++)
				a.target.parentNode.getChildAt(e)
					 != a.target && a.target.parentNode.getChildAt(e).applyStyle({
						fillOpacity: .4
					})
			},
				V = function (a) {
				a.target.scale(1 / 1.1, 1 / 1.1);
				for (var d = a.target.parentNode.childrenCount, e = 0; e < d; e++)
					a.target.parentNode.getChildAt(e).applyStyle({
						fillOpacity: 1
					})
			}, ca = 0; ca < e.length; ca++) {
				P = e[ca] / k * C;
				P = this.drawRectangle({
					x: 0,
					y: 0 > P ? 0 : -P,
					width: L,
					height: Math.abs(P)
				}, {
					fill: f[ca],
					stroke: g.stroke,
					strokeThickness: g.strokeThickness
				}, {
					group: n
				});
				P.translate(L * ca, 0);
				if (!g.plugable || g && !0 === g.plugable)
					this.attachEventListener(a.Graphics.EVENT_MOUSE_OVER, X, P), this.attachEventListener(a.Graphics.EVENT_MOUSE_OUT, V,
						P);
				var Wa = Math.round(Math.abs(e[ca]) / u * 1E4) / 100 + "%";
				P.applyStyle({
					tooltip: g.description && g.description[ca] ? g.description[ca] + " \n value:" + e[ca] + " \n percent:" + Wa : null
				})
			}
		e = this.getWidthHeight(n);
		this.setLeftTop(n, d.cx - e.w / 2, d.cy + (2 * C - e.h) / 2);
		n.applyStyle({
			filter: g.filter
		});
		return n
	};
	a.Graphics.prototype.getScaleValue = function (d) {
		if (a.isNull(d))
			return null;
		d = d.getTransformMatrix();
		if (!a.isNull(d))
			return d = d.exportToJSON(), {
				scaleX: Math.sqrt(d[0] * d[0] + d[1] * d[1]),
				scaleY: Math.sqrt(d[2] * d[2] + d[3] * d[3])
			}
	};
	a.Graphics.prototype.clearToolTips = function () {
		this.oui.tooltipManager.hideTooltip()
	};
	a.Graphics.prototype.createTextBlock = function (d, e, f, g, k, n) {
		d = {
			textValue: d,
			maxWidth: k,
			maxLines: n,
			x: f,
			y: g,
			textAlign: a.Text.HORIZONTALALIGN_CENTER
		};
		e && (d.fontFamily = e.fontFamily, d.fontSize = e.fontSize, d.fontStyle = e.fontStyle, d.fontWeight = e.fontWeight, d.fill = e.fill);
		e = new this.oui.graphics.TextBlock(d);
		e.setDisplay(!1);
		this.oui.rootNode.appendChild(e);
		d = e.getLocalBounds();
		this.remove(e);
		e.setDisplay(!0);
		return {
			node: e,
			w: d.width,
			h: d.height
		}
	};
	a.Graphics.prototype.cloneText = function (d) {
		if (d.hasChildNodes()) {
			for (var e = this.createGroup(), f = 0; f < d.childrenCount; f++) {
				var g = this.cloneText(d.getChildAt(f));
				e.appendChild(g)
			}
			return e
		}
		if (d.vtype === a.Graphics.TYPE_IMAGE)
			return d = {
				src: d.src(),
				x: d.x(),
				y: d.y(),
				width: d.width(),
				height: d.height()
			},
		d = new this.oui.graphics.Image(d),
		d.vtype = a.Graphics.TYPE_IMAGE,
		d;
		try {
			var e = d.getTextValue(),
			f = d.getTransform(),
			g = d.getFontStyle(),
			k = d.getFontFamily(),
			n = d.getFontWeight(),
			u = d.getFontSize(),
			C = d.getX(),
			L = d.getY(),
			P = d.getFill();
			if (d.getMaxWidth) {
				var X = d.getMaxLines(),
				V = d.getMaxWidth();
				return new this.oui.graphics.TextBlock({
					textValue: e,
					maxWidth: V,
					maxLines: X,
					x: C,
					y: L,
					textAlign: a.Text.HORIZONTALALIGN_CENTER,
					fontFamily: k,
					fontSize: u,
					fontStyle: g,
					fontWeight: n,
					fill: P,
					transform: f
				})
			}
			return this.oui.load({
				type: "text",
				textValue: e,
				fontFamily: k,
				fontSize: u,
				fontStyle: g,
				fontWeight: n,
				fill: P,
				transform: f,
				x: C,
				y: L
			})
		} catch (ca) {
			return null
		}
	};
	a.Graphics.prototype.createFillPattern = function (a) {
		return new this.oui.style.PatternPaint({
			src: a
		})
	};
	a.UndoManager = a.Class.extend({
		initialize: function () {
			this.reset()
		},
		reset: function () {
			this.index = 0;
			this.undoStack = []
		},
		addEdit: function (a) {
			this.undoStack[this.index++] = a;
			this.undoStack.splice(this.index);
			return this.index - 1
		},
		undo: function () {
			try {
				var d = 0;
				do {
					var e = this.editToUndo();
					if (a.isNull(e))
						break;
					e.undo();
					this.index--;
					e.type && (e.type === a.UndoManager.ENDBLOCK ? d++ : e.type === a.UndoManager.STARTBLOCK && d--)
				} while (0 < d)
			} catch (f) {
				a.util.Logger.warning("MAPVIEWER_9021", "OM.UndoManager.undo", f.message)
			}
		},
		redo: function () {
			try {
				var d =
					0;
				do {
					var e = this.editToRedo();
					e.redo();
					this.index++;
					e.type && (e.type === a.UndoManager.ENDBLOCK ? d-- : e.type === a.UndoManager.STARTBLOCK && d++)
				} while (0 < d)
			} catch (f) {
				a.util.Logger.warning("MAPVIEWER_9021", "OM.UndoManager.redo", f.message)
			}
		},
		editToUndo: function () {
			return this.undoStack[this.index - 1]
		},
		editToRedo: function () {
			return this.undoStack[this.index]
		},
		canUndo: function () {
			var a = this.editToUndo();
			try {
				return a && a.canUndo()
			} catch (e) {
				throw e;
			}
		},
		canRedo: function () {
			var a = this.editToRedo();
			try {
				return a && a.canRedo()
			} catch (e) {
				throw e;
			}
		},
		canUndoOrRedo: function () {
			return this.canRedo() || this.canUndo()
		},
		trimEdits: function (a, e) {
			a = a || 0;
			e = e || this.undoStack.length;
			var f = e - a,
			g = this.undoStack.splice(a, f),
			k = [],
			n = 0,
			u;
			for (u in this.undoStack)
				k[n++] = this.undoStack[u];
			this.undoStack = k;
			this.index >= e ? this.index -= f : this.index >= a && (this.index = a);
			return g
		},
		getRedoPresentationName: function () {
			var a = this.editToRedo();
			try {
				return a.getPresentationName()
			} catch (e) {
				throw e;
			}
		},
		getUndoOrRedoPresentationName: function () {
			var d = this.getUndoPresentationName();
			a.isNull(d) && (d = this.getRedoPresentationName());
			return d
		},
		getUndoPresentationName: function () {
			var a = this.editToUndo();
			try {
				return a.getPresentationName()
			} catch (e) {
				throw e;
			}
		},
		startChangeBlock: function (d) {
			return this.addEdit(new a.UndoManager.SpecialEdit(d || "start change block", a.UndoManager.STARTBLOCK))
		},
		endChangeBlock: function (d) {
			return this.addEdit(new a.UndoManager.SpecialEdit(d || "end change block", a.UndoManager.ENDBLOCK))
		},
		destroy: function () {
			this.undoStack = this.index = c
		},
		print: function () {
			for (var a =
					"Undo stack:\n", e = this.undoStack.length, f = 0; f < e; f++) {
				var g = this.undoStack[f],
				a = f === this.index ? a + "\x3e" : a + " ",
				a = a + ("[" + f + "] ");
				try {
					a += g.getPresentationName()
				} catch (k) {
					a += k
				}
				a += "\n"
			}
			return a
		}
	});
	a.UndoManager.SpecialEdit = a.Class.extend({
		initialize: function (a, e) {
			this.name = a;
			this.type = e
		},
		canUndo: function () {
			return !0
		},
		canRedo: function () {
			return !0
		},
		undo: function () {},
		redo: function () {},
		getPresentationName: function () {
			return this.name
		}
	});
	a.UndoManager.STARTBLOCK = "START_CHANGE_BLOCK";
	a.UndoManager.ENDBLOCK = "END_CHANGE_BLOCK";
	a.proj.ProjUtil = a.proj.ProjUtil || {};
	a.proj.ProjUtil.EPSLN = 1E-10;
	a.proj.ProjUtil.TWO_PI = 2 * Math.PI;
	a.proj.ProjUtil.LONG_MAX = Math.pow(2, 32) + 1;
	a.proj.ProjUtil.DBLLONG = 461168601E10;
	a.proj.ProjUtil.RADIAN = Math.PI / 180;
	a.proj.ProjUtil.DEGREE = 180 / Math.PI;
	a.proj.ProjUtil.radians = function (d) {
		return d * a.proj.ProjUtil.RADIAN
	};
	a.proj.ProjUtil.degrees = function (d) {
		return d * a.proj.ProjUtil.DEGREE
	};
	a.proj.ProjUtil.adjustLon = function (a) {
		for (; -180 > a; )
			a += 360;
		for (; 180 < a; )
			a -= 360;
		return a
	};
	a.proj.Albers = function (d) {
		this.name =
			d.name || "ALBERS CONICAL EQUAL-AREA";
		var e = a.proj.ProjUtil,
		f = e.radians(d.standardParallel_1),
		g = e.radians(d.standardParallel_2),
		k = e.radians(d.latOrigin),
		n = e.radians(d.lonCenter),
		u = d.rMajor || 6378206.4,
		C = .5 * (Math.sin(f) + Math.sin(g));
		d = Math.cos(f);
		var L = d * d + 2 * C * Math.sin(f),
		P = Math.sqrt(L - 2 * C * Math.sin(k)) / C;
		return {
			forward: function (a, d) {
				var f = C * (e.radians(a) - n),
				k = Math.sqrt(L - 2 * C * Math.sin(e.radians(d))) / C;
				return {
					x: k * Math.sin(f) * u,
					y: (P - k * Math.cos(f)) * u
				}
			},
			inverse: function (a, d) {
				a /= u;
				d /= u;
				var f = Math.sqrt(a * a +
						Math.pow(P - d, 2)),
				k = e.degrees(n + Math.atan(a / (P - d)) / C),
				f = e.degrees(Math.asin((L - f * f * C * C) / (2 * C)));
				return {
					x: k,
					y: f
				}
			}
		}
	};
	a.proj.ablers_mainland = new a.proj.Albers({
		standardParallel_1: 29.5,
		standardParallel_2: 45.5,
		lonCenter: -96,
		latOrigin: 23
	});
	a.proj.albers_hawaii = new a.proj.Albers({
		standardParallel_1: 8,
		standardParallel_2: 18,
		lonCenter: -160,
		latOrigin: 20
	});
	a.proj.albers_hawaii.forward2 = function (a) {
		a.x -= 12E5;
		a.y += 4E5;
		return a
	};
	a.proj.albers_hawaii.inverse2 = function (a, e) {
		return {
			x: a + 12E5,
			y: e - 4E5
		}
	};
	a.proj.albers_alaska =
		new a.proj.Albers({
			standardParallel_1: 55,
			standardParallel_2: 65,
			lonCenter: -160,
			latOrigin: 60
		});
	a.proj.albers_alaska.forward2 = function (a) {
		a.x = .4 * a.x - 22E5;
		a.y = .4 * a.y + 4E5;
		return a
	};
	a.proj.albers_alaska.inverse2 = function (a, e) {
		return {
			x: (a + 22E5) / .4,
			y: (e - 4E5) / .4
		}
	};
	a.proj.albers_puertorico = new a.proj.Albers({
		standardParallel_1: 8,
		standardParallel_2: 18,
		lonCenter: -60,
		latOrigin: 10
	});
	a.proj.AlbersUSA = function () {
		var d = a.proj.albers_alaska,
		e = a.proj.albers_hawaii,
		f = a.proj.albers_puertorico,
		g = a.proj.ablers_mainland;
		return {
			forward: function (a, n) {
				var u = 50 < n ? d : -140 > a ? e : 21 > n ? f : g,
				C = u.forward(a, n);
				return u.forward2 ? u.forward2(C) : C
			},
			inverse: function (a, f) {
				var u = null,
				C = -145E4 > a && 93E4 > f ? d : -65E4 > a && -125E4 < a && 66E4 > f ? e : g;
				return C.inverse2 ? (u = C.inverse2(a, f), C.inverse(u.x, u.y)) : C.inverse(a, f)
			}
		}
	}
	();
	a.proj.Robinson = function (d) {
		var e = a.proj.ProjUtil,
		f = [[1, 0], [.9986, .062], [.9954, .124], [.99, .186], [.9822, .248], [.973, .31], [.96, .372], [.9427, .434], [.9216, .4958], [.8962, .5571], [.8679, .6176], [.835, .6769], [.7986, .7346], [.7597, .7903], [.7186,
				.8435], [.6732, .8936], [.6213, .9394], [.5722, .9761], [.5322, 1], [.5322, 1]],
		g = 0;
		try {
			g = parseInt(d, 10) || 0,
			g = e.adjustLon(g)
		} catch (k) {}
		return {
			forward: function (a, d) {
				var u,
				C,
				L;
				a = e.adjustLon(a);
				a -= g;
				a = e.adjustLon(a);
				90 < Math.abs(d) && (d = 90 * (0 < d ? 1 : -1));
				u = parseInt(Math.abs(d) / 5, 10);
				C = Math.abs(d) / 5 - u;
				a = e.radians(a);
				d = e.radians(d);
				L = f[u][0] + C * (f[u + 1][0] - f[u][0]);
				u = f[u][1] + C * (f[u + 1][1] - f[u][1]);
				u *= 8625154.6651;
				0 > d && (u = -u);
				return {
					x: 5413124.8719 * L * a,
					y: u
				}
			},
			inverse: function (a, d) {
				var u,
				C,
				L;
				u = 0;
				if (8625154.6651 <= Math.abs(d))
					C =
						90, u = f[18][0];
				else {
					C = Math.abs(d / 8625154.6651);
					for (L = 0; 19 > L; L++)
						if (f[L + 1][1] > C) {
							u = L;
							break
						}
					L = (C - f[u][1]) / (f[u + 1][1] - f[u][1]);
					C = 5 * (u + L);
					u = f[u][0] + L * (f[u + 1][0] - f[u][0])
				}
				u = e.degrees(a / (5413124.8719 * u)) + g;
				u = e.adjustLon(u);
				0 > d && (C = -C);
				return {
					x: u,
					y: C
				}
			}
		}
	};
	a.proj.Winkel3 = function (d) {
		var e = a.proj.ProjUtil,
		f = Math.PI / 2,
		g = 0;
		try {
			g = parseInt(d, 10) || 0,
			g = e.adjustLon(g)
		} catch (n) {
			g = 0
		}
		var k = function (a) {
			return 1 < a ? 0 : -1 > a ? Math.PI : Math.acos(a)
		};
		return {
			forward: function (a, d) {
				a = e.adjustLon(a);
				a -= g;
				a = e.adjustLon(a);
				a = e.radians(a);
				d = e.radians(d);
				var C;
				C = a;
				var L = d,
				P = Math.cos(L),
				X;
				X = (X = k(P * Math.cos(C /= 2))) ? X / Math.sin(X) : 1;
				C = [2 * P * Math.sin(C) * X, Math.sin(L) * X];
				return {
					x: (C[0] + a / f) / 2 * 6378137,
					y: (C[1] + d) / 2 * 6378137
				}
			},
			inverse: function (a, d) {
				a /= 6378137;
				d /= 6378137;
				var C = a,
				L = d,
				P = 25,
				X = 0,
				V,
				ca;
				do {
					var Wa = Math.cos(L),
					va = Math.sin(L),
					b = Math.sin(2 * L),
					Hb = va * va,
					c = Wa * Wa,
					pb = Math.sin(C),
					qb = Math.cos(C / 2),
					ub = Math.sin(C / 2),
					Bb = ub * ub,
					Fb = (ca = 1 - c * qb * qb) ? k(Wa * qb) * Math.sqrt(X = 1 / ca) : X = 0;
					ca = .5 * (2 * Fb * Wa * ub + C / f) - a;
					var Da = .5 * (Fb * va + L) - d,
					Ea = .5 * X * (c * Bb + Fb * Wa * qb * Hb) +
						.5 / f;
					V = X * (pb * b / 4 - Fb * va * ub);
					va = .125 * X * (b * ub - Fb * va * c * pb);
					Hb = .5 * X * (Hb * qb + Fb * Bb * Wa) + .5;
					Wa = V * va - Hb * Ea;
					V = (Da * V - ca * Hb) / Wa;
					ca = (ca * va - Da * Ea) / Wa;
					C -= V;
					L -= ca
				} while ((1E-6 < Math.abs(V) || 1E-6 < Math.abs(ca)) && 0 < --P);
				C = e.degrees(C) + g;
				C = e.adjustLon(C);
				L = e.degrees(L);
				return {
					x: C,
					y: L
				}
			}
		}
	};
	a.util.Logger = a.util.Logger || {};
	a.util.Logger.LEVELS = {
		finest: 0,
		finer: 1,
		fine: 2,
		info: 3,
		config: 4,
		warning: 5,
		severe: 6
	};
	a.util.Logger.LEVELS_TEXT = {
		0: "finest",
		1: "finer",
		2: "fine",
		3: "info",
		4: "config",
		5: "warning",
		6: "severe"
	};
	a.util.Logger.currentLevel =
		a.util.Logger.LEVELS.warning;
	a.util.Logger.NO_ALERT_BOX = !1;
	a.util.Logger._log = function (a) {
		"object" === typeof console ? console.log(a) : "object" === typeof opera ? opera.postError(a) : "object" === typeof java && "object" === typeof java.lang && java.lang.System.out.println(a)
	};
	a.util.Logger.finest = function (d, e, f) {
		a.util.Logger.LEVELS.finest >= a.util.Logger.currentLevel && a.util.Logger._log("[FINEST]  " + a.util.Logger._mix(d, e, f))
	};
	a.util.Logger.finer = function (d, e, f) {
		a.util.Logger.LEVELS.finer >= a.util.Logger.currentLevel &&
		a.util.Logger._log("[FINER]  " + a.util.Logger._mix(d, e, f))
	};
	a.util.Logger.fine = function (d, e, f) {
		a.util.Logger.LEVELS.fine >= a.util.Logger.currentLevel && a.util.Logger._log("[FINE]  " + a.util.Logger._mix(d, e, f))
	};
	a.util.Logger.info = function (d, e, f) {
		a.util.Logger.LEVELS.info >= a.util.Logger.currentLevel && a.util.Logger._log("[INFO]  " + a.util.Logger._mix(d, e, f))
	};
	a.util.Logger.config = function (d, e, f) {
		a.util.Logger.LEVELS.config >= a.util.Logger.currentLevel && a.util.Logger._log("[CONFIG]  " + a.util.Logger._mix(d,
				e, f))
	};
	a.util.Logger.warning = function (d, e, f) {
		a.util.Logger.LEVELS.warning >= a.util.Logger.currentLevel && a.util.Logger._log("[WARNING]  " + a.util.Logger._mix(d, e, f))
	};
	a.util.Logger.severe = function (d, e, f) {
		a.util.Logger.LEVELS.severe >= a.util.Logger.currentLevel && a.util.Logger._log("[SEVERE]  " + a.util.Logger._mix(d, e, f))
	};
	a.util.Logger.alert = function (d, e, f) {
		d = a.util.Logger._mix(d, e, f);
		a.util.Logger._log("[ALERT]  " + d);
		a.util.Logger.errorHandler ? a.util.Logger.errorHandler(d) : a.util.Logger.NO_ALERT_BOX ||
		alert(d)
	};
	a.util.Logger.throwErr = function (d, e, f) {
		f = a.util.Logger._mix(d, e, f);
		f = Error(f);
		f.stack && a.util.Logger.warning(d, e, f.stack);
		throw f;
	};
	a.util.Logger._mix = function (d, e, f) {
		var g = null;
		d && (g = a.Messages.getErrorMessage(d));
		e && (g = g ? g + ("\n    " + a.Messages.getString("Source") + ": " + e) : a.Messages.getString("Source") + ": " + e);
		f && (g = g ? g + ("\n    " + f) : f);
		return g
	};
	a.util.ScreenTransform = function (a, e) {
		this.dw = a;
		this.sw = e;
		this.sx = e.w / a.w;
		this.sy = -e.h / a.h;
		this.tx = -a.x * this.sx + e.x;
		this.ty = -a.y * this.sy + e.y + e.h;
		this.xtr = a.w / e.w;
		this.ytr = a.h / e.h;
		this.rsx = 1 / this.sx;
		this.rsy = 1 / this.sy;
		this.rtx = -e.x * this.rsx + a.x;
		this.rty = -e.y * this.rsy + a.y + a.h
	};
	a.util.ScreenTransform.prototype.toScreenPoint = function (a, e) {
		var f = {};
		f.x = Math.round(a * this.sx + this.tx);
		f.y = Math.round(e * this.sy + this.ty);
		return f
	};
	a.util.ScreenTransform.prototype.toMapDataPoint = function (a, e) {
		var f = {};
		f.x = a * this.rsx + this.rtx;
		f.y = e * this.rsy + this.rty;
		return f
	};
	a.util.ScreenTransform.prototype.toScreenXLength = function (a) {
		return a * this.sx
	};
	a.util.ScreenTransform.prototype.toScreenYLength =
	function (a) {
		return -a * this.sy
	};
	a.util.ScreenTransform.prototype.transformSegment = function (d, e, f) {
		a.isNull(f) && (f = 2);
		if (!d.length || 2 >= d.length)
			return null;
		var g = e * this.xtr;
		e *= this.ytr;
		var k = [],
		n = d[0],
		u = d[1],
		C = n,
		L = u,
		n = Math.round(n * this.sx + this.tx),
		u = Math.round(u * this.sy + this.ty);
		k.push(n);
		k.push(u);
		for (var P = f, X = d.length; P < X; P += f)
			if (n = d[P], u = d[P + 1], Math.abs(n - C) > g || Math.abs(u - L) > e)
				C = n, L = u, n = Math.round(n * this.sx + this.tx), u = Math.round(u * this.sy + this.ty), k.push(n, u);
		if (2 >= k.length)
			return null;
		d[0] !== d[X -
			2] || d[1] !== d[X - 1] || k[0] === k[k.length - 2] && k[1] === k[k.length - 1] || k.push(k[0], k[1]);
		return k
	};
	a.util.ScreenTransform.getScreenCoordinates = function (a, e, f, g, k, n, u, C, L) {
		return {
			x: (C - e) * n / (g - e) - a.divLeft,
			y: (k - L) * u / (k - f) - a.divTop
		}
	};
	a.util.ScreenTransform.prototype.toHeatMapPoint = function (a, e, f, g, k) {
		var n = {};
		n.x = Math.round((a * this.sx + this.tx - f) / k);
		n.y = Math.round((e * this.sy + this.ty - g) / k);
		return n
	};
	a.util.ScreenTransform.prototype.transformHeatMapSegment = function (d, e, f, g, k, n) {
		a.isNull(f) && (f = 2);
		if (!d.length ||
			2 >= d.length)
			return null;
		var u = e * this.xtr;
		e *= this.ytr;
		var C = [],
		L = d[0],
		P = d[1],
		X = L,
		V = P,
		L = Math.round((L * this.sx + this.tx - g) / n),
		P = Math.round((P * this.sy + this.ty - k) / n);
		C.push(L);
		C.push(P);
		for (var ca = f, Wa = d.length; ca < Wa; ca += f)
			if (L = d[ca], P = d[ca + 1], Math.abs(L - X) > u || Math.abs(P - V) > e)
				X = L, V = P, L = Math.round(L * this.sx + this.tx), P = Math.round(P * this.sy + this.ty), C.push((L - g) / n, (P - k) / n);
		if (2 >= C.length)
			return null;
		d[0] !== d[Wa - 2] || d[1] !== d[Wa - 1] || C[0] === C[C.length - 2] && C[1] === C[C.length - 1] || C.push(C[0], C[1]);
		return C
	};
	a.util.GeomUtil =
		a.util.GeomUtil || {};
	a.util.GeomUtil.earthRadius = 6372795;
	a.util.GeomUtil.distance = function (a, e, f, g) {
		return Math.sqrt(Math.pow(f - a, 2) + Math.pow(g - e, 2))
	};
	a.util.GeomUtil.pointLineDistance = function (a, e, f, g, k, n) {
		var u = g - n,
		C = k - f;
		return Math.abs(u * a + C * e + (f * n - g * k)) / Math.sqrt(u * u + C * C)
	};
	a.util.GeomUtil.pointSegmentDistance = function (d, e, f, g, k, n) {
		var u = a.util.GeomUtil.distance(d, e, f, g),
		C = a.util.GeomUtil.distance(d, e, k, n),
		L = a.util.GeomUtil.distance(f, g, k, n);
		if (0 === L)
			return u;
		L = ((d - f) * (k - f) + (e - g) * (n - g)) / (L * L);
		return 0 >
		L || 1 < L ? Math.min(u, C) : a.util.GeomUtil.pointLineDistance(d, e, f, g, k, n)
	};
	a.util.GeomUtil.pointInRect = function (a, e, f, g, k, n) {
		return a <= k && a >= f && e <= n && e >= g
	};
	a.util.GeomUtil.pointInPolygon = function (a, e, f, g, k) {
		var n,
		u,
		C = 0;
		n = 0;
		for (u = f - 1; n < f; u = n++)
			k[n] > e != k[u] > e && a < (g[u] - g[n]) * (e - k[n]) / (k[u] - k[n]) + g[n] && (C = !C);
		return C
	};
	a.util.GeomUtil.getPointAtBearing = function (d, e, f, g) {
		d = a.util.GeomUtil.getRadiansFromLatLon(d, e);
		e = d.y;
		f /= a.util.GeomUtil.earthRadius;
		var k = Math.asin(Math.sin(e) * Math.cos(f) + Math.cos(e) * Math.sin(f) *
				Math.cos(g));
		return a.util.GeomUtil.getLatLonFromRadians(d.x + Math.atan2(Math.sin(g) * Math.sin(f) * Math.cos(e), Math.cos(f) - Math.sin(e) * Math.sin(k)), k)
	};
	a.util.GeomUtil.getRadiansFromLatLon = function (a, e) {
		for (; -180 > a; )
			a += 360;
		for (; 180 < a; )
			a -= 360;
		a = a * Math.PI / 180;
		e = e * Math.PI / 180;
		return {
			x: a,
			y: e
		}
	};
	a.util.GeomUtil.getLatLonFromRadians = function (a, e) {
		a = 180 * a / Math.PI;
		e = 180 * e / Math.PI;
		return {
			x: a,
			y: e
		}
	};
	a.util.GeomUtil.densifyOrdinates = function (a, e) {
		if (!a || 4 > a.length)
			return a;
		for (var f = [], g = 0; g < a.length - 2; g += 2) {
			var k =
				a[g],
			n = a[g + 1],
			u = a[g + 2] - k,
			C = a[g + 3] - n;
			f.push(k);
			f.push(n);
			var L = Math.max(Math.ceil(Math.abs(u) / e), Math.ceil(Math.abs(C) / e));
			if (0 < L)
				for (var u = 1 * u / L, C = 1 * C / L, P = 0; P < L - 1; P++)
					k += u, n += C, f.push(k), f.push(n)
		}
		f.push(a[a.length - 2]);
		f.push(a[a.length - 1]);
		return f
	};
	a.util.GeomUtil.SimplifyCoordinates = function (a) {
		for (var e = a.length, f = a[0], g = a[1], k = [f, g], n = 2; n < e; n += 2)
			if (1 <= Math.abs(f - a[n]) || 1 <= Math.abs(g - a[n + 1]))
				f = a[n], g = a[n + 1], k.push(f), k.push(g);
		return k
	};
	a.util.GeomUtil.getLength = function (d, e, f) {
		if (a.isNull(d))
			return 0;
		var g = d ? d.type : "",
		k = d.srid,
		n = null;
		if ("LineString" !== g && "MultiLineString" !== g && "Polygon" !== g && "MultiPolygon" !== g && "Rectangle" !== g)
			return a.util.Logger.alert("MAPVIEWER_9015", "OM.util.GeomUtil.getLength", ""), n = -1;
		var g = function (a) {
			var d = 0,
			e = 2,
			f = a.length;
			if (a && 3 < f) {
				for (; e < f; e += 2)
					var k = a[e] - a[e - 2], g = a[e + 1] - a[e - 1], d = d + Math.sqrt(k * k + g * g);
				return d
			}
			return 0
		},
		u,
		C,
		L,
		P,
		X;
		f && (u = f.idx ? f.idx : 0, C = f.unit ? f.unit : "METER", L = f.transformToGeodetic, P = f.dataSource ? f.dataSource : a.gv.defaultDataSource, X = !1 === f.toServerTranform ?
				!1 : !0);
		if (!k)
			return n = g(d.coordinates), e && e(n, u), n;
		(f = a.gv.getSRS(k)) ? (a.util.GeomUtil.isGeo(k) && (f.type = "GEODETIC"), f.distConvFactor = a.gv.getUnitFactor(f.unit)) : f = a.util.GeomUtil.isGeo(k) ? {
			type: "GEODETIC",
			distConvFactor: 1,
			maxX: 180,
			maxY: 90,
			minX: -180,
			minY: -90
		}
		 : {
			type: "",
			distConvFactor: 1,
			maxX: 180,
			maxY: 90,
			minX: -180,
			minY: -90
		};
		var V = null;
		L && (V = a.util.CSTransformUtil.getCSTransformFunction(k, 8307));
		if (!L || a.util.GeomUtil.isGeo(k) || L && V || a.isNull(P)) {
			k = 0;
			C ? (k = a.gv.getUnitFactor(C), f.distConvFactor && !L && (k /=
					f.distConvFactor)) : k = 1;
			var ca = d.coordinates.slice(0);
			V && (ca = a.util.CSTransformUtil.transformOrdinates(V, ca, d.dimension), f.type = "GEODETIC");
			if (k)
				return n = f && f.type && "GEODETIC" === f.type.toUpperCase() && L ? a.util.GeomUtil.getGreatCircleLength(ca) / k : g(ca) / k, e && e(n, u), n
		}
		a.$("#sub_tr_1") && !V && L && a.$("#sub_tr_1").hide();
		g = d.toString();
		d = a.gv.localbaseURL() + "/foi";
		g = {
			request: "getlength",
			version: 1,
			figord: g
		};
		C && (g.unit = C);
		L && (g.togeodetic = !0 === L ? "yes" : "no");
		P && (g.datasource = P);
		C = function (a) {
			a *= 1;
			e && e(a, u);
			n =
				a
		};
		try {
			X && a.util.HttpRequest.send(d, g, C, "text")
		} catch (Wa) {
			a.util.Logger.alert("MAPVIEWER_9016", "OM.util.GeomUtil.getLength", Wa.stack ? Wa.message + "\nStack: " + Wa.stack : Wa.message),
			n = -1
		}
		return n
	};
	a.util.GeomUtil.getArea = function (d, e, f) {
		var g = d ? d.type : "";
		if ("Polygon" !== g && "MultiPolygon" !== g)
			return a.util.Logger.alert("MAPVIEWER_9046", "OM.util.GeomUtil.getArea", ""), C = -1;
		var k,
		n,
		u;
		f && (k = f.unit ? f.unit : "SQ_METER", n = f.transformToGeodetic, u = f.dataSource ? f.dataSource : a.gv.defaultDataSource);
		var C;
		f = d.toString();
		d = a.gv.localbaseURL() + "/foi";
		f = {
			request: "getarea",
			version: 1,
			figord: f
		};
		k && (f.unit = k);
		n && (f.togeodetic = !0 === n ? "yes" : "no");
		u && (f.datasource = u);
		k = function (a) {
			a *= 1;
			e && e(a);
			C = a
		};
		try {
			a.util.HttpRequest.send(d, f, k, "text")
		} catch (L) {
			a.util.Logger.alert("MAPVIEWER_9047", "OM.util.GeomUtil.getArea", L.stack ? L.message + "\nStack: " + L.stack : L.message),
			C = -1
		}
		return C
	};
	a.util.GeomUtil.moveCoordinates = function (d, e, f, g, k) {
		var n = function (d, e, f) {
			if (d) {
				var n = d.length,
				u = 2;
				a.notNull(k) && (u = k);
				g && (u += u);
				for (var C = 0; C < n; C += u)
					d[C] +=
					e, d[C + 1] += f
			}
		},
		u = a.util.ValidationUtil.isNumberArray;
		if (u(d))
			n(d, e, f);
		else
			for (var C = d.length, L = 0; L < C; L++)
				if (u(d[L]))
					n(d[L], e, f);
				else
					for (var P = d[L].length, X = 0; X < P; X++)
						n(d[L][X], e, f)
	};
	a.util.GeomUtil.moveGeometry = function (d, e, f) {
		var g = d.getOrdinates(),
		k = d.getType(),
		n = d.getDimension(),
		u;
		if ("Polygon" === k || "MultiLineString" === k) {
			for (d = 0; d < g.length; d++)
				for (k = 0; k < g[d].length; k += n)
					g[d][k] += e, g[d][k + 1] += f;
			return !0
		}
		if ("MultiPolygon" === k) {
			for (k = 0; k < g.length; k++)
				for (d = 0; d < g[k].length; d++)
					for (u = 0; u < g[k][d].length; u +=
						n)
						g[k][d][u] += e, g[k][d][u + 1] += f;
			return !0
		}
		if ("LineString" === k) {
			for (d = 0; d < g.length; d += n)
				g[d] += e, g[d + 1] += f;
			return !0
		}
		if ("Rectangle" === k)
			return d.move(e, f), !0;
		if ("Point" === k)
			return g[0] += e, g[1] += f, !0;
		a.util.Logger.warning("", "OM.util.GeomUtil.moveGeometry", "Unsupported geometry type:" + k);
		return !1
	};
	a.util.GeomUtil.getGreatCircleLength = function (d) {
		for (var e = 0, f = a.util.GeomUtil, g = 0; g < d.length - 2; g += 2)
			e += f.getGreatCircleDistance({
				x: d[g],
				y: d[g + 1]
			}, {
				x: d[g + 2],
				y: d[g + 3]
			});
		return e
	};
	a.util.GeomUtil.getGreatCircleDistance =
	function (d, e) {
		var f = a.util.GeomUtil;
		d = f.getRadiansFromLatLon(d.x, d.y);
		e = f.getRadiansFromLatLon(e.x, e.y);
		var g = Math.sin((e.y - d.y) / 2),
		k = Math.sin((e.x - d.x) / 2),
		g = g * g + Math.cos(d.y) * Math.cos(e.y) * k * k;
		return 2 * Math.atan2(Math.sqrt(g), Math.sqrt(1 - g)) * f.earthRadius
	};
	a.util.GeomUtil.getOGCOrdinateString = function (d, e) {
		var f = 2;
		a.notNull(e) && (f = e);
		for (var g = 0, k = "", n = a.gv.decimals || 6; g < d.length; g += f) {
			0 < g && (k += " ");
			for (var k = k + (d[g].toFixed(n) + "," + d[g + 1].toFixed(n)), u = 2; u < f; u++)
				k += "," + d[g + u].toFixed(n)
		}
		return k
	};
	a.util.GeomUtil.getWktCoordinateStringFromPoint = function (d, e) {
		var f = 2;
		a.notNull(e) && (f = e);
		for (var g = 0, k = ""; g < d.length; g += f) {
			0 < g && (k += " ");
			for (var n = 0; n < f; n++)
				k += d[g + n], n < f - 1 && (k += " ")
		}
		return k
	};
	a.util.GeomUtil.getWktCoordinateStringFromOrientedPoint = function (d, e) {
		var f = 2;
		a.notNull(e) && (f = e);
		for (var g = 0, k = ""; g < f; g += f) {
			0 < g && (k += " ");
			for (var n = 0; n < f; n++)
				k += d[g + n], n < f - 1 && (k += " ")
		}
		return k
	};
	a.util.GeomUtil.getWktCoordinateStringFromLine = function (d, e) {
		var f = 2;
		a.notNull(e) && (f = e);
		for (var g = 0, k = ""; g < d.length; g +=
			f) {
			0 < g && (k += " ");
			for (var n = 0; n < f; n++)
				k += d[g + n], n < f - 1 && (k += " ");
			k += ","
		}
		return k
	};
	a.util.GeomUtil.getCurrentDistancePerPixelPrivate = function (d) {
		var e = d.getUniverse();
		d = d.getZoomLevel();
		d = e.getZoomLevels()[d];
		if (a.notNull(d.distancePerPixel))
			return d.distancePerPixel;
		var e = e.getSRID(),
		f = null,
		f = a.util.GeomUtil.isGeo(e) ? 111195 * d.resolution : d.resolution;
		return d.distancePerPixel = f
	};
	a.util.GeomUtil.getCurrentDistancePerPixel = function (d, e) {
		var f = a.util.GeomUtil.getCurrentDistancePerPixelPrivate(d);
		if (!a.isNull(e))
			if ("pixel" ===
				e)
				f = 1;
			else {
				var g = a.gv.getUnitFactor(e);
				0 !== g && (f /= g)
			}
		return f
	};
	a.util.GeomUtil.calculateGreatCircle = function (d, e, f, g) {
		var k = d.clone(),
		n = e.clone(),
		u = k.getY() * Math.PI / 180,
		C = k.getX() * Math.PI / 180,
		L = n.getY() * Math.PI / 180,
		P = n.getX() * Math.PI / 180,
		n = g,
		k = [],
		X = 0,
		V = Math.PI / 180;
		Math.abs(P - C) === Math.PI && 0 === u + L && (L += Math.PI / 18E7);
		var ca = f * Math.PI / 180;
		for (g *= Math.PI / 180; ca <= g; ) {
			var Wa = Math.atan((Math.sin(u) * Math.cos(L) * Math.sin(ca - P) - Math.sin(L) * Math.cos(u) * Math.sin(ca - C)) / (Math.cos(u) * Math.cos(L) * Math.sin(C - P)));
			k[2 * X] = 180 * ca / Math.PI;
			k[2 * X + 1] = 180 * Wa / Math.PI;
			X++;
			ca = ca < g && ca + V >= g ? g : ca + V
		}
		g = [];
		if (d.getX() > e.getX() && 180 !== n && -180 !== f) {
			for (u = 0; u < k.length / 2; u++)
				g[2 * u] = k[k.length - 2 * u - 2], g[2 * u + 1] = k[k.length - 2 * u - 1];
			k = g
		}
		if (d.getX() < e.getX() && (180 === n || -180 === f)) {
			for (u = 0; u < k.length / 2; u++)
				g[2 * u] = k[k.length - 2 * u - 2], g[2 * u + 1] = k[k.length - 2 * u - 1];
			k = g
		}
		return new a.geometry.LineString(k, 8307)
	};
	a.util.GeomUtil.createGreatCircle = function (d, e) {
		var f = a.util.GeomUtil.isGeo;
		if (f(d.srid) && f(e.srid)) {
			var f = d.getX(),
			g = e.getX(),
			k = [];
			if (f <
				g && 180 > g - f)
				return k[0] = a.util.GeomUtil.calculateGreatCircle(d, e, f, g), k[0];
			if (180 > Math.abs(f - g))
				return k[0] = a.util.GeomUtil.calculateGreatCircle(d, e, g, f), k[0];
			f > g ? (k[0] = a.util.GeomUtil.calculateGreatCircle(d, e, f, 180), k[1] = a.util.GeomUtil.calculateGreatCircle(d, e, -180, g)) : (k[0] = a.util.GeomUtil.calculateGreatCircle(d, e, g, 180), k[1] = a.util.GeomUtil.calculateGreatCircle(d, e, -180, f));
			return new a.geometry.MultiLineString([k[0].coordinates, k[1].coordinates], 8307)
		}
		a.util.Logger.alert("MAPVIEWER_9017", "OM.util.GeomUtil.getGreatCircle",
			"")
	};
	a.util.GeomUtil.flatten = function (d, e, f) {
		var g = [];
		if (!d)
			return null;
		for (var k = d.length, n = 0, u = 0; u < k; u++) {
			var C = d[u];
			if (!(C instanceof a.geometry.Geometry) || 0 > C.getType().indexOf(e))
				return null;
			var L = C.getSRID();
			n || (n = L);
			if (n !== L)
				return null;
			f ? g.push(C.coordinates) : (g.push(C.getX()), g.push(C.getY()))
		}
		return {
			ordinates: g,
			srid: n
		}
	};
	a.util.GeomUtil.getOutCode = function (a, e, f) {
		return a.minX > e ? a.minY > f ? 3 : a.maxY < f ? 9 : 1 : a.maxX < e ? a.minY > f ? 6 : a.maxY < f ? 12 : 4 : a.minY > f ? 2 : a.maxY < f ? 8 : 0
	};
	a.util.GeomUtil.clipLineSegment =
	function (d, e, f, g, k) {
		for (var n = a.util.GeomUtil.getOutCode, u = n(d, e, f), C = n(d, g, k); ; ) {
			if (0 === (u | C))
				return {
					x0: e,
					y0: f,
					x1: g,
					y1: k
				};
			if (0 !== (u & C))
				return null;
			var L = 0 !== u ? u : C,
			P = null,
			X = null;
			0 !== (L & 8) ? (P = e + (g - e) * (d.maxY - f) / (k - f), X = d.maxY) : 0 !== (L & 2) ? (P = e + (g - e) * (d.minY - f) / (k - f), X = d.minY) : 0 !== (L & 4) ? (P = d.maxX, X = f + (k - f) * (d.maxX - e) / (g - e)) : (P = d.minX, X = f + (k - f) * (d.minX - e) / (g - e));
			L === u ? (e = P, f = X, u = n(d, e, f)) : (g = P, k = X, C = n(d, g, k))
		}
	};
	a.util.GeomUtil.clipLine = function (d, e) {
		var f = [];
		a.util.GeomUtil.concatMultiLine(e);
		for (var g =
				0, k = e.length; g < k; g++)
			if (e[g] && e[g][0])
				for (var n = e[g][0], u = 3, C = n.length; u < C; u += 2) {
					var L = a.util.GeomUtil.clipLineSegment(d, n[u - 3], n[u - 2], n[u - 1], n[u]);
					if (L) {
						var P = f.length - 1;
						if (0 <= P) {
							var X = f[P].length;
							if (1 < X && L.x0 === f[P][X - 2] && L.y0 === f[P][X - 1]) {
								f[P].push(L.x1, L.y1);
								continue
							}
						}
						f.push([L.x0, L.y0, L.x1, L.y1])
					}
				}
		return f
	};
	a.util.GeomUtil.getSegmentLength = function (a, e, f, g) {
		return Math.sqrt((a - f) * (a - f) + (e - g) * (e - g))
	};
	a.util.GeomUtil.getScreenLength = function (d) {
		for (var e = 0, f = 0, g = d.length - 3; f < g; f += 2)
			e += a.util.GeomUtil.getSegmentLength(d[f],
				d[f + 1], d[f + 2], d[f + 3]);
		return e
	};
	a.util.GeomUtil.getPointByPercent = function (d, e, f) {
		for (var g = [], k = a.util.GeomUtil, n = 0, u = d.length; n < u; n++) {
			var C = d[n],
			L = k.getScreenLength(C);
			L < f / 2 || (L *= e, (C = k.getPointByLength(L, C)) && g.push(C))
		}
		return g
	};
	a.util.GeomUtil.getPointByLength = function (d, e) {
		for (var f = a.util.GeomUtil, g = 0, k = e.length - 3; g < k; g += 2) {
			var n = f.getSegmentLength(e[g], e[g + 1], e[g + 2], e[g + 3]);
			if (n >= d)
				return f = d / n, {
					x: e[g] + (e[g + 2] - e[g]) * f,
					y: e[g + 1] + (e[g + 3] - e[g + 1]) * f,
					pos: g,
					len: n
				};
			d -= n
		}
		return null
	};
	a.util.GeomUtil.getPoinsByLength =
	function (d, e, f, g, k, n) {
		for (var u = a.util.GeomUtil.getSegmentLength(d[e], d[e + 1], f, g), C = d.length; u < k && 2 <= e && e < C - 2; )
			5 <= u && (k -= u), e += n, u = a.util.GeomUtil.getSegmentLength(d[e], d[e + 1], f, g);
		return u >= k ? (f = k / u, {
			x: d[e - n] + (d[e] - d[e - n]) * f,
			y: d[e + 1 - n] + (d[e + 1] - d[e + 1 - n]) * f
		}) : {
			x: d[e],
			y: d[e + 1]
		}
	};
	a.util.GeomUtil.getCircle = function (a, e, f, g, k, n) {
		var u = Math.sqrt((a - f) * (a - f) + (e - g) * (e - g)),
		C = Math.sqrt((f - k) * (f - k) + (g - n) * (g - n)),
		L = Math.sqrt((a - k) * (a - k) + (e - n) * (e - n)),
		P = (u + C + L) / 2,
		u = u * C * L / 4 / Math.sqrt(P * (P - u) * (P - C) * (P - L)),
		C = ((a * a -
				f * f + e * e - g * g) * (e - n) - (a * a - k * k + e * e - n * n) * (e - g)) / (2 * (e - n) * (a - f) - 2 * (e - g) * (a - k)),
		L = ((a * a - f * f + e * e - g * g) * (a - k) - (a * a - k * k + e * e - n * n) * (a - f)) / (2 * (e - g) * (a - k) - 2 * (e - n) * (a - f));
		a = Math.atan2(e - L, a - C);
		0 > a && (a += 2 * Math.PI);
		k = Math.atan2(n - L, k - C);
		0 > k && (k += 2 * Math.PI);
		f = Math.atan2(g - L, f - C);
		0 > f && (f += 2 * Math.PI);
		a < f && a > k ? k += 2 * Math.PI : a < f && f > k ? a += 2 * Math.PI : a > f && a < k ? k -= 2 * Math.PI : a > f && f < k && (a -= 2 * Math.PI);
		return {
			x: C,
			y: L,
			r: u,
			sAngle: a,
			eAngle: k
		}
	};
	a.util.GeomUtil.isGeo = function (a) {
		return 8307 === a || 8265 === a || 4326 === a || 4269 === a
	};
	a.util.GeomUtil.isClockwise =
	function (d, e) {
		return 0 <= a.util.GeomUtil.polygonArea(d, e)
	};
	a.util.GeomUtil.polylineLength = function (a, e) {
		for (var f = a.length / e, g = 0, k = 0, n, u = 1; u < f; u++)
			n = u * e, k *= e, g += Math.sqrt((a[n] - a[k]) * (a[n] - a[k]) + (a[n + 1] - a[k + 1]) * (a[n + 1] - a[k + 1])), k = u;
		return g
	};
	a.util.GeomUtil.polygonArea = function (a, e) {
		for (var f = e || 2, g = a.length / f, k = 0, n = g - 1, u = 0, k = 0; k < g; k++)
			u += (a[n * f] + a[k * f]) * (a[n * f + 1] - a[k * f + 1]), n = k;
		return u / 2
	};
	a.util.GeomUtil.reverseCoordinates = function (a) {
		for (var e = [], f = 0; f < a.length - 1; f += 2)
			e.unshift(a[f + 1]), e.unshift(a[f]);
		return e
	};
	a.util.GeomUtil.getTransformedGeometry = function (d, e) {
		var f = [],
		g = d.getOrdinates(),
		k = d.getType(),
		n = d.getDimension(),
		u,
		C,
		L;
		if ("Polygon" === k || "MultiLineString" == k)
			for (C = 0; C < g.length; C++)
				u = a.util.GeomUtil.getTransformedCoordinates(g[C], n, e), f[C] = u;
		else if ("MultiPolygon" === k)
			for (L = 0; L < g.length; L++)
				for (f[L] = [], C = 0; C < g[L].length; C++)
					u = a.util.GeomUtil.getTransformedCoordinates(g[L][C], n, e), f[L][C] = u;
		else
			f = a.util.GeomUtil.getTransformedCoordinates(g, n, e);
		if ("Polygon" === k)
			f = new a.geometry.Polygon(f,
					d.srid, d.dim);
		else if ("MultiPolygon" === k)
			f = new a.geometry.MultiPolygon(f, d.srid, d.dim);
		else if ("LineString" === k)
			f = new a.geometry.LineString(f, d.srid, d.dim);
		else if ("MultiLineString" === k)
			f = new a.geometry.MultiLineString(f, d.srid, d.dim);
		else
			throw Error("Unsupported geometry type:" + k);
		return f
	};
	a.util.GeomUtil.getTransformedCoordinates = function (a, e, f) {
		var g = [];
		if (2 === e)
			f.transformAll(a, g);
		else {
			var k = a.length || 0,
			n,
			u,
			C,
			L,
			P,
			X,
			V,
			g = g || a;
			C = f.a;
			L = f.b;
			P = f.c;
			X = f.d;
			V = f.tx;
			f = f.ty;
			for (k = 0; k < a.length; k += e)
				if (n =
						a[k], u = a[k + 1], g[k] = C * n + P * u + V, g[k + 1] = L * n + X * u + f, 2 < e)
					for (n = 2; n < e; n++)
						g[k + n] = a[k + n]
		}
		return g
	};
	a.util.GeomUtil.parseGeoJson = function (d) {
		if (!d.type)
			return null;
		var e = d.coordinates ? d.coordinates : d.geometries,
		f = e.length,
		g = Array.prototype.concat,
		k;
		switch (d.type) {
		case "Point":
			return d.dimension = f,
			d;
		case "OrientedPoint":
			return "number" !== typeof e[0] && (d.coordinates = g.apply([], e)),
			d.dimension = f / 2,
			d;
		case "MultiPoint":
			return d.dimension = e[0].length,
			d;
		case "OrientedMultiPoint":
			if ("number" !== typeof e[0][0])
				for (k =
						0; k < f; k++)
					d.coordinates[k] = g.apply([], e[k]);
			d.dimension = e[0].length / 2;
			return d;
		case "LineString":
			return "number" !== typeof e[0] && (d.dimension = e[0].length, d.coordinates = g.apply([], e)),
			d;
		case "MultiLineString":
			for (k = 0; k < f; k++)
				"number" !== typeof e[k][0] && (d.dimension = e[k][0].length, d.coordinates[k] = g.apply([], e[k]));
			return d;
		case "Polygon":
			for (k = 0; k < f; k++)
				"number" !== typeof e[k][0] && (d.dimension = e[k][0].length, d.coordinates[k] = g.apply([], e[k]));
			return d;
		case "MultiPolygon":
			for (k = 0; k < f; k++)
				for (var n = 0; n <
					e[k].length; n++)
					"number" !== typeof e[k][n][0] && (d.dimension = e[k][n][0].length, d.coordinates[k][n] = g.apply([], e[k][n]));
			return d;
		case "GeometryCollection":
			for (k = 0; k < f; k++)
				e[k] = a.util.GeomUtil.parseGeoJson(e[k]);
			d.dimension = d.geometries[0].dimension;
			return d;
		case "Circle":
			d.dimension = 2;
			for (k = 0; k < f; k++)
				isNaN(e[k][0]) && (d.coordinates[k] = e[k]);
			return d;
		case "Rectangle":
			d.dimension = 2;
			for (k = 0; k < f; k++)
				isNaN(e[k][0]) && (d.coordinates[k] = e[k]);
			return d
		}
	};
	a.util.GeomUtil.parseCRSName = function (d) {
		d.indexOf("EPSG");
		var e = d.split(":");
		1 === e.length && (e = d.split(" "));
		for (d = e.length - 1; -1 < d; d--)
			e[d] = e[d].trim(), "" === e[d] && e.splice(d, 1);
		for (d = 0; d < e.length - 1; d++)
			if ("EPSG" === e[d].toUpperCase())
				return a.util.GeomUtil.EPSG_SDO_Map[e[d + 1]];
		return null
	};
	a.util.GeomUtil.concatMultiLine = function (a) {
		for (var e = a.length, f = 0, g = e - 1; f < g; f++)
			if (a[f] && a[f][0])
				for (var k = f + 1; k < e; k++)
					if (a[k] && a[k][0]) {
						var n = a[f][0].length,
						u = a[k][0].length;
						3 > Math.abs(a[f][0][n - 2] - a[k][0][0]) && 3 > Math.abs(a[f][0][n - 1] - a[k][0][1]) ? (Array.prototype.push.apply(a[f][0],
								a[k][0]), a.splice(k, 1), e--, g--, k--) : 3 > Math.abs(a[f][0][0] - a[k][0][u - 2]) && 3 > Math.abs(a[f][0][1] - a[k][0][u - 1]) && (Array.prototype.push.apply(a[k][0], a[f][0]), a[f] = a[k], a.splice(k, 1), e--, g--, k--)
					}
	};
	a.util.GeomUtil.distanceToSegment = function (a, e, f, g, k, n) {
		var u = [],
		C;
		if (0 >= (a - f) * (k - f) + (e - g) * (n - g))
			return u[0] = Math.sqrt((a - f) * (a - f) + (e - g) * (e - g)), u[1] = 0, u;
		if (0 >= (a - k) * (f - k) + (e - n) * (g - n))
			return u[0] = Math.sqrt((a - k) * (a - k) + (e - n) * (e - n)), u[1] = 1, u;
		u[1] = 2;
		C = Math.sqrt((k - f) * (k - f) + (n - g) * (n - g));
		if (0 === C)
			return u[0] = Math.sqrt((a -
						f) * (a - f) + (e - g) * (e - g)), u;
		u[0] = Math.abs((a - f) * (n - g) - (e - g) * (k - f)) / C;
		return u
	};
	a.util.GeomUtil.getSegmentPoint = function (a, e, f, g, k, n) {
		k -= f;
		n -= g;
		0 === k ? a = e : 0 === n ? (f = a, a = g) : (n /= k, f = (a + n * (e - g) + n * n * f) / (1 + n * n), a = (a - f) / n + e);
		return [f, a]
	};
	a.util.GeomUtil.poinInPolygonGeometry = function (d, e, f) {
		if (a.isNull(d) || "Polygon" !== d.getType())
			return !1;
		var g = d.getDimension(),
		k = d.coordinates.length,
		n = d.coordinates[0].length,
		u = [],
		C = [],
		L;
		for (L = 0; L < n; L += g)
			u[L / g] = d.coordinates[0][L], C[L / g] = d.coordinates[0][L + 1];
		if (a.util.GeomUtil.pointInPolygon(e,
				f, n / g, u, C)) {
			for (var P = !1, X = 1; X < k; X++) {
				n = d.coordinates[X].length;
				u = [];
				C = [];
				L = n / g;
				for (var V = 0; V < n; V += g)
					u[V / g] = d.coordinates[X][V], C[V / g] = d.coordinates[X][V + 1];
				if (a.util.GeomUtil.pointInPolygon(e, f, L, u, C)) {
					P = !0;
					break
				}
			}
			if (!1 === P)
				return !0
		}
		return !1
	};
	a.util.GeomUtil.findGeometryElement = function (d, e, f, g) {
		if (a.isNull(d))
			return !1;
		var k = d.getType(),
		n = d.getDimension(),
		u = -1,
		C = Number.MAX_VALUE,
		L = d.getOrdinates();
		switch (k) {
		case "Point":
			n = d.getX() - e;
			d = d.getY() - f;
			d = Math.sqrt(n * n + d * d);
			d <= g && (u = 0);
			break;
		case "MultiPoint":
			for (k =
					0; k < L.length; k++)
				n = L[k][0] - e, d = L[k][1] - f, d = Math.sqrt(n * n + d * d), d <= g && d < C && (C = d, u = k);
			break;
		case "LineString":
			for (C = 0; C < L.length - n; C += n)
				if (d = a.util.GeomUtil.distanceToSegment(e, f, L[C], L[C + 1], L[C + n], L[C + n + 1]), d[0] <= g) {
					u = 0;
					break
				}
			break;
		case "MultiLineString":
			for (k = 0; k < L.length; k++)
				for (var P = 0; P < L[k].length - n; P += n)
					if (d = a.util.GeomUtil.distanceToSegment(e, f, L[k][P], L[k][P + 1], L[k][P + n], L[k][P + n + 1]), d[0] <= g && d[0] < C) {
						u = k;
						C = d[0];
						break
					}
			break;
		case "Polygon":
			a.util.GeomUtil.poinInPolygonGeometry(d, e, f) && (u = 0);
			break;
		case "MultiPolygon":
			for (g = 0; g < L.length; g++)
				if (C = new a.geometry.Polygon(L[g], d.getSRID(), d.dim), a.util.GeomUtil.poinInPolygonGeometry(C, e, f)) {
					u = g;
					break
				}
		}
		return u
	};
	a.util.GeomUtil.removeGeometryElement = function (d, e) {
		if (a.isNull(d) || 0 > e)
			return null;
		var f = d.getType();
		if ("MultiPoint" !== f && "MultiLineString" !== f && "OrientedMultiPoint" !== f && "MultiPolygon" !== f && "GeometryCollection" !== f)
			return null;
		var g = d.getDimension(),
		k = d.getOrdinates();
		if (a.isNull(k))
			return null;
		var n = k.length;
		if (e >= n)
			return null;
		switch (f) {
		case "MultiPoint":
			k.splice(e,
				1);
			if (2 === n && (d = new a.geometry.Point(k[0][0], k[0][1], d.getSRID()), 2 < g))
				for (f = 2; f < g; f++)
					d.addDimension(k[0][f]);
			break;
		case "OrientedMultiPoint":
			return null;
		case "MultiLineString":
			k.splice(e, 1);
			2 === n && (d = new a.geometry.LineString(k[0], d.getSRID(), g));
			break;
		case "MultiPolygon":
			k.splice(e, 1);
			2 === n && (d = new a.geometry.Polygon(k[0], d.getSRID(), g));
			break;
		case "GeometryCollection":
			return null;
		default:
			return null
		}
		d.mbr = null;
		d.getMBR();
		return d
	};
	a.util.GeomUtil.cloneGeometryElement = function (d, e) {
		if (a.isNull(d) ||
			0 > e)
			return null;
		var f = d.getType();
		if ("MultiPoint" !== f && "MultiLineString" !== f && "OrientedMultiPoint" !== f && "MultiPolygon" !== f && "GeometryCollection" !== f)
			return null;
		var g = d.getDimension(),
		k = d.getOrdinates();
		if (a.isNull(k) || e >= k.length)
			return null;
		var n = null,
		n = [],
		u = function (a) {
			for (var d = [], e = 0; e < a.length; e++)
				d[e] = a[e]instanceof Array ? u(a[e]) : a[e];
			return d
		};
		switch (f) {
		case "MultiPoint":
			n = new a.geometry.Point(k[e][0], k[e][1], d.getSRID());
			if (2 < g)
				for (f = 2; f < g; f++)
					n.addDimension(k[e][f]);
			break;
		case "OrientedMultiPoint":
			return null;
		case "MultiLineString":
			n = u(k[e]);
			n = new a.geometry.LineString(n, d.getSRID(), g);
			break;
		case "MultiPolygon":
			n = u(k[e]);
			n = new a.geometry.Polygon(n, d.getSRID(), g);
			break;
		case "GeometryCollection":
			return null;
		default:
			return null
		}
		n.mbr = null;
		n.getMBR();
		return n
	};
	a.util.GeomUtil.getSquareDistance = function (a, e) {
		var f = a.x - e.x,
		g = a.y - e.y;
		return f * f + g * g
	};
	a.util.GeomUtil.getSquareSegmentDistance = function (a, e, f) {
		var g = e.x;
		e = e.y;
		var k = f.x - g,
		n = f.y - e,
		u;
		if (0 !== k || 0 !== n)
			u = ((a.x - g) * k + (a.y - e) * n) / (k * k + n * n), 1 < u ? (g = f.x, e = f.y) :
			0 < u && (g += k * u, e += n * u);
		k = a.x - g;
		n = a.y - e;
		return k * k + n * n
	};
	a.util.GeomUtil.simplifyRadialDistance = function (a, e) {
		var f,
		g = a.length,
		k,
		n = a[0],
		u = [n];
		for (f = 1; f < g; f++)
			k = a[f], this.getSquareDistance(k, n) > e && (u.push(k), n = k);
		n !== k && u.push(k);
		return u
	};
	a.util.GeomUtil.simplifyDouglasPeucker = function (a, e) {
		var f = a.length,
		g = new(typeof Uint8Array !== c + "" ? Uint8Array : Array)(f),
		k = 0,
		n = f - 1,
		u,
		C,
		L,
		P,
		X = [],
		V = [],
		ca = [];
		for (g[k] = g[n] = 1; n; ) {
			C = 0;
			for (u = k + 1; u < n; u++)
				L = this.getSquareSegmentDistance(a[u], a[k], a[n]), L > C && (P = u, C = L);
			C > e && (g[P] =
					1, X.push(k), V.push(P), X.push(P), V.push(n));
			k = X.pop();
			n = V.pop()
		}
		for (u = 0; u < f; u++)
			g[u] && ca.push(a[u]);
		return ca
	};
	a.util.GeomUtil.simplify = function (a, e) {
		var f = e !== c ? e * e : 1;
		a = this.simplifyRadialDistance(a, f);
		return a = this.simplifyDouglasPeucker(a, f)
	};
	a.util.GeomUtil.simplifyCoordinates = function (a, e) {
		var f = this.coordinates2points(a),
		f = this.simplify(f, e);
		return this.points2coordinates(f)
	};
	a.util.GeomUtil.points2coordinates = function (a) {
		for (var e = [], f = 0; f < a.length; f++)
			e.push(a[f].x), e.push(a[f].y);
		return e
	};
	a.util.GeomUtil.coordinates2points = function (a) {
		for (var e = [], f = 0; f < a.length; )
			e.push({
				x: a[f],
				y: a[f + 1]
			}), f += 2;
		return e
	};
	a.util.GeomUtil.toValidCoordinate = function (a, e) {
		for (var f = a.getUniverse().getMapBounds(), g = f.getWidth(), k = f.getMinX(), f = f.getMaxX(), n = 0; n < e.length; n++)
			e[2 * n] < k && (e[2 * n] -= Math.floor((e[2 * n] + g / 2) / g) * g), e[2 * n] > f && (e[2 * n] -= Math.ceil((e[2 * n] - g / 2) / g) * g);
		return e
	};
	a.util.GeomUtil.isWithinBBox = function (a, e, f, g, k, n) {
		return a < f || a > k || e < g || e > n ? !1 : !0
	};
	a.util.GeomUtil.screenPointsXOffset = function (a,
		e, f) {
		var g = f.getUniverse().getMapBounds().getWidth(),
		k = f.getBaseWholeMapIndex(),
		n = f.getUniverse().getZoomLevels()[f.getZoomLevel()].resolution;
		return 1 < f.getWholeMapNum() ? a + g * (e - k) / n + (f.getRoundMapCenterPoint().getX() - f.getCenterPoint().getX()) / n : a + g * (e - k) / n
	};
	a.util.GeomUtil.EPSG_SDO_Map = {
		3857: 3857,
		3875: 3857,
		4326: 8307,
		4269: 8265,
		4267: 8260,
		4202: 81920,
		4203: 81921,
		20248: 81922,
		20249: 81924,
		20250: 81926,
		20251: 81928,
		20252: 81930,
		20253: 81932,
		20254: 81934,
		20255: 81936,
		20256: 81938,
		20257: 81940,
		20258: 81942,
		20348: 81923,
		20349: 81925,
		20350: 81927,
		20351: 81929,
		20352: 81931,
		20353: 81933,
		20354: 81935,
		20355: 81937,
		20356: 81939,
		20357: 81941,
		20358: 81943,
		23028: 82323,
		23029: 82328,
		23030: 82337,
		23031: 82340,
		23032: 82343,
		23033: 82346,
		23034: 82349,
		23035: 82352,
		23036: 82355,
		23037: 82358,
		23038: 82361
	};
	a.util.BaiduUtil = a.util.BaiduUtil || {};
	a.util.BaiduUtil.SRID = 38578009;
	a.util.BaiduUtil.MIN_ZOOM_LEVEL = 4;
	a.util.BaiduUtil.MAX_ZOOM_LEVEL = 18;
	a.util.BaiduUtil.transformGeom = function (d) {
		if (a.isNull(d) || a.isNull(d.map))
			return a.util.Logger.warning("", "OM.util.BaiduUtil.transformGeom",
				"No valid map parameter found. Please provide {'map':myMap}."), d.geom;
		if (a.isNull(d.geom))
			return a.util.Logger.warning("", "OM.util.BaiduUtil.transformGeom", "No valid geometry parameter found. Please provide {'geom':myGeometry}."), null;
		d.toSrid = a.notNull(d.toSrid) ? d.toSrid : a.util.BaiduUtil.SRID;
		if (a.util.BaiduUtil.isSameSRID(d.geom.srid, d.toSrid))
			return a.notNull(d.callBack) && d.callBack(d.geom), d.geom;
		if (d.geom.srid === a.util.BaiduUtil.SRID)
			return a.util.BaiduUtil.transform_PixToBD09LonLat({
				geom: d.geom,
				toSrid: 8307,
				bdutil: d.map.bdutil,
				callBack: function (a) {
					return a.transform(d.toSrid, d.callBack)
				}
			});
		if (d.toSrid === a.util.BaiduUtil.SRID)
			return d.geom.transform(8307, function (e) {
				return a.util.BaiduUtil.transform_BD09LonLatToPix({
					geom: e,
					toSrid: a.util.BaiduUtil.SRID,
					bdutil: d.map.bdutil,
					callBack: d.callBack,
					inputIsBD09LonLat: d.inputIsBD09LonLat
				})
			});
		a.util.Logger.warning("", "OM.util.BaiduUtil.transformGeom", "Transform not supported from " + d.geom.srid + " to " + d.toSrid);
		return null
	};
	a.util.BaiduUtil.isSameSRID =
	function (a, e) {
		return a !== e && (8307 !== a && 4326 !== a || 8307 !== e && 4326 !== e) ? !1 : !0
	};
	a.util.BaiduUtil.transform_BD09LonLatToPix = function (d) {
		if (a.isNull(d) || a.isNull(d.geom))
			return a.util.Logger.warning("", "OM.util.BaiduUtil.transform_BD09LonLatToPix", "No geometry found in the input parameters."), null;
		if (a.isNull(d.bdutil))
			return a.util.Logger.warning("", "OM.util.BaiduUtil.transform_BD09LonLatToPix", "No Baidu conversion utilities found in the input parameters."), null;
		var e = d.geom,
		f = a.util.BaiduUtil.SRID,
		g =
			d.bdutil,
		k = d.callBack;
		d = d.inputIsBD09LonLat;
		if (8307 !== e.srid && 4326 !== e.srid)
			return a.util.Logger.warning("", "OM.util.BaiduUtil.transform_BD09LonLatToPix", "SRID [" + e.srid + "] is not supported."), null;
		if (e.srid === a.util.BaiduUtil.SRID)
			return k && k(e, g), e;
		if (g)
			switch (e.type) {
			case "Point":
				return a.util.BaiduUtil.transformLonLatToPix_Point(e, f, g, k, d);
			case "LineString":
				return a.util.BaiduUtil.transformLonLatToPix_Line(e, f, g, k, d);
			case "MultiLineString":
				return a.util.BaiduUtil.transformLonLatToPix_MultiLine(e,
					f, g, k, d);
			case "Rectangle":
				return a.util.BaiduUtil.transformLonLatToPix_Rectangle(e, f, g, k, d);
			case "Polygon":
				return a.util.BaiduUtil.transformLonLatToPix_Polygon(e, f, g, k, d);
			case "MultiPolygon":
				return a.util.BaiduUtil.transformLonLatToPix_MultiPolygon(e, f, g, k, d);
			default:
				return a.util.Logger.warning("", "OM.util.BaudiUtil.transform_BD09LonLatToPix", "Type [" + this.type + "] is not supported yet."),
				null
			}
		else
			return a.util.Logger.warning("", "OM.util.BaudiUtil.transform_BD09LonLatToPix", "Baidu BD09 encoding utility is not provided."),
			null
	};
	a.util.BaiduUtil.transformLonLatToPix_Point = function (d, e, f, g, k) {
		return f.enableBD09Encoding && this.isWithinChinaRect(d) && !0 !== k ? a.util.BaiduUtil.Point_WGS84ToBaiduPix(d, e, f, g) : a.util.BaiduUtil.Point_BD09LonLatToPix(d, e, f, g)
	};
	a.util.BaiduUtil.Point_WGS84ToBaiduPix = function (d, e, f, g) {
		var k = a.geometry,
		n = null;
		try {
			for (var u = f.WGS84ToBD09, C = [], L = 0, P = d.coordinates.length; L < P; L += d.dim)
				C.push(new BMap.Point(d.coordinates[L], d.coordinates[L + 1]));
			u.translate(C, 1, 5, function (u) {
				if (0 === u.status) {
					u = u.points;
					for (var C = u.length, L = [], P = 0; P < C; P++) {
						var va = f.project.lngLatToPoint(u[P]);
						L.push(va.x);
						L.push(va.y);
						3 === d.dim && L.push(d.coordinates[P * d.dim + 2])
					}
					n = k.Geometry.createGeometry({
						type: d.type,
						dim: d.dim,
						coordinates: L
					}, e);
					n.dim = d.dim;
					a.notNull(g) && g(n, f)
				} else
					a.util.Logger.warning(null, "OM.util.BaudiUtil.transformLonLatToPix_Point", "server returned status: Failed.")
			});
			return n
		} catch (X) {
			return a.util.Logger.warning(null, "OM.util.BaiduUtil.transformLonLatToPix_Point", "Cannot transform geometry coordinates to SRID: " +
				e + ", due to " + X.message),
			null
		}
	};
	a.util.BaiduUtil.Point_BD09LonLatToPix = function (d, e, f, g, k) {
		var n = a.geometry,
		u = null,
		C,
		L,
		P,
		X = [],
		V = [],
		ca,
		Wa;
		try {
			C = 0;
			for (P = d.coordinates.length; C < P; C += d.dim)
				ca = d.coordinates[C], Wa = d.coordinates[C + 1], k ? X.push(new BMap.Pixel(ca, Wa)) : X.push(new BMap.Point(ca, Wa));
			P = X.length;
			V = [];
			for (L = 0; L < P; L += d.dim) {
				var va;
				k ? (va = f.project.pointToLngLat(X[L]), V.push(va.lng), V.push(va.lat)) : (va = f.project.lngLatToPoint(X[L]), V.push(va.x), V.push(va.y));
				3 === d.dim && V.push(d.coordinates[L * d.dim +
						2])
			}
			u = n.Geometry.createGeometry({
				type: d.type,
				dim: d.dim,
				coordinates: V
			}, e);
			u.dim = d.dim;
			a.notNull(g) && g(u, f);
			return u
		} catch (b) {
			return a.util.Logger.warning(null, "OM.util.BaiduUtil.Point_BD09LonLatToPix", "Cannot transform geometry coordinates to SRID: " + e + ", due to " + b.message),
			null
		}
	};
	a.util.BaiduUtil.isWithinChinaRect = function (d) {
		var e,
		f,
		g,
		k;
		switch (d.type) {
		case "Polygon":
			e = [];
			for (k = 0; k < d.coordinates.length; k++)
				for (g = 0; g < d.coordinates[k].length; g++)
					e.push(d.coordinates[k][g]);
			break;
		case "MultiPolygon":
			e =
				[];
			for (f = 0; f < d.coordinates.length; f++) {
				var n = d.coordinates[f];
				for (k = 0; k < n.length; k++)
					for (g = 0; g < n[k].length; g++)
						e.push(n[k][g])
			}
			break;
		case "MultiLine":
			e = [];
			for (k = 0; k < d.coordinates.length; k++)
				for (g = 0; g < d.coordinates[k].length; g++)
					e.push(d.coordinates[k][g]);
			break;
		default:
			e = d.getOrdinates()
		}
		f = d.getDimension();
		d = {
			minX: Number.POSITIVE_INFINITY,
			minY: Number.POSITIVE_INFINITY,
			maxX: Number.NEGATIVE_INFINITY,
			maxY: Number.NEGATIVE_INFINITY
		};
		d = a.geometry.Geometry.getCoordsMBR(e, f, d);
		e = a.util.GeomUtil.pointInRect;
		return e(d.minX, d.minY, 73, 1, 134, 53) && e(d.minX, d.maxY, 73, 1, 134, 53) && e(d.maxX, d.minY, 73, 1, 134, 53) && e(d.maxX, d.maxY, 73, 1, 134, 53) ? !0 : !1
	};
	a.util.BaiduUtil.MultiLine_WGS84ToBaiduPix = function (d, e, f, g) {
		var k = a.geometry,
		n,
		u,
		C,
		L,
		P,
		X;
		try {
			var V = 0,
			ca = [];
			for (P = 0; P < d.coordinates.length; P += 1) {
				var Wa = d.coordinates[P];
				ca.push(Math.ceil(Wa.length / 200));
				var va = [],
				b = {};
				C = 0;
				for (X = Wa.length; C < X; C += d.dim) {
					var Hb = Wa[C],
					c = Wa[C + 1];
					0 < C && 0 === C % 200 ? (u = va.join(""), va = [], a.util.BaiduUtil.doBaiduConversion(u, b, V, f), V += 1) : C === X - d.dim &&
					(va.push(";" + Hb + "," + c), u = va.join(""), va = [], a.util.BaiduUtil.doBaiduConversion(u, b, V, f), V += 1);
					0 === C || 0 === C % 200 ? va.push("" + Hb + "," + c) : va.push(";" + Hb + "," + c)
				}
			}
			var pb = !0,
			qb,
			ub = 0;
			qb = setInterval(function () {
				a: if (ub++, 100 < ub)
					clearInterval(qb), a.util.Logger.warning(null, "OM.util.BaudiUtil.MultiLine_WGS84ToBaiduPix", "Failed to assemble the feature.");
				else {
					for (P = V = 0; P < ca.length; P += 1)
						for (C = 0; C < ca[P]; C += 1) {
							if (a.isNull(b[V.toString()])) {
								pb = !1;
								break a
							}
							V += 1
						}
					if (!0 === pb) {
						clearInterval(qb);
						var u = [];
						V = 0;
						var X = [];
						for (C =
								0; C < ca.length; C += 1) {
							var u = [],
							Wa = V.toString();
							for (P = 0; P < b[V].length; P += 1) {
								var va = new BMap.Point(b[Wa][P].x, b[Wa][P].y),
								va = f.project.lngLatToPoint(va);
								u.push(va.x);
								u.push(va.y);
								for (L = 2; L < d.dim; L += 1)
									u.push("")
							}
							V += 1;
							X.push(u)
						}
						n = k.Geometry.createGeometry({
							type: d.type,
							dim: d.dim,
							coordinates: X
						}, e);
						n.dim = d.dim;
						g(n, f)
					}
				}
			}, 1E3);
			return n
		} catch (Bb) {
			return a.util.Logger.warning(null, "OM.util.BaiduUtil.MultiLine_WGS84ToBaiduPix", "Cannot transform geometry coordinates to SRID: " + e + ", due to " + Bb.message),
			null
		}
	};
	a.util.BaiduUtil.MultiLine_BD09LonLatToPix =
	function (d, e, f, g, k) {
		var n = a.geometry;
		try {
			for (var u = [], C = 0; C < d.coordinates.length; C += 1) {
				for (var L = d.coordinates[C], P = [], X = 0; X < L.length; X += d.dim) {
					var V;
					k ? (V = f.project.pointToLngLat(new BMap.Pixel(L[X], L[X + 1])), P.push(V.lng), P.push(V.lat)) : (V = f.project.lngLatToPoint(new BMap.Point(L[X], L[X + 1])), P.push(V.x), P.push(V.y));
					for (var ca = 2; ca < d.dim; ca += 1)
						P.push("")
				}
				u.push(P)
			}
			var Wa = n.Geometry.createGeometry({
				type: d.type,
				dim: d.dim,
				coordinates: u
			}, e);
			g && g(Wa, f);
			return Wa
		} catch (va) {
			return a.util.Logger.warning(null,
				"OM.util.BaiduUtil.MultiLine_BD09LonLatToPix", "Cannot transform geometry coordinates to SRID " + e + ", due to " + va.message),
			null
		}
	};
	a.util.BaiduUtil.Polygon_WGS84ToPix = function (d, e, f, g) {
		var k = a.geometry,
		n,
		u,
		C,
		L,
		P;
		try {
			var X = 0,
			V = [],
			ca;
			for (C = 0; C < d.coordinates.length; C += 1) {
				var Wa = d.coordinates[C];
				V.push(Math.ceil(Wa.length / 200));
				var va = [],
				b = {};
				n = 0;
				for (L = Wa.length; n < L; n += d.dim) {
					var c = Wa[n],
					h = Wa[n + 1];
					0 < n && 0 === n % 200 ? (ca = va.join(""), va = [], a.util.BaiduUtil.doBaiduConversion(ca, b, X, f), X += 1) : n === L - d.dim && (va.push(";" +
							c + "," + h), ca = va.join(""), va = [], a.util.BaiduUtil.doBaiduConversion(ca, b, X, f), X += 1);
					0 === n || 0 === n % 200 ? va.push("" + c + "," + h) : n !== L - d.dim && va.push(";" + c + "," + h)
				}
			}
			var pb = !0,
			qb,
			ub = 0;
			qb = setInterval(function () {
				a: if (ub++, 100 < ub)
					clearInterval(qb), a.util.Logger.warning(null, "OM.util.BaudiUtil.Polygon_WGS84ToPix", "Failed to assemble the feature.");
				else {
					var L = 0;
					for (C = 0; C < V.length; C += 1)
						for (n = 0; n < V[C]; n += 1) {
							if (a.isNull(b[L.toString()])) {
								pb = !1;
								break a
							}
							L += 1
						}
					if (!0 === pb) {
						clearInterval(qb);
						var X = [],
						L = 0,
						ca = [];
						for (n = 0; n < V.length; n +=
							1) {
							var X = [],
							Wa = L.toString();
							for (C = 0; C < b[L].length; C += 1) {
								var va = new BMap.Point(b[Wa][C].x, b[Wa][C].y),
								va = f.project.lngLatToPoint(va);
								X.push(va.x);
								X.push(va.y);
								for (u = 2; u < d.dim; u += 1)
									X.push("")
							}
							L += 1;
							ca.push(X)
						}
						P = k.Geometry.createGeometry({
							type: d.type,
							dim: d.dim,
							coordinates: ca
						}, e);
						P.dim = d.dim;
						g(P, f)
					}
				}
			}, 1E3);
			return P
		} catch (Bb) {
			return a.util.Logger.warning(null, "OM.util.BaiduUtil.Polygon_WGS84ToPix", "Cannot transform geometry coordinates to SRID " + e + ", due to " + Bb.message),
			null
		}
	};
	a.util.BaiduUtil.Rectangle_WGS84ToPix =
	function (d, e, f, g) {
		var k = a.geometry,
		n,
		u,
		C,
		L,
		P;
		try {
			var X = 0,
			V = [],
			ca;
			for (C = 0; C < d.coordinates.length; C += 1) {
				var Wa = d.coordinates[C];
				V.push(1);
				var b = [],
				ab = {};
				n = 0;
				for (L = Wa.length; n < L; n += d.dim) {
					var c = Wa[n],
					h = Wa[n + 1];
					0 < n && 0 === n % 200 ? (ca = b.join(""), b = [], a.util.BaiduUtil.doBaiduConversion(ca, ab, X, f), X += 1) : n === L - d.dim && (b.push(";" + c + "," + h), ca = b.join(""), b = [], a.util.BaiduUtil.doBaiduConversion(ca, ab, X, f), X += 1);
					0 === n ? b.push("" + c + "," + h) : n !== L - d.dim && b.push(";" + c + "," + h)
				}
				a.util.BaiduUtil.doBaiduConversion(ca, ab, X, f)
			}
			var pb =
				!0,
			qb,
			ub = 0;
			qb = setInterval(function () {
				a: if (ub++, 100 < ub)
					clearInterval(qb), a.util.Logger.warning(null, "OM.util.BaudiUtil.Rectangle_WGS84ToPix", "Failed to assemble the feature.");
				else {
					var L = 0;
					for (C = 0; C < V.length; C += 1)
						for (n = 0; n < V[C]; n += 1) {
							if (a.isNull(ab[L.toString()])) {
								pb = !1;
								break a
							}
							L += 1
						}
					if (!0 === pb) {
						clearInterval(qb);
						var X = [],
						L = 0,
						ca = [];
						for (n = 0; n < V.length; n += 1) {
							var X = [],
							Wa = L.toString();
							for (C = 0; C < ab[L].length; C += 1) {
								var b = new BMap.Point(ab[Wa][C].x, ab[Wa][C].y),
								b = f.project.lngLatToPoint(b);
								X.push(b.x);
								X.push(b.y);
								for (u = 2; u < d.dim; u += 1)
									X.push("")
							}
							L += 1;
							ca.push(X)
						}
						P = k.Geometry.createGeometry({
							type: d.type,
							dim: d.dim,
							coordinates: ca
						}, e);
						P.dim = d.dim;
						g(P, f)
					}
				}
			}, 1E3);
			return P
		} catch (Bb) {
			return a.util.Logger.warning(null, "OM.util.BaiduUtil.Rectangle_WGS84ToPix", "Cannot transform geometry coordinates to SRID " + e + ", due to " + Bb.message),
			null
		}
	};
	a.util.BaiduUtil.Polygon_BD09LonLatToPix = function (d, e, f, g, k) {
		var n = a.geometry,
		u;
		try {
			for (var C = [], L = 0; L < d.coordinates.length; L += 1) {
				for (var P = d.coordinates[L], X = [], V = 0; V < P.length; V +=
					d.dim) {
					var ca;
					k ? (ca = f.project.pointToLngLat(new BMap.Pixel(P[V], P[V + 1])), X.push(ca.lng), X.push(ca.lat)) : (ca = f.project.lngLatToPoint(new BMap.Point(P[V], P[V + 1])), X.push(ca.x), X.push(ca.y));
					for (var Wa = 2; Wa < d.dim; Wa += 1)
						X.push("")
				}
				C.push(X)
			}
			u = n.Geometry.createGeometry({
				type: d.type,
				dim: d.dim,
				coordinates: C
			}, e);
			g && g(u, f);
			return u
		} catch (b) {
			return a.util.Logger.warning(null, "OM.util.BaiduUtil.Polygon_BD09LonLatToPix", "Cannot transform geometry coordinates to SRID " + e + ", due to " + b.message),
			null
		}
	};
	a.util.BaiduUtil.Rectangle_BD09LonLatToPix =
	function (d, e, f, g, k) {
		var n = a.geometry,
		u;
		try {
			for (var C = d.coordinates, L = [], P = 0; P < C.length; P += d.dim) {
				var X;
				k ? (X = f.project.pointToLngLat(new BMap.Pixel(C[P], C[P + 1])), L.push(X.lng), L.push(X.lat)) : (X = f.project.lngLatToPoint(new BMap.Point(C[P], C[P + 1])), L.push(X.x), L.push(X.y))
			}
			u = n.Geometry.createGeometry({
				type: d.type,
				dim: d.dim,
				coordinates: L
			}, e);
			g && g(u, f);
			return u
		} catch (V) {
			return a.util.Logger.warning(null, "OM.util.BaiduUtil.Rectangle_BD09LonLatToPix", "Cannot transform geometry coordinates to SRID " + e + ", due to " +
				V.message),
			null
		}
	};
	a.util.BaiduUtil.MultiPolygon_WGS84LonLatToPix = function (d, e, f, g) {
		var k = a.geometry,
		n,
		u,
		C,
		L,
		P;
		try {
			var X = 0,
			V = [],
			ca;
			for (L = 0; L < d.coordinates.length; L += 1) {
				var Wa = d.coordinates[L];
				V.push(Math.ceil(Wa.length / 200));
				var b = [],
				ab = {};
				u = 0;
				for (P = Wa.length; u < P; u += d.dim) {
					var c = Wa[u],
					h = Wa[u + 1];
					0 < u && 0 === u % 200 ? (ca = b.join(""), b = [], a.util.BaiduUtil.doBaiduConversion(ca, ab, X, f), X += 1) : u === P - d.dim && (b.push(";" + c + "," + h), ca = b.join(""), b = [], a.util.BaiduUtil.doBaiduConversion(ca, ab, X, f), X += 1);
					0 === u || 0 === u % 200 ?
					b.push("" + c + "," + h) : b.push(";" + c + "," + h)
				}
			}
			var pb = !0,
			qb,
			ub = 0;
			qb = setInterval(function () {
				a: if (ub++, 100 < ub)
					clearInterval(qb), a.util.Logger.warning(null, "OM.util.BaudiUtil.MultiPolygon_WGS84LonLatToPix", "Failed to assemble the feature.");
				else {
					var P = 0;
					for (L = 0; L < V.length; L += 1)
						for (u = 0; u < V[L]; u += 1) {
							if (a.isNull(ab[P.toString()])) {
								pb = !1;
								break a
							}
							P += 1
						}
					if (!0 === pb) {
						clearInterval(qb);
						var X,
						P = 0,
						ca = [];
						for (u = 0; u < V.length; u += 1) {
							X = [];
							var b = P.toString();
							for (L = 0; L < ab[P].length; L += 1) {
								var Wa = new BMap.Point(ab[b][L].x, ab[b][L].y),
								Wa = f.project.lngLatToPoint(Wa);
								X.push(Wa.x);
								X.push(Wa.y);
								for (C = 2; C < d.dim; C += 1)
									X.push("")
							}
							P += 1;
							ca.push(X)
						}
						n = k.Geometry.createGeometry({
							type: d.type,
							dim: d.dim,
							coordinates: ca
						}, e);
						n.dim = d.dim;
						g(n, f)
					}
				}
			}, 1E3);
			return n
		} catch (Bb) {
			return a.util.Logger.warning(null, "OM.util.BaiduUtil.MultiPolygon_WGS84LonLatToPix", "Cannot transform geometry coordinates to SRID " + e + ", due to " + Bb.message),
			null
		}
	};
	a.util.BaiduUtil.MultiPolygon_BD09LonLatToPix = function (d, e, f, g, k) {
		var n = a.geometry,
		u,
		C,
		L,
		P;
		try {
			var X = [];
			for (C = 0; C <
				d.coordinates.length; C += 1) {
				var V = d.coordinates[C][0],
				ca = [];
				for (P = 0; P < V.length; P += d.dim) {
					var b;
					k ? (b = f.project.pointToLngLat(new BMap.Pixel(V[P], V[P + 1])), ca.push(b.lng), ca.push(b.lat)) : (b = f.project.lngLatToPoint(new BMap.Point(V[P], V[P + 1])), ca.push(b.x), ca.push(b.y));
					for (L = 2; L < d.dim; L += 1)
						ca.push("")
				}
				var va = [];
				va.push(ca);
				X.push(va)
			}
			u = n.Geometry.createGeometry({
				type: d.type,
				dim: d.dim,
				coordinates: X
			}, e);
			g && g(u, f);
			return u
		} catch (ab) {
			return a.util.Logger.warning(null, "OM.util.BaiduUtil.MultiPolygon_BD09LonLatToPix",
				"Cannot transform geometry coordinates to SRID " + e + ", due to " + ab.message),
			null
		}
	};
	a.util.BaiduUtil.Line_WGS84ToBaiduPix = function (d, e, f, g) {
		var k = a.geometry,
		n,
		u,
		C,
		L,
		P;
		try {
			var X,
			V = 0,
			ca = Math.ceil(d.coordinates.length / 200),
			b = [],
			va = {};
			n = 0;
			for (L = d.coordinates.length; n < L; n += d.dim) {
				var ab = d.coordinates[n],
				c = d.coordinates[n + 1];
				0 < n && 0 === n % 200 ? (X = b.join(""), b = [], a.util.BaiduUtil.doBaiduConversion(X, va, V, f), V += 1) : n === L - d.dim && (b.push(";" + ab + "," + c), X = b.join(""), b = [], a.util.BaiduUtil.doBaiduConversion(X, va, V, f),
					V += 1);
				0 === n || 0 === n % 200 ? b.push("" + ab + "," + c) : b.push(";" + ab + "," + c)
			}
			var h = !0,
			pb,
			qb = 0;
			pb = setInterval(function () {
				a: if (qb++, 100 < qb)
					clearInterval(pb), a.util.Logger.warning(null, "OM.util.BaiduUtil.Line_WGS84ToBaiduPix", "Failed to assemble the feature.");
				else {
					for (n = 0; n < ca; n += 1)
						if (a.isNull(va[n.toString()])) {
							h = !1;
							break a
						}
					if (!0 === h) {
						clearInterval(pb);
						var L = [];
						for (n = 0; n < ca; n += 1) {
							var V = n.toString();
							for (C = 0; C < va[V].length; C += 1) {
								var X = new BMap.Point(va[V][C].x, va[V][C].y),
								X = f.project.lngLatToPoint(X);
								L.push(X.x);
								L.push(X.y);
								for (u = 2; u < d.dim; u += 1)
									L.push("")
							}
						}
						P = k.Geometry.createGeometry({
							type: d.type,
							dim: d.dim,
							coordinates: L
						}, e);
						P.dim = d.dim;
						g(P, f)
					}
				}
			}, 1E3);
			return P
		} catch (ub) {
			return a.util.Logger.warning(null, "OM.util.BaiduUtil.Line_WGS84ToBaiduPix", "Cannot transform geometry coordinates to SRID " + e + ", due to " + ub.message),
			null
		}
	};
	a.util.BaiduUtil.Line_BD09LonLatToPix = function (d, e, f, g, k) {
		var n = a.geometry,
		u,
		C,
		L;
		try {
			var P = [];
			for (L = 0; L < d.coordinates.length; L += d.dim) {
				var X;
				k ? (X = f.project.pointToLngLat(new BMap.Pixel(d.coordinates[L],
								d.coordinates[L + 1])), P.push(X.lng), P.push(X.lat)) : (X = f.project.lngLatToPoint(new BMap.Point(d.coordinates[L], d.coordinates[L + 1])), P.push(X.x), P.push(X.y));
				for (C = 2; C < d.dim; C += 1)
					P.push("")
			}
			u = n.Geometry.createGeometry({
				type: d.type,
				dim: d.dim,
				coordinates: P
			}, e);
			g && g(u, f);
			return u
		} catch (V) {
			return a.util.Logger.warning(null, "OM.util.BaiduUtil.Line_BD09LonLatToPix", "Cannot transform geometry coordinates to SRID " + e + ", due to " + V.message),
			null
		}
	};
	a.util.BaiduUtil.transformLonLatToPix_MultiLine = function (d, e,
		f, g, k) {
		return f.enableBD09Encoding && this.isWithinChinaRect(d) && !0 !== k ? a.util.BaiduUtil.MultiLine_WGS84ToBaiduPix(d, e, f, g) : a.util.BaiduUtil.MultiLine_BD09LonLatToPix(d, e, f, g)
	};
	a.util.BaiduUtil.transformLonLatToPix_Line = function (d, e, f, g, k) {
		return f.enableBD09Encoding && this.isWithinChinaRect(d) && !0 !== k ? a.util.BaiduUtil.Line_WGS84ToBaiduPix(d, e, f, g) : a.util.BaiduUtil.Line_BD09LonLatToPix(d, e, f, g)
	};
	a.util.BaiduUtil.transformLonLatToPix_Rectangle = function (d, e, f, g, k) {
		return f.enableBD09Encoding && this.isWithinChinaRect(d) &&
		!0 !== k ? a.util.BaiduUtil.Rectangle_WGS84ToPix(d, e, f, g) : a.util.BaiduUtil.Rectangle_BD09LonLatToPix(d, e, f, g)
	};
	a.util.BaiduUtil.transformLonLatToPix_Polygon = function (d, e, f, g, k) {
		return f.enableBD09Encoding && this.isWithinChinaRect(d) && !0 !== k ? a.util.BaiduUtil.Polygon_WGS84ToPix(d, e, f, g) : a.util.BaiduUtil.Polygon_BD09LonLatToPix(d, e, f, g)
	};
	a.util.BaiduUtil.transformLonLatToPix_MultiPolygon = function (d, e, f, g, k) {
		return f.enableBD09Encoding && this.isWithinChinaRect(d) && !0 !== k ? a.util.BaiduUtil.MultiPolygon_WGS84LonLatToPix(d,
			e, f, g) : a.util.BaiduUtil.MultiPolygon_BD09LonLatToPix(d, e, f, g)
	};
	a.util.BaiduUtil.doBaiduConversion = function (d, e, f, g) {
		var k = {};
		k.coords = d;
		k.from = "1";
		k.to = "5";
		k.ak = g.ak;
		$.ajax({
			type: "GET",
			dataType: "jsonp",
			data: k,
			crossDomain: !0,
			url: g.BD09_APIURL,
			success: function (d) {
				if (0 === d.status) {
					var k,
					g = [];
					for (k = 0; k < d.result.length; k++)
						g.push(d.result[k]);
					e[f.toString()] = g
				} else
					a.util.Logger.warning("", "OM.util.BaiduUtil.doBaiduConversion", "baidu server returned error: " + d.message)
			},
			error: function () {
				a.util.Logger.warning("",
					"OM.util.BaiduUtil.doBaiduConversion", "failed to encode.")
			}
		})
	};
	a.util.BaiduUtil.isZoomLevelValid = function (d) {
		return a.isNull(d) ? !1 : d < a.util.BaiduUtil.MIN_ZOOM_LEVEL ? (a.util.Logger.warning("", "BaiduUtil.isZoomLevelValid", "Baidu Map zoom level cannot be smaller than " + a.util.BaiduUtil.MIN_ZOOM_LEVEL), !1) : d > a.util.BaiduUtil.MAX_ZOOM_LEVEL ? (a.util.Logger.warning("", "BaiduUtil.isZoomLevelValid", "Baidu Map zoom level cannot be larger than " + a.util.BaiduUtil.MAX_ZOOM_LEVEL), !1) : !0
	};
	a.util.BaiduUtil.getValidZoomLevel =
	function (d) {
		return a.isNull(d) ? (a.util.Logger.warning("", "BaiduUtil.getValidZoomLevel", "Desired zoom level was not provided, returning: " + a.util.BaiduUtil.MIN_ZOOM_LEVEL), a.util.BaiduUtil.MIN_ZOOM_LEVEL) : d < a.util.BaiduUtil.MIN_ZOOM_LEVEL ? (a.util.Logger.warning("", "BaiduUtil.getValidZoomLevel", "Zoom level was out of supported range, adjusted from " + d + " to " + a.util.BaiduUtil.MIN_ZOOM_LEVEL), a.util.BaiduUtil.MIN_ZOOM_LEVEL) : d > a.util.BaiduUtil.MAX_ZOOM_LEVEL ? (a.util.Logger.warning("", "BaiduUtil.getValidZoomLevel",
				"Zoom level was out of supported range, adjusted from " + d + " to " + a.util.BaiduUtil.MAX_ZOOM_LEVEL), a.util.BaiduUtil.MAX_ZOOM_LEVEL) : d
	};
	a.util.BaiduUtil.transform_PixToBD09LonLat = function (d) {
		a.isNull(d.toSrid) && (d.toSrid = 8307);
		var e = d.geom;
		if (a.isNull(e.srid) || a.isNull(d.toSrid))
			return a.util.Logger.warning("", "OM.util.BaiduUtil.transform_BD09LonLatToPix", "SRID is not specified."), null;
		var f = d.geom,
		g = d.callBack,
		k = d.bdutil,
		n = d.toSrid;
		if (8307 === e.srid || 4326 === e.srid)
			return g && g(e, k), f;
		if (d.bdutil)
			switch (e.type) {
			case "Point":
				return a.util.BaiduUtil.Point_BD09LonLatToPix(e,
					n, k, g, !0);
			case "LineString":
				return a.util.BaiduUtil.Line_BD09LonLatToPix(f, n, k, g, !0);
			case "MultiLineString":
				return a.util.BaiduUtil.MultiLine_BD09LonLatToPix(f, n, k, g, !0);
			case "Rectangle":
				return a.util.BaiduUtil.Rectangle_BD09LonLatToPix(f, n, k, g, !0);
			case "Polygon":
				return a.util.BaiduUtil.Polygon_BD09LonLatToPix(f, n, k, g, !0);
			case "MultiPolygon":
				return a.util.BaiduUtil.MultiPolygon_BD09LonLatToPix(f, n, k, g, !0);
			default:
				return a.util.Logger.warning("", "OM.util.BaudiUtil.transform_PixToBD09LonLat", "Type [" +
					this.type + "] is not supported yet."),
				null
			}
		else
			return a.util.Logger.warning("", "OM.util.BaudiUtil.transform_PixToBD09LonLat", "Baidu BD09 encoding utility is not provided."), null
	};
	a.util.DomUtil = function () {};
	a.util.DomUtil.css = function (d) {
		var e = document.styleSheets,
		f = {},
		g;
		for (g in e)
			try {
				var k = e[g].rules || e[g].cssRules,
				n;
				for (n in k)
					d.is(k[n].selectorText) && a.$.extend(f, a.util.DomUtil.css2json(k[n].style))
			} catch (u) {}
		a.$.extend(f, a.util.DomUtil.css2json(d.attr("style")));
		return f
	};
	a.util.DomUtil.css2json =
	function (a) {
		var e = {};
		if (!a)
			return e;
		var f;
		if (a instanceof CSSStyleDeclaration)
			for (f in a)
				a[f].toLowerCase && (e[a[f].toLowerCase()] = a[a[f]]);
		else if ("string" == typeof a)
			for (f in a = a.split(";"), a) {
				var g = a[f].split(":");
				e[g[0].toLowerCase()] = g[1]
			}
		return e
	};
	a.util.DomUtil.getComputedStyle = function (a) {
		var e = {};
		if (h.getComputedStyle) {
			var f = function (a, d) {
				return d.toUpperCase()
			};
			a = h.getComputedStyle(a, null);
			for (var g = 0, k = a.length; g < k; g++) {
				var n = a[g],
				u = n.replace(/\-([a-z])/g, f),
				n = a.getPropertyValue(n);
				e[u] =
					n
			}
		} else if (a.currentStyle)
			for (f in a = a.currentStyle, a)
				e[f] = a[f];
		return e
	};
	a.util.DomUtil.setImageSrc = function (d, e, f) {
		var g = a.$(d);
		e ? (g.css("opacity", f), g.attr("src", e)) : g.attr("src", a.util.MiscUtil.transparentImgURL);
		a.gv.anonymousTileImages && g.attr("crossOrigin", "Anonymous");
		g[0].onerror = function () {
			g.attr("src", a.gv.resourcePath() + "blank.gif");
			a.gv.anonymousTileImages && g.attr("crossOrigin", "Anonymous");
			a.util.Logger.warning("", "OM.util.DomUtil.setImageSrc", "Failed fetching image from: " + e)
		}
	};
	a.util.DomUtil.changeOpacity =
	function (d, e) {
		a.$(d).css("opacity", e)
	};
	a.util.DomUtil.pixel = function (a) {
		return Math.round(a) + "px"
	};
	a.util.DomUtil.createImageNode = function (d, e) {
		var f = null,
		f = document.createElement("img");
		f.src = d;
		f.alt = "";
		a.browser.msie && !e && (f.galleryImg = "no");
		a.browser.mozilla ? f.style.MozUserSelect = "none" : a.browser.safari ? f.style.KhtmlUserSelect = "none" : a.browser.msie && (f.unselectable = "on");
		return f
	};
	a.util.DomUtil.setCursor = function (d, e) {
		try {
			-1 < e.indexOf(".") && (e = 'url("' + e + '"),auto'),
			d.style.cursor = e
		} catch (f) {
			"pointer" ==
			e && a.util.DomUtil.setCursor(d, "hand")
		}
	};
	a.util.DomUtil.getTouchCount = function (d) {
		if (a.isNull(d.originalEvent) && a.isNull(d.touches))
			return a.util.Logger.warning("", "OM.util.DomUtil.getTouchCount", "Received event with no touch information: "), 0;
		d.originalEvent && (d = d.originalEvent);
		if ("TOUCHSTART" === d.type.toUpperCase())
			return d.touches.length;
		if ("TOUCHEND" === d.type.toUpperCase())
			return d.changedTouches.length
	};
	a.util.DomUtil.getTouchesPosition = function (a) {
		a.originalEvent && (a = a.originalEvent);
		if (a.touches) {
			for (var e =
					a.touches.length, f = [], g = 0; g < e; g++)
				f.push({
					x: a.touches[g].pageX,
					y: a.touches[g].pageY
				});
			return 1 == f.length ? f[0] : f
		}
		return []
	};
	a.util.DomUtil.getTouchesClientPosition = function (a) {
		a.originalEvent && (a = a.originalEvent);
		if (a.touches) {
			for (var e = a.touches.length, f = [], g = 0; g < e; g++)
				f.push({
					x: a.touches[g].clientX,
					y: a.touches[g].clientY
				});
			return 1 === f.length ? f[0] : f
		}
		return []
	};
	a.util.DomUtil.getChangedTouchesPosition = function (a) {
		a.originalEvent && (a = a.originalEvent);
		if (a.changedTouches) {
			for (var e = a.changedTouches.length,
				f = [], g = 0; g < e; g++)
				f.push({
					x: a.changedTouches[g].pageX,
					y: a.changedTouches[g].pageY
				});
			return f
		}
		return []
	};
	a.util.DomUtil.getTouchesScale = function (a) {
		a.originalEvent && (a = a.originalEvent);
		return a.scale
	};
	a.util.DomUtil.getElementPos = function (a) {
		if (a)
			return a.position()
	};
	a.util.DomUtil.getPageDirection = function (d) {
		this.$div = a.$("\x3cdiv style\x3d'position:absolute;width:0px;height:0px;z-index:3000'\x3e\x3c/div\x3e");
		d.$topLayerDIV.append(this.$div);
		d = document.createElement("table");
		var e = document.createElement("tr"),
		f = document.createElement("td"),
		g = document.createElement("td"),
		k = document.createElement("tbody");
		d.cellSpacing = 0;
		d.cellPadding = 0;
		f.innerHTML = "fsdfsds";
		g.innerHTML = "p";
		k.appendChild(e);
		d.appendChild(k);
		e.appendChild(f);
		e.appendChild(g);
		this.$div[0].appendChild(d);
		this.pageDirection = 0 === f.offsetLeft ? !0 : !1;
		this.$div[0].removeChild(d);
		this.$div.remove();
		return this.pageDirection
	};
	a.util.DomUtil.isHtml = function (a) {
		return 0 <= a.indexOf("\x3c!DOCTYPE") || 0 <= a.toUpperCase().indexOf("\x3cHTML") || 0 <= a.toUpperCase().indexOf("\x3cBODY") ||
		0 <= a.toUpperCase().indexOf("\x3cIMG") || 0 <= a.toUpperCase().indexOf("\x3cDIV") || 0 <= a.toUpperCase().indexOf("\x3cP\x3e") || 0 <= a.toUpperCase().indexOf("\x3cBR") || 0 <= a.toUpperCase().indexOf("\x3cA") || 0 <= a.toUpperCase().indexOf("\x3cTABLE") || 0 <= a.toUpperCase().indexOf("\x3cTEXTAREA") || 0 <= a.toUpperCase().indexOf("\x3cINPUT") || 0 <= a.toUpperCase().indexOf("\x3cFONT") || 0 <= a.toUpperCase().indexOf("\x3cAREA") || 0 <= a.toUpperCase().indexOf("\x3cLABEL") || 0 <= a.toUpperCase().indexOf("\x3cTD") ? !0 : 0 <= a.toUpperCase().indexOf("\x3cSPAN") ?
		!0 : !1
	};
	a.util.DomUtil.setFontIcon = function (d, e, f) {
		if (d)
			return d = a.$(d), d.attr("omv2-font-icon", e), a.notNull(f) && d.css("color", f), d
	};
	a.util.XMLUtil = {};
	a.util.XMLUtil.parse = "undefined" !== typeof h.DOMParser ? function (a) {
		return (new DOMParser).parseFromString(a, "text/xml")
	}
	 : function (a) {
		var e = new ActiveXObject("Microsoft.XMLDOM");
		e.async = "false";
		e.loadXML(a);
		return e
	};
	a.util.XMLUtil.xmlToString = "undefined" !== typeof XMLSerializer ? function (a) {
		return (new XMLSerializer).serializeToString(a)
	}
	 : function (a) {
		return a.xml
	};
	a.util.XMLUtil.getAllTextContent = function (d, e) {
		return a.util.XMLUtil.getAllTextContent_(d, e, []).join("")
	};
	a.util.XMLUtil.getAllTextContent_ = function (d, e, f) {
		if (d.nodeType === Node.CDATA_SECTION_NODE || d.nodeType === Node.TEXT_NODE)
			e ? f.push(String(d.nodeValue).replace(/(\r\n|\r|\n)/g, "")) : f.push(d.nodeValue);
		else
			for (d = d.firstChild; d; d = d.nextSibling)
				a.util.XMLUtil.getAllTextContent_(d, e, f);
		return f
	};
	a.util.XMLUtil.getAttributeNS = function (a, e, f) {
		return a.getAttributeNS(e, f) || ""
	};
	a.util.XMLUtil.makeArrayPusher =
	function (a, e) {
		return function (f, g) {
			var k = a.call(e !== c ? e : this, f, g);
			k !== c && g[g.length - 1].push(k)
		}
	};
	a.util.XMLUtil.makeObjectPropertyPusher = function (a, e, f) {
		return function (g, k) {
			var n = a.call(f !== c ? f : this, g, k);
			if (n !== c) {
				var u = k[k.length - 1],
				C = e !== c ? e : g.localName;
				(C in u ? u[C] : u[C] = []).push(n)
			}
		}
	};
	a.util.XMLUtil.makeObjectPropertySetter = function (a, e, f) {
		return function (g, k) {
			var n = a.call(f !== c ? f : this, g, k);
			n !== c && (k[k.length - 1][e !== c ? e : g.localName] = n)
		}
	};
	a.util.XMLUtil.makeStructureNS = function (a, e, f) {
		f = f !== c ?
			f : {};
		f[a] = e;
		return f
	};
	a.util.XMLUtil.parseNode = function (a, e, f, g) {
		for (e = e.firstElementChild; e; e = e.nextElementSibling) {
			var k = a[e.namespaceURI];
			k !== c && (k = k[e.localName], k !== c && k.call(g, e, f))
		}
	};
	a.util.XMLUtil.pushParseAndPop = function (d, e, f, g, k) {
		g.push(d);
		a.util.XMLUtil.parseNode(e, f, g, k);
		return g.pop()
	};
	a.util.ValidationUtil = a.util.ValidationUtil || {
		isNumber: function (a) {
			return !isNaN(parseFloat(a)) && isFinite(a)
		},
		isNumber2: function (a) {
			return null !== a && "number" === typeof a
		},
		isObject: function (a) {
			return null !==
			a && "object" === typeof a
		},
		isNumberArray: function (d) {
			if (!d || "object" !== typeof d)
				return !1;
			var e = d.length;
			if (0 === e)
				return !1;
			for (var f = a.util.ValidationUtil.isNumber, g = 0; g < e; g++)
				if (!f(d[g]))
					return !1;
			return !0
		},
		getColor: function (d) {
			if (a.isNull(d))
				return null;
			var e = typeof d;
			if ("string" === e)
				return /#[0-9a-fA-F]{6}/.test(d) ? d : /[0-9a-fA-F]{6}/.test(d) ? "#" + d : null;
			if ("number" === e) {
				if (0 === d)
					return "#000000";
				for (d = Math.round(d).toString(16); 6 > d.length; )
					d = "0" + d;
				return "#" + d
			}
			return null
		}
	};
	a.util.CSTransformUtil = a.util.CSTransformUtil ||
	function () {
		var d = [],
		e = [{
				srid: 54004,
				params: [0, 0, 1, 0, 0]
			}, {
				srid: 8307,
				params: [6378137, 298.257223563]
			}
		],
		f = new function () {
			this.getCSTransformFunction = function (e, f) {
				var n = d[e];
				if (n) {
					if (a.notNull(n[f]))
						return n[f];
					var u = n[8307],
					C = d[8307][f];
					return a.notNull(u) && a.notNull(C) ? function (a, d) {
						var e = u(a, d);
						return C(e.x, e.y)
					}
					 : null
				}
				return null
			};
			this.addCSTransformFunction = function (a, e, f) {
				var u = d[a];
				u || (u = d[a] = []);
				u[e] = f
			};
			this.transOrdinatesArray = function (a, d, e) {
				for (var f = a.length, C = Array(f), L = 0; L < f; L += d) {
					var P = e(a[L],
							a[L + 1]);
					C[L] = P.x;
					C[L + 1] = P.y;
					for (P = 2; P < d; P++)
						C[L + P] = a[L + P]
				}
				return C
			};
			this.transformOrdinates = function (d, e, f) {
				var u = a.util.ValidationUtil,
				C = null;
				f || (f = 2);
				var L = this.transOrdinatesArray;
				if (u.isNumberArray(e))
					C = L(e, f, d);
				else
					for (var P = e.length, C = Array(P), X = 0; X < P; X++)
						if (u.isNumberArray(e[X]))
							C[X] = L(e[X], f, d);
						else {
							var V = e[X].length;
							C[X] = Array(V);
							for (var ca = 0; ca < V; ca++)
								C[X][ca] = L(e[X][ca], f, d)
						}
				return C
			};
			this.bootstrapTransformations = function () {
				var d = this,
				e = d.addCSTransformFunction;
				e(54004, 8307, function (a,
						e) {
					return d.mercatorToGeodetic(a, e, 54004, 8307)
				});
				e(8307, 54004, function (a, e) {
					return d.geodeticToMercator(a, e, 8307, 54004)
				});
				e(3785, 8307, function (a, e) {
					return d.SphereMercatorToGeodetic(a, e, 6378137)
				});
				e(8307, 3785, function (a, e) {
					return d.geodeticToSphereMercator(a, e, 6378137)
				});
				e(3857, 8307, function (a, e) {
					return d.SphereMercatorToGeodetic(a, e, 6378137)
				});
				e(8307, 3857, function (a, e) {
					return d.geodeticToSphereMercator(a, e, 6378137)
				});
				e(53004, 8307, function (a, e) {
					return d.SphereMercatorToGeodetic(a, e, 6371E3)
				});
				e(8307,
					53004, function (a, e) {
					return d.geodeticToSphereMercator(a, e, 6371E3)
				});
				e(54004, 4326, function (a, e) {
					return d.mercatorToGeodetic(a, e, 54004, 8307)
				});
				e(4326, 54004, function (a, e) {
					return d.geodeticToMercator(a, e, 8307, 54004)
				});
				e(3785, 4326, function (a, e) {
					return d.SphereMercatorToGeodetic(a, e, 6378137)
				});
				e(4326, 3785, function (a, e) {
					return d.geodeticToSphereMercator(a, e, 6378137)
				});
				e(3857, 4326, function (a, e) {
					return d.SphereMercatorToGeodetic(a, e, 6378137)
				});
				e(4326, 3857, function (a, e) {
					return d.geodeticToSphereMercator(a,
						e, 6378137)
				});
				e(53004, 4326, function (a, e) {
					return d.SphereMercatorToGeodetic(a, e, 6371E3)
				});
				e(4326, 53004, function (a, e) {
					return d.geodeticToSphereMercator(a, e, 6371E3)
				});
				e(53004, 54004, function (a, e) {
					var f = d.SphereMercatorToGeodetic(a, e, 6371E3);
					return d.geodeticToMercator(f.x, f.y, 8307, 54004)
				});
				e(54004, 53004, function (a, e) {
					var f = d.mercatorToGeodetic(a, e, 54004, 8307);
					return d.geodeticToSphereMercator(f.x, f.y, 6371E3)
				});
				e(3785, 54004, function (a, e) {
					var f = d.SphereMercatorToGeodetic(a, e, 6378137);
					return d.geodeticToMercator(f.x,
						f.y, 8307, 54004)
				});
				e(54004, 3785, function (a, e) {
					var f = d.mercatorToGeodetic(a, e, 54004, 8307);
					return d.geodeticToSphereMercator(f.x, f.y, 6378137)
				});
				e(3857, 54004, function (a, e) {
					var f = d.SphereMercatorToGeodetic(a, e, 6378137);
					return d.geodeticToMercator(f.x, f.y, 8307, 54004)
				});
				e(54004, 3857, function (a, e) {
					var f = d.mercatorToGeodetic(a, e, 54004, 8307);
					return d.geodeticToSphereMercator(f.x, f.y, 6378137)
				});
				e(3785, 53004, function (a, e) {
					var f = d.SphereMercatorToGeodetic(a, e, 6378137);
					return d.geodeticToSphereMercator(f.x, f.y,
						6371E3)
				});
				e(53004, 3785, function (a, e) {
					var f = d.SphereMercatorToGeodetic(a, e, 6371E3);
					return d.geodeticToSphereMercator(f.x, f.y, 6378137)
				});
				e(3857, 53004, function (a, e) {
					var f = d.SphereMercatorToGeodetic(a, e, 6378137);
					return d.geodeticToSphereMercator(f.x, f.y, 6371E3)
				});
				e(53004, 3857, function (a, e) {
					var f = d.SphereMercatorToGeodetic(a, e, 6371E3);
					return d.geodeticToSphereMercator(f.x, f.y, 6378137)
				});
				e(3857, 3785, function (a, d) {
					return {
						x: a,
						y: d
					}
				});
				e(3785, 3857, function (a, d) {
					return {
						x: a,
						y: d
					}
				});
				e(4326, 8307, function (a, d) {
					return {
						x: a,
						y: d
					}
				});
				e(8307, 4326, function (a, d) {
					return {
						x: a,
						y: d
					}
				});
				var f = new a.proj.Albers({
					standardParallel_1: 29.5,
					standardParallel_2: 45.5,
					lonCenter: -96,
					latOrigin: 23
				});
				e(8307, 32775, f.forward);
				e(32775, 8307, f.inverse);
				e(8307, 505050, a.proj.AlbersUSA.forward);
				e(505050, 8307, a.proj.AlbersUSA.inverse);
				e(4326, 505050, a.proj.AlbersUSA.forward);
				e(505050, 4326, a.proj.AlbersUSA.inverse);
				f = new a.proj.Winkel3(0);
				e(8307, 1009801, f.forward);
				e(1009801, 8307, f.inverse);
				f = new a.proj.Robinson(0);
				e(8307, 180224, f.forward);
				e(180224, 8307,
					f.inverse)
			};
			this.geodeticToMercator = function (d, e, f, u) {
				u = this.getCSParameters(u);
				var C = this.getCSParameters(f);
				if (!u || !C)
					return null;
				e = a.util.GeomUtil.getRadiansFromLatLon(d, e);
				d = e.x;
				e = e.y;
				f = u[2];
				var L = C[0],
				C = 1 / C[1],
				C = Math.sqrt(2 * C - C * C),
				P = Math.sin(e);
				return {
					x: u[3] + L * f * (d - u[1]),
					y: u[4] + L * f * Math.log(Math.tan(Math.PI / 4 + e / 2) * Math.pow((1 - C * P) / (1 + C * P), C / 2))
				}
			};
			this.mercatorToGeodetic = function (d, e, f, u) {
				f = this.getCSParameters(f);
				var C = this.getCSParameters(u);
				if (!f || !C)
					return null;
				u = f[2];
				var L = C[0],
				C = 1 / C[1],
				C = Math.sqrt(2 * C - C * C);
				e = Math.PI / 2 - 2 * Math.atan2(Math.pow(Math.E, (f[4] - e) / (L * u)), 1);
				var P = Math.pow(C, 4),
				X = Math.pow(C, 6),
				V = Math.pow(C, 8);
				return a.util.GeomUtil.getLatLonFromRadians((d - f[3]) / (L * u) + f[1], e + (C * C / 2 + 5 * P / 24 + X / 12 + 13 * V / 360) * Math.sin(2 * e) + (7 * P / 48 + 29 * X / 240 + 811 * V / 11520) * Math.sin(2 * e) + (7 * X / 120 + 81 * V / 1120) * Math.sin(6 * e) + 4279 * V / 161280 * Math.sin(8 * e))
			};
			this.getCSParameters = function (a) {
				for (var d = e.length, f = 0; f < d; f++)
					if (e[f].srid === a)
						return e[f].params;
				return null
			};
			this.geodeticToSphereMercator = function (d,
				e, f) {
				85 < e ? e = 85 : -85 > e && (e = -85);
				e = a.util.GeomUtil.getRadiansFromLatLon(d, e);
				d = e.x;
				e = e.y;
				e = Math.sin(e);
				return {
					x: f * d,
					y: Math.log((1 + e) / (1 - e)) * f / 2
				}
			};
			this.SphereMercatorToGeodetic = function (d, e, f) {
				e = Math.pow(Math.E, 2 * e / f);
				return a.util.GeomUtil.getLatLonFromRadians(d / f, Math.asin((e - 1) / (e + 1)))
			}
		};
		f.bootstrapTransformations();
		return f
	}
	();
	a.util.HttpRequest = {};
	a.util.HttpRequest.localDomain = document.location.protocol + "//" + document.location.host;
	a.util.HttpRequest.instanceId = Math.round(1E4 * Math.random());
	a.util.HttpRequest.reqCount =
		0;
	a.util.HttpRequest.scriptTagCount = 0;
	a.util.HttpRequest.requests = [];
	a.util.HttpRequest.urlMaxLength = 4E3;
	a.util.HttpRequest.instanceIdTable = {};
	a.util.HttpRequest.send = function (d, e, f, g, k, n, u) {
		if (d) {
			a.isNull(u) && (u = a.gv.proxyEnabled);
			var C = a.util.HttpRequest,
			L = function (e, f, g) {
				"abort" !== g && (k ? k(e, f, g) : (f = "URL: " + d, f += "\ngv.localbaseURL: " + a.gv.localbaseURL(), g && (f += "\nError: " + g), e && e.responseText && (f += "\nResponse : " + e.responseText), a.util.Logger.alert("MAPVIEWER_9014", "OM.util.HttpRequest.send", f)))
			},
			P = "POST";
			"GET" === a.gv._httpMethod && (P = "GET");
			var X = !1;
			e.$enableXHR && (X = !0, delete e.$enableXHR);
			return C.isLocalDomain(d) || X ? "json" === g || "jsonp" === g ? (new C.XHR(a.$.ajax({
						url: d,
						data: e,
						method: P,
						success: function (d) {
							try {
								var e = null,
								e = a.$.parseJSON(d);
								f(e)
							} catch (g) {
								d = g.message,
								g.stack && (d += "\n  Stack: " + g.stack),
								a.util.Logger.warning("MAPVIEWER_9013", "OM.util.HttpRequest.send", d),
								k && k(this.jqXHR, "Error parsing response as JSON data.", g)
							}
						},
						dataType: "text",
						xhrFields: {
							withCredentials: !0
						}
					}))).setErrorHandler(L) :
			(new C.XHR(a.$.ajax({
						url: d,
						method: P,
						data: e,
						success: f,
						dataType: g,
						xhrFields: {
							withCredentials: !0
						}
					}))).setErrorHandler(L) : "jsonp" === g || "xml" === g || "XML" === g || "Xml" === g ? (new C.XHR(a.$.ajax({
						url: d,
						method: P,
						data: e,
						success: f,
						dataType: g
					}))).setErrorHandler(L) : u ? (n = a.util.HttpRequest.localDomain + a.gv.proxyPath, e.rtarget = d, (new C.XHR(P(n, e, function (a) {
							f(a)
						}, g))).setErrorHandler(L)) : C.sendAsScripts(d, e, f, g, n)
		}
	};
	a.util.HttpRequest.sendAsScripts = function (d, e, f, g, k) {
		function n(a) {
			C = a;
			u.instanceIdTable[d] = a;
			u.sendAsScriptsWithId(d,
				e, f, g, C)
		}
		if (!d)
			return null;
		var u = a.util.HttpRequest,
		C = u.instanceIdTable[d];
		if (a.isNull(C)) {
			var L = "v2" + u.reqCount++,
			P = d,
			P = 0 < P.indexOf("?") ? P + "\x26" : P + "?",
			P = P + ("callback_id\x3d" + L + "\x26"),
			X = "text",
			V = n;
			k ? (u.instanceIdTable[d] = "_1", X = g, V = f) : P += "getinstid\x3dtrue";
			P += "\x26" + a.$.param(e);
			return u.sendAsScript(P, V, X, L)
		}
		return u.sendAsScriptsWithId(d, e, f, g, C)
	};
	a.util.HttpRequest.sendAsScriptsWithId = function (d, e, f, g, k) {
		var n = a.util.HttpRequest,
		u = new n.XHR;
		k = "v2" + k + "_" + n.reqCount++;
		d = 0 < d.indexOf("?") ? d + "\x26" :
			d + "?";
		d += "callback_id\x3d" + k + "\x26";
		var C = d + a.$.param(e);
		if (C.length > n.urlMaxLength) {
			var C = {},
			L;
			for (L in e)
				C[L] = e[L] + "";
			e = 1;
			for (d += "ref\x3d" + Math.floor(1E4 * Math.random()) + "\x26"; ; ) {
				L = d + "pn\x3d" + e;
				var P = n.getParameters(C, n.urlMaxLength - L.length);
				if (0 < n.getParametersCount(C))
					L = n.sendAsScript(L + P, f, g, k, e), u.addScriptId(L.getScriptIds()[0]);
				else {
					L = n.sendAsScript(d + "pn\x3de" + e + P, f, g, k, e);
					u.addScriptId(L.getScriptIds()[0]);
					break
				}
				e++
			}
			return u
		}
		return n.sendAsScript(C, f, g, k)
	};
	a.util.HttpRequest.sendAsScript =
	function (d, e, f, g, k) {
		if (!d)
			return null;
		var n = a.util.HttpRequest,
		u = document.createElement("script");
		u.id = "OMV_XHR_" + n.scriptTagCount++;
		u.src = d;
		u.type = "text/javascript";
		u.charset = "utf-8";
		u.className = "OMV_XHR_";
		n.requests.push({
			jsNode: u,
			callBack: e,
			reqId: g,
			format: f,
			parts: k
		});
		document.body.appendChild(u);
		d = new n.XHR;
		d.addScriptId(u.id);
		return d
	};
	a.util.HttpRequest.callBack = function (d, e, f) {
		for (var g = a.util.HttpRequest.requests, k = null; 0 < g.length && (k = g[0], !k.callBack && !k.parts); ) {
			if (k.jsNode) {
				try {
					document.body.removeChild(k.jsNode)
				} catch (u) {}
				k.jsNode =
					null
			}
			g.shift()
		}
		for (var n = 0; n < g.length; n++)
			if (k = g[n], k.reqId === d && k.parts === f) {
				d = !1;
				k = g[n];
				try {
					document.body.removeChild(k.jsNode)
				} catch (u) {
					d = !0
				}
				k.jsNode = null;
				0 === n && g.shift();
				!d && a.notNull(e) && k.callBack && ("json" === k.format ? "string" === typeof e ? k.callBack(a.$.parseJSON(e)) : k.callBack(e) : "xml" === k.format ? k.callBack(a.util.XMLUtil.parse(e)) : k.callBack(e));
				k.callBack = null;
				break
			}
	};
	a.util.HttpRequest.isLocalDomain = function (d) {
		var e = a.util.HttpRequest;
		d = a.$.trim(d);
		return 0 === d.toLowerCase().indexOf("http://") ||
		0 === d.toLowerCase().indexOf("https://") ? e.getDomain(d) === e.localDomain : !0
	};
	a.util.HttpRequest.getDomain = function (a) {
		if (!a)
			return null;
		var e = a.indexOf("://");
		return 0 < e ? (e = a.indexOf("/", e + 3), 0 < e ? a.substring(0, e) : a.substring(0)) : null
	};
	a.util.HttpRequest.getParameters = function (a, e) {
		var f = "",
		g;
		for (g in a) {
			var k = "\x26" + g + "\x3d";
			if (f.length + k.length >= e)
				break;
			f += k;
			e -= f.length;
			var k = a[g],
			n = encodeURIComponent(k),
			u = n.length;
			if (u <= e)
				f += n, delete a[g];
			else
				for (u = Math.floor(1 * k.length / u * e); 0 <= u; u--)
					if (n = k.substring(0,
								u), n = encodeURIComponent(n), n.length <= e)
						return a[g] = k.substring(u), f + n
		}
		return f
	};
	a.util.HttpRequest.getParametersCount = function (a) {
		var e = 0,
		f;
		for (f in a)
			++e;
		return e
	};
	a.util.HttpRequest.XHR = function (a) {
		this.scriptTags = [];
		this.error = this.jQXHR = null;
		a && (this.jQXHR = a)
	};
	a.util.HttpRequest.XHR.prototype.addScriptId = function (a) {
		this.scriptTags.push(a)
	};
	a.util.HttpRequest.XHR.prototype.getScriptIds = function () {
		return this.scriptTags
	};
	a.util.HttpRequest.XHR.prototype.abort = function () {
		if (this.jQXHR)
			this.jQXHR.abort();
		else
			for (var a = 0; a < this.scriptTags.length; a++) {
				var e = document.getElementById(this.scriptTags[a]);
				if (e && e.parentNode)
					try {
						e.parentNode.removeChild(e)
					} catch (f) {}
			}
	};
	a.util.HttpRequest.XHR.prototype.setErrorHandler = function (a) {
		this.jQXHR ? this.jQXHR.fail(a) : this.error = a;
		return this
	};
	a.util.CoverageGrid = function (a) {
		this.yResolution = this.xResolution = null;
		this.grid = {};
		this.gridDeviceSize = this.gridHeight = this.gridWidth = 128;
		this.setBox(a)
	};
	a.util.CoverageGrid.prototype.setBox = function (d) {
		this.minX = d.minX;
		this.minY =
			d.minY;
		this.maxX = d.maxX;
		this.maxY = d.maxY;
		a.notNull(d.gridSize) && (this.gridDeviceSize = d.gridSize)
	};
	a.util.CoverageGrid.prototype.init = function () {
		this.clear()
	};
	a.util.CoverageGrid.prototype.clear = function () {
		var a = this.grid,
		e;
		for (e in a)
			delete a[e]
	};
	a.util.CoverageGrid.prototype.conflicts = function (a) {
		for (var e = Math.floor((a[1] - this.minY) / this.gridHeight), f = Math.floor((a[2] - this.minX) / this.gridWidth), g = Math.floor((a[3] - this.minY) / this.gridHeight), k = Math.floor((a[0] - this.minX) / this.gridWidth); k <= f; k++)
			for (var n =
					e; n <= g; n++)
				if (this.conflictsWithCell(k, n, a))
					return !0;
		return !1
	};
	a.util.CoverageGrid.prototype.insert = function (a) {
		for (var e = Math.floor((a[1] - this.minY) / this.gridHeight), f = Math.floor((a[2] - this.minX) / this.gridWidth), g = Math.floor((a[3] - this.minY) / this.gridHeight), k = Math.floor((a[0] - this.minX) / this.gridWidth); k <= f; k++)
			for (var n = e; n <= g; n++)
				this.insertToCell(k, n, a)
	};
	a.util.CoverageGrid.prototype.remove = function (a) {
		for (var e = Math.floor((a[1] - this.minY) / this.gridHeight), f = Math.floor((a[2] - this.minX) / this.gridWidth),
			g = Math.floor((a[3] - this.minY) / this.gridHeight), k = Math.floor((a[0] - this.minX) / this.gridWidth); k <= f; k++)
			for (var n = e; n <= g; n++)
				this.removeFromCell(k, n, a)
	};
	a.util.CoverageGrid.prototype.insertToCell = function (a, e, f) {
		this.grid[a] || (this.grid[a] = {});
		this.grid[a][e] || (this.grid[a][e] = []);
		this.grid[a][e].push(f)
	};
	a.util.CoverageGrid.prototype.conflictsWithCell = function (a, e, f) {
		if (!this.grid[a] || !this.grid[a][e])
			return !1;
		a = this.grid[a][e];
		for (e = 0; e < a.length; e++) {
			var g = a[e];
			if (!(g[2] <= f[0] || g[0] >= f[2] || g[3] < f[1] ||
					g[1] > f[3]))
				return !0
		}
		return !1
	};
	a.util.CoverageGrid.prototype.removeFromCell = function (a, e, f) {
		if (this.grid[a] && this.grid[a][e]) {
			e = this.grid[a][e];
			for (var g = 0; g < e.length; g++)
				if (e[g] === f) {
					this.grid[a].splice(g, 1);
					break
				}
		}
	};
	a.util.MiscUtil = a.util.MiscUtil || {
		arraysAreEqual: function (d, e) {
			if (!(d === e || a.isNull(d) && a.isNull(e) || a.isNull(d) && 0 === e.length || 0 === d.length && a.isNull(e))) {
				if (null === d || null === e || d.length !== e.length)
					return !1;
				for (var f = 0, g = d.length; f < g; f++)
					if (d[f] != e[f])
						return !1
			}
			return !0
		},
		mixin: function (a) {
			for (var e =
					Array.prototype.slice.call(arguments, 1), f = e.length, g, k = 0; k < f; k++)
				if (g = e[k])
					for (var n in g)
						g.hasOwnProperty(n) && (a[n] = g[n]);
			return a
		},
		mark: function () {
			var a = 0;
			return function (e) {
				e._omapsid_ = e._omapsid_ || ++a;
				return e._omapsid_
			}
		}
		(),
		signURL: function (d, e) {
			if (a.isNull(CryptoJS) || a.isNull(d) || a.isNull(e))
				return null;
			var f = d.replace("-", "+"),
			f = f.replace("_", "/"),
			f = CryptoJS.enc.Base64.parse(f),
			f = CryptoJS.HmacSHA1(e, f),
			f = CryptoJS.enc.Base64.stringify(f),
			f = f.replace("+", "-");
			return f = f.replace("/", "_")
		},
		generateUid: function (a) {
			function e() {
				return (65536 *
					(1 + Math.random()) | 0).toString(16).substring(1)
			}
			a = a || "-";
			return e() + e() + a + e() + a + e() + a + e() + a + e() + e() + e()
		},
		parseNumberAndUnit: function (d) {
			var e = {};
			if (a.isNull(d))
				return e;
			if (a.util.ValidationUtil.isNumber(d))
				return e.value = d, e;
			d = d.trim();
			for (var f = "", g = null, k = 0; k < d.length; k++) {
				var n = d.charAt(k);
				if (a.util.ValidationUtil.isNumber(n) || "-" === n && 0 === k)
					f += n;
				else if ("." === n)
					a.util.ValidationUtil.isNumber(d.charAt(k + 1)) && (f += n);
				else {
					g = d.substring(k, d.length).trim();
					break
				}
			}
			0 < f.length && (e.value = f);
			a.isNotNull(g) &&
			(e.unit = g);
			return e
		},
		substituteStr: function (d, e, f) {
			var g = d.toUpperCase().indexOf(e.toUpperCase());
			return 0 > g ? (a.util.Logger.warning("MAPVIEWER_9200", "OM.util.MiscUtil.substituteStr", "Did not find " + e + " in " + d), d) : d.substring(0, g) + f + d.substring(g + e.length)
		},
		debounce: function (d, e) {
			var f;
			if (a.isNull(e) || 0 >= e)
				e = a.event.MouseEvent.DEBOUNCE_MILI_SEC;
			return function () {
				var a = this,
				k = arguments;
				clearTimeout(f);
				f = setTimeout(function () {
					f = null;
					d.apply(a, k)
				}, e)
			}
		},
		simpleHash: function (a) {
			var e = 0,
			f,
			g;
			if (0 === a.length)
				return "hash-0";
			for (f = 0; f < a.length; f++)
				g = a.charCodeAt(f), e = (e << 5) - e + g, e |= 0;
			return "hash-" + e
		},
		md5Hash: function () {
			function d(a, d) {
				var f = d[0],
				g = d[1],
				k = d[2],
				X = d[3],
				V = d[4],
				ca = d[5],
				b = d[6],
				va = d[7],
				ab = d[8],
				c = d[9],
				h = d[10],
				pb = d[11],
				qb = d[12],
				ub = d[13],
				Bb = d[14],
				Fb = d[15],
				Da = a[0],
				Ea = a[1],
				Fa = a[2],
				Ga = a[3],
				Da = e(Ea & Fa | ~Ea & Ga, Da, Ea, f, 7, -680876936),
				Ga = e(Da & Ea | ~Da & Fa, Ga, Da, g, 12, -389564586),
				Fa = e(Ga & Da | ~Ga & Ea, Fa, Ga, k, 17, 606105819),
				Ea = e(Fa & Ga | ~Fa & Da, Ea, Fa, X, 22, -1044525330),
				Da = e(Ea & Fa | ~Ea & Ga, Da, Ea, V, 7, -176418897),
				Ga = e(Da & Ea | ~Da & Fa, Ga, Da, ca,
						12, 1200080426),
				Fa = e(Ga & Da | ~Ga & Ea, Fa, Ga, b, 17, -1473231341),
				Ea = e(Fa & Ga | ~Fa & Da, Ea, Fa, va, 22, -45705983),
				Da = e(Ea & Fa | ~Ea & Ga, Da, Ea, ab, 7, 1770035416),
				Ga = e(Da & Ea | ~Da & Fa, Ga, Da, c, 12, -1958414417),
				Fa = e(Ga & Da | ~Ga & Ea, Fa, Ga, h, 17, -42063),
				Ea = e(Fa & Ga | ~Fa & Da, Ea, Fa, pb, 22, -1990404162),
				Da = e(Ea & Fa | ~Ea & Ga, Da, Ea, qb, 7, 1804603682),
				Ga = e(Da & Ea | ~Da & Fa, Ga, Da, ub, 12, -40341101),
				Fa = e(Ga & Da | ~Ga & Ea, Fa, Ga, Bb, 17, -1502002290),
				Ea = e(Fa & Ga | ~Fa & Da, Ea, Fa, Fb, 22, 1236535329),
				Da = e(Ea & Ga | Fa & ~Ga, Da, Ea, g, 5, -165796510),
				Ga = e(Da & Fa | Ea & ~Fa, Ga, Da, b, 9, -1069501632),
				Fa = e(Ga & Ea | Da & ~Ea, Fa, Ga, pb, 14, 643717713),
				Ea = e(Fa & Da | Ga & ~Da, Ea, Fa, f, 20, -373897302),
				Da = e(Ea & Ga | Fa & ~Ga, Da, Ea, ca, 5, -701558691),
				Ga = e(Da & Fa | Ea & ~Fa, Ga, Da, h, 9, 38016083),
				Fa = e(Ga & Ea | Da & ~Ea, Fa, Ga, Fb, 14, -660478335),
				Ea = e(Fa & Da | Ga & ~Da, Ea, Fa, V, 20, -405537848),
				Da = e(Ea & Ga | Fa & ~Ga, Da, Ea, c, 5, 568446438),
				Ga = e(Da & Fa | Ea & ~Fa, Ga, Da, Bb, 9, -1019803690),
				Fa = e(Ga & Ea | Da & ~Ea, Fa, Ga, X, 14, -187363961),
				Ea = e(Fa & Da | Ga & ~Da, Ea, Fa, ab, 20, 1163531501),
				Da = e(Ea & Ga | Fa & ~Ga, Da, Ea, ub, 5, -1444681467),
				Ga = e(Da & Fa | Ea & ~Fa, Ga, Da, k, 9, -51403784),
				Fa = e(Ga & Ea | Da &
						~Ea, Fa, Ga, va, 14, 1735328473),
				Ea = e(Fa & Da | Ga & ~Da, Ea, Fa, qb, 20, -1926607734),
				Da = e(Ea ^ Fa ^ Ga, Da, Ea, ca, 4, -378558),
				Ga = e(Da ^ Ea ^ Fa, Ga, Da, ab, 11, -2022574463),
				Fa = e(Ga ^ Da ^ Ea, Fa, Ga, pb, 16, 1839030562),
				Ea = e(Fa ^ Ga ^ Da, Ea, Fa, Bb, 23, -35309556),
				Da = e(Ea ^ Fa ^ Ga, Da, Ea, g, 4, -1530992060),
				Ga = e(Da ^ Ea ^ Fa, Ga, Da, V, 11, 1272893353),
				Fa = e(Ga ^ Da ^ Ea, Fa, Ga, va, 16, -155497632),
				Ea = e(Fa ^ Ga ^ Da, Ea, Fa, h, 23, -1094730640),
				Da = e(Ea ^ Fa ^ Ga, Da, Ea, ub, 4, 681279174),
				Ga = e(Da ^ Ea ^ Fa, Ga, Da, f, 11, -358537222),
				Fa = e(Ga ^ Da ^ Ea, Fa, Ga, X, 16, -722521979),
				Ea = e(Fa ^ Ga ^ Da, Ea, Fa, b,
						23, 76029189),
				Da = e(Ea ^ Fa ^ Ga, Da, Ea, c, 4, -640364487),
				Ga = e(Da ^ Ea ^ Fa, Ga, Da, qb, 11, -421815835),
				Fa = e(Ga ^ Da ^ Ea, Fa, Ga, Fb, 16, 530742520),
				Ea = e(Fa ^ Ga ^ Da, Ea, Fa, k, 23, -995338651),
				Da = e(Fa ^ (Ea | ~Ga), Da, Ea, f, 6, -198630844),
				Ga = e(Ea ^ (Da | ~Fa), Ga, Da, va, 10, 1126891415),
				Fa = e(Da ^ (Ga | ~Ea), Fa, Ga, Bb, 15, -1416354905),
				Ea = e(Ga ^ (Fa | ~Da), Ea, Fa, ca, 21, -57434055),
				Da = e(Fa ^ (Ea | ~Ga), Da, Ea, qb, 6, 1700485571),
				Ga = e(Ea ^ (Da | ~Fa), Ga, Da, X, 10, -1894986606),
				Fa = e(Da ^ (Ga | ~Ea), Fa, Ga, h, 15, -1051523),
				Ea = e(Ga ^ (Fa | ~Da), Ea, Fa, g, 21, -2054922799),
				Da = e(Fa ^ (Ea | ~Ga), Da,
						Ea, ab, 6, 1873313359),
				Ga = e(Ea ^ (Da | ~Fa), Ga, Da, Fb, 10, -30611744),
				Fa = e(Da ^ (Ga | ~Ea), Fa, Ga, b, 15, -1560198380),
				Ea = e(Ga ^ (Fa | ~Da), Ea, Fa, ub, 21, 1309151649),
				Da = e(Fa ^ (Ea | ~Ga), Da, Ea, V, 6, -145523070),
				Ga = e(Ea ^ (Da | ~Fa), Ga, Da, pb, 10, -1120210379),
				Fa = e(Da ^ (Ga | ~Ea), Fa, Ga, k, 15, 718787259),
				Ea = e(Ga ^ (Fa | ~Da), Ea, Fa, c, 21, -343485551);
				a[0] = ~~(Da + a[0]);
				a[1] = ~~(Ea + a[1]);
				a[2] = ~~(Fa + a[2]);
				a[3] = ~~(Ga + a[3])
			}
			function e(a, d, e, f, g, k) {
				d = ~~(~~(d + a) + ~~(f + k));
				return ~~((d << g | d >>> 32 - g) + e)
			}
			function f(a) {
				return k[a >> 4 & 15] + k[a >> 0 & 15] + k[a >> 12 & 15] + k[a >>
					8 & 15] + k[a >> 20 & 15] + k[a >> 16 & 15] + k[a >> 28 & 15] + k[a >> 24 & 15]
			}
			var g = [0, 8, 16, 24],
			k = "0123456789abcdef".split("");
			return function (e) {
				if (a.isNull(e))
					return "";
				for (var k = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], C = e.length, L = [1732584193, -271733879, -1732584194, 271733878], P = 64; P <= C; P += 64) {
					var X = k,
					V = e,
					ca = P - 64;
					X[0] = V.charCodeAt(ca) + (V.charCodeAt(1 + ca) << 8) + (V.charCodeAt(2 + ca) << 16) + (V.charCodeAt(3 + ca) << 24);
					X[1] = V.charCodeAt(4 + ca) + (V.charCodeAt(5 + ca) << 8) + (V.charCodeAt(6 + ca) << 16) + (V.charCodeAt(7 + ca) << 24);
					X[2] = V.charCodeAt(8 + ca) +
						(V.charCodeAt(9 + ca) << 8) + (V.charCodeAt(10 + ca) << 16) + (V.charCodeAt(11 + ca) << 24);
					X[3] = V.charCodeAt(12 + ca) + (V.charCodeAt(13 + ca) << 8) + (V.charCodeAt(14 + ca) << 16) + (V.charCodeAt(15 + ca) << 24);
					X[4] = V.charCodeAt(16 + ca) + (V.charCodeAt(17 + ca) << 8) + (V.charCodeAt(18 + ca) << 16) + (V.charCodeAt(19 + ca) << 24);
					X[5] = V.charCodeAt(20 + ca) + (V.charCodeAt(21 + ca) << 8) + (V.charCodeAt(22 + ca) << 16) + (V.charCodeAt(23 + ca) << 24);
					X[6] = V.charCodeAt(24 + ca) + (V.charCodeAt(25 + ca) << 8) + (V.charCodeAt(26 + ca) << 16) + (V.charCodeAt(27 + ca) << 24);
					X[7] = V.charCodeAt(28 +
							ca) + (V.charCodeAt(29 + ca) << 8) + (V.charCodeAt(30 + ca) << 16) + (V.charCodeAt(31 + ca) << 24);
					X[8] = V.charCodeAt(32 + ca) + (V.charCodeAt(33 + ca) << 8) + (V.charCodeAt(34 + ca) << 16) + (V.charCodeAt(35 + ca) << 24);
					X[9] = V.charCodeAt(36 + ca) + (V.charCodeAt(37 + ca) << 8) + (V.charCodeAt(38 + ca) << 16) + (V.charCodeAt(39 + ca) << 24);
					X[10] = V.charCodeAt(40 + ca) + (V.charCodeAt(41 + ca) << 8) + (V.charCodeAt(42 + ca) << 16) + (V.charCodeAt(43 + ca) << 24);
					X[11] = V.charCodeAt(44 + ca) + (V.charCodeAt(45 + ca) << 8) + (V.charCodeAt(46 + ca) << 16) + (V.charCodeAt(47 + ca) << 24);
					X[12] = V.charCodeAt(48 +
							ca) + (V.charCodeAt(49 + ca) << 8) + (V.charCodeAt(50 + ca) << 16) + (V.charCodeAt(51 + ca) << 24);
					X[13] = V.charCodeAt(52 + ca) + (V.charCodeAt(53 + ca) << 8) + (V.charCodeAt(54 + ca) << 16) + (V.charCodeAt(55 + ca) << 24);
					X[14] = V.charCodeAt(56 + ca) + (V.charCodeAt(57 + ca) << 8) + (V.charCodeAt(58 + ca) << 16) + (V.charCodeAt(59 + ca) << 24);
					X[15] = V.charCodeAt(60 + ca) + (V.charCodeAt(61 + ca) << 8) + (V.charCodeAt(62 + ca) << 16) + (V.charCodeAt(63 + ca) << 24);
					d(L, k)
				}
				k = e.substring(P - 64);
				P = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
				X = k.length & -4;
				for (e = 0; e < X; e += 4)
					P[e >> 2] = k.charCodeAt(e) |
						k.charCodeAt(e + 1) << 8 | k.charCodeAt(e + 2) << 16 | k.charCodeAt(e + 3) << 24;
				X = k.length;
				for (V = e >> 2; e < X; ++e)
					P[V] |= k.charCodeAt(e) << g[e & 3];
				P[V] |= 128 << g[e & 3];
				55 < e && (d(L, P), P = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
				P[14] = 8 * C;
				d(L, P);
				return f(L[0]) + f(L[1]) + f(L[2]) + f(L[3])
			}
		}
		(),
		transparentImgURL: "data:image/gif;base64,R0lGODlhBQAFAIAAAP///wAAACH5BAEAAAAALAAAAAAFAAUAAAIEhI+pWAA7"
	};
	(function () {
		var d = a.util;
		d.PathUtils = {};
		d.ToolkitUtils = {};
		d.PathUtils.isSVGPath = function (a) {
			return a ? (a = a.trim().substr(0, 1)) && ("M" === a || "m" ===
				a) : !1
		};
		d.ToolkitUtils.roundDecimal = function (d) {
			return a.gv.isTestEnvironment ? Math.round(1E3 * d) / 1E3 : d
		};
		d.PathUtils.createPathArray = function (a) {
			if (!a)
				return null;
			a = a.replace(/([0-9])([\-])/g, "$1 $2");
			a = a.replace(/([mlqhvzcast])/gi, ",$1,").split(/[ ,]/g);
			var d = a.length,
			e;
			for (e = 0; e < d; e++) {
				var f = a[e];
				f ? isNaN(f) || (a[e] = parseFloat(f)) : (a.splice(e, 1), e--, d--)
			}
			return a
		};
		var e = 0,
		f = {},
		g = a.util.MiscUtil.simpleHash;
		d.PathUtils.getBBox = function (d) {
			var n = g(d);
			if (a.notNull(f[n]))
				return f[n];
			var u = document.getElementById("OM.dvt.PathUtils.getBBox.SVG");
			a.isNull(u) && (u = document.createElementNS("http://www.w3.org/2000/svg", "svg"));
			u.setAttribute("id", "OM.dvt.PathUtils.getBBox.SVG");
			document.body.appendChild(u);
			var C = document.getElementById("OM.dvt.PathUtils.getBBox.PATH");
			a.isNull(C) && (C = document.createElementNS("http://www.w3.org/2000/svg", "path"));
			C.setAttribute("id", "OM.dvt.PathUtils.getBBox.PATH");
			C.setAttribute("d", d);
			C.setAttribute("visibility", "hidden");
			u.appendChild(C);
			d = u.getBBox();
			u.removeChild(C);
			document.body.removeChild(u);
			u = {
				minX: d.x,
				minY: d.y,
				maxX: d.x + d.width,
				maxY: d.y + d.height,
				width: d.width,
				height: d.height
			};
			500 > e && (f[n] = u, e++);
			return u
		};
		d.PathUtils.getPathString = function (a) {
			for (var d = "", e = a.length, f, g = 0; g < e; g++)
				f = a[g], f !== c && null !== f && (d += (0 < g ? " " : "") + a[g]);
			return d
		};
		d.PathUtils.transformPath = function (a, e, f, g, L) {
			if (a) {
				for (var P = "", X = "", V, ca = 0; ca < a.length; ca++) {
					"string" == typeof a[ca] && (X = a[ca], V = X === X.toUpperCase(), P += X + " ");
					for (var b = []; ca < a.length - 1 && "number" == typeof a[ca + 1]; )
						ca++, b.push(a[ca]);
					var va;
					if ("A" === X.toUpperCase())
						for (va =
								0; va < b.length; va += 7)
							P += d.ToolkitUtils.roundDecimal(parseFloat(b[va]) * g) + " ", P += d.ToolkitUtils.roundDecimal(parseFloat(b[va + 1]) * L) + " ", P += d.ToolkitUtils.roundDecimal(b[va + 2]) + " ", P += d.ToolkitUtils.roundDecimal(b[va + 3]) + " ", P += d.ToolkitUtils.roundDecimal(b[va + 4]) + " ", P += d.ToolkitUtils.roundDecimal(parseFloat(b[va + 5]) * g + (V ? e : 0)) + " ", P += d.ToolkitUtils.roundDecimal(parseFloat(b[va + 6]) * L + (V ? f : 0)) + " ";
					else {
						var ab = [],
						c = [];
						"H" === X.toUpperCase() ? (ab.push(g), c.push(V ? e : 0)) : ("V" === X.toUpperCase() ? ab.push(L) :
							(ab.push(g), ab.push(L), c.push(V ? e : 0)), c.push(V ? f : 0));
						for (va = 0; va < b.length; va++)
							var h = ab[va % ab.length], pb = c[va % c.length], P = P + (d.ToolkitUtils.roundDecimal(parseFloat(b[va]) * h + pb) + " ")
					}
				}
				return P
			}
		};
		d.PathUtils._fitsInScale = function (a, d, e) {
			return Math.abs(a) > e || Math.abs(d) > e
		};
		d.PathUtils.simplifyPath = function (a, e) {
			for (var f, g = "", L = "", P = 0, X = 0, V, ca = 0, b = 0, va = 0, ab = 0; ab < a.length; ab++)
				if (isNaN(a[ab])) {
					if (f = a[ab], "Z" == f || "z" == f)
						V = f, L += f, 0 < va && (g += L, b = ca = 0), L = "", X = P = va = 0
				} else
					switch (f) {
					case "M":
						b = ca = 0;
					case "m":
						ca +=
						a[ab];
						b += a[ab + 1];
						L = L + f + ca + " " + b;
						V = f;
						ab++;
						break;
					case "l":
						P += a[ab];
						X += a[ab + 1];
						d.PathUtils._fitsInScale(P, X, e) && (V != f ? (V = f, L += f) : L += " ", L = L + P + " " + X, X = P = 0, va++);
						ab++;
						break;
					case "h":
					case "v":
						"h" == f ? P += a[ab] : X += a[ab],
						d.PathUtils._fitsInScale(P, X, e) && (0 !== P && 0 !== X ? ("l" != V ? (V = "l", L += "l") : L += " ", L = L + P + " " + X) : (V = f, L = L + f + ("h" == f ? P : X)), X = P = 0, va++)
					}
			return g
		};
		d.PathUtils._rectangle = function (a, e, f, g) {
			return d.PathUtils.moveTo(a, e) + d.PathUtils.horizontalLineTo(a + f) + d.PathUtils.verticalLineTo(e + g) + d.PathUtils.horizontalLineTo(a) +
			d.PathUtils.closePath()
		}
	})();
	a.util.LoadFileUtil = {};
	a.util.LoadFileUtil.CssLoaded = !1;
	a.util.LoadFileUtil.JsLoaded = !1;
	a.util.LoadFileUtil.JsLoadedTwice = !1;
	a.util.LoadFileUtil.LoadCss = function (d) {
		var e = document.getElementsByTagName("head")[0],
		f = document.createElement("link");
		f.setAttribute("rel", "stylesheet");
		f.setAttribute("href", d);
		e.appendChild(f);
		f.onload = f.onreadystatechange = function () {
			a.util.LoadFileUtil.CssLoaded = !0;
			f.onload = f.onreadystatechange = null
		}
	};
	a.util.LoadFileUtil.LoadJs = function (d, e) {
		var f =
			document.getElementsByTagName("head")[0],
		g = document.createElement("script");
		g.setAttribute("type", "text/javascript");
		g.setAttribute("src", d);
		f.appendChild(g);
		g.onload = g.onreadystatechange = function () {
			a.isNull(e) ? a.util.LoadFileUtil.JsLoaded = !0 : a.util.LoadFileUtil.JsLoadedTwice = !0;
			g.onload = g.onreadystatechange = null
		}
	};
	a.util.TimerManager = function (a) {
		var e = function () {
			var a = this;
			a.schedule = function (d, e) {
				a.cancel();
				a.time = e;
				a.callback = d;
				a.timeout = setTimeout(a.doCallback, e)
			};
			a.reset = function () {
				a.timeout &&
				a.schedule(a.callback, a.time)
			};
			a.cancel = function () {
				a.timeout && (clearTimeout(a.timeout), a.timeout = c)
			};
			a.doCallback = function () {
				try {
					a.callback()
				} catch (d) {}
			};
			return {
				reset: a.reset,
				schedule: a.schedule,
				cancel: a.cancel
			}
		},
		f = this;
		f.defaultTime = a ? a : 2E3;
		f.timers = [];
		f.getTimer = function (a) {
			a || (a = "NO_NAME");
			f.timers[a] || (f.timers[a] = new e);
			return f.timers[a]
		};
		f.schedule = function (a, d, e) {
			0 === d || d || (d = f.defaultTime);
			f.getTimer(a).schedule(e, d)
		};
		f.reset = function (a) {
			f.getTimer(a).reset()
		};
		f.cancel = function (a) {
			f.getTimer(a).cancel()
		};
		return {
			schedule: f.schedule,
			reset: f.reset,
			cancel: f.cancel
		}
	};
	a.util.WorldMercatorUtil = a.util.WorldMercatorUtil || function () {
		var d = 12756274 * Math.PI / 256,
		e = [d, d / 2, d / 4, d / 8, d / 16, d / 32, d / 64, d / 128, d / 256, d / 512, d / 1024, d / 2048, d / 4096, d / 8192, d / 16384, d / 32768, d / 65536, d / 131072, d / 262144, d / 524288, d / 1048576, d / 2097152, d / 4194304, d / 8388608],
		f = 12756274 * Math.PI / 2;
		return new function () {
			this.pixelsToMeters = function (a, d, n) {
				a = e[a];
				return [d * a - f, n * a - f]
			};
			this.metersToLonLat = function (a, d) {
				var e = a / f * 180,
				u = d / f * 180,
				u = 180 / Math.PI * (2 * Math.atan(Math.exp(u *
								Math.PI / 180)) - Math.PI / 2);
				return [e, u]
			};
			this.lonLatToMeters = function (a, d) {
				var e = a * f / 180,
				u = Math.log(Math.tan((90 + d) * Math.PI / 360)) / (Math.PI / 180),
				u = u * f / 180;
				return [e, u]
			};
			this.metersToPixels = function (a, d, n) {
				a = e[a];
				return [Math.round((d + f) / a), Math.round((n + f) / a)]
			};
			this.getTileCoverage = function (d, e, f) {
				f = (1 << d) - 1 - f;
				var u = this.pixelsToMeters(d, 256 * e, 256 * f);
				d = this.pixelsToMeters(d, 256 * (e + 1), 256 * (f + 1));
				return new a.geometry.Rectangle(u[0], u[1], d[0], d[1], 3857)
			};
			this.getTileCoverageLL = function (d, e, f) {
				e = this.getTileCoverage(d,
						e, f);
				d = this.metersToLonLat(e.getMinX(), e.getMinY());
				e = this.metersToLonLat(e.getMaxX(), e.getMaxY());
				return new a.geometry.Rectangle(d[0], d[1], e[0], e[1], 8307)
			}
		}
	}
	();
	a.util.Publisher = a.util.Publisher || {
		subscribers: {
			any: []
		},
		subscribe: function (a, e) {
			e = e || "any";
			"undefined" === typeof this.subscribers[e] && (this.subscribers[e] = []);
			this.subscribers[e].push(a)
		},
		unsubscribe: function (a, e) {
			this.visitSubscribers("unsubscribe", a, e)
		},
		publish: function (a, e) {
			this.visitSubscribers("publish", {
				publisher: this,
				publication: a
			},
				e)
		},
		visitSubscribers: function (d, e, f) {
			var g = f || "any";
			f = this.subscribers[g] || [];
			var k = f.length;
			0 === k && a.util.Logger.info(0, "OM.util.Publisher", 'No methods subscribed to "' + g + '"');
			for (g = 0; g < k; g++)
				if ("publish" === d)
					f[g](e);
				else
					f[g] === e && f.splice(g, 1)
		}
	};
	a.util.Task = a.Class.extend({
		mixin: a.util.Publisher,
		initialize: function (d, e) {
			this.subscribers = {
				any: []
			};
			this.taskType = a.util.Task.types.ANY;
			for (var f in a.util.Task.types)
				if (f === e) {
					this.taskType = e;
					break
				}
			this.status = a.util.Task.actions.IDLE;
			d instanceof a.util.Progress &&
			this.subscribe(d.updateTask.bind(d))
		},
		start: function () {
			this.updateTask(a.util.Task.actions.START)
		},
		update: function (d) {
			isNaN(d) ? a.util.Logger.warn(0, "OM.util.Task.update", "Non numeric update!") : 0 < d && 1 > d ? this.updateTask(100 * d) : a.util.Logger.warn(0, "OM.util.Task.update", "Update out of range")
		},
		updateTask: function (d) {
			100 === this.status || this.status === a.util.Task.actions.ERROR || this.status === a.util.Task.actions.FINISH ? a.util.Logger.info(0, "OM.util.Task", "WARNING: NOT UPDATING AS TASK IS DONE") : (this.status =
					d, this.publish(d))
		},
		complete: function () {
			this.updateTask(a.util.Task.actions.FINISH)
		},
		abort: function () {
			this.updateTask(a.util.Task.actions.ERROR)
		}
	});
	a.util.Task.actions = {
		START: "START",
		IDLE: "IDLE",
		PENDING: "PENDING",
		FINISH: "FINISH",
		ERROR: "ERROR"
	};
	a.util.Task.types = {
		ANY: "ANY",
		DETERMINISTIC: "DETERMINISTIC",
		INDETERMINISTIC: "INDETERMINISTIC"
	};
	a.util.Progress = a.Class.extend({
		mixin: a.util.Publisher,
		initialize: function () {
			this.subscribers = {
				any: []
			};
			this.taskFamilies = {
				any: []
			};
			this.taskFamiliesStatus = {
				any: {
					advance: 0,
					total: 0,
					pending: 0,
					finished: 0,
					error: 0
				}
			};
			this.progress = 0;
			this.mode = a.util.Progress.modes.DETERMINISTIC;
			if (a.isNull(this.map) || a.isNull(this.container) || a.isNull(this.progDiv) || a.isNull(this.progSpan))
				return null
		},
		addTask: function (a) {
			var e = a.publication;
			a = a.publisher;
			"undefined" === typeof this.taskFamilies.any && (this.taskFamilies.any = [], this.taskFamiliesStatus.any = {});
			this.taskFamilies.any.push(a);
			a.status = e
		},
		updateTask: function (d) {
			var e = d.publication,
			f = d.publisher,
			g = this.mode;
			e !== a.util.Task.actions.FINISH &&
			e !== a.util.Task.actions.ERROR && 100 !== e && "100%" !== e || this.isTaskRegistered(f) ? (this.isTaskRegistered(f) ? f.status = e : this.addTask(d), this.progress = this.updateProgress(), "100%" !== f.status && 100 !== f.status && f.status !== a.util.Task.actions.FINISH && f.status !== a.util.Task.actions.ERROR || this.removeCompletedTasks(f), "function" === typeof this.publish && (this.publish(this.progress, "progress"), g !== this.mode && this.publish(this.mode, "mode"))) : a.util.Logger.warning(0, "OM.util.Progress.update", "Cannot finish a task not previously started")
		},
		isTaskRegistered: function (a) {
			var e = this.taskFamilies.any;
			return "undefined" === typeof e || 0 > e.indexOf(a) ? !1 : !0
		},
		removeCompletedTasks: function (d) {
			if (this.isTaskRegistered(d)) {
				d = this.taskFamilies.any;
				for (var e = d.length, f = 0; f < e; f++)
					if (d[f].status !== a.util.Task.actions.FINISH && d[f].status !== a.util.Task.actions.ERROR && "100" !== d[f].status && "100%" !== d[f].status)
						return;
				this.taskFamilies.any.length = 0;
				this.taskFamiliesStatus.any.advance = 0
			}
		},
		updateProgress: function () {
			var d = [],
			e = 0,
			f = 0;
			this.mode = a.util.Progress.modes.DETERMINISTIC;
			for (var g in this.taskFamilies) {
				var k = this.taskFamilies[g],
				n = this.taskFamiliesStatus[g],
				u = k.length;
				if (0 !== u) {
					for (var C = a.util.Task.actions, L = 0, P = 0, X = 0, V = 0, ca = 0; ca < u; ca++) {
						var b = 0;
						k[ca].status === C.FINISH || k[ca].status === C.ERROR ? (b = 100, k[ca].status === C.FINISH ? P++ : V++) : isNaN(parseInt(k[ca].status)) ? (k[ca].taskType === a.util.Task.types.INDETERMINISTIC && (this.mode = a.util.Progress.modes.INDETERMINISTIC), b = 0, X++) : (b = parseInt(k[ca].status), 100 > b ? (k[ca].taskType === a.util.Task.types.INDETERMINISTIC && (this.mode =
										a.util.Progress.modes.INDETERMINISTIC), X++) : P++);
						L += b;
						f++
					}
					0 < L && (L /= u);
					k = n.advance;
					if ("undefined" === typeof k || L >= k)
						n.advance = L;
					n.total = u;
					n.pending = X;
					n.finish = P;
					n.error = V;
					d.push(n.advance)
				}
			}
			for (f = 0; f < d.length; f++)
				e += d[f];
			0 < e && (e /= d.length);
			return e
		},
		getStatistics: function () {
			return this.taskFamiliesStatus
		},
		getCurrentTasks: function () {
			return this.taskFamilies
		}
	});
	a.util.Progress.modes = {
		DETERMINISTIC: "DETERMINISTIC",
		INDETERMINISTIC: "INDETERMINISTIC"
	};
	a.util.ProgressBar = a.Class.extend({
		initialize: function (d,
			e) {
			a.isNull(d) || a.isNull(d.$oracleMapDiv) ? a.util.Logger.warning(0, "OM.util.ProgressBar", "Map instance or container is null!") : (this.options = e || {
					enable: !0,
					mode: a.util.Progress.modes.DETERMINISTIC
				}, this.container = d.$oracleMapDiv, this.progressBarDiv = a.$("\x3cdiv class\x3d'omv2_progDiv' id \x3d'progressBarDiv" + d.mapInstanceId + "'\x3e\x3c/div\x3e"), this.indetProgressBarSpan = a.$("\x3cspan class\x3d'omv2_progSpanInd' style\x3d'width:100%'\x3e\x3c/span\x3e"), this.deterProgressBarSpan = a.$("\x3cspan class\x3d'omv2_progSpan' style\x3d'width:0%'\x3e\x3c/span\x3e"),
				this.progressBarSpan = this.options.mode === a.util.Progress.modes.DETERMINISTIC ? this.deterProgressBarSpan : this.indetProgressBarSpan, this.progressBarDiv.append(this.progressBarSpan), this.container.append(this.progressBarDiv), this.prevStatus = 0)
		},
		updateUi: function (d) {
			d = d.publication;
			if (isNaN(d))
				a.util.Logger.warning(0, "OM.util.ProgressBar.UpdateUi", "Wrong update type: ");
			else if (!0 === this.options.enable) {
				this.progressBarDiv.css("visibility", "visible");
				this.progressBarSpan.css("width", this.prevStatus + "%");
				this.options.mode === a.util.Progress.modes.DETERMINISTIC ? this.progressBarSpan.css("width", d + "%") : this.progressBarSpan.css("width", "100%");
				this.prevStatus = d;
				var e = this.progressBarDiv;
				100 <= d && (d = this.prevStatus = 0, this.options.mode === a.util.Progress.modes.DETERMINISTIC && (d = 500), setTimeout(function () {
						e.css("visibility", "hidden")
					}, d))
			}
		},
		switchMode: function (d) {
			d = d.publication;
			var e;
			d !== a.util.Progress.modes.DETERMINISTIC && d !== a.util.Progress.modes.INDETERMINISTIC ? a.util.Logger.warning(0, "OM.util.ProgressBar.SwitchMode",
				"Wrong mode: " + d) : (e = this.progressBarSpan === this.deterProgressBarSpan ? a.util.Progress.modes.DETERMINISTIC : a.util.Progress.modes.INDETERMINISTIC, d !== e && (this.progressBarSpan.remove(), this.progressBarSpan = d === a.util.Progress.modes.DETERMINISTIC ? this.deterProgressBarSpan : this.indetProgressBarSpan, this.progressBarDiv.append(this.progressBarSpan), this.options.mode = d))
		}
	});
	a.util.ProgressBar.modes = {
		DETERMINATE: "DETERMINATE",
		INDETERMINATE: "INDETERMINTATE"
	};
	a.util.ProgressBar.INDETERMINATE_START = "START_INDETERMINATE";
	a.util.ProgressBar.INDETERMINATE_FINISH = "FINISH_INDETERMINATE";
	a.geometry.Geometry = a.Class.extend({
		initialize: function (d) {
			this.srid = this.type = null;
			if (a.isNull(d))
				this.srid = 8307;
			else if (a.util.ValidationUtil.isNumber(d))
				this.srid = "number" === typeof d ? d : parseInt(d);
			else
				return a.util.Logger.throwErr("MAPVIEWER_9018", "geom.Geometry", "srid:" + d), null;
			this.mbr = this.geometries = this.coordinates = null;
			this.dim = 2
		},
		getMBR: function () {
			var d = a.geometry;
			if (!this.mbr) {
				var e = d.Geometry.calculateMBR(this.coordinates,
						this.type, this.dim);
				this.mbr = new d.Rectangle(e.minX, e.minY, e.maxX, e.maxY, this.srid)
			}
			return this.mbr
		},
		getMIR: function () {
			var d = [];
			if ("GeometryCollection" === this.type) {
				var e = this.geometries;
				if (a.isNull(e) || 0 === e.length)
					return null;
				for (var f = -1, g = null, k = null, n = 0; n < e.length; n++)
					g = e[n].getMIR(), a.notNull(g) && (d = [g.getMinX(), g.getMinY(), g.getMaxX(), g.getMaxY()], d = this.getRectangleArea(d), d > f && (k = g, f = d));
				return k
			}
			e = this.dim ? this.dim : 2;
			f = this.coordinates;
			g = this.getMBR();
			d[0] = g.getMinX();
			d[1] = g.getMinY();
			d[2] =
				g.getMaxX();
			d[3] = g.getMaxY();
			if ("Polygon" === this.type)
				d = this.getLabelBox(f, e);
			else if ("MultiPolygon" === this.type)
				for (g = -1, k = null, n = 0; n < f.length; n++)
					k = this.getLabelBox(f[n], e), this.getRectangleArea(k) > g && (d = k, g = this.getRectangleArea(d));
			else if ("Rectangle" === this.type)
				return new a.geometry.Rectangle(this.getMinX(), this.getMinY(), this.getMaxX(), this.getMaxY(), this.srid);
			return a.isNull(d) ? null : new a.geometry.Rectangle(d[0], d[1], d[2], d[3], this.srid)
		},
		getDimension: function () {
			return this.dim
		},
		_getMeasure: function (d) {
			var e =
				this.coordinates,
			f = this.geometries,
			g = null,
			k = 0;
			if (a.isNull(e)) {
				if (a.isNull(f))
					return 0;
				for (e = 0; e < f.length; e++)
					k += f[e]._getMeasure(d);
				return k
			}
			"area" === d ? g = a.util.GeomUtil.polygonArea : "length" === d && (g = a.util.GeomUtil.polylineLength);
			if (a.$.isArray(e[0])) {
				for (d = 0; d < e.length; d++)
					k += g(e[d], this.dim);
				return k
			}
			return g(e, this.dim)
		},
		getLength: function () {
			return this._getMeasure("length")
		},
		getArea: function () {
			return this._getMeasure("area")
		},
		getLabelBox: function (d, e) {
			for (var f = d[0], g = a.geometry.Geometry.calculateMBR(d,
						"Polygon", e), g = new a.geometry.Rectangle(g.minX, g.minY, g.maxX, g.maxY, this.srid), k = (g.getMaxY() - g.getMinY()) / 100, n = [], u = 0; 100 > u; u++)
				n[u] = this.findIntersections(f, e, g, 100, u);
			var u = Math.floor(50),
			C = this.findLongestSegment(n[u]),
			f = null,
			L,
			P,
			X;
			-1 != C && (L = u, P = n[u][C], C = n[u][C + 1], X = g.getMinY() + (u + 1) * k, f = this.getOptimalBox(n, g, 100, P, C, X, L));
			for (u = 0; 100 > u; u++)
				C = this.findLongestSegment(n[u]), -1 != C && (L = u, P = n[u][C], C = n[u][C + 1], X = g.getMinY() + (u + 1) * k, L = this.getOptimalBox(n, g, 100, P, C, X, L), this.getRectangleArea(L) >
					1 * this.getRectangleArea(f) && (f = L));
			return f
		},
		getOptimalBox: function (d, e, f, g, k, n, u) {
			g = [g, n, k, n];
			n = k = !0;
			var C = (e.getMaxY() - e.getMinY()) / f,
			L = u + 1;
			for (--u; k || n; L++, u--) {
				L >= f && (k = !1);
				0 > u && (n = !1);
				var P = null,
				X = null,
				V;
				k && (V = e.getMinY() + (L + 1) * C, P = this.expandBox(g, d[L], V));
				n && (V = e.getMinY() + (u + 1) * C, X = this.expandBox(g, d[u], V));
				V = P;
				this.getRectangleArea(P) < this.getRectangleArea(X) ? (V = X, k && L--) : n && u++;
				if (a.isNull(V) || this.getRectangleArea(V) < this.getRectangleArea(g))
					break;
				else
					g = V
			}
			return g
		},
		expandBox: function (d,
			e, f) {
			var g = d[0],
			k = d[2],
			n = g,
			u = k,
			C = 0;
			if (a.isNull(e) || 2 > e.length)
				return null;
			for (var L = 1; L < e.length; L += 2) {
				var P = e[L - 1],
				X = e[L];
				if (P >= k)
					break;
				if (!(X <= g) && (P = Math.max(P, g), X = Math.min(X, k), X > P)) {
					var V = X - P;
					V > C && (C = V, n = P, u = X)
				}
			}
			if (0 >= C)
				return null;
			e = [];
			e[0] = n;
			e[1] = Math.min(d[1], f);
			e[2] = u;
			e[3] = Math.max(d[3], f);
			return e
		},
		findLongestSegment: function (d) {
			var e = -1,
			f = 0;
			if (a.isNull(d) || 2 > d.length)
				return -1;
			for (var g = 1; g < d.length; g += 2) {
				var k = d[g] - d[g - 1];
				k > e && (e = k, f = g - 1)
			}
			return f
		},
		findIntersections: function (a, e, f, g, k) {
			g =
				(f.getMaxY() - f.getMinY()) / g;
			f = f.getMinY() + (k + 1) * g;
			k = [];
			for (g = e; g < a.length; g += e) {
				var n = a[g - e],
				u = a[g - e + 1],
				C = a[g],
				L = a[g + 1],
				P,
				X;
				u > L && (P = u, X = n, u = L, n = C, L = P, C = X);
				f < u || f > L || (u != L ? k.push((C - n) * (f - u) / (L - u) + n) : (k.push(n), k.push(C)))
			}
			k.sort(function (a, d) {
				return a - d
			});
			return k
		},
		getRectangleArea: function (d) {
			return a.isNull(d) ? 0 : (d[2] - d[0]) * (d[3] - d[1])
		},
		transform: function (d, e, f, g, k) {
			if (a.notNull(k) && (d === a.util.BaiduUtil.SRID || this.srid === a.util.BaiduUtil.SRID))
				return a.util.BaiduUtil.transformGeom({
					geom: this,
					toSrid: d,
					callBack: e,
					map: k.map,
					inputIsBD09LonLat: k.inputIsBD09LonLat
				});
			var n = a.geometry;
			if (a.isNull(this.srid) || a.isNull(d))
				return a.util.Logger.warning("MAPVIEWER_9019", "geom.Geometry.transform", ""), null;
			if (this.srid === d)
				return e ? e(this) : this;
			if (k = a.util.CSTransformUtil.getCSTransformFunction(this.srid, d)) {
				f = null;
				try {
					if (this instanceof n.GeometryCollection)
						f = this.clientTransform(d);
					else {
						var u = a.util.CSTransformUtil.transformOrdinates(k, this.coordinates, this.dim);
						f = n.Geometry.createGeometry({
							type: this.type,
							dim: this.dim,
							coordinates: u
						}, d);
						f.dim = this.dim
					}
					if (e) {
						e(f);
						return
					}
					return f
				} catch (C) {
					return a.util.Logger.warning(null, "geom.Geometry.transform", "Cannot transform geometry coordinates to SRID " + d + ": " + this.toString() + ", due to " + C.message),
					null
				}
			}
			u = a.gv.localbaseURL();
			if (!f && u)
				f = u + "/mcserver";
			else if (!f) {
				a.util.Logger.warning("MAPVIEWER_9020", "geom.Geometry.transform", "");
				return
			}
			a.util.HttpRequest.send(f, {
				request: "cstransform",
				gformat: "geojson",
				dstsrid: d,
				datasource: g,
				geometry: this.toString()
			}, function (f) {
				f ?
				(f = n.Geometry.createGeometry(f, d), e(f)) : a.util.Logger.warning("MAPVIEWER_9018", "geom.Geometry.transform", "")
			}, "json", function (d) {
				d ? a.util.Logger.warning("MAPVIEWER_9018", "geom.Geometry.transform", d.responseText) : a.util.Logger.warning("MAPVIEWER_9018", "geom.Geometry.transform", "")
			})
		},
		clone: function (d) {
			var e = a.geometry,
			f = this.coordinates;
			if (d && f)
				var g = function (a) {
					for (var d = [], e = 0; e < a.length; e++)
						d[e] = a[e]instanceof Array ? g(a[e]) : a[e];
					return d
				},
			f = g(this.coordinates);
			if (this instanceof e.Circle)
				return new e.Circle(this.getCenterX(),
					this.getCenterY(), this.getRadius(), this.srid);
			switch (this.type) {
			case "Point":
				return d = new e.Point(this.getX(), this.getY(), this.srid),
				2 < this.dim && (d.coordinates = f, d.dim = this.dim),
				d;
			case "OrientedPoint":
				return d = new e.Point(this.getX(), this.getY(), this.srid, this.getOrientationX(), this.getOrientationY()),
				2 < this.dim && (d.coordinates = f, d.dim = this.dim),
				d;
			case "MultiPoint":
			case "OrientedMultiPoint":
				return new e.MultiPoint(f, this.srid, this.dim);
			case "LineString":
				return new e.LineString(f, this.srid, this.dim);
			case "MultiLineString":
				return new e.MultiLineString(f, this.srid, this.dim);
			case "Polygon":
				return new e.Polygon(f, this.srid, this.dim);
			case "MultiPolygon":
				return new e.MultiPolygon(f, this.srid, this.dim);
			case "Rectangle":
				return new e.Rectangle(this.getMinX(), this.getMinY(), this.getMaxX(), this.getMaxY(), this.srid);
			case "GeometryCollection":
				for (var f = [], k = 0, n = this.geometries; k < n; k++)
					f.push(this.geometries[k].clone(d));
				return new e.GeometryCollection(f, this.srid);
			default:
				return new e.Geometry(f, this.srid,
					this.dim)
			}
		},
		toString: function (d) {
			return a.isNull(d) || !0 !== d.strict ? this.toStringMVNative() : this.toStringStrict()
		},
		toStringMVNative: function () {
			var d;
			d = "{" + ('"type":"' + this.type + '",');
			d = a.isNull(this.srid) ? d + '"srid":8307,' : d + ('"srid":' + this.srid + ",");
			d += '"coordinates":';
			var e = a.GeomTypes;
			if (this.type === e.MULTIPOINT || this.type === e.MULTILINESTRING || this.type === e.MULTIPOLYGON || this.type === e.POLYGON || this.type === e.ORIENTEDMULTIPOINT) {
				d += "[";
				for (var f = this.coordinates.length, g = 0; g < f; g++) {
					d += "[";
					if (this.type ===
						e.MULTIPOLYGON) {
						for (var k = this.coordinates[g].length, n = 0; n < k; n++)
							d += "[" + this.coordinates[g][n] + "],";
						k = d.length;
						d = d.substring(0, k - 1)
					} else
						d += this.coordinates[g];
					d += "],"
				}
				f = d.length;
				d = d.substring(0, f - 1);
				d += "]"
			} else
				d += "[" + this.coordinates + "]";
			return d + "}"
		},
		toStringStrict: function () {
			var d;
			d = "{" + ('"type":"' + this.type + '",');
			d = a.isNull(this.srid) ? d + '"srid":8307,' : d + ('"srid":' + this.srid + ",");
			d += '"coordinates":';
			var e = a.GeomTypes;
			if (this.type === e.MULTIPOINT || this.type === e.MULTILINESTRING || this.type === e.MULTIPOLYGON ||
				this.type === e.POLYGON || this.type === e.ORIENTEDMULTIPOINT) {
				d += "[";
				for (var f = this.coordinates.length, g = 0; g < f; g++) {
					d += "[";
					if (this.type === e.MULTIPOLYGON) {
						for (var k = this.coordinates[g].length, n = 0; n < k; n++)
							d += "[", d += this.getCoordsString(this.coordinates[g][n]), d += "],";
						k = d.length;
						d = d.substring(0, k - 1)
					} else
						d += this.getCoordsString(this.coordinates[g]);
					d += "],"
				}
				f = d.length;
				d = d.substring(0, f - 1)
			} else
				d = d + "[" + this.getCoordsString(this.coordinates);
			d += "]";
			return d += "}"
		},
		getCoordsString: function (d) {
			var e = this.dim,
			f =
				a.gv.decimals;
			if (a.isNull(e) || 2 > e)
				e = 2;
			var g = "";
			if (a.isNull(d) || 0 === d.length)
				return "";
			if (this.type === a.GeomTypes.POINT || this.type === a.GeomTypes.MULTIPOINT || this.type === a.GeomTypes.ORIENTEDPOINT)
				return "" + d[0].toFixed(f) + "," + d[1].toFixed(f);
			for (var k = 0; k < d.length; k += e)
				g += "[" + d[k].toFixed(f) + "," + d[k + 1].toFixed(f) + "]", k + e < d.length && (g += ",");
			return g
		},
		densify: function () {
			var d = a.GeomTypes;
			if (this.type === d.POINT || this.type === d.MULTIPOINT || this.type === d.ORIENTEDPOINT || this.type === d.ORIENTEDMULTIPOINT)
				return this;
			var e = {
				type: "GEODETIC",
				distConvFactor: 1
			};
			if (8307 !== this.srid && 8265 !== this.srid && 4326 !== this.srid && 4269 !== this.srid && (!e || "GEODETIC" !== e.type && "PROJECTED" !== e.type))
				return this;
			var f = 1;
			e && "PROJECTED" === e.type && (f = 1E5 * e.distConvFactor);
			var g = e = null;
			if (this.type === d.LINESTRING)
				e = a.util.GeomUtil.densifyOrdinates(this.coordinates, f), g = this.type;
			else if (this.type === d.RECTANGLE)
				d = [this.getMinX(), this.getMinY(), this.getMinX(), this.getMaxY(), this.getMaxX(), this.getMaxY(), this.getMaxX(), this.getMinY(), this.getMinX(),
					this.getMinY()], e = a.util.GeomUtil.densifyOrdinates(d, f), g = "Polygon";
			else {
				if (this.type === d.GEOMETRYCOLLECTION) {
					f = this.geometries.length;
					d = Array(f);
					for (e = 0; e < f; e++)
						d[e] = this.geometries[e].densify();
					return new a.geometry.GeometryCollection(d, this.srid)
				}
				for (var g = this.coordinates.length, e = Array(g), k = 0; k < g; k++)
					if (this.type === d.MULTIPOLYGON) {
						var n = this.coordinates[k].length;
						e[k] = Array(n);
						for (var u = 0; u < n; u++)
							e[k][u] = a.util.GeomUtil.densifyOrdinates(this.coordinates[k][u], f)
					} else
						e[k] = a.util.GeomUtil.densifyOrdinates(this.coordinates[k],
								f);
				g = this.type
			}
			return new a.geometry.Geometry.createGeometry({
				type: g,
				coordinates: e
			}, this.srid)
		},
		move: function (d, e, f) {
			a.util.GeomUtil.moveCoordinates(this.coordinates, d, e, "OrientedPoint" === this.type || "OrientedMultiPoint" === this.type ? !0 : !1, this.dim, f);
			this.mbr && this.mbr.move(d, e)
		},
		getSRID: function () {
			return this.srid
		},
		getOrdinates: function () {
			return this.coordinates
		},
		getType: function () {
			return this.type
		},
		toJSON: function () {
			return this.type === a.GeomTypes.GEOMETRYCOLLECTION ? {
				type: this.type,
				srid: this.srid,
				geometries: this.geometries
			}
			 : {
				type: this.type,
				srid: this.srid,
				coordinates: this.coordinates
			}
		}
	});
	a.geometry.Geometry.createGeometry = function (d, e) {
		var f,
		g,
		k = a.geometry;
		f = a.GeomTypes;
		var n = d.type,
		u = 2;
		d.dim && (u = d.dim);
		var C = d.coordinates;
		g = null;
		var L = k.Geometry;
		if (n === f.POINT) {
			if (f = C[0], g = C[1], g = new k.Point(f, g, e), 2 < u)
				for (f = 2; f < u; f++)
					g.addDimension(C[f])
		} else if (n === f.ORIENTEDPOINT) {
			if (f = C[0], g = C[1], g = new k.Point(f, g, e, C[u], C[u + 1]), 2 < u)
				for (f = 2; f < u; f++)
					g.addDimension(C[f], C[u + f])
		} else if (n === f.LINESTRING)
			g =
				new k.LineString(C, e, u);
		else if (n === f.RECTANGLE)
			g = new k.Rectangle(C[0], C[1], C[2], C[3], e);
		else if (n === f.POLYGON)
			g = new k.Polygon(C, e, u);
		else if (n === f.MULTIPOINT || n === f.ORIENTEDMULTIPOINT)
			g = new k.MultiPoint(C, e, u);
		else if (n === f.MULTILINESTRING)
			g = new k.MultiLineString(C, e, u);
		else if (n === f.MULTIPOLYGON)
			g = new k.MultiPolygon(C, e, u);
		else if (n === f.CIRCLE)
			g = new k.Circle(C[0], C[1], C[2], e);
		else if (n === f.GEOMETRYCOLLECTION) {
			u = d.geometries;
			C = u.length;
			g = L.createGeometry;
			for (f = 0; f < C; f++)
				u[f] = g(u[f], e);
			g = new k.GeometryCollection(u,
					e)
		}
		!d.mbr || d.mbr instanceof L || (g.mbr = new k.Rectangle(d.mbr.minX, d.mbr.minY, d.mbr.maxX, d.mbr.maxY, e));
		return g
	};
	a.geometry.Geometry.calculateMBR = function (d, e, f) {
		var g = {
			minX: Number.POSITIVE_INFINITY,
			minY: Number.POSITIVE_INFINITY,
			maxX: Number.NEGATIVE_INFINITY,
			maxY: Number.NEGATIVE_INFINITY
		},
		k = a.geometry.Geometry.getCoordsMBR,
		n = d.length;
		f = f ? f : 2;
		if ("Polygon" === e)
			g = k(d[0], f, g);
		else if ("MultiPolygon" === e)
			for (e = 0; e < n; e++)
				g = k(d[e][0], f, g);
		else if ("LineString" === e)
			g = k(d, f, g);
		else if ("MultiLineString" === e)
			for (e =
					0; e < n; e++)
				g = k(d[e], f, g);
		else if ("Rectangle" === e)
			g = {
				minX: d[0],
				minY: d[1],
				maxX: d[2],
				maxY: d[3]
			};
		else if ("Point" === e || "OrientedPoint" === e)
			g = {
				minX: d[0],
				minY: d[1],
				maxX: d[0],
				maxY: d[1]
			};
		else if ("MultiPoint" === e)
			for (e = 0; e < n; e++)
				g = k(d[e], f, g);
		else if ("OrientedMultiPoint" === e)
			for (e = 0; e < n; e++)
				g = k([d[e][0], d[e][1]], f, g);
		return g
	};
	a.geometry.Geometry.getCoordsMBR = function (a, e, f) {
		a[0] < f.minX && (f.minX = a[0]);
		a[0] > f.maxX && (f.maxX = a[0]);
		a[1] < f.minY && (f.minY = a[1]);
		a[1] > f.maxY && (f.maxY = a[1]);
		for (var g = e, k = a.length; g < k; g +=
			e)
			a[g] < f.minX ? f.minX = a[g] : a[g] > f.maxX && (f.maxX = a[g]), a[g + 1] < f.minY ? f.minY = a[g + 1] : a[g + 1] > f.maxY && (f.maxY = a[g + 1]);
		return f
	};
	a.geometry.Geometry.calculateGeomCollectionMBR = function (d, e) {
		if (!d || 0 === d.length || e !== a.GeomTypes.GEOMETRYCOLLECTION)
			return null;
		var f,
		g = null;
		f = null;
		for (var k = 0; k < d.length; k++)
			if (f = d[k].coordinates)
				f = a.geometry.Geometry.calculateMBR(f, d[k].type), g ? (g.minX > f.minX && (g.minX = f.minX), g.minY > f.minY && (g.minY = f.minY), g.maxX < f.maxX && (g.maxX = f.maxX), g.maxY < f.maxY && (g.maxY = f.maxY)) : (g = {},
					g.minX = f.minX, g.minY = f.minY, g.maxX = f.maxX, g.maxY = f.maxY);
		return g
	};
	a.geometry.Geometry.findSubstring = function (a, e) {
		var f = e.wkti,
		g = e.wktStr.substring(f).match(a);
		return g ? (f += g[0].length, e.wkti = f, e.wktMatch = g[0], e) : null
	};
	a.geometry.Geometry.wktGetCoords = function (d) {
		for (var e = [], f, g = a.geometry.Geometry.findSubstring; g(/^[-+]?([0-9]*\.[0-9]+([eE][-+]?[0-9]+)?|[0-9]+([eE][-+]?[0-9]+)?)/, d) || g(/^(\,)/, d); )
			f = d.wktMatch, "," != f && e.push(parseFloat(f)), g(/^\s*/, d);
		d.wktCoords = e;
		return e.length ? d : null
	};
	a.geometry.Geometry.wktGetMulticoords =
	function (d) {
		var e = a.geometry.Geometry.findSubstring;
		e(/^\s*/, d);
		for (var f = 0, g = [], k = [], n = g, u; e(/^(\()/, d) || e(/^(\))/, d) || e(/^(\,)/, d) || e(/^[-+]?([0-9]*\.[0-9]+([eE][-+]?[0-9]+)?|[0-9]+([eE][-+]?[0-9]+)?)/, d); ) {
			u = d.wktMatch;
			if ("(" == u)
				k.push(n), n = [], k[k.length - 1].push(n), f++;
			else if (")" == u) {
				n = k.pop();
				if (!n)
					return null;
				f--;
				if (0 === f)
					break
			} else if ("," !== u) {
				if (isNaN(parseFloat(u)))
					return null;
				n.push(parseFloat(u))
			}
			e(/^\s*/, d)
		}
		if (0 !== f)
			return null;
		d.wktCoords = g[0];
		return d
	};
	a.geometry.Geometry.wktGetMulticoordsPoint =
	function (d) {
		var e = a.geometry.Geometry.findSubstring;
		e(/^\s*/, d);
		for (var f = 0, g = [], k = [g], n = g, u; e(/^(\()/, d) || e(/^(\))/, d) || e(/^(\,)/, d) || e(/^[-+]?([0-9]*\.[0-9]+([eE][-+]?[0-9]+)?|[0-9]+([eE][-+]?[0-9]+)?)/, d); ) {
			u = d.wktMatch;
			if ("(" == u)
				k.push(n), n = [], k[k.length - 1].push(n), f++;
			else if (")" == u) {
				n = k.pop();
				if (!n)
					return;
				f--;
				if (0 === f)
					break
			} else if ("," == u)
				n = [], k[k.length - 1].push(n);
			else {
				if (isNaN(parseFloat(u)))
					return null;
				n.push(parseFloat(u))
			}
			e(/^\s*/, d)
		}
		if (0 !== f)
			return null;
		d.wktCoords = g;
		return d
	};
	a.geometry.Geometry.wktToPoint =
	function (d) {
		var e = a.geometry,
		f = e.Geometry.findSubstring;
		if (!f(/^(point)/i, d))
			return null;
		f(/^\s*/, d);
		f(/^z/i, d) && (d.wktDim = 3, f(/^\s*/, d));
		if (!f(/^(\()/, d))
			return null;
		var g = [];
		if (e.Geometry.wktGetCoords(d))
			g = d.wktCoords;
		else
			return null;
		f(/^\s*/, d);
		if (!f(/^(\))/, d))
			return null;
		e = new e.Point(g[0], g[1], 8307);
		3 == d.wktDim && e.addDimension(g[2]);
		return e
	};
	a.geometry.Geometry.wktToLinestring = function (d) {
		var e = a.geometry,
		f = e.Geometry.findSubstring;
		if (!f(/^(linestring)/i, d))
			return null;
		f(/^\s*/, d);
		f(/^z/i,
			d) && (d.wktDim = 3, f(/^\s*/, d));
		if (!f(/^(\()/, d))
			return null;
		var g = [];
		if (e.Geometry.wktGetCoords(d))
			g = d.wktCoords;
		else
			return null;
		return g && f(/^(\))/, d) ? 2 == d.wktDim ? new e.LineString(g) : new e.LineString(g, 8307, d.wktDim) : null
	};
	a.geometry.Geometry.wktToPolygon = function (d) {
		var e = a.geometry,
		f = e.Geometry.findSubstring;
		if (!f(/^(polygon)/i, d))
			return null;
		f(/^\s*/, d);
		f(/^z/i, d) && (d.wktDim = 3, f(/^\s*/, d));
		f = [];
		if (e.Geometry.wktGetMulticoords(d))
			f = d.wktCoords;
		else
			return null;
		return 2 == d.wktDim ? new e.Polygon(f) :
		new e.Polygon(f, 8307, d.wktDim)
	};
	a.geometry.Geometry.wktToMultipoint = function (d) {
		var e = a.geometry,
		f = e.Geometry.findSubstring;
		if (!f(/^(multipoint)/i, d))
			return null;
		f(/^\s*/, d);
		f(/^z/i, d) && (d.wktDim = 3, f(/^\s*/, d));
		var g = [];
		if (e.Geometry.wktGetMulticoordsPoint(d))
			g = d.wktCoords;
		else
			return null;
		f(/^\s*/, d);
		return 2 == d.wktDim ? new e.MultiPoint(g) : new e.MultiPoint(g, 8307, d.wktDim)
	};
	a.geometry.Geometry.wktToMultilinestring = function (d) {
		var e = a.geometry,
		f = e.Geometry.findSubstring;
		if (!f(/^(multilinestring)/i,
				d))
			return null;
		f(/^\s*/, d);
		f(/^z/i, d) && (d.wktDim = 3, f(/^\s*/, d));
		f = [];
		if (e.Geometry.wktGetMulticoords(d))
			f = d.wktCoords;
		else
			return null;
		return 2 == d.wktDim ? new e.MultiLineString(f) : new e.MultiLineString(f, 8307, d.wktDim)
	};
	a.geometry.Geometry.wktToMultipolygon = function (d) {
		var e = a.geometry,
		f = e.Geometry.findSubstring;
		if (!f(/^(multipolygon)/i, d))
			return null;
		f(/^\s*/, d);
		f(/^z/i, d) && (d.wktDim = 3, f(/^\s*/, d));
		f = [];
		if (e.Geometry.wktGetMulticoords(d))
			f = d.wktCoords;
		else
			return null;
		return 2 == d.wktDim ? new e.MultiPolygon(f) :
		new e.MultiPolygon(f, 8307, d.wktDim)
	};
	a.geometry.Geometry.wktToGeometrycollection = function (d) {
		var e = a.geometry,
		f = e.Geometry.findSubstring,
		g = [],
		k;
		if (!f(/^(geometrycollection)/i, d))
			return null;
		f(/^\s*/, d);
		f(/^z/i, d) && (d.wktDim = 3, f(/^\s*/, d));
		if (!f(/^(\()/, d))
			return null;
		do
			if (k = e.Geometry.root(d))
				g.push(k), f(/^\s*/, d), f(/^(\,)/, d), f(/^\s*/, d);
			else
				break;
		while (k);
		return f(/^(\))/, d) ? new e.GeometryCollection(g) : null
	};
	a.geometry.Geometry.root = function (d) {
		var e = a.geometry;
		return e.Geometry.wktToGeometrycollection(d) ||
		e.Geometry.wktToPoint(d) || e.Geometry.wktToLinestring(d) || e.Geometry.wktToPolygon(d) || e.Geometry.wktToMultipoint(d) || e.Geometry.wktToMultilinestring(d) || e.Geometry.wktToMultipolygon(d)
	};
	a.geometry.Geometry.createGeometryFromWKT = function (d) {
		return a.geometry.Geometry.root({
			wktStr: d,
			wkti: 0,
			wktMatch: "",
			wktCoords: [],
			wktDim: 2
		})
	};
	a.geometry.Rectangle = a.geometry.Geometry.extend({
		initialize: function e(a, g, k, n, u) {
			e.base.call(this, u);
			this.setRectangle(a, g, k, n)
		},
		getCenter: function () {
			return new a.geometry.Point((this.getMaxX() -
					this.getMinX()) / 2 + this.getMinX(), (this.getMaxY() - this.getMinY()) / 2 + this.getMinY(), this.srid)
		},
		getMinX: function () {
			return this.coordinates[0]
		},
		getMinY: function () {
			return this.coordinates[1]
		},
		getMaxX: function () {
			return this.coordinates[2]
		},
		getMaxY: function () {
			return this.coordinates[3]
		},
		getWidth: function () {
			return this.coordinates[2] - this.coordinates[0]
		},
		getHeight: function () {
			return this.coordinates[3] - this.coordinates[1]
		},
		setRectangle: function (e, f, g, k) {
			var n = a.util.ValidationUtil.isNumber;
			n(e) || a.util.Logger.throwErr("MAPVIEWER_9018",
				"geom.Rectangle.setRectangle", "minX:" + e);
			n(g) || a.util.Logger.throwErr("MAPVIEWER_9018", "geom.Rectangle.setRectangle", "maxX:" + g);
			n(f) || a.util.Logger.throwErr("MAPVIEWER_9018", "geom.Rectangle.setRectangle", "minY:" + f);
			n(k) || a.util.Logger.throwErr("MAPVIEWER_9018", "geom.Rectangle.setRectangles", "maxY:" + k);
			e = Number(e);
			f = Number(f);
			g = Number(g);
			k = Number(k);
			e > g && (n = g, g = e, e = n);
			f > k && (n = k, k = f, f = n);
			this.type = "Rectangle";
			this.coordinates = [e, f, g, k]
		},
		getLength: function () {
			var a = this.coordinates;
			return 2 * (a[2] - a[0]) +
			2 * (a[3] - a[1])
		},
		getArea: function () {
			return this.getWidth() * this.getHeight()
		},
		move: function (a, f) {
			this.coordinates[0] += a;
			this.coordinates[1] += f;
			this.coordinates[2] += a;
			this.coordinates[3] += f
		},
		expand: function (a) {
			a && a.type === this.type && (this.coordinates[0] > a.coordinates[0] && (this.coordinates[0] = a.coordinates[0]), this.coordinates[1] > a.coordinates[1] && (this.coordinates[1] = a.coordinates[1]), this.coordinates[2] < a.coordinates[2] && (this.coordinates[2] = a.coordinates[2]), this.coordinates[3] < a.coordinates[3] && (this.coordinates[3] =
						a.coordinates[3]))
		},
		toGML: function () {
			var a = '\x3cgml:Polygon srsName\x3d"SDO:' + this.srid + '" xmlns:gml\x3d"http://www.opengis.net/gml"\x3e',
			a = a + "\x3cgml:outerBoundaryIs\x3e\x3cgml:LinearRing\x3e\x3cgml:coordinates\x3e" + (this.getMinX() + "," + this.getMinY() + " " + this.getMaxX() + "," + this.getMinY() + " "),
			a = a + (this.getMaxX() + "," + this.getMaxY() + " " + this.getMinX() + "," + this.getMaxY() + " "),
			a = a + (this.getMinX() + "," + this.getMinY() + "\x3c/gml:coordinates\x3e\x3c/gml:LinearRing\x3e\x3c/gml:outerBoundaryIs\x3e");
			return a +=
			"\x3c/gml:Polygon\x3e"
		},
		toWKT: function () {
			return "Rectangle" != this.type ? null : "POLYGON (" + this.coordinates[0] + " " + this.coordinates[1] + ", " + this.coordinates[0] + " " + this.coordinates[3] + ", " + this.coordinates[2] + " " + this.coordinates[3] + ", " + this.coordinates[2] + " " + this.coordinates[1] + ", " + this.coordinates[0] + " " + this.coordinates[1] + ")"
		}
	});
	a.geometry.Point = a.geometry.Geometry.extend({
		initialize: function f(g, k, n, u, C) {
			f.base.call(this, n);
			n = a.util.ValidationUtil.isNumber;
			n(g) || a.util.Logger.throwErr("MAPVIEWER_9018",
				"geom.Point", "x:" + g);
			n(k) || a.util.Logger.throwErr("MAPVIEWER_9018", "geom.Point", "y:" + k);
			a.notNull(u) && a.notNull(C) ? (n(u) || a.util.Logger.throwErr("MAPVIEWER_9018", "geom.Point", "orientationX:" + u), n(C) || a.util.Logger.throwErr("MAPVIEWER_9018", "geom.Point", "orientationY:" + C), this.type = "OrientedPoint", this.coordinates = [Number(g), Number(k), Number(u), Number(C)]) : (this.type = "Point", this.coordinates = [Number(g), Number(k)])
		},
		setPointIndex: function (f) {
			a.notNull(f) && (this.wraparoundMapIndex = f)
		},
		equals: function (f) {
			if (a.isNull(f) ||
				f.type !== this.type || f.srid !== this.srid || f.dim !== this.dim || f.coordinates.length !== this.coordinates.length)
				return !1;
			for (var g = 0; g < this.coordinates.length; g++)
				if (this.coordinates[g] !== f.coordinates[g])
					return !1;
			return !0
		},
		getX: function () {
			return this.coordinates[0]
		},
		getY: function () {
			return this.coordinates[1]
		},
		getDimensionValue: function (a) {
			return 0 > a || a > this.dim - 1 ? c : this.coordinates[a]
		},
		getOrientationX: function () {
			return "OrientedPoint" === this.type ? this.coordinates[this.dim] : c
		},
		getOrientationY: function () {
			return "OrientedPoint" ===
			this.type ? this.coordinates[this.dim + 1] : c
		},
		getOrientationValue: function (a) {
			return 0 > a || a > this.dim - 1 || "OrientedPoint" !== this.type ? c : this.coordinates[this.dim + a]
		},
		isOriented: function () {
			return this.coordinates.length > this.dim ? !0 : !1
		},
		getLength: function () {
			return 0
		},
		getArea: function () {
			return 0
		},
		setPoint: function (f, g) {
			var k = a.util.ValidationUtil.isNumber;
			k(f) || a.util.Logger.throwErr("MAPVIEWER_9018", "geom.Point", "x:" + f);
			k(g) || a.util.Logger.throwErr("MAPVIEWER_9018", "geom.Point", "y:" + g);
			this.coordinates[0] =
				Number(f);
			this.coordinates[1] = Number(g)
		},
		setDimensionValue: function (a, g) {
			0 > a || a > this.dim - 1 || (this.coordinates[a] = g)
		},
		setOrientationValue: function (a, g) {
			0 > a || a > this.dim - 1 || "OrientedPoint" !== this.type || (this.coordinates[this.dim + a] = g)
		},
		move: function g(a, n) {
			this.x += a;
			this.y += n;
			g.base.call(this, a, n)
		},
		toGML: function () {
			var g = a.util.GeomUtil.getOGCOrdinateString(this.coordinates, this.dim),
			k = '\x3cgml:Point srsName\x3d"SDO:' + this.srid + '" xmlns:gml\x3d"http://www.opengis.net/gml"\x3e\x3cgml:coordinates decimal\x3d"." cs\x3d"," ts\x3d" "\x3e';
			return k + g + "\x3c/gml:coordinates\x3e\x3c/gml:Point\x3e"
		},
		toWKT: function () {
			if ("Point" !== this.type && "OrientedPoint" !== this.type)
				return null;
			var g,
			k = this.dim;
			g = "Point" === this.type ? a.util.GeomUtil.getWktCoordinateStringFromPoint(this.coordinates, k) : a.util.GeomUtil.getWktCoordinateStringFromOrientedPoint(this.coordinates, k);
			var n = "POINT";
			if (2 == k)
				n += " (";
			else if (3 == k)
				n += " Z (";
			else
				return null;
			return n + (g + ")")
		},
		getOrientationPoint: function (g, k, n) {
			if (a.isNull(n))
				if (this.isOriented())
					n = Math.atan2(this.coordinates[this.dim +
								1], this.coordinates[this.dim]);
				else
					return null;
			return new a.geometry.Point(this.coordinates[0] + g * Math.cos(n) * k.resolution, this.coordinates[1] + g * Math.sin(n) * k.resolution * k.stretchRatio, this.srid)
		},
		addDimension: function (g, k) {
			"OrientedPoint" === this.type ? (a.isNull(k) ? this.coordinates.push(0) : this.coordinates.push(k), this.coordinates.splice(this.dim, 0, g)) : this.coordinates.push(g);
			this.dim++
		},
		removeDimension: function (a) {
			2 > a || a > this.dim - 1 || ("OrientedPoint" === this.type && this.coordinates.splice(this.dim +
					a, 1), this.coordinates.splice(this.dim - 1, 1), this.dim--)
		}
	});
	a.geometry.LineString = a.geometry.Geometry.extend({
		initialize: function k(n, u, C) {
			k.base.call(this, u);
			!a.isNull(n) && a.util.ValidationUtil.isNumberArray(n) || a.util.Logger.throwErr("MAPVIEWER_9018", "geom.LineString", "ordinates:" + n);
			4 > n.length && a.util.Logger.throwErr("MAPVIEWER_9011", "geom.LineString", "ordinates:" + n);
			this.dim = C || 2;
			this.type = "LineString";
			this.coordinates = n
		},
		toGML: function () {
			var k = a.util.GeomUtil.getOGCOrdinateString(this.coordinates,
					this.dim),
			n = '\x3cgml:LineString srsName\x3d"SDO:' + this.srid + '" xmlns:gml\x3d"http://www.opengis.net/gml"\x3e\x3cgml:coordinates decimal\x3d"." cs\x3d"," ts\x3d" "\x3e';
			return n + k + "\x3c/gml:coordinates\x3e\x3c/gml:LineString\x3e"
		},
		toWKT: function () {
			if ("LineString" != this.type)
				return null;
			var k = "LINESTRING",
			n = this.dim;
			if (2 == n)
				k += " (";
			else if (3 == n)
				k += " Z (";
			else
				return null;
			n = a.util.GeomUtil.getWktCoordinateStringFromLine(this.coordinates, n);
			k += n;
			k = k.substring(0, k.length - 1);
			return k + ")"
		},
		getFirstPoint: function () {
			var k =
				this.coordinates;
			return 2 > k.length ? null : new a.geometry.Point(k[0], k[1], this.srid)
		},
		getLastPoint: function () {
			var k = this.coordinates;
			if (2 > k.length)
				return null;
			var n = k.length;
			return new a.geometry.Point(k[n - 2], k[n - 1], this.srid)
		}
	});
	a.geometry.LineString.create = function (k) {
		(a.isNull(k) || 2 > k.length) && a.util.Logger.throwErr("MAPVIEWER_9018", "geom.LineString.create", "pointArray:" + k);
		var n = a.util.GeomUtil.flatten(k, "Point");
		n || a.util.Logger.throwErr("MAPVIEWER_9018", "geom.LineString.create", "pointArray:" + k);
		return new a.geometry.LineString(n.ordinates, n.srid)
	};
	a.geometry.Polygon = a.geometry.Geometry.extend({
		initialize: function n(u, C, L) {
			n.base.call(this, C);
			C = a.util.ValidationUtil;
			(a.isNull(u) || 0 === u.length) && a.util.Logger.throwErr("MAPVIEWER_9018", "geom.Polygon", "ordinates:" + u);
			C.isNumberArray(u) && (u = [u]);
			C.isNumberArray(u[0]) || a.util.Logger.throwErr("MAPVIEWER_9018", "geom.Polygon", "ordinates:" + u);
			a.notNull(L) && (this.dim = L);
			this.type = "Polygon";
			this.coordinates = u
		},
		toGML: function () {
			var n = a.util.GeomUtil.getOGCOrdinateString(this.coordinates[0],
					this.dim),
			u = '\x3cgml:Polygon srsName\x3d"SDO:' + this.srid + '" xmlns:gml\x3d"http://www.opengis.net/gml"\x3e',
			u = u + '\x3cgml:outerBoundaryIs\x3e\x3cgml:LinearRing\x3e\x3cgml:coordinates decimal\x3d"." cs\x3d"," ts\x3d" "\x3e' + (n + "\x3c/gml:coordinates\x3e\x3c/gml:LinearRing\x3e\x3c/gml:outerBoundaryIs\x3e");
			if (1 < this.coordinates.length)
				for (n = 1; n < this.coordinates.length; n++)
					var C = a.util.GeomUtil.getOGCOrdinateString(this.coordinates[n], this.dim), u = u + '\x3cgml:innerBoundaryIs\x3e\x3cgml:LinearRing\x3e\x3cgml:coordinates decimal\x3d"." cs\x3d"," ts\x3d" "\x3e',
					u = u + (C + "\x3c/gml:coordinates\x3e\x3c/gml:LinearRing\x3e\x3c/gml:innerBoundaryIs\x3e");
			return u += "\x3c/gml:Polygon\x3e"
		},
		toWKT: function () {
			if ("Polygon" !== this.type)
				return null;
			var n = this.coordinates.length,
			u = "POLYGON",
			C = this.dim;
			if (2 == C)
				u += " (";
			else if (3 == C)
				u += " Z (";
			else
				return null;
			for (var L = 0; L < n; L++)
				var P = a.util.GeomUtil.getWktCoordinateStringFromLine(this.coordinates[L], C), u = u + ("(" + P), u = u.substring(0, u.length - 1), u = u + "), ";
			u = u.substring(0, u.length - 2);
			return u + ")"
		}
	});
	a.geometry.Polygon.createCirclePolygon =
	function (n, u, C, L) {
		L || (L = 8307);
		for (var P = [], X = 2 * Math.PI / 480, V = 0; 480 > V; V++) {
			var ca = V * X;
			P[2 * V] = n + C * Math.cos(ca);
			P[2 * V + 1] = u + C * Math.sin(ca)
		}
		P[960] = P[0];
		P[961] = P[1];
		return new a.geometry.Polygon(P, L)
	};
	a.geometry.Polygon.createGeodeticCirclePolygon = function (n, u, C, L) {
		L || (L = 8307);
		for (var P = [], X = 0; 36 > X; X++) {
			var V = a.util.GeomUtil.getPointAtBearing(n, u, C, X * Math.PI / 18);
			P[2 * X] = V.x;
			P[2 * X + 1] = V.y
		}
		P[72] = P[0];
		P[73] = P[1];
		return new a.geometry.Polygon(P, L)
	};
	a.geometry.Polygon.create = function (n, u) {
		(a.isNull(n) || 3 > n.length) &&
		a.util.Logger.throwErr("MAPVIEWER_9018", "geom.Polygon.create", "pointArray:" + n);
		var C = a.util.GeomUtil.flatten(n, "Point");
		C || a.util.Logger.throwErr("MAPVIEWER_9018", "geom.Polygon.create", "pointArray:" + n);
		if (u && 2 < u.length) {
			var L = a.util.GeomUtil.flatten(u, "Point");
			L ? C.srid !== L.srid && a.util.Logger.throwErr("MAPVIEWER_9033", "geom.Polygon.create", "") : a.util.Logger.throwErr("MAPVIEWER_9018", "geom.Polygon.create", "outerPointArray:" + u);
			return new a.geometry.Polygon([C.ordinates, L.ordinates], C.srid)
		}
		return new a.geometry.Polygon([C.ordinates],
			C.srid)
	};
	a.geometry.Circle = a.geometry.Geometry.extend({
		initialize: function u(C, L, P, X) {
			u.base.call(this, X);
			X = a.util.ValidationUtil.isNumber;
			X(C) || a.util.Logger.throwErr("MAPVIEWER_9018", "geom.Circle", "centerX:" + C);
			X(L) || a.util.Logger.throwErr("MAPVIEWER_9018", "geom.Circle", "centerY:" + L);
			X(P) || a.util.Logger.throwErr("MAPVIEWER_9018", "geom.Circle", "radius:" + P);
			this.centerX = Number(C);
			this.centerY = Number(L);
			this.radius = Number(P);
			this.toCirclePolygon();
			this.type = "Polygon"
		},
		getRadius: function () {
			return this.radius
		},
		getCenterX: function () {
			return this.centerX
		},
		getLength: function () {
			return 6.283185307179586 * this.radius
		},
		getArea: function () {
			return 3.141592653589793 * this.radius * this.radius
		},
		getCenterY: function () {
			return this.centerY
		},
		setCircle: function (u, C, L) {
			var P = a.util.ValidationUtil.isNumber;
			P(u) || a.util.Logger.throwErr("MAPVIEWER_9018", "geom.Circle.setCircle", "centerX:" + u);
			P(C) || a.util.Logger.throwErr("MAPVIEWER_9018", "geom.Circle.setCircle", "centerY:" + C);
			P(L) || a.util.Logger.throwErr("MAPVIEWER_9018", "geom.Circle.setCircle",
				"radius:" + L);
			this.centerX = Number(u);
			this.centerY = Number(C);
			this.radius = Number(L);
			this.toCirclePolygon()
		},
		toCirclePolygon: function () {
			this.circlePolygon || (this.circlePolygon = a.geometry.Polygon.createCirclePolygon(this.centerX, this.centerY, this.radius, this.srid), this.coordinates = this.circlePolygon.coordinates)
		},
		move: function C(a, P) {
			this.centerX += a;
			this.centerY += P;
			C.base.call(this, a, P)
		},
		toGML: function () {
			return this.circlePolygon.toGML()
		},
		toWKT: function () {
			return this.circlePolygon.toWKT()
		}
	});
	a.geometry.MultiPoint =
		a.geometry.Geometry.extend({
			initialize: function L(P, X, V) {
				L.base.call(this, X);
				X = a.util.ValidationUtil;
				(a.isNull(P) || 1 > P.length) && a.util.Logger.throwErr("MAPVIEWER_9018", "geom.MultiPoint", "ordinates:" + P);
				X.isNumberArray(P[0]) || a.util.Logger.throwErr("MAPVIEWER_9018", "geom.MultiPoint", "ordinates:" + P);
				a.notNull(V) && (this.dim = V);
				V = P.length;
				X = !0;
				for (var ca = 0; ca < V; ca++)
					P[ca].length < 2 * this.dim && (X = !1);
				this.type = X ? "OrientedMultiPoint" : "MultiPoint";
				this.coordinates = P
			},
			getLength: function () {
				return 0
			},
			getArea: function () {
				return 0
			},
			toGML: function () {
				for (var L = this.coordinates.length, P = '\x3cgml:MultiPoint srsName\x3d"SDO:' + this.srid + '" xmlns:gml\x3d"http://www.opengis.net/gml"\x3e', X = 0; X < L; X++)
					var V = a.util.GeomUtil.getOGCOrdinateString(this.coordinates[X], this.dim), P = P + "\x3cgml:pointMember\x3e", P = P + ('\x3cgml:Point srsName\x3d"SDO:' + this.srid + '" xmlns:gml\x3d"http://www.opengis.net/gml"\x3e\x3cgml:coordinates decimal\x3d"." cs\x3d"," ts\x3d" "\x3e'), P = P + (V + "\x3c/gml:coordinates\x3e\x3c/gml:Point\x3e"), P = P + "\x3c/gml:pointMember\x3e";
				return P + "\x3c/gml:MultiPoint\x3e"
			},
			toWKT: function () {
				if ("MultiPoint" != this.type)
					return null;
				var L = this.coordinates.length,
				P = "MULTIPOINT",
				X = this.dim;
				if (2 == X)
					P += " (";
				else if (3 == X)
					P += " Z (";
				else
					return null;
				for (var V = 0; V < L; V++)
					var ca = a.util.GeomUtil.getWktCoordinateStringFromPoint(this.coordinates[V], X), P = P + (ca + ", ");
				P = P.substring(0, P.length - 2);
				return P + ")"
			}
		});
	a.geometry.MultiPoint.create = function (L) {
		(a.isNull(L) || 2 > L.length) && a.util.Logger.throwErr("MAPVIEWER_9018", "geom.MultiPoint.create", "pointArray:" +
			L);
		var P = a.util.GeomUtil.flatten(L, "Point", !0);
		P || a.util.Logger.throwErr("MAPVIEWER_9018", "geom.MultiPoint.create", "pointArray:" + L);
		return new a.geometry.MultiPoint(P.ordinates, P.srid)
	};
	a.geometry.MultiLineString = a.geometry.Geometry.extend({
		initialize: function P(X, V, ca) {
			P.base.call(this, V);
			V = a.util.ValidationUtil;
			var b = a.isNull(X) ? 0 : X.length;
			1 > b && a.util.Logger.throwErr("MAPVIEWER_9018", "geom.MultiLineString", "ordinates:" + X);
			for (var va = 0; va < b; va++)
				!a.isNull(X[va]) && V.isNumberArray(X[va]) || a.util.Logger.throwErr("MAPVIEWER_9018",
					"geom.MultiLineString", "ordinates:" + X);
			a.notNull(ca) && (this.dim = ca);
			this.type = "MultiLineString";
			this.coordinates = X
		},
		toGML: function () {
			for (var P = this.coordinates.length, X = '\x3cgml:MultiLineString srsName\x3d"SDO:' + this.srid + '" xmlns:gml\x3d"http://www.opengis.net/gml"\x3e', V = 0; V < P; V++)
				var X = X + "\x3cgml:lineStringMember\x3e", ca = a.util.GeomUtil.getOGCOrdinateString(this.coordinates[V], this.dim), X = X + ('\x3cgml:LineString srsName\x3d"SDO:' + this.srid + '" xmlns:gml\x3d"http://www.opengis.net/gml"\x3e\x3cgml:coordinates decimal\x3d"." cs\x3d"," ts\x3d" "\x3e'),
				X = X + (ca + "\x3c/gml:coordinates\x3e\x3c/gml:LineString\x3e"), X = X + "\x3c/gml:lineStringMember\x3e";
			return X + "\x3c/gml:MultiLineString\x3e"
		},
		toWKT: function () {
			if ("MultiLineString" !== this.type)
				return null;
			var P = this.coordinates.length,
			X = "MULTILINESTRING",
			V = this.dim;
			if (2 == V)
				X += " (";
			else if (3 == V)
				X += " Z (";
			else
				return null;
			for (var ca = 0; ca < P; ca++)
				var b = a.util.GeomUtil.getWktCoordinateStringFromLine(this.coordinates[ca], V), X = X + ("(" + b), X = X.substring(0, X.length - 1), X = X + "), ";
			X = X.substring(0, X.length - 2);
			return X +
			")"
		}
	});
	a.geometry.MultiLineString.create = function (P) {
		(a.isNull(P) || 2 > P.length) && a.util.Logger.throwErr("MAPVIEWER_9018", "geom.MultiLineString.create", "lineArray:" + P);
		var X = a.util.GeomUtil.flatten(P, "LineString", !0);
		X || a.util.Logger.throwErr("MAPVIEWER_9018", "geom.MultiLineString.create", "lineArray:" + P);
		return new a.geometry.MultiLineString(X.ordinates, X.srid)
	};
	a.geometry.MultiPolygon = a.geometry.Geometry.extend({
		initialize: function X(V, ca, b) {
			X.base.call(this, ca);
			ca = a.util.ValidationUtil;
			var va = a.isNull(V) ?
				0 : V.length;
			1 > va && a.util.Logger.throwErr("MAPVIEWER_9018", "geom.MultiPolygon", "ordinates:" + V);
			for (var ab = 0; ab < va; ab++)
				(a.isNull(V[ab]) || 0 === V[ab].length) && a.util.Logger.throwErr("MAPVIEWER_9018", "geom.MultiPolygon", "ordinates:" + V), ca.isNumberArray(V[ab]) && (V[ab] = [V[ab]]), ca.isNumberArray(V[ab][0]) || a.util.Logger.throwErr("MAPVIEWER_9018", "geom.MultiPolygon", "ordinates:" + V);
			a.notNull(b) && (this.dim = b);
			this.type = "MultiPolygon";
			this.coordinates = V
		},
		_getMeasure: function (X) {
			var V = this.coordinates,
			ca = V.length,
			b = null,
			va = 0;
			"area" === X ? b = a.util.GeomUtil.polygonArea : "length" === X && (b = a.util.GeomUtil.polylineLength);
			for (var ab = 0; ab < ca; ab++)
				if (X = V[ab], a.$.isArray(X[0]))
					for (var c = 0; c < X.length; c++)
						va += b(X[c], this.dim);
				else
					va += b(X, this.dim);
			return va
		},
		toGML: function () {
			for (var X = this.coordinates.length, V = '\x3cgml:MultiPolygon srsName\x3d"SDO:' + this.srid + '" xmlns:gml\x3d"http://www.opengis.net/gml"\x3e', ca = 0; ca < X; ca++) {
				var V = V + "\x3cgml:polygonMember\x3e",
				b = a.util.GeomUtil.getOGCOrdinateString(this.coordinates[ca][0],
						this.dim),
				V = V + ('\x3cgml:Polygon srsName\x3d"SDO:' + this.srid + '" xmlns:gml\x3d"http://www.opengis.net/gml"\x3e'),
				V = V + '\x3cgml:outerBoundaryIs\x3e\x3cgml:LinearRing\x3e\x3cgml:coordinates decimal\x3d"." cs\x3d"," ts\x3d" "\x3e',
				V = V + (b + "\x3c/gml:coordinates\x3e\x3c/gml:LinearRing\x3e\x3c/gml:outerBoundaryIs\x3e");
				if (1 < this.coordinates[ca].length)
					for (b = 1; b < this.coordinates[ca].length; b++)
						var va = a.util.GeomUtil.getOGCOrdinateString(this.coordinates[ca][b], this.dim), V = V + '\x3cgml:innerBoundaryIs\x3e\x3cgml:LinearRing\x3e\x3cgml:coordinates decimal\x3d"." cs\x3d"," ts\x3d" "\x3e',
						V = V + (va + "\x3c/gml:coordinates\x3e\x3c/gml:LinearRing\x3e\x3c/gml:innerBoundaryIs\x3e");
				V += "\x3c/gml:Polygon\x3e";
				V += "\x3c/gml:polygonMember\x3e"
			}
			return V + "\x3c/gml:MultiPolygon\x3e"
		},
		toWKT: function () {
			if ("MultiPolygon" !== this.type)
				return null;
			var X = this.coordinates.length,
			V = "MULTIPOLYGON",
			ca = this.dim;
			if (2 == ca)
				V += " (";
			else if (3 == ca)
				V += " Z (";
			else
				return null;
			for (var b = 0; b < X; b++) {
				for (var va = this.coordinates[b].length, ab = this.coordinates[b], V = V + "(", c = 0; c < va; c++)
					var h = a.util.GeomUtil.getWktCoordinateStringFromLine(ab[c],
							ca), V = V + ("(" + h), V = V.substring(0, V.length - 1), V = V + "), ";
				V = V.substring(0, V.length - 2);
				V += "), "
			}
			V = V.substring(0, V.length - 2);
			return V + ")"
		}
	});
	a.geometry.MultiPolygon.create = function (X) {
		(a.isNull(X) || 2 > X.length) && a.util.Logger.throwErr("MAPVIEWER_9018", "geom.MultiPolygon.create", "polygonArray:" + X);
		var V = a.util.GeomUtil.flatten(X, "Polygon", !0);
		V || a.util.Logger.throwErr("MAPVIEWER_9018", "geom.MultiPolygon.create", "polygonArray:" + X);
		return new a.geometry.MultiPolygon(V.ordinates, V.srid)
	};
	a.geometry.GeometryCollection =
		a.geometry.Geometry.extend({
			initialize: function V(ca, b) {
				V.base.call(this, b);
				for (var va = ca.length, c = 0; c < va; c++)
					ca[c]instanceof a.geometry.Geometry ? a.isNull(b) ? ca[c].srid = b : ca[c].srid !== b && (ca[c] = ca[c].transform(b)) : a.util.Logger.throwErr("MAPVIEWER_9018", "geom.GeometryCollection", "geometryArray:" + ca);
				this.geometries = ca;
				this.type = "GeometryCollection"
			},
			getMBR: function () {
				if (!this.mbr) {
					var V = a.geometry.Geometry.calculateGeomCollectionMBR(this.geometries, this.type);
					this.mbr = new a.geometry.Rectangle(V.minX,
							V.minY, V.maxX, V.maxY, this.srid)
				}
				return this.mbr
			},
			toString: function () {
				var a;
				a = "{" + ('"type":"' + this.type + '",');
				a += '"srid":' + this.srid + ",";
				a += '"geometries":[';
				for (var ca = this.geometries.length, b = 0; b < ca; b++)
					a += this.geometries[b].toString() + ",";
				ca = a.length;
				a = a.substring(0, ca - 1);
				return a + "]}"
			},
			clientTransform: function (V) {
				for (var ca = this.geometries.length, b = Array(ca), va = 0; va < ca; va++)
					b[va] = this.geometries[va].transform(V);
				return new a.geometry.GeometryCollection(b, V)
			},
			move: function (a, ca) {
				for (var b = this.geometries.length,
					va = 0; va < b; va++)
					this.geometries[va].move(a, ca);
				this.mbr && this.mbr.move(a, ca)
			},
			toGML: function () {
				for (var a = this.geometries.length, ca = '\x3cgml:MultiGeometry srsName\x3d"SDO:' + this.srid + '" xmlns:gml\x3d"http://www.opengis.net/gml"\x3e', b = 0; b < a; b++)
					ca += "\x3cgml:geometryMember\x3e", ca += this.geometries[b].toGML(), ca += "\x3c/gml:geometryMember\x3e";
				return ca + "\x3c/gml:MultiGeometry\x3e"
			},
			toWKT: function () {
				if ("GeometryCollection" != this.type)
					return null;
				for (var a = this.geometries.length, ca = "GEOMETRYCOLLECTION (",
					b = 0; b < a; b++)
					ca += this.geometries[b].toWKT(), ca += ", ";
				ca = ca.substring(0, ca.length - 2);
				return ca + ")"
			}
		});
	a.event.EventSource = {
		addListener: function (a, ca, b) {
			var va = this._omListeners = this._omListeners || {};
			va[a] = va[a] || [];
			va[a].push({
				listener: ca,
				context: b || this
			});
			return this
		},
		hasListener: function (V, ca, b) {
			if (a.isNull(ca))
				return "_omListeners" in this && V in this._omListeners && 0 < this._omListeners[V].length;
			if ("_omListeners" in this && V in this._omListeners && 0 < this._omListeners[V].length) {
				b = b || this;
				for (var va = 0, c =
						this._omListeners, h = c[V].length; va < h; va++)
					if (c[V][va].listener === ca && (!b || c[V][va].context === b))
						return !0
			}
			return !1
		},
		getListeners: function (a) {
			return this.hasListener(a) ? this._omListeners[a] : []
		},
		deleteListener: function (a, ca, b) {
			if (!this.hasListener(a, ca, b))
				return this;
			for (var va = 0, c = this._omListeners, h = c[a].length; va < h; va++)
				if (c[a][va].listener === ca && (!b || c[a][va].context === b)) {
					c[a].splice(va, 1);
					break
				}
			return this
		},
		deleteListeners: function (a) {
			if (!this.hasListener(a))
				return this;
			this._omListeners[a] = [];
			return this
		},
		deleteAllListeners: function () {
			this._omListeners = {};
			return this
		},
		fire: function (V) {
			if (!this.hasListener(V))
				return this;
			var ca = this._omListeners[V].slice(),
			b = [].slice.apply(arguments),
			va,
			c;
			2 <= b.length && b.splice(0, 1);
			for (var h = 0, Ob = ca.length; h < Ob; h++)
				if (va = ca[h].listener) {
					c = ca[h].context || this;
					try {
						0 < b.length ? va.apply(c, b) : va.call(c)
					} catch (pb) {
						va = pb.message,
						pb.stack && (va += "\nStack: " + pb.stack),
						a.util.Logger.warning("MAPVIEWER_9032", "EventSource.fire", va)
					}
				}
			return this
		},
		stopEvents: {},
		initProcessedEventStatus: function () {
			this.processedStatus = {}
		},
		setProcessedEventStatus: function (V, ca, b) {
			ca === a.event.MouseEvent.TOUCH_TAP && (ca = a.event.MouseEvent.MOUSE_CLICK);
			ca === a.event.MouseEvent.MOUSE_CLICK && (this.processedStatus[V.name] = this.processedStatus[V.name] || {}, this.processedStatus[V.name][ca] = b)
		},
		getProcessedEventStatus: function (V, ca) {
			if (ca !== a.event.MouseEvent.MOUSE_CLICK || a.isNull(this.processedStatus[V]))
				return !1;
			for (var b = this.processedStatus[V], va = 0; va < b.length; va += 1) {
				var c = b[va];
				if (a.notNull(c) && c.etype === ca)
					return c.etype
			}
			return !1
		},
		resetProcessedEvent: function (a,
			ca) {
			this.setProcessedEventStatus(a, ca, !1)
		},
		isProcessedEvent: function (V, ca) {
			return a.isNull(this.processedStatus[V.name]) ? !1 : this.processedStatus[V.name][ca]
		}
	};
	a.event.EventSource.on = a.event.EventSource.addListener;
	a.event.Event = a.Class.extend({
		initialize: function (V, ca) {
			if (a.isNull(V) || a.isNull(ca))
				return null;
			this.type = V;
			this.target = ca;
			this.evt = null
		}
	});
	a.event.MapEvent = a.event.Event.extend({
		initialize: function ca(a, b) {
			ca.base.call(this, a, b);
			this.preMapCenter = this.affectedLayer = this.beforeZoomLevel =
				null
		}
	});
	a.event.MapEvent.I_MAP_CENTER_ZOOM = "i_mapCenterZoom";
	a.event.MapEvent.I_MAP_DRAGGING = "i_mapDragging";
	a.event.MapEvent.MAP_BEFORE_ZOOM = "mapBeforeZoom";
	a.event.MapEvent.MAP_AFTER_ZOOM = "mapAfterZoom";
	a.event.MapEvent.MAP_RECENTERED = "mapRecentered";
	a.event.MapEvent.MAP_INITIALIZED = "mapInitialized";
	a.event.MapEvent.MAP_RESET_UNIVERSE = "mapResetUniverse";
	a.event.MapEvent.MAP_RESIZED = "mapResized";
	a.event.MapEvent.MAP_BEFORE_REFRESH = "mapBeforeRefresh";
	a.event.MapEvent.MAP_AFTER_REFRESH = "mapAfterRefresh";
	a.event.MapEvent.MAP_REDRAW = "mapRedraw";
	a.event.MapEvent.LAYER_ADDED = "layerAdded";
	a.event.MapEvent.LAYER_DELETED = "layerDeleted";
	a.event.MapEvent.LAYER_REORDERED = "layerReordered";
	a.event.MapEvent.MAP_DESTROY = "mapDestroy";
	a.event.MapEvent.MAP_RESTRICT_CENTER = "mapRestrictCenter";
	a.event.MapEvent.MAP_STYLE_CHANGED = "mapStyleChanged";
	a.event.MapEvent.MAP_CLEAN = "mapClean";
	a.event.MapEvent.I_MAP_NSDP_MAPPED = "mapNSDPMapped";
	a.event.KeyboardEvent = a.event.Event.extend({
		initialize: function Wa(a, b) {
			Wa.base.call(this,
				a, b);
			this.event = null
		}
	});
	a.event.KeyboardEvent.KEY_DOWN = "keyDown";
	a.event.KeyboardEvent.KEY_UP = "keyUp";
	a.event.LayerEvent = a.event.Event.extend({
		initialize: function va(a, b) {
			va.base.call(this, a, b);
			this.affectedFeature = null
		}
	});
	a.event.LayerEvent.BEFORE_REFRESH = "beforeFresh";
	a.event.LayerEvent.AFTER_REFRESH = "afterFresh";
	a.event.LayerEvent.FEATURE_SELECTED = "featureSelected";
	a.event.LayerEvent.FEATURE_DESELECTED = "featureDeselected";
	a.event.LayerEvent.RENDERING_STYLE_CHANGED = "renderingStyleChanged";
	a.event.LayerEvent.LABELING_STYLE_CHANGED =
		"labelingStyleChanged";
	a.event.LayerEvent.SELECTION_STYLE_CHANGED = "selectionStyleChanged";
	a.event.LayerEvent.HOVER_STYLE_CHANGED = "hoverStyleChanged";
	a.event.LayerEvent.RESULT_STYLE_CHANGED = "resultStyleChanged";
	a.event.LayerEvent.LABEL_VISIBILITY_CHANGED = "labelVisibilityChanged";
	a.event.LayerEvent.LAYER_VISIBILITY_CHANGED = "layerVisibilityChanged";
	a.event.LayerEvent.LAYER_REMOVED = "layerRemoved";
	a.event.LayerEvent.LAYER_INITIALIZED = "layerInitialized";
	a.event.LayerEvent.FEATURE_MOVING = "featureMoving";
	a.event.LayerEvent.FEATURE_MOVED = "featureMoved";
	a.event.LayerEvent.FEATURE_EDITED = "featureEdited";
	a.event.LayerEvent.FEATURE_ORIENTATION_CHANGING = "featureOrientationChanging";
	a.event.LayerEvent.LAYER_Z_INDEX_CHANGED = "layerZIndexChanged";
	a.event.LayerEvent.LAYER_INIT = "layerInit";
	a.event.LayerEvent.FINISH_GOT_CONFIG = "layerFinishGotConfig";
	a.event.LayerEvent.FINISH_LOAD = "layerFinishLoad";
	a.event.LayerEvent.TILE_IMG_LOADED = "tileImgLoaded";
	a.event.LayerEvent.ALL_TILES_LOADED = "allTilesImgLoaded";
	a.event.LayerEvent.TILE_IMG_LOAD_ERROR =
		"tileImgLoadError";
	a.event.LayerEvent.TILE_IMG_LOADING = "tileImgLoading";
	a.event.LayerEvent.VECTOR_LAYER_LOADING_THEME = "GETTING_THEME_DATA";
	a.event.LayerEvent.VECTOR_LAYER_PARSING_THEME = "PARSING_THEME_DATA";
	a.event.LayerEvent.FEATURES_LOADED = "featuresLoad";
	a.event.LayerEvent.FEATURES_DISPLAYED = "featuresDisplay";
	a.event.LayerEvent.INIT_ERROR = "initError";
	a.event.LayerEvent.NSDP_MAPPED = "nsdpMapped";
	a.event.MapDecorationEvent = a.event.Event.extend({
		initialize: function ab(a, b) {
			ab.base.call(this, a, b)
		}
	});
	a.event.MapDecorationEvent.BEFORE_COLLAPSE = "beforeCollapse";
	a.event.MapDecorationEvent.AFTER_COLLAPSE = "afterCollapse";
	a.event.MapDecorationEvent.BEFORE_RESTORE = "beforeRestore";
	a.event.MapDecorationEvent.AFTER_RESTORE = "afterRestore";
	a.event.MapDecorationEvent.DRAG_START = "dragStart";
	a.event.MapDecorationEvent.DRAG = "drag";
	a.event.MapDecorationEvent.DRAG_END = "dragEnd";
	a.event.MapDecorationEvent.DISPLAYED = "displayed";
	a.event.MouseEvent = a.event.Event.extend({
		initialize: function Hb(a, b) {
			Hb.base.call(this,
				a, b);
			this.feature = this.location = null
		}
	});
	a.event.MouseEvent.MOUSE_DOWN = "mouseDown";
	a.event.MouseEvent.MOUSE_UP = "mouseUp";
	a.event.MouseEvent.MOUSE_MOVE = "mouseMove";
	a.event.MouseEvent.MOUSE_OVER = "mouseOver";
	a.event.MouseEvent.MOUSE_OUT = "mouseOut";
	a.event.MouseEvent.MOUSE_CLICK = "click";
	a.event.MouseEvent.MOUSE_RIGHT_CLICK = "rightClick";
	a.event.MouseEvent.MOUSE_DOUBLE_CLICK = "doubleClick";
	a.event.MouseEvent.WHEEL_SCROLL = "wheelScroll";
	a.event.MouseEvent.TOUCH_TAP = "tap";
	a.event.MouseEvent.TOUCH_LONG_PRESS =
		"touchlongpress";
	a.event.MouseEvent.TOUCH_END = "touchend";
	a.event.MouseEvent.TOUCH_START = "touchstart";
	a.event.MouseEvent.MOUSE_ENTER = "mouseEnter";
	a.event.MouseEvent.MOUSE_LEAVE = "mouseLeave";
	a.event.MouseEvent.DEBOUNCE_MILI_SEC = 300;
	a.event.MouseEvent.DELAY_MILI_SEC = 300;
	a.event.ToolEvent = a.event.Event.extend({
		initialize: function Ob(a, b) {
			Ob.base.call(this, a, b);
			this.location = null
		}
	});
	a.event.ToolEvent.TOOL_START = "toolStart";
	a.event.ToolEvent.TOOL_END = "toolEnd";
	a.event.ToolEvent.TOOL_CLEAR = "toolClear";
	a.event.ToolEvent.RECTANGLE_DRAG =
		"rectangleDrag";
	a.event.ToolEvent.CIRCLE_DRAG = "circleDrag";
	a.event.ToolEvent.REDLINE_POINT_CREATE = "redlinePointCreate";
	a.event.ToolEvent.REDLINE_POINT_REMOVE = "redlinePointRemove";
	a.event.ToolEvent.REDLINE_DRAW = "redlineDraw";
	a.event.ToolEvent.REDLINE_EDITED = "redlineEdited";
	a.event.ToolEvent.DISTANCE_UPDATE = "distanceUpdate";
	a.event.ToolEvent.SNAP_POINT = "snapPoint";
	a.event.ToolEvent.MOUSE_RIGHT_CLICK = "mouseRightClick";
	a.event.ToolbarEvent = a.event.Event.extend({
		initialize: function pb(a, b) {
			pb.base.call(this,
				a, b)
		}
	});
	a.event.ToolbarEvent.BUTTON_STATE_CHANGE = "buttonStateChange";
	a.event.ToolbarEvent.BUTTON_DOWN = "buttonDown";
	a.event.ToolbarEvent.BUTTON_UP = "buttonUp";
	a.universe.ZoomLevel = a.Class.extend({
		initialize: function (b, c) {
			!a.isNull(b) && a.util.ValidationUtil.isNumber(b) && (this.resolution = b, this.stretchRatio = 1, c && c.stretchRatio && (this.stretchRatio = c.stretchRatio), this.infotip = null, c && c.infotip && (this.infotip = c.infotip))
		}
	});
	a.universe.Universe = a.Class.extend({
		initialize: function (b) {
			if (a.isNull(b) || !a.util.ValidationUtil.isObject(b) ||
				a.isNull(b.srid) || !b.bounds)
				return null;
			this.srid = b.srid;
			this.bound = b.bounds;
			this.bound.srid !== this.srid && (this.bound = this.bound.transform(this.srid));
			this.geodetic = b.geodetic ? b.geodetic : this.srid && 8307 === this.srid;
			if (!b.zoomLevels && b.numberOfZoomLevels) {
				this.zoomLevels = [];
				var c = this.bound,
				h = Math.abs(c.getMaxX() - c.getMinX()) / 256,
				c = Math.abs(c.getMaxY() - c.getMinY()) / 256;
				c > h && (h = c);
				for (c = 0; c < b.numberOfZoomLevels; c++)
					this.zoomLevels[c] = new a.universe.ZoomLevel(h), h /= 2
			} else
				this.zoomLevels = b.zoomLevels;
			this.homeZoomlevel = this.homeCenter = null
		},
		getSRID: function () {
			return this.srid
		},
		getMapBounds: function () {
			return this.bound
		},
		getZoomLevelNumber: function () {
			return this.zoomLevels.length
		},
		getZoomLevels: function () {
			return this.zoomLevels
		},
		equals: function (a) {
			if (this.srid !== a.srid || this.zoomLevels && a.zoomLevels && this.zoomLevels.length !== a.zoomLevels.length)
				return !1;
			for (var b = this.zoomLevels.length, c = 0; c < b; c++) {
				var h = Math.abs(this.zoomLevels[c].stretchRatio - a.zoomLevels[c].stretchRatio);
				if (.001 < Math.abs(this.zoomLevels[c].resolution -
						a.zoomLevels[c].resolution) / this.zoomLevels[c].resolution || .001 < h)
					return !1
			}
			return !0
		},
		clone: function () {
			var b = {};
			a.$.extend(b, this);
			return b
		},
		copy: function (a) {
			this.homeCenter = a.homeCenter;
			this.homeZoomlevel = a.homeZoomlevel;
			return this
		}
	});
	a.universe.Universe.EPSG4326 = {
		SRID: 8307,
		unites: "degrees",
		metersPerUnit: 6378137 * Math.PI / 180,
		bounds: new a.geometry.Rectangle(-180, -90, 180, 90, 8307)
	};
	a.universe.Universe.EPSG3857 = {
		SRID: 3857,
		unites: "meters",
		metersPerUnit: 1,
		bounds: new a.geometry.Rectangle(-20037508, -20037508,
			20037508, 20037508, 3857)
	};
	a.universe.Universe.getMPU = function (b) {
		switch (b) {
		case 3857:
			return a.universe.Universe.EPSG3857.metersPerUnit;
		case 8307:
			return a.universe.Universe.EPSG4326.metersPerUnit;
		default:
			return a.util.Logger.warning("", "OM.universe.Universe.getMPU", "srid's MPU is not found, 1 is returned."),
			1
		}
	};
	a.universe.Universe.getSpecs = function (b) {
		switch (b) {
		case 3857:
			return a.universe.Universe.EPSG3857;
		case 8307:
			return a.universe.Universe.EPSG4326;
		case 2180:
			return a.universe.Universe.EPSG2180
		}
	};
	a.universe.WorldMercatorUniverse = a.universe.Universe.extend({
		initialize: function qb() {
			var b = a.universe.ZoomLevel,
			b = {
				srid: 3857,
				bounds: new a.geometry.Rectangle(-20037508, -20037508, 20037508, 20037508, 3857),
				zoomLevels: [new b(78271.515625), new b(39135.7578125), new b(19567.87890625), new b(9783.939453125), new b(4891.9697265625), new b(2445.98486328125), new b(1222.992431640625), new b(611.4962158203125), new b(305.74810791015625), new b(152.87405395507812), new b(76.43702697753906), new b(38.21851348876953), new b(19.109256744384766),
					new b(9.554628372192383), new b(4.777314186096191), new b(2.3886570930480957), new b(1.1943285465240479), new b(.5971642732620239), new b(.29858213663101196)]
			};
			qb.base.call(this, b)
		}
	});
	a.universe.ElocationUniverse = a.universe.Universe.extend({
		initialize: function ub() {
			var b = a.universe.ZoomLevel,
			b = {
				srid: 3857,
				bounds: new a.geometry.Rectangle(-20037508, -20037508, 20037508, 20037508, 3857),
				zoomLevels: [new b(78271.515625), new b(39135.7578125), new b(19567.87890625), new b(9783.939453125), new b(4891.9697265625), new b(2445.98486328125),
					new b(1222.992431640625), new b(611.4962158203125), new b(305.74810791015625), new b(152.87405395507812), new b(76.43702697753906), new b(38.21851348876953), new b(19.109256744384766), new b(9.554628372192383), new b(4.777314186096191), new b(2.3886570930480957), new b(1.1943285465240479), new b(.5971642732620239), new b(.29858213663101196)]
			};
			ub.base.call(this, b)
		}
	});
	a.universe.SElocationUniverse = a.universe.Universe.extend({
		initialize: function Bb() {
			var b = a.universe.ZoomLevel,
			b = {
				srid: 3857,
				bounds: new a.geometry.Rectangle(-20037508,
					-20037508, 20037508, 20037508, 3857),
				zoomLevels: [new b(52181.010416666664), new b(31308.60625), new b(17393.67013888889), new b(9208.413602941177), new b(4743.72821969697), new b(2371.864109848485), new b(1185.9320549242425), new b(592.9660274621212), new b(297.04560009487665), new b(148.52280004743832), new b(74.26140002371916), new b(37.12189500829974), new b(18.56314849401162), new b(9.28157424700581), new b(4.640511983458825), new b(2.3201184380187336), new b(1.1599302843826644), new b(.5799651421913322), new b(.2897185251365837)]
			};
			Bb.base.call(this, b)
		}
	});
	a.universe.LatLonUniverse = a.universe.Universe.extend({
		initialize: function Fb() {
			var b = a.universe.ZoomLevel,
			b = {
				srid: 8307,
				bounds: new a.geometry.Rectangle(-180, -90, 180, 90, 8307),
				zoomLevels: [new b(.703125), new b(.3515625), new b(.17578125), new b(22.5 / 256), new b(11.25 / 256), new b(5.625 / 256), new b(2.8125 / 256), new b(1.40625 / 256), new b(.703125 / 256), new b(.3515625 / 256), new b(.17578125 / 256), new b(.087890625 / 256), new b(.0439453125 / 256), new b(8.58306884765625E-5), new b(4.291534423828125E-5),
					new b(2.1457672119140625E-5), new b(1.0728836059570312E-5), new b(5.364418029785156E-6), new b(2.682209014892578E-6)]
			};
			Fb.base.call(this, b)
		}
	});
	a.universe.OSMUniverse = a.universe.Universe.extend({
		initialize: function Da() {
			var b = a.universe.ZoomLevel,
			b = {
				srid: 3857,
				bounds: new a.geometry.Rectangle(-20037508, -20037508, 20037508, 20037508, 3857),
				zoomLevels: [new b(156543.03125), new b(78271.515625), new b(39135.7578125), new b(19567.87890625), new b(9783.939453125), new b(4891.9697265625), new b(2445.98486328125), new b(1222.992431640625),
					new b(611.4962158203125), new b(305.74810791015625), new b(152.87405395507812), new b(76.43702697753906), new b(38.21851348876953), new b(19.109256744384766), new b(9.554628372192383), new b(4.777314186096191), new b(2.3886570930480957), new b(1.1943285465240479), new b(.5971642732620239), new b(.298582136631)]
			};
			Da.base.call(this, b)
		}
	});
	a.universe.TomTomUniverse = a.universe.Universe.extend({
		initialize: function Ea() {
			var b = a.universe.ZoomLevel,
			b = {
				srid: 3857,
				bounds: new a.geometry.Rectangle(-20037508, -20037508, 20037508,
					20037508, 3857),
				zoomLevels: [new b(19567.9), new b(9783.9), new b(4892), new b(2446), new b(1223), new b(611.5), new b(305.7), new b(152.9), new b(76.4), new b(38.2), new b(19.1), new b(9.6), new b(4.8), new b(2.4), new b(1.2), new b(.596875)]
			};
			Ea.base.call(this, b)
		}
	});
	a.universe.BaiduUniverse = a.universe.Universe.extend({
		initialize: function Fa() {
			var b = a.universe.ZoomLevel,
			b = {
				srid: a.util.BaiduUtil.SRID,
				bounds: new a.geometry.Rectangle(-2.003772637E7, -1.247410417E7, 2.003772637E7, 1.247410417E7, a.util.BaiduUtil.SRID),
				zoomLevels: [new b(262144),
					new b(131072), new b(65536), new b(32768), new b(16384), new b(8192), new b(4096), new b(2048), new b(1024), new b(512), new b(256), new b(128), new b(64), new b(32), new b(16), new b(8), new b(4), new b(2), new b(1)]
			};
			Fa.base.call(this, b)
		}
	});
	a.universe.LocationBoxUniverse = a.universe.Universe.extend({
		initialize: function Ga() {
			var b = a.universe.ZoomLevel,
			b = {
				srid: 3857,
				bounds: new a.geometry.Rectangle(-20037508, -20037508, 20037508, 20037508, 3857),
				zoomLevels: [new b(4891.9697265625), new b(2445.98486328125), new b(1222.992431640625),
					new b(611.4962158203125), new b(305.74810791015625), new b(152.87405395507812), new b(76.43702697753906), new b(38.21851348876953), new b(19.109256744384766), new b(9.554628372192383), new b(4.777314186096191), new b(2.3886570930480957), new b(1.1943285465240479), new b(.5971642732620239), new b(.29858213663101196)]
			};
			Ga.base.call(this, b)
		}
	});
	a.style.Style = a.Class.extend({
		initialize: function (b) {
			this.origConfig = a.isNull(b) ? null : a.$.extend(!0, {}, b);
			this.styleName = b && b.styleName ? b.styleName : this.generateName();
			this.styleType =
				b && b.styleType ? b.styleType : "Style";
			this.effects = b && b.effects ? b.effects : [];
			this.animation = b && b.animationStyle ? b.animationStyle : null;
			this.bindings = null;
			this.isServerSide = b && b.isServerSide ? b.isServerSide : !1
		},
		clone: function () {
			return a.$.extend(!0, {}, this)
		},
		generateName: function () {
			var a = 0;
			return function () {
				return "_om_style" + ++a
			}
		}
		(),
		getConfig: function () {
			return this.origConfig
		},
		getStyleName: function () {
			return this.styleName
		},
		draw: function (a, b, gb) {},
		getBindables: function () {
			return []
		},
		isBindable: function (a) {
			var b =
				this.getBindables();
			if (!a || !b || 0 === b.length)
				return !1;
			for (var gb = 0; gb < b.length; gb++)
				if (a.toUpperCase() === b[gb].toUpperCase())
					return !0;
			return !1
		},
		isBound: function (b) {
			var c = this.bindings;
			if (a.isNull(b) || a.isNull(c) || 0 === c.length || b && !this.isBindable(b))
				return !1;
			for (var gb = 0; gb < c.length; gb++)
				if (b.toUpperCase() === c[gb].attribute.toUpperCase())
					return !0;
			return !1
		},
		hasBinding: function () {
			return a.notNull(this.bindings) && 0 < this.bindings.length
		},
		isFeatureBound: function (b) {
			var c = this.bindings;
			if (a.isNull(c) || 0 ===
				c.length)
				return !1;
			for (var gb, Ja = !1, Na = c.length, Sa = 0; Sa < Na; Sa++)
				gb = this.resolveDataValue(c[Sa], b), a.notNull(gb) && (Ja = !0);
			return Ja
		},
		isServerSide: function () {
			return this.isServerSide
		},
		bindData: function (b, c, gb) {
			if (b && c && this.isBindable(b)) {
				a.isNull(this.bindings) && (this.bindings = []);
				var Ja = {};
				Ja.attribute = b.toUpperCase();
				Ja.column = "string" === typeof c ? c.toUpperCase() : c;
				a.notNull(gb) ? gb instanceof a.style.Formatter ? Ja.formatter = gb : (Ja.resolver = gb.resolver, Ja.attrList = gb.attrList, Ja.classification = gb.classification ?
							gb.classification : "equal") : a.util.Logger.throwErr("MAPVIEWER_9051", "style.bindData", "Must specify a Formatter.");
				this.bindings.push(Ja)
			} else
				a.util.Logger.warning(null, "Style.bindData", "Invalid binding attribute or column")
		},
		unbindData: function (a) {
			if (a && this.bindings && this.isBound(a))
				for (var b = this.bindings, c = 0; c < b.length; c++)
					a.toUpperCase() === b[c].attribute.toUpperCase() && (b.splice(c, 1), this.initialize(this.origConfig), this.bindings = b)
		},
		unbindAllData: function (a) {
			if (a && this.isBound(a))
				for (var b = this.bindings,
					c = 0; c < b.length; c++)
					if (a === b[c].attribute) {
						b.splice(c, 1);
						this.initialize(this.origConfig);
						this.bindings = b;
						break
					}
		},
		resolveDataValue: function (b, h) {
			if ("string" === typeof b.column) {
				var gb = b._colName = b.column,
				Ja = h.parentLayer;
				if (a.isNull(Ja))
					return c;
				b.column = new a.Column({
					data: Ja.getAllFeatures(),
					keyGetter: function () {
						return this.id
					},
					valueGetter: function () {
						var a = this.attributes && this.attributes[gb] ? this.attributes[gb] : null;
						return !isNaN(parseFloat(a)) && isFinite(a) ? parseFloat(a) : a
					}
				})
			}
			return b.column.getValueOfRow(h.id)
		},
		resolveBinding: function (b, c) {
			var gb,
			Ja = null,
			Na,
			Sa;
			gb = this.resolveDataValue(b, c);
			if (a.notNull(b.formatter))
				return Ja = b.formatter.resolve(gb, b.column, c);
			if (a.notNull(b.resolver))
				Ja = b.resolver(gb, b.column);
			else if (Na = b.column.getMin(), Sa = b.column.getMax(), b.attrList && 0 < b.attrList.length) {
				if (Na === Sa)
					return b.attrList[0];
				if ("logarithmic" === b.classification) {
					1 > Na && (Na = 1);
					var $a = Math.log(Na);
					Sa = (Math.log(Sa) - $a) / b.attrList.length;
					for (var ib = 0; ib < b.attrList.length; ib++) {
						var Za = Math.exp($a + Sa * (ib + 1));
						if (0 ===
							ib && gb <= Za || gb >= Na && gb <= Za) {
							Ja = b.attrList[ib];
							break
						}
						Na = Za
					}
				} else
					gb = parseInt((gb - Na) / ((Sa - Na) / b.attrList.length)), gb >= b.attrList.length && (gb = b.attrList.length - 1), Ja = b.attrList[gb]
			}
			return Ja
		}
	});
	a.style.Style.calculateStyleSize = function (b, c) {
		if (!(a.isNull(b) || a.notNull(b.realWidth) && a.notNull(b.realHeight))) {
			var gb = b.lengthUnit ? b.lengthUnit : "pixel",
			gb = gb.toLowerCase(),
			Ja = a.util.GeomUtil.getCurrentDistancePerPixel(c);
			if ("pixel" !== gb) {
				var Na = a.gv.getUnitFactor(gb);
				0 === Na ? gb = "pixel" : Ja /= Na
			}
			"pixel" === gb ?
			(b.realWidth = b.width, b.realHeight = b.height) : b.unitFontSize ? b.fontSize = parseFloat(b.unitFontSize / Ja) : b.unitFillWidth || b.unitCenterLineWidth || b.unitStrokeThickness ? (b.fillWidth = parseFloat(b.unitFillWidth / Ja), b.centerLineWidth = parseFloat(b.unitCenterLineWidth / Ja), b.strokeThickness = parseFloat(b.unitStrokeThickness / Ja), b.calculateRealSize()) : b.unitSpotlightRadius ? b.spotlightRadius = parseFloat(b.unitSpotlightRadius / Ja) : (Na = b.height, gb = parseFloat(b.width / Ja), Ja = parseFloat(Na / Ja), gb = gb < parseFloat(b.minlength) ?
						parseFloat(b.minlength) : gb, Ja = Ja < parseFloat(b.minlength) ? parseFloat(b.minlength) : Ja, b.realWidth = gb > parseFloat(b.maxlength) ? parseFloat(b.maxlength) : gb, b.realHeight = Ja > parseFloat(b.maxlength) ? parseFloat(b.maxlength) : Ja, !a.isNull(b.max_size_in_px) && 0 < b.max_size_in_px && (b.realWidth > b.max_size_in_px || b.realHeight > b.max_size_in_px) && (Ja = b.max_size_in_px / Math.max(b.realWidth, b.realHeight), b.realWidth *= Ja, b.realHeight *= Ja))
		}
	};
	a.style.Style.rgbToHsv = function (a) {
		var b,
		c = a.r / 255,
		Ja = a.g / 255;
		a = a.b / 255;
		var Na =
			Math.max(c, Ja, a),
		Sa = Na - Math.min(c, Ja, a);
		0 === Sa ? b = 0 : Na === Ja ? b = 60 * (a - c) / Sa + 120 : Na === a ? b = 60 * (c - Ja) / Sa + 240 : Na === c && (b = Ja >= a ? 60 * (Ja - a) / Sa + 0 : 60 * (Ja - a) / Sa + 360);
		return {
			h: Math.round(b),
			s: Math.round(100 * (0 === Na ? 0 : Sa / Na)),
			v: Math.round(100 * Na)
		}
	};
	a.style.Style.hsvToRgb = function (a) {
		var b = a.h,
		c = a.s;
		a = a.v;
		var Ja,
		Na,
		Sa,
		$a,
		ib,
		Za;
		if (0 === c)
			Sa = Na = Ja = b = c = a = Math.round(255 * a / 100);
		else {
			c /= 100;
			a /= 100;
			$a = Math.floor(b / 60) % 6;
			ib = b / 60 - $a;
			b = a * (1 - c);
			Za = a * (1 - c * ib);
			c = a * (1 - c * (1 - ib));
			switch ($a) {
			case 0:
				Ja = a;
				Na = c;
				Sa = b;
				break;
			case 1:
				Ja =
					Za;
				Na = a;
				Sa = b;
				break;
			case 2:
				Ja = b;
				Na = a;
				Sa = c;
				break;
			case 3:
				Ja = b;
				Na = Za;
				Sa = a;
				break;
			case 4:
				Ja = c;
				Na = b;
				Sa = a;
				break;
			case 5:
				Ja = a,
				Na = b,
				Sa = Za
			}
			Ja = Math.round(255 * Ja);
			Na = Math.round(255 * Na);
			Sa = Math.round(255 * Sa)
		}
		return {
			r: Ja,
			g: Na,
			b: Sa
		}
	};
	a.style.Style.ColorLuminance = function (a, b) {
		a = String(a).replace(/[^0-9a-f]/gi, "");
		6 > a.length && (a = a[0] + a[0] + a[1] + a[1] + a[2] + a[2]);
		b = b || 0;
		var c = "#",
		Ja,
		Na;
		for (Na = 0; 3 > Na; Na++)
			Ja = parseInt(a.substr(2 * Na, 2), 16), Ja = Math.round(Math.min(Math.max(0, Ja + Ja * b), 255)).toString(16), c += ("00" + Ja).substr(Ja.length);
		return c
	};
	a.style.colorbrewer = {
		YlGn: {
			3: ["#f7fcb9", "#addd8e", "#31a354"],
			4: ["#ffffcc", "#c2e699", "#78c679", "#238443"],
			5: ["#ffffcc", "#c2e699", "#78c679", "#31a354", "#006837"],
			6: "#ffffcc #d9f0a3 #addd8e #78c679 #31a354 #006837".split(" "),
			7: "#ffffcc #d9f0a3 #addd8e #78c679 #41ab5d #238443 #005a32".split(" "),
			8: "#ffffe5 #f7fcb9 #d9f0a3 #addd8e #78c679 #41ab5d #238443 #005a32".split(" "),
			9: "#ffffe5 #f7fcb9 #d9f0a3 #addd8e #78c679 #41ab5d #238443 #006837 #004529".split(" ")
		},
		YlGnBu: {
			3: ["#edf8b1", "#7fcdbb",
				"#2c7fb8"],
			4: ["#ffffcc", "#a1dab4", "#41b6c4", "#225ea8"],
			5: ["#ffffcc", "#a1dab4", "#41b6c4", "#2c7fb8", "#253494"],
			6: "#ffffcc #c7e9b4 #7fcdbb #41b6c4 #2c7fb8 #253494".split(" "),
			7: "#ffffcc #c7e9b4 #7fcdbb #41b6c4 #1d91c0 #225ea8 #0c2c84".split(" "),
			8: "#ffffd9 #edf8b1 #c7e9b4 #7fcdbb #41b6c4 #1d91c0 #225ea8 #0c2c84".split(" "),
			9: "#ffffd9 #edf8b1 #c7e9b4 #7fcdbb #41b6c4 #1d91c0 #225ea8 #253494 #081d58".split(" ")
		},
		GnBu: {
			3: ["#e0f3db", "#a8ddb5", "#43a2ca"],
			4: ["#f0f9e8", "#bae4bc", "#7bccc4", "#2b8cbe"],
			5: ["#f0f9e8",
				"#bae4bc", "#7bccc4", "#43a2ca", "#0868ac"],
			6: "#f0f9e8 #ccebc5 #a8ddb5 #7bccc4 #43a2ca #0868ac".split(" "),
			7: "#f0f9e8 #ccebc5 #a8ddb5 #7bccc4 #4eb3d3 #2b8cbe #08589e".split(" "),
			8: "#f7fcf0 #e0f3db #ccebc5 #a8ddb5 #7bccc4 #4eb3d3 #2b8cbe #08589e".split(" "),
			9: "#f7fcf0 #e0f3db #ccebc5 #a8ddb5 #7bccc4 #4eb3d3 #2b8cbe #0868ac #084081".split(" ")
		},
		BuGn: {
			3: ["#e5f5f9", "#99d8c9", "#2ca25f"],
			4: ["#edf8fb", "#b2e2e2", "#66c2a4", "#238b45"],
			5: ["#edf8fb", "#b2e2e2", "#66c2a4", "#2ca25f", "#006d2c"],
			6: "#edf8fb #ccece6 #99d8c9 #66c2a4 #2ca25f #006d2c".split(" "),
			7: "#edf8fb #ccece6 #99d8c9 #66c2a4 #41ae76 #238b45 #005824".split(" "),
			8: "#f7fcfd #e5f5f9 #ccece6 #99d8c9 #66c2a4 #41ae76 #238b45 #005824".split(" "),
			9: "#f7fcfd #e5f5f9 #ccece6 #99d8c9 #66c2a4 #41ae76 #238b45 #006d2c #00441b".split(" ")
		},
		PuBuGn: {
			3: ["#ece2f0", "#a6bddb", "#1c9099"],
			4: ["#f6eff7", "#bdc9e1", "#67a9cf", "#02818a"],
			5: ["#f6eff7", "#bdc9e1", "#67a9cf", "#1c9099", "#016c59"],
			6: "#f6eff7 #d0d1e6 #a6bddb #67a9cf #1c9099 #016c59".split(" "),
			7: "#f6eff7 #d0d1e6 #a6bddb #67a9cf #3690c0 #02818a #016450".split(" "),
			8: "#fff7fb #ece2f0 #d0d1e6 #a6bddb #67a9cf #3690c0 #02818a #016450".split(" "),
			9: "#fff7fb #ece2f0 #d0d1e6 #a6bddb #67a9cf #3690c0 #02818a #016c59 #014636".split(" ")
		},
		PuBu: {
			3: ["#ece7f2", "#a6bddb", "#2b8cbe"],
			4: ["#f1eef6", "#bdc9e1", "#74a9cf", "#0570b0"],
			5: ["#f1eef6", "#bdc9e1", "#74a9cf", "#2b8cbe", "#045a8d"],
			6: "#f1eef6 #d0d1e6 #a6bddb #74a9cf #2b8cbe #045a8d".split(" "),
			7: "#f1eef6 #d0d1e6 #a6bddb #74a9cf #3690c0 #0570b0 #034e7b".split(" "),
			8: "#fff7fb #ece7f2 #d0d1e6 #a6bddb #74a9cf #3690c0 #0570b0 #034e7b".split(" "),
			9: "#fff7fb #ece7f2 #d0d1e6 #a6bddb #74a9cf #3690c0 #0570b0 #045a8d #023858".split(" ")
		},
		BuPu: {
			3: ["#e0ecf4", "#9ebcda", "#8856a7"],
			4: ["#edf8fb", "#b3cde3", "#8c96c6", "#88419d"],
			5: ["#edf8fb", "#b3cde3", "#8c96c6", "#8856a7", "#810f7c"],
			6: "#edf8fb #bfd3e6 #9ebcda #8c96c6 #8856a7 #810f7c".split(" "),
			7: "#edf8fb #bfd3e6 #9ebcda #8c96c6 #8c6bb1 #88419d #6e016b".split(" "),
			8: "#f7fcfd #e0ecf4 #bfd3e6 #9ebcda #8c96c6 #8c6bb1 #88419d #6e016b".split(" "),
			9: "#f7fcfd #e0ecf4 #bfd3e6 #9ebcda #8c96c6 #8c6bb1 #88419d #810f7c #4d004b".split(" ")
		},
		RdPu: {
			3: ["#fde0dd", "#fa9fb5", "#c51b8a"],
			4: ["#feebe2", "#fbb4b9", "#f768a1", "#ae017e"],
			5: ["#feebe2", "#fbb4b9", "#f768a1", "#c51b8a", "#7a0177"],
			6: "#feebe2 #fcc5c0 #fa9fb5 #f768a1 #c51b8a #7a0177".split(" "),
			7: "#feebe2 #fcc5c0 #fa9fb5 #f768a1 #dd3497 #ae017e #7a0177".split(" "),
			8: "#fff7f3 #fde0dd #fcc5c0 #fa9fb5 #f768a1 #dd3497 #ae017e #7a0177".split(" "),
			9: "#fff7f3 #fde0dd #fcc5c0 #fa9fb5 #f768a1 #dd3497 #ae017e #7a0177 #49006a".split(" ")
		},
		PuRd: {
			3: ["#e7e1ef", "#c994c7", "#dd1c77"],
			4: ["#f1eef6", "#d7b5d8",
				"#df65b0", "#ce1256"],
			5: ["#f1eef6", "#d7b5d8", "#df65b0", "#dd1c77", "#980043"],
			6: "#f1eef6 #d4b9da #c994c7 #df65b0 #dd1c77 #980043".split(" "),
			7: "#f1eef6 #d4b9da #c994c7 #df65b0 #e7298a #ce1256 #91003f".split(" "),
			8: "#f7f4f9 #e7e1ef #d4b9da #c994c7 #df65b0 #e7298a #ce1256 #91003f".split(" "),
			9: "#f7f4f9 #e7e1ef #d4b9da #c994c7 #df65b0 #e7298a #ce1256 #980043 #67001f".split(" ")
		},
		OrRd: {
			3: ["#fee8c8", "#fdbb84", "#e34a33"],
			4: ["#fef0d9", "#fdcc8a", "#fc8d59", "#d7301f"],
			5: ["#fef0d9", "#fdcc8a", "#fc8d59", "#e34a33",
				"#b30000"],
			6: "#fef0d9 #fdd49e #fdbb84 #fc8d59 #e34a33 #b30000".split(" "),
			7: "#fef0d9 #fdd49e #fdbb84 #fc8d59 #ef6548 #d7301f #990000".split(" "),
			8: "#fff7ec #fee8c8 #fdd49e #fdbb84 #fc8d59 #ef6548 #d7301f #990000".split(" "),
			9: "#fff7ec #fee8c8 #fdd49e #fdbb84 #fc8d59 #ef6548 #d7301f #b30000 #7f0000".split(" ")
		},
		YlOrRd: {
			3: ["#ffeda0", "#feb24c", "#f03b20"],
			4: ["#ffffb2", "#fecc5c", "#fd8d3c", "#e31a1c"],
			5: ["#ffffb2", "#fecc5c", "#fd8d3c", "#f03b20", "#bd0026"],
			6: "#ffffb2 #fed976 #feb24c #fd8d3c #f03b20 #bd0026".split(" "),
			7: "#ffffb2 #fed976 #feb24c #fd8d3c #fc4e2a #e31a1c #b10026".split(" "),
			8: "#ffffcc #ffeda0 #fed976 #feb24c #fd8d3c #fc4e2a #e31a1c #b10026".split(" "),
			9: "#ffffcc #ffeda0 #fed976 #feb24c #fd8d3c #fc4e2a #e31a1c #bd0026 #800026".split(" ")
		},
		YlOrBr: {
			3: ["#fff7bc", "#fec44f", "#d95f0e"],
			4: ["#ffffd4", "#fed98e", "#fe9929", "#cc4c02"],
			5: ["#ffffd4", "#fed98e", "#fe9929", "#d95f0e", "#993404"],
			6: "#ffffd4 #fee391 #fec44f #fe9929 #d95f0e #993404".split(" "),
			7: "#ffffd4 #fee391 #fec44f #fe9929 #ec7014 #cc4c02 #8c2d04".split(" "),
			8: "#ffffe5 #fff7bc #fee391 #fec44f #fe9929 #ec7014 #cc4c02 #8c2d04".split(" "),
			9: "#ffffe5 #fff7bc #fee391 #fec44f #fe9929 #ec7014 #cc4c02 #993404 #662506".split(" ")
		},
		Purples: {
			3: ["#efedf5", "#bcbddc", "#756bb1"],
			4: ["#f2f0f7", "#cbc9e2", "#9e9ac8", "#6a51a3"],
			5: ["#f2f0f7", "#cbc9e2", "#9e9ac8", "#756bb1", "#54278f"],
			6: "#f2f0f7 #dadaeb #bcbddc #9e9ac8 #756bb1 #54278f".split(" "),
			7: "#f2f0f7 #dadaeb #bcbddc #9e9ac8 #807dba #6a51a3 #4a1486".split(" "),
			8: "#fcfbfd #efedf5 #dadaeb #bcbddc #9e9ac8 #807dba #6a51a3 #4a1486".split(" "),
			9: "#fcfbfd #efedf5 #dadaeb #bcbddc #9e9ac8 #807dba #6a51a3 #54278f #3f007d".split(" ")
		},
		Blues: {
			3: ["#deebf7", "#9ecae1", "#3182bd"],
			4: ["#eff3ff", "#bdd7e7", "#6baed6", "#2171b5"],
			5: ["#eff3ff", "#bdd7e7", "#6baed6", "#3182bd", "#08519c"],
			6: "#eff3ff #c6dbef #9ecae1 #6baed6 #3182bd #08519c".split(" "),
			7: "#eff3ff #c6dbef #9ecae1 #6baed6 #4292c6 #2171b5 #084594".split(" "),
			8: "#f7fbff #deebf7 #c6dbef #9ecae1 #6baed6 #4292c6 #2171b5 #084594".split(" "),
			9: "#f7fbff #deebf7 #c6dbef #9ecae1 #6baed6 #4292c6 #2171b5 #08519c #08306b".split(" ")
		},
		Greens: {
			3: ["#e5f5e0", "#a1d99b", "#31a354"],
			4: ["#edf8e9", "#bae4b3", "#74c476", "#238b45"],
			5: ["#edf8e9", "#bae4b3", "#74c476", "#31a354", "#006d2c"],
			6: "#edf8e9 #c7e9c0 #a1d99b #74c476 #31a354 #006d2c".split(" "),
			7: "#edf8e9 #c7e9c0 #a1d99b #74c476 #41ab5d #238b45 #005a32".split(" "),
			8: "#f7fcf5 #e5f5e0 #c7e9c0 #a1d99b #74c476 #41ab5d #238b45 #005a32".split(" "),
			9: "#f7fcf5 #e5f5e0 #c7e9c0 #a1d99b #74c476 #41ab5d #238b45 #006d2c #00441b".split(" ")
		},
		Oranges: {
			3: ["#fee6ce", "#fdae6b", "#e6550d"],
			4: ["#feedde", "#fdbe85",
				"#fd8d3c", "#d94701"],
			5: ["#feedde", "#fdbe85", "#fd8d3c", "#e6550d", "#a63603"],
			6: "#feedde #fdd0a2 #fdae6b #fd8d3c #e6550d #a63603".split(" "),
			7: "#feedde #fdd0a2 #fdae6b #fd8d3c #f16913 #d94801 #8c2d04".split(" "),
			8: "#fff5eb #fee6ce #fdd0a2 #fdae6b #fd8d3c #f16913 #d94801 #8c2d04".split(" "),
			9: "#fff5eb #fee6ce #fdd0a2 #fdae6b #fd8d3c #f16913 #d94801 #a63603 #7f2704".split(" ")
		},
		Reds: {
			3: ["#fee0d2", "#fc9272", "#de2d26"],
			4: ["#fee5d9", "#fcae91", "#fb6a4a", "#cb181d"],
			5: ["#fee5d9", "#fcae91", "#fb6a4a", "#de2d26",
				"#a50f15"],
			6: "#fee5d9 #fcbba1 #fc9272 #fb6a4a #de2d26 #a50f15".split(" "),
			7: "#fee5d9 #fcbba1 #fc9272 #fb6a4a #ef3b2c #cb181d #99000d".split(" "),
			8: "#fff5f0 #fee0d2 #fcbba1 #fc9272 #fb6a4a #ef3b2c #cb181d #99000d".split(" "),
			9: "#fff5f0 #fee0d2 #fcbba1 #fc9272 #fb6a4a #ef3b2c #cb181d #a50f15 #67000d".split(" ")
		},
		Greys: {
			3: ["#f0f0f0", "#bdbdbd", "#636363"],
			4: ["#f7f7f7", "#cccccc", "#969696", "#525252"],
			5: ["#f7f7f7", "#cccccc", "#969696", "#636363", "#252525"],
			6: "#f7f7f7 #d9d9d9 #bdbdbd #969696 #636363 #252525".split(" "),
			7: "#f7f7f7 #d9d9d9 #bdbdbd #969696 #737373 #525252 #252525".split(" "),
			8: "#ffffff #f0f0f0 #d9d9d9 #bdbdbd #969696 #737373 #525252 #252525".split(" "),
			9: "#ffffff #f0f0f0 #d9d9d9 #bdbdbd #969696 #737373 #525252 #252525 #000000".split(" ")
		},
		PuOr: {
			3: ["#f1a340", "#f7f7f7", "#998ec3"],
			4: ["#e66101", "#fdb863", "#b2abd2", "#5e3c99"],
			5: ["#e66101", "#fdb863", "#f7f7f7", "#b2abd2", "#5e3c99"],
			6: "#b35806 #f1a340 #fee0b6 #d8daeb #998ec3 #542788".split(" "),
			7: "#b35806 #f1a340 #fee0b6 #f7f7f7 #d8daeb #998ec3 #542788".split(" "),
			8: "#b35806 #e08214 #fdb863 #fee0b6 #d8daeb #b2abd2 #8073ac #542788".split(" "),
			9: "#b35806 #e08214 #fdb863 #fee0b6 #f7f7f7 #d8daeb #b2abd2 #8073ac #542788".split(" "),
			10: "#7f3b08 #b35806 #e08214 #fdb863 #fee0b6 #d8daeb #b2abd2 #8073ac #542788 #2d004b".split(" "),
			11: "#7f3b08 #b35806 #e08214 #fdb863 #fee0b6 #f7f7f7 #d8daeb #b2abd2 #8073ac #542788 #2d004b".split(" ")
		},
		BrBG: {
			3: ["#d8b365", "#f5f5f5", "#5ab4ac"],
			4: ["#a6611a", "#dfc27d", "#80cdc1", "#018571"],
			5: ["#a6611a", "#dfc27d", "#f5f5f5", "#80cdc1", "#018571"],
			6: "#8c510a #d8b365 #f6e8c3 #c7eae5 #5ab4ac #01665e".split(" "),
			7: "#8c510a #d8b365 #f6e8c3 #f5f5f5 #c7eae5 #5ab4ac #01665e".split(" "),
			8: "#8c510a #bf812d #dfc27d #f6e8c3 #c7eae5 #80cdc1 #35978f #01665e".split(" "),
			9: "#8c510a #bf812d #dfc27d #f6e8c3 #f5f5f5 #c7eae5 #80cdc1 #35978f #01665e".split(" "),
			10: "#543005 #8c510a #bf812d #dfc27d #f6e8c3 #c7eae5 #80cdc1 #35978f #01665e #003c30".split(" "),
			11: "#543005 #8c510a #bf812d #dfc27d #f6e8c3 #f5f5f5 #c7eae5 #80cdc1 #35978f #01665e #003c30".split(" ")
		},
		PRGn: {
			3: ["#af8dc3", "#f7f7f7", "#7fbf7b"],
			4: ["#7b3294", "#c2a5cf", "#a6dba0", "#008837"],
			5: ["#7b3294", "#c2a5cf", "#f7f7f7", "#a6dba0", "#008837"],
			6: "#762a83 #af8dc3 #e7d4e8 #d9f0d3 #7fbf7b #1b7837".split(" "),
			7: "#762a83 #af8dc3 #e7d4e8 #f7f7f7 #d9f0d3 #7fbf7b #1b7837".split(" "),
			8: "#762a83 #9970ab #c2a5cf #e7d4e8 #d9f0d3 #a6dba0 #5aae61 #1b7837".split(" "),
			9: "#762a83 #9970ab #c2a5cf #e7d4e8 #f7f7f7 #d9f0d3 #a6dba0 #5aae61 #1b7837".split(" "),
			10: "#40004b #762a83 #9970ab #c2a5cf #e7d4e8 #d9f0d3 #a6dba0 #5aae61 #1b7837 #00441b".split(" "),
			11: "#40004b #762a83 #9970ab #c2a5cf #e7d4e8 #f7f7f7 #d9f0d3 #a6dba0 #5aae61 #1b7837 #00441b".split(" ")
		},
		PiYG: {
			3: ["#e9a3c9", "#f7f7f7", "#a1d76a"],
			4: ["#d01c8b", "#f1b6da", "#b8e186", "#4dac26"],
			5: ["#d01c8b", "#f1b6da", "#f7f7f7", "#b8e186", "#4dac26"],
			6: "#c51b7d #e9a3c9 #fde0ef #e6f5d0 #a1d76a #4d9221".split(" "),
			7: "#c51b7d #e9a3c9 #fde0ef #f7f7f7 #e6f5d0 #a1d76a #4d9221".split(" "),
			8: "#c51b7d #de77ae #f1b6da #fde0ef #e6f5d0 #b8e186 #7fbc41 #4d9221".split(" "),
			9: "#c51b7d #de77ae #f1b6da #fde0ef #f7f7f7 #e6f5d0 #b8e186 #7fbc41 #4d9221".split(" "),
			10: "#8e0152 #c51b7d #de77ae #f1b6da #fde0ef #e6f5d0 #b8e186 #7fbc41 #4d9221 #276419".split(" "),
			11: "#8e0152 #c51b7d #de77ae #f1b6da #fde0ef #f7f7f7 #e6f5d0 #b8e186 #7fbc41 #4d9221 #276419".split(" ")
		},
		RdBu: {
			3: ["#ef8a62", "#f7f7f7", "#67a9cf"],
			4: ["#ca0020", "#f4a582", "#92c5de", "#0571b0"],
			5: ["#ca0020", "#f4a582", "#f7f7f7", "#92c5de", "#0571b0"],
			6: "#b2182b #ef8a62 #fddbc7 #d1e5f0 #67a9cf #2166ac".split(" "),
			7: "#b2182b #ef8a62 #fddbc7 #f7f7f7 #d1e5f0 #67a9cf #2166ac".split(" "),
			8: "#b2182b #d6604d #f4a582 #fddbc7 #d1e5f0 #92c5de #4393c3 #2166ac".split(" "),
			9: "#b2182b #d6604d #f4a582 #fddbc7 #f7f7f7 #d1e5f0 #92c5de #4393c3 #2166ac".split(" "),
			10: "#67001f #b2182b #d6604d #f4a582 #fddbc7 #d1e5f0 #92c5de #4393c3 #2166ac #053061".split(" "),
			11: "#67001f #b2182b #d6604d #f4a582 #fddbc7 #f7f7f7 #d1e5f0 #92c5de #4393c3 #2166ac #053061".split(" ")
		},
		RdGy: {
			3: ["#ef8a62", "#ffffff", "#999999"],
			4: ["#ca0020", "#f4a582", "#bababa", "#404040"],
			5: ["#ca0020", "#f4a582", "#ffffff", "#bababa", "#404040"],
			6: "#b2182b #ef8a62 #fddbc7 #e0e0e0 #999999 #4d4d4d".split(" "),
			7: "#b2182b #ef8a62 #fddbc7 #ffffff #e0e0e0 #999999 #4d4d4d".split(" "),
			8: "#b2182b #d6604d #f4a582 #fddbc7 #e0e0e0 #bababa #878787 #4d4d4d".split(" "),
			9: "#b2182b #d6604d #f4a582 #fddbc7 #ffffff #e0e0e0 #bababa #878787 #4d4d4d".split(" "),
			10: "#67001f #b2182b #d6604d #f4a582 #fddbc7 #e0e0e0 #bababa #878787 #4d4d4d #1a1a1a".split(" "),
			11: "#67001f #b2182b #d6604d #f4a582 #fddbc7 #ffffff #e0e0e0 #bababa #878787 #4d4d4d #1a1a1a".split(" ")
		},
		RdYlBu: {
			3: ["#fc8d59", "#ffffbf", "#91bfdb"],
			4: ["#d7191c", "#fdae61", "#abd9e9", "#2c7bb6"],
			5: ["#d7191c", "#fdae61", "#ffffbf", "#abd9e9", "#2c7bb6"],
			6: "#d73027 #fc8d59 #fee090 #e0f3f8 #91bfdb #4575b4".split(" "),
			7: "#d73027 #fc8d59 #fee090 #ffffbf #e0f3f8 #91bfdb #4575b4".split(" "),
			8: "#d73027 #f46d43 #fdae61 #fee090 #e0f3f8 #abd9e9 #74add1 #4575b4".split(" "),
			9: "#d73027 #f46d43 #fdae61 #fee090 #ffffbf #e0f3f8 #abd9e9 #74add1 #4575b4".split(" "),
			10: "#a50026 #d73027 #f46d43 #fdae61 #fee090 #e0f3f8 #abd9e9 #74add1 #4575b4 #313695".split(" "),
			11: "#a50026 #d73027 #f46d43 #fdae61 #fee090 #ffffbf #e0f3f8 #abd9e9 #74add1 #4575b4 #313695".split(" ")
		},
		Spectral: {
			3: ["#fc8d59", "#ffffbf", "#99d594"],
			4: ["#d7191c", "#fdae61", "#abdda4", "#2b83ba"],
			5: ["#d7191c", "#fdae61", "#ffffbf", "#abdda4", "#2b83ba"],
			6: "#d53e4f #fc8d59 #fee08b #e6f598 #99d594 #3288bd".split(" "),
			7: "#d53e4f #fc8d59 #fee08b #ffffbf #e6f598 #99d594 #3288bd".split(" "),
			8: "#d53e4f #f46d43 #fdae61 #fee08b #e6f598 #abdda4 #66c2a5 #3288bd".split(" "),
			9: "#d53e4f #f46d43 #fdae61 #fee08b #ffffbf #e6f598 #abdda4 #66c2a5 #3288bd".split(" "),
			10: "#9e0142 #d53e4f #f46d43 #fdae61 #fee08b #e6f598 #abdda4 #66c2a5 #3288bd #5e4fa2".split(" "),
			11: "#9e0142 #d53e4f #f46d43 #fdae61 #fee08b #ffffbf #e6f598 #abdda4 #66c2a5 #3288bd #5e4fa2".split(" ")
		},
		RdYlGn: {
			3: ["#fc8d59", "#ffffbf", "#91cf60"],
			4: ["#d7191c", "#fdae61", "#a6d96a", "#1a9641"],
			5: ["#d7191c", "#fdae61", "#ffffbf", "#a6d96a", "#1a9641"],
			6: "#d73027 #fc8d59 #fee08b #d9ef8b #91cf60 #1a9850".split(" "),
			7: "#d73027 #fc8d59 #fee08b #ffffbf #d9ef8b #91cf60 #1a9850".split(" "),
			8: "#d73027 #f46d43 #fdae61 #fee08b #d9ef8b #a6d96a #66bd63 #1a9850".split(" "),
			9: "#d73027 #f46d43 #fdae61 #fee08b #ffffbf #d9ef8b #a6d96a #66bd63 #1a9850".split(" "),
			10: "#a50026 #d73027 #f46d43 #fdae61 #fee08b #d9ef8b #a6d96a #66bd63 #1a9850 #006837".split(" "),
			11: "#a50026 #d73027 #f46d43 #fdae61 #fee08b #ffffbf #d9ef8b #a6d96a #66bd63 #1a9850 #006837".split(" ")
		},
		Accent: {
			3: ["#7fc97f", "#beaed4", "#fdc086"],
			4: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99"],
			5: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0"],
			6: "#7fc97f #beaed4 #fdc086 #ffff99 #386cb0 #f0027f".split(" "),
			7: "#7fc97f #beaed4 #fdc086 #ffff99 #386cb0 #f0027f #bf5b17".split(" "),
			8: "#7fc97f #beaed4 #fdc086 #ffff99 #386cb0 #f0027f #bf5b17 #666666".split(" ")
		},
		Dark2: {
			3: ["#1b9e77", "#d95f02", "#7570b3"],
			4: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a"],
			5: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e"],
			6: "#1b9e77 #d95f02 #7570b3 #e7298a #66a61e #e6ab02".split(" "),
			7: "#1b9e77 #d95f02 #7570b3 #e7298a #66a61e #e6ab02 #a6761d".split(" "),
			8: "#1b9e77 #d95f02 #7570b3 #e7298a #66a61e #e6ab02 #a6761d #666666".split(" ")
		},
		Paired: {
			3: ["#a6cee3", "#1f78b4", "#b2df8a"],
			4: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c"],
			5: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99"],
			6: "#a6cee3 #1f78b4 #b2df8a #33a02c #fb9a99 #e31a1c".split(" "),
			7: "#a6cee3 #1f78b4 #b2df8a #33a02c #fb9a99 #e31a1c #fdbf6f".split(" "),
			8: "#a6cee3 #1f78b4 #b2df8a #33a02c #fb9a99 #e31a1c #fdbf6f #ff7f00".split(" "),
			9: "#a6cee3 #1f78b4 #b2df8a #33a02c #fb9a99 #e31a1c #fdbf6f #ff7f00 #cab2d6".split(" "),
			10: "#a6cee3 #1f78b4 #b2df8a #33a02c #fb9a99 #e31a1c #fdbf6f #ff7f00 #cab2d6 #6a3d9a".split(" "),
			11: "#a6cee3 #1f78b4 #b2df8a #33a02c #fb9a99 #e31a1c #fdbf6f #ff7f00 #cab2d6 #6a3d9a #ffff99".split(" "),
			12: "#a6cee3 #1f78b4 #b2df8a #33a02c #fb9a99 #e31a1c #fdbf6f #ff7f00 #cab2d6 #6a3d9a #ffff99 #b15928".split(" ")
		},
		Pastel1: {
			3: ["#fbb4ae", "#b3cde3", "#ccebc5"],
			4: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4"],
			5: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6"],
			6: "#fbb4ae #b3cde3 #ccebc5 #decbe4 #fed9a6 #ffffcc".split(" "),
			7: "#fbb4ae #b3cde3 #ccebc5 #decbe4 #fed9a6 #ffffcc #e5d8bd".split(" "),
			8: "#fbb4ae #b3cde3 #ccebc5 #decbe4 #fed9a6 #ffffcc #e5d8bd #fddaec".split(" "),
			9: "#fbb4ae #b3cde3 #ccebc5 #decbe4 #fed9a6 #ffffcc #e5d8bd #fddaec #f2f2f2".split(" ")
		},
		Pastel2: {
			3: ["#b3e2cd", "#fdcdac", "#cbd5e8"],
			4: ["#b3e2cd", "#fdcdac",
				"#cbd5e8", "#f4cae4"],
			5: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9"],
			6: "#b3e2cd #fdcdac #cbd5e8 #f4cae4 #e6f5c9 #fff2ae".split(" "),
			7: "#b3e2cd #fdcdac #cbd5e8 #f4cae4 #e6f5c9 #fff2ae #f1e2cc".split(" "),
			8: "#b3e2cd #fdcdac #cbd5e8 #f4cae4 #e6f5c9 #fff2ae #f1e2cc #cccccc".split(" ")
		},
		Set1: {
			3: ["#e41a1c", "#377eb8", "#4daf4a"],
			4: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3"],
			5: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00"],
			6: "#e41a1c #377eb8 #4daf4a #984ea3 #ff7f00 #ffff33".split(" "),
			7: "#e41a1c #377eb8 #4daf4a #984ea3 #ff7f00 #ffff33 #a65628".split(" "),
			8: "#e41a1c #377eb8 #4daf4a #984ea3 #ff7f00 #ffff33 #a65628 #f781bf".split(" "),
			9: "#e41a1c #377eb8 #4daf4a #984ea3 #ff7f00 #ffff33 #a65628 #f781bf #999999".split(" ")
		},
		Set2: {
			3: ["#66c2a5", "#fc8d62", "#8da0cb"],
			4: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3"],
			5: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854"],
			6: "#66c2a5 #fc8d62 #8da0cb #e78ac3 #a6d854 #ffd92f".split(" "),
			7: "#66c2a5 #fc8d62 #8da0cb #e78ac3 #a6d854 #ffd92f #e5c494".split(" "),
			8: "#66c2a5 #fc8d62 #8da0cb #e78ac3 #a6d854 #ffd92f #e5c494 #b3b3b3".split(" ")
		},
		Set3: {
			3: ["#8dd3c7", "#ffffb3", "#bebada"],
			4: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072"],
			5: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3"],
			6: "#8dd3c7 #ffffb3 #bebada #fb8072 #80b1d3 #fdb462".split(" "),
			7: "#8dd3c7 #ffffb3 #bebada #fb8072 #80b1d3 #fdb462 #b3de69".split(" "),
			8: "#8dd3c7 #ffffb3 #bebada #fb8072 #80b1d3 #fdb462 #b3de69 #fccde5".split(" "),
			9: "#8dd3c7 #ffffb3 #bebada #fb8072 #80b1d3 #fdb462 #b3de69 #fccde5 #d9d9d9".split(" "),
			10: "#8dd3c7 #ffffb3 #bebada #fb8072 #80b1d3 #fdb462 #b3de69 #fccde5 #d9d9d9 #bc80bd".split(" "),
			11: "#8dd3c7 #ffffb3 #bebada #fb8072 #80b1d3 #fdb462 #b3de69 #fccde5 #d9d9d9 #bc80bd #ccebc5".split(" "),
			12: "#8dd3c7 #ffffb3 #bebada #fb8072 #80b1d3 #fdb462 #b3de69 #fccde5 #d9d9d9 #bc80bd #ccebc5 #ffed6f".split(" ")
		}
	};
	a.style.Text = a.style.Style.extend({
		initialize: function Pb(b) {
			b = b || {};
			b.styleType = "Text";
			Pb.base.call(this, b);
			this.fontFamily = a.notNull(b.fontFamily) ? b.fontFamily : null;
			this.fontStyle = a.notNull(b.fontStyle) ? b.fontStyle : a.Text.FONTSTYLE_NORMAL;
			this.fontWeight = a.notNull(b.fontWeight) ? b.fontWeight :
				a.Text.FONTWEIGHT_NORMAL;
			this.fill = a.notNull(b.fill) ? b.fill : null;
			this.lengthUnit = a.notNull(b.lengthUnit) ? b.lenghtUnit : "pixel";
			this.lengthUnit = a.notNull(b.sizeUnit) ? b.sizeUnit : "pixel";
			"pixel" === this.lengthUnit ? this.fontSize = a.notNull(b.fontSize) ? parseInt(b.fontSize) : 12 : this.unitFontSize = a.notNull(b.fontSize) ? parseInt(b.fontSize) : 10;
			this.hAlign = a.notNull(b.hAlign) ? b.hAlign : a.Text.HORIZONTALALIGN_CENTER;
			this.vAlign = a.notNull(b.vAlign) ? b.vAlign : a.Text.VERTICALALIGN_CENTER;
			this.sticky = a.notNull(b.sticky) ?
				b.sticky : !1
		},
		toXMLString: function () {
			var b = "",
			c = "",
			c = a.notNull(this.fontStyle) && this.fontStyle === a.Text.FONTSTYLE_ITALIC ? "font-style:italic;" : "font-style:plain;",
			b = a.notNull(this.hAlign) && this.hAlign === a.HORIZONTALALIGN_LEFT ? "text-align:left;" : a.notNull(this.hAlign) && this.hAlign === a.HORIZONTALALIGN_RIGHT ? "text-align:right;" : "text-align:center;",
			Ja;
			Ja = "" + ('\x3cstyle name\x3d"' + this.getStyleName() + '"\x3e');
			Ja = Ja + '\x3cg class\x3d"text" style\x3d"' + c;
			Ja += a.notNull(this.fontFamily) ? "font-family:" + this.fontFamily +
			";" : "";
			Ja += a.notNull(this.fontSize) ? "font-size:" + this.fontSize + "pt;" : "";
			Ja += b;
			Ja += a.notNull(this.fill) ? "fill:" + this.fill : "";
			return Ja += '"\x3e\x3c/g\x3e\x3c/style\x3e'
		},
		draw: function (b, c, Ja) {
			this.resolve(b);
			var Na = b.geo,
			Sa = b.geo.type;
			if (Ja.markerPoint && b.shapeGroup)
				b.shapeGroup.push(this.drawText(c, Ja.group, Ja.markerPoint, b.markerText));
			else if (Ja.sPoint)
				b.shape = this.drawText(c, Ja.group, Ja.sPoint, b.markerText);
			else if ("LineString" !== Sa && "MultiLineString" !== Sa)
				if ("Polygon" === Sa || "MultiPolygon" === Sa)
					b.screenPoints ||
					(Sa = null, b.labelBox ? Sa = new a.geometry.Point((b.labelBox[0] + b.labelBox[2]) / 2, (b.labelBox[1] + b.labelBox[3]) / 2, Na.srid) : Na.mbr && (Sa = new a.geometry.Point((Na.mbr.getMinX() + Na.mbr.getMaxX()) / 2, (Na.mbr.getMinY() + Na.mbr.getMaxY()) / 2, Na.srid)), Sa = b.transformGeometry(Sa), b.screenPoints || (b.screenPoints = Sa)), b.shape = this.drawText(c, Ja.group, b.screenPoints, b.markerText);
				else if (b.screenPoints || b.transformGeometry(Na), "Point" === Sa || "OrientedPoint" === Sa)
					b.shape = this.drawText(c, Ja.group, b.screenPoints, b.text),
					a.isNull(b.renderingStyle) || (b.markerWidth = this.realWidthInPx, b.markerHeight = this.realWidthInPx)
		},
		drawText: function (b, c, Ja, Na) {
			if (0 !== this.width && 0 !== this.height) {
				var Sa = b.getGraphics();
				Ja = Sa.createTextNode(Na, this, Ja.x, Ja.y);
				c.appendChild(Ja);
				this.size = Sa.getWidthHeight(Ja);
				a.style.Style.calculateStyleSize(this, b);
				c = b = 0;
				if (a.notNull(this.hAlign))
					switch (this.hAlign) {
					case a.Text.HORIZONTALALIGN_CENTER:
						b = (0 - this.size.w) / 2;
						break;
					case a.Text.HORIZONTALALIGN_RIGHT:
						b = -this.size.w
					}
				if (a.notNull(this.vAlign))
					switch (this.hAlign) {
					case a.Text.VERTICALALIGN_CENTER:
						c =
							(this.size.h - 4) / 2;
						break;
					case a.Text.VERTICALALIGN_TOP:
						c = this.size.h
					}
				(new Sa.oui.geom.Matrix).translate(b, c);
				return Ja
			}
		},
		getBindables: function () {
			a.isNull(this.bindableAttrs) && (this.bindableAttrs = ["Color", "FontSize", "FontFamily", "FontStyle"]);
			return this.bindableAttrs
		},
		resolve: function (b) {
			if (!this.bindings || 0 === this.bindings.length)
				return this;
			for (var c = 0, Ja = this.bindings.length; c < Ja; c++) {
				var Na = this.bindings[c],
				Sa = this.resolveBinding(Na, b);
				"COLOR" === Na.attribute ? (this.fill = Sa, this.isBound("COLOR") &&
					1 === this.bindings.length && Sa === a.PaintTypes.NO_PAINT && (this.width = 0)) : "FONTSIZE" === Na.attribute ? this.fontSize = Sa : "FONTFAMILY" === Na.attribute ? this.fontFamily = Sa : "FONSTYLE" === Na.attribute && (this.fontStyle = Sa)
			}
			return this
		}
	});
	a.style.Gradient = a.style.Style.extend({
		initialize: function gb(b) {
			b = b || {};
			b.styleType = b && b.styleType ? b.styleType : "AbstractGradient";
			gb.base.call(this, b);
			if (a.isNull(b.stops))
				return a.util.Logger.throwErr(null, "Gradient.initialize", "Color stops not provided."), null;
			this.copyOrigStops();
			this.useFeatureBoundingBox = b && a.notNull(b.useFeatureBoundingBox) ? b.useFeatureBoundingBox : !0;
			this.stroke = b && a.notNull(b.stroke) ? b.stroke : null;
			this.strokeThickness = b && a.notNull(b.strokeThickness) ? parseFloat(b.strokeThickness) : 1;
			this.strokeOpacity = b && a.notNull(b.strokeOpacity) ? b.strokeOpacity : 1;
			this.fillOpacity = b && a.notNull(b.fillOpacity) ? b.fillOpacity : 1;
			this.strokeDash = a.notNull(b.strokeDash) ? b.strokeDash : []
		},
		copyOrigStops: function () {
			this.stops1 = [];
			for (var a, b = this.origConfig, c = 0; c < b.stops.length; c++)
				a =
					b.stops[c], this.stops1.push({
					offset: a.offset,
					color: a.color
				})
		},
		createGradientStop: function (a) {
			a = a.oui.style.GradientStop;
			if (this.stops1) {
				var b = this.stops1.length;
				this.stops = [];
				for (var c = 0; c < b; c++)
					this.stops1[c]instanceof a || (this.stops[c] = new a({
							offset: this.stops1[c].offset,
							color: this.stops1[c].color
						}))
			}
		},
		draw: function (b, c, Na) {
			var Sa = b.geo,
			$a = Na.type ? Na.type : Sa.type;
			c = c.getGraphics();
			var ib,
			Za,
			Ka;
			Na.screenPoints ? Sa = Na.screenPoints : (b.screenPoints || b.transformGeometry(Sa), Sa = b.screenPoints);
			this.resolve(b,
				c);
			if (("LineString" === $a || "MultiLineString" === $a) && Sa && 0 < Sa.length)
				if (ib = {
						stroke: this.stroke,
						strokeOpacity: this.strokeOpacity,
						strokeThickness: this.strokeThickness
					}, "LineString" === $a)
					b.shape = c.drawPath(Sa, ib, Na);
				else {
					Ka = c.createGroup();
					Na.group.appendChild(Ka);
					Na.group = Ka;
					$a = 0;
					for (Za = Sa.length; $a < Za; $a++)
						c.drawPath(Sa[$a], ib, Na);
					b.shape = Ka
				}
			else if (this.createStyle(c), ib = {
					stroke: this.stroke,
					strokeOpacity: this.strokeOpacity,
					strokeThickness: this.strokeThickness,
					fill: this.fill,
					fillOpacity: this.fillOpacity,
					strokeDashArray: this.strokeDash
				}, "Point" === $a || "OrientedPoint" === $a || "MultiPoint" === $a || "OrientedMultiPoint" === $a)
				if (Za = a.gv.defaultMarkerStyleWidth, Ka = a.gv.defaultMarkerStyleHeight, ib = [{
							shape: {
								type: "circle",
								cx: Za / 2,
								cy: Ka / 2,
								width: Za,
								height: Ka,
								scaleX: 1,
								scaleY: 1
							},
							style: ib
						}
					], "MultiPoint" === $a || "OrientedMultiPoint" === $a) {
					Ka = c.createGroup();
					Na.group.appendChild(Ka);
					Na.group = Ka;
					$a = 0;
					for (Za = Sa.length; $a < Za; $a++)
						c.drawVectorMarker({
							x: Sa[$a].x,
							y: Sa[$a].y
						}, ib, Na);
					b.shape = Ka
				} else
					b.shape = c.drawVectorMarker({
						x: Sa.x,
						y: Sa.y
					}, ib, Na);
			else if (Sa && 0 !== Sa.length)
				if ("Rectangle" === $a)
					b.shape = c.drawRectangle(Sa, ib, Na);
				else if ("Polygon" === $a)
					b.shape = c.drawPath(Sa, ib, Na);
				else if ("MultiPolygon" === $a) {
					$a = c.createGroup();
					Na.group.appendChild($a);
					Na.group = $a;
					Za = 0;
					for (Ka = Sa.length; Za < Ka; Za++)
						c.drawPath(Sa[Za], ib, Na);
					b.shape = $a
				}
		},
		getBindables: function () {
			return ["StartColor", "EndColor"]
		},
		resolve: function (b) {
			var c,
			Na;
			if (!this.bindings || 0 === this.bindings.length)
				return Na = this.stops1.length, this.stops1[0].color === this.origConfig.stops[0].color &&
				this.stops1[Na - 1].color === this.origConfig.stops[Na - 1].color || this.copyOrigStops(), this;
			c = 0;
			for (Na = this.bindings.length; c < Na; c++) {
				var Sa = this.bindings[c],
				$a = this.resolveBinding(Sa, b);
				"STARTCOLOR" === Sa.attribute ? a.notNull($a) && a.util.ValidationUtil.getColor($a) ? this.stops1[0].color = $a : this.stops1[0].color = this.origConfig.stops[0].color : "ENDCOLOR" === Sa.attribute && (a.notNull($a) && a.util.ValidationUtil.getColor($a) ? (Na = this.stops1.length, this.stops1[Na - 1].color = $a) : (Na = this.origConfig.stops.length, this.origConfig.stops[Na -
								1].color = $a))
			}
			return this
		}
	});
	a.style.LinearGradient = a.style.Gradient.extend({
		initialize: function Ja(a) {
			a.styleType = "LinearGradient";
			Ja.base.call(this, a);
			this.x1 = a.x1 || 0;
			this.y1 = a.y1 || 0;
			this.x2 = a.x2 || 0;
			this.y2 = a.y2 || 0
		},
		createStyle: function (a) {
			this.createGradientStop(a);
			this.fill = new a.oui.style.LinearGradient({
				x1: this.x1,
				y1: this.y1,
				x2: this.x2,
				y2: this.y2,
				stops: this.stops
			})
		}
	});
	a.style.Color = a.style.Style.extend({
		initialize: function Na(b) {
			b = b || {};
			b.styleType = "Color";
			Na.base.call(this, b);
			var c = a.util.ValidationUtil.getColor;
			this.stroke = a.notNull(b.stroke) && c(b.stroke) ? c(b.stroke) : a.PaintTypes.NO_PAINT;
			this.strokeOpacity = a.notNull(b.strokeOpacity) ? b.strokeOpacity : 1;
			this.strokeThickness = a.notNull(b.strokeThickness) ? parseFloat(b.strokeThickness) : 1;
			this.strokeDash = a.notNull(b.strokeDash) ? b.strokeDash : [];
			this.fill = a.notNull(b.fill) && c(b.fill) ? c(b.fill) : a.PaintTypes.NO_PAINT;
			this.fillOpacity = a.notNull(b.fillOpacity) ? b.fillOpacity : 1;
			this.gradient = b.gradient || "off";
			this.outlineStroke = a.notNull(b.outlineStroke) && c(b.outlineStroke) ?
				c(b.outlineStroke) : null;
			this.outlineStrokeThickness = a.notNull(b.outlineStrokeThickness) ? parseFloat(b.outlineStrokeThickness) : 1;
			this.fill === a.PaintTypes.NO_PAINT ? (this.fillOpacity = 0, this.noNativeFill = !0) : this.noNativeFill = !1;
			a.notNull(b.stroke) && (b.stroke = c(b.stroke));
			a.notNull(b.outlineStroke) && (b.outlineStroke = c(b.outlineStroke));
			a.notNull(b.fill) && (b.fill = c(b.fill))
		},
		resolve: function (b) {
			if (!this.bindings || 0 === this.bindings.length)
				return this;
			for (var c = 0, $a = this.bindings.length; c < $a; c++) {
				var ib =
					this.bindings[c],
				Za = this.resolveBinding(ib, b);
				"FILL" === ib.attribute ? (this.fill = Za, Za && a.util.ValidationUtil.getColor(Za)) ? this.noNativeFill && 0 === this.fillOpacity && (this.fillOpacity = 1) : this.fillOpacity = 0 : "STROKE" === ib.attribute ? (this.stroke = Za, Za && a.util.ValidationUtil.getColor(Za) || (this.stroke = a.PaintTypes.NO_PAINT)) : "STROKETHICKNESS" === ib.attribute && (this.strokeThickness = Number(Za), isNaN(Za))
			}
			return this
		},
		draw: function (b, c, $a) {
			this.resolve(b, Ka);
			var ib = b.geo,
			Za = $a.type ? $a.type : ib.type,
			Ka = c.getGraphics();
			"off" === this.gradient || 0 === this.fillOpacity || this.fill instanceof Ka.oui.style.LinearGradient || (this.fill = new Ka.oui.style.LinearGradient({
					x1: 0,
					y1: 0,
					x2: 1,
					y2: 1,
					stops: [new Ka.oui.style.GradientStop({
							offset: 0,
							color: "#eeffffff"
						}), new Ka.oui.style.GradientStop({
							offset: 1,
							color: this.fill
						})]
				}));
			var Xa,
			h;
			$a.screenPoints ? c = $a.screenPoints : (b.screenPoints || b.transformGeometry(ib), c = b.screenPoints);
			if ("Point" === Za || "OrientedPoint" === Za || "MultiPoint" === Za || "OrientedMultiPoint" === Za) {
				var eb = a.gv.defaultMarkerStyleWidth;
				Xa = a.gv.defaultMarkerStyleHeight;
				ib = [{
						shape: {
							type: "circle",
							cx: eb / 2,
							cy: Xa / 2,
							width: eb,
							height: Xa,
							scaleX: 1,
							scaleY: 1
						},
						style: this
					}
				];
				$a.width = eb;
				$a.height = Xa;
				if ("MultiPoint" === Za || "OrientedMultiPoint" === Za) {
					Za = Ka.createGroup();
					$a.group.appendChild(Za);
					$a.group = Za;
					Xa = 0;
					for (h = c.length; Xa < h; Xa++)
						Ka.drawVectorMarker({
							x: c[Xa].x,
							y: c[Xa].y
						}, ib, $a);
					b.shape = Za
				} else
					b.shape = Ka.drawVectorMarker({
						x: c.x,
						y: c.y
					}, ib, $a)
			} else if (c && 0 !== c.length)
				if (ib = {
						stroke: this.stroke,
						strokeOpacity: this.strokeOpacity,
						strokeThickness: this.strokeThickness,
						strokeDashArray: this.strokeDash,
						fill: this.fill,
						fillOpacity: this.fillOpacity
					}, eb = null, a.notNull(this.outlineStroke) && (eb = {
							stroke: this.outlineStroke,
							strokeThickness: 2 * this.outlineStrokeThickness + this.strokeThickness,
							fill: this.fill,
							fillOpacity: this.fillOpacity
						}), "LineString" === Za || "MultiLineString" === Za ? (ib.stroke || (ib.stroke = ib.fill ? ib.fill : "#000000"), ib.fill = null) : ib.fill === a.PaintTypes.NO_PAINT && (ib.fill = "#ffffff", ib.fillOpacity = 0), "LineString" === Za || "Polygon" === Za || "Rectangle" === Za)
					Xa = Ka.drawPath,
					"Rectangle" === Za && (Xa = Ka.drawRectangle), a.isNull(eb) ? b.shape = Xa.call(Ka, c, ib, $a) : (Za = Ka.createGroup(), $a.group.appendChild(Za), $a.group = Za, Xa.call(Ka, c, eb, $a), Xa.call(Ka, c, ib, $a), b.shape = Za);
				else if ("MultiLineString" === Za || "MultiPolygon" === Za) {
					Za = Ka.createGroup();
					$a.group.appendChild(Za);
					$a.group = Za;
					Xa = 0;
					for (h = c.length; Xa < h; Xa++)
						a.notNull(eb) && Ka.drawPath(c[Xa], eb, $a), Ka.drawPath(c[Xa], ib, $a);
					b.shape = Za
				}
		},
		getBindables: function () {
			return this.bindableAttrs ? this.bindableAttrs : this.bindableAttrs = ["Fill",
				"Stroke", "StrokeThickness"]
		},
		toXMLString: function () {
			var b;
			b = "" + ('\x3cstyle name\x3d"' + this.getStyleName() + '"\x3e');
			b = b + '\x3cg class\x3d"color" style\x3d"' + (a.notNull(this.stroke) ? "stroke:" + this.stroke + ";" : "");
			b += a.notNull(this.strokeOpacity) ? "stroke-opacity:" + Math.min(Math.round(255 * this.strokeOpacity), 255) + ";" : "";
			b += a.notNull(this.fill) ? "fill:" + this.fill + ";" : "";
			b += a.notNull(this.fillOpacity) ? "fill-opacity:" + Math.min(Math.round(255 * this.fillOpacity), 255) + ";" : "";
			return b += '"\x3e\x3c/g\x3e\x3c/style\x3e'
		}
	});
	a.style.Bucket = a.Class.extend({
		initialize: function (a) {
			this.seq = a.seq || 0;
			a.label && (this.label = a.label);
			a.labelStyle && (this.labelStyle = a.labelStyle)
		},
		evaluate: function () {
			return !1
		},
		clone: function () {
			return a.$.extend(!0, {}, this)
		}
	});
	a.style.RangedBucket = a.style.Bucket.extend({
		initialize: function Sa(b) {
			Sa.base.call(this, b);
			this.low = a.notNull(b.low) ? b.low : Number.NEGATIVE_INFINITY;
			this.high = a.notNull(b.high) ? b.high : Number.POSITIVE_INFINITY;
			this.includeHighValue = a.notNull(b.includeHighValue) ? b.includeHighValue :
				!1
		},
		evaluate: function (b) {
			if (a.isNull(b))
				return !1;
			a.$.isArray(b) && (b = b[0]);
			return this.includeHighValue ? b >= this.low && b <= this.high : b >= this.low && b < this.high
		},
		setIncludeHighValue: function (a) {
			this.includeHighValue = a
		},
		toXMLString: function () {
			var b;
			b = "\x3cRangedBucket" + (a.isNull(this.seq) ? "" : ' seq\x3d"' + this.seq + '"');
			b += a.isNull(this.label) ? "" : ' label\x3d"' + this.label + '"';
			b += a.isNull(this.labelStyle) ? "" : ' label_style\x3d"' + this.label + '"';
			b += a.isNull(this.low) ? "" : ' low\x3d"' + this.low + '"';
			b += a.isNull(this.high) ?
			"" : ' high\x3d"' + this.high + '"';
			return b + "/\x3e"
		}
	});
	a.style.CollectionBucket = a.style.Bucket.extend({
		initialize: function $a(a) {
			$a.base.call(this, a);
			this.keepWhiteSpace = a.keepWhiteSpace || !1;
			this.dataType = a.dataType || "string";
			this.values = a.values || []
		},
		evaluate: function (b) {
			var c = this.values.length;
			if (a.isNull(b) || 0 === c)
				return !1;
			a.$.isArray(b) && (b = b[0]);
			for (var Za = 0; Za < c; Za++)
				if (this.values[Za] == b)
					return !0;
			return !1
		},
		toXMLString: function (b) {
			var c;
			c = "\x3cCollectionBucket" + (a.isNull(this.seq) ? "" : ' seq\x3d"' +
					this.seq + '"');
			c += a.isNull(this.dataType) ? "" : ' type\x3d"' + this.dataType + '"';
			c += a.isNull(this.keep_white_space) || !0 !== this.keep_white_space ? "" : ' keep_white_space\x3d""true"';
			c += a.isNull(b) ? "" : ' style\x3d"' + b + '"';
			b = "";
			for (var Za = 0, Ka = this.values.length; Za < Ka; Za++)
				b += this.values[Za], Za < Ka - 1 && (b += ",");
			c = c + "\x3e" + b;
			return c += "\x3c/CollectionBucket\x3e"
		}
	});
	a.style.BucketStyle = a.style.Style.extend({
		initialize: function ib(b) {
			b = b || {};
			b.styleType = b.styleType || "BucketStyle";
			ib.base.call(this, b);
			b.style && b.buckets &&
			b.style !== b.buckets && a.util.Logger.warning("MAPVIEWER_9030", "OM.style.BucketStyle", "");
			this.styles = b.styles || [];
			0 === this.styles.length && "ColorScheme" !== b.styleType && "VariableMarker" !== b.styleType && a.util.Logger.warning("MAPVIEWER_9029", "OM.style.BucketStyle", "");
			this.gradient = b.gradient || "off";
			for (var Ka = this.styles.length, Xa = Array(Ka), h = 0, eb = this, wb = function (b, ya) {
				Xa[b] = ya;
				h += 1;
				if (h === Ka) {
					eb.styles = Xa;
					for (var ea = 0; ea < Ka; ea++)
						if ("off" !== eb.gradient && eb.styles[ea]instanceof a.style.Color) {
							eb.createGradients();
							break
						}
				}
			}, ob = 0; ob < Ka; ob++) {
				var ya = this.styles[ob];
				ya instanceof a.style.Style ? wb(ob, this.styles[ob]) : a.style.StyleStore.getServerSideStyle(ya.dataSource, ya.style, {
					url: ya.url,
					styleIdx: ob,
					callback: wb
				})
			}
			this.numClasses = b.numClasses || 5;
			this.defaultStyle = b.defaultStyle || null;
			this.buckets = b.buckets || [];
			b.classification || b.low === c || b.high === c || (this.buckets = this.createEqualBuckets(b.high, b.low));
			this.classification = b.classification || "equal";
			0 < this.buckets.length && "custom" !== this.classification && (a.util.Logger.info("MAPVIEWER_9028",
					"OM.style.BucketStyle", ""), this.classification = "custom");
			this.algorithm = b.algorithm || null;
			this.effects = b.effects || null;
			this.isNumeric = "undefined" === typeof b.isNumeric ? !0 : b.isNumeric;
			this.gradient = b.gradient || "off";
			this.options = b.options || {};
			this.checkRangedBuckets()
		},
		resolve: function (b) {
			var c = b.parentLayer.styleAttributes;
			this.generateBuckets(b.parentLayer.featureArray, c, !1);
			var Ka = b.attributes;
			if (Ka) {
				var Xa = null,
				h = a.notNull(c) ? c.length : 0;
				if (0 < h) {
					Xa = Ka[c[0].toUpperCase()];
					if (1 < h)
						for (Xa = [Xa], b = 1; b <
							h; b++)
							Xa.push(Ka[c[b].toUpperCase()]);
					return this.getRealStyle(Xa)
				}
				if (b.columns)
					return Xa = Ka[b.columns[0].toUpperCase()], this.getRealStyle(Xa)
			}
			return null
		},
		draw: function (a, b, c) {
			var Xa = this.resolve(a);
			Xa && Xa.draw(a, b, c)
		},
		generateBuckets: function (b, c, Ka) {
			this.buckets && 0 < this.buckets.length && (!Ka || this.buckets[0]instanceof a.style.CollectionBucket) || !b || 0 === b.length || !(c = c || b[0].columns) || (c = c instanceof Array ? c[0] : c, c = c.toUpperCase(), "equal" === this.classification ? this.buckets = this.equalRangeMethod(b,
						c) : "quantile" === this.classification || "quantiles" === this.classification ? this.buckets = this.quantilesMethod(b, c) : "logarithmic" === this.classification ? this.buckets = this.logarithmicMethod(b, c) : this.algorithm ? this.buckets = this.algorithm.call(this, b, c, this.numClasses, this.options) : "custom" === this.classification ? a.isNull(this.buckets) && a.util.Logger.warning("MAPVIEWER_9096", "OM.style.BucketStyle", "") : (a.util.Logger.warning("MAPVIEWER_9026", "OM.style.BucketStyle", ""), this.buckets = []), this.checkRangedBuckets())
		},
		checkRangedBuckets: function () {
			var b = this.buckets;
			if (!(a.isNull(b) || 0 === b.length || b[0]instanceof a.style.CollectionBucket)) {
				for (var c = -1, Ka, Xa = Number.NEGATIVE_INFINITY, h = 0; h < b.length; h++)
					Ka = b[h].high, a.notNull(Ka) && Ka > Xa && (Xa = Ka, c = h);
				b[c].setIncludeHighValue(!0)
			}
		},
		getDefaultStyle: function () {
			return this.defaultStyle
		},
		setDefaultStyle: function (a) {
			this.defaultStyle = a
		},
		getRealStyle: function (a) {
			if (typeof a === c || null === a)
				return this.defaultStyle;
			var b = this.buckets,
			Ka = this.buckets.length;
			if (b && 0 < Ka)
				for (var Xa =
						0; Xa < Ka; Xa++)
					if (b[Xa].evaluate(a))
						return this.styles[Xa];
			return this.defaultStyle
		},
		logarithmicMethod: function (a, b) {
			var c = this.getMinMaxValues(a, b);
			return this.createLogarithmicBuckets(c.max, c.min)
		},
		getMinMaxValues: function (b, c) {
			if ("_NUMBERINCLUSTER" === c)
				return this.getMinMaxNumbers(b);
			for (var Ka = null, Xa = null, h = b.length, eb, wb = a.util.ValidationUtil.isNumber2, ob = 0; ob < h; ob++)
				if ((eb = b[ob]) && eb.attributes && "undefined" !== typeof eb.attributes[c] && (eb = eb.attributes[c], a.notNull(eb))) {
					this.isNumeric && !wb(eb) &&
					(eb = Number(eb));
					if (a.isNull(Ka) || Ka > eb)
						Ka = eb;
					if (a.isNull(Xa) || eb > Xa)
						Xa = eb
				}
			return {
				min: Ka,
				max: Xa
			}
		},
		getMinMaxNumbers: function (a) {
			return {
				min: a[0],
				max: a[1]
			}
		},
		equalRangeMethod: function (a, b) {
			var c = this.getMinMaxValues(a, b);
			return this.createEqualBuckets(c.max, c.min)
		},
		createEqualBuckets: function (b, c) {
			for (var Ka = [], Xa = (b - c) / this.numClasses, h = c, eb = 1; eb <= this.numClasses; eb++)
				Ka[eb - 1] = new a.style.RangedBucket({
					low: h,
					high: h + Xa
				}), h += Xa;
			Ka[this.numClasses - 1].high++;
			return Ka
		},
		createLogarithmicBuckets: function (b,
			c) {
			for (var Ka = [], Xa = c, h = Math.log(Math.max(c, 1)), eb = (Math.log(Math.max(b, 1)) - h) / this.numClasses, wb = 1; wb <= this.numClasses; wb++) {
				var ob = Math.exp(h + eb * wb);
				Ka[wb - 1] = new a.style.RangedBucket({
					low: Xa,
					high: ob
				});
				Xa = ob
			}
			Ka[this.numClasses - 1].high++;
			return Ka
		},
		quantilesMethod: function () {
			return []
		},
		createGradients: function () {
			for (var b = this.styles, c, Ka = [], Xa = 0; Xa < b.length; Xa++)
				c = b[Xa], c instanceof a.style.Color ? Ka.push(new a.style.LinearGradient({
						stops: [{
								offset: 0,
								color: "#eeffffff"
							}, {
								offset: 1,
								color: c.fill
							}
						],
						x1: 0,
						y1: 0,
						x2: 1,
						y2: 1,
						stroke: c.stroke,
						fillOpacity: c.fillOpacity,
						strokeOpacity: c.strokeOpacity
					})) : Ka.push(c);
			this.styles = Ka
		},
		clearBuckets: function () {
			if ("equal" === this.classification || "quantile" === this.classification || "quantiles" === this.classification || "logarithmic" === this.classification || this.algorithm)
				this.buckets = []
		},
		toXMLString_substyles: function () {
			for (var b = "", c = "", c = null, Ka = 0, Xa = this.styles.length; Ka < Xa; Ka += 1)
				c = this.styles[Ka], c = a.isNull(c) ? "" : c.toXMLString(), a.isNull(c) || (b += c);
			c = this.defaultStyle;
			a.notNull(c) && !this.hasStyle(c) && (c = c.toXMLString(), b += c);
			return b
		},
		hasStyle: function (b) {
			for (var c = 0, Ka = this.styles.length; c < Ka; c += 1) {
				var Xa = this.styles[c];
				if (!a.isNull(Xa) && a.notNull(b.styleName) && a.notNull(Xa.styleName) && b.styleName.toUpperCase() === Xa.styleName.toUpperCase())
					return !0
			}
			return !1
		},
		toXMLString_adv: function () {
			var b = "",
			b = "";
			this.buckets.length !== this.styles.length && a.util.Logger.warning("", "OM.style.BucketStyle", "Number of buckets and styles do not match");
			for (var c = Math.min(this.buckets.length,
						this.styles.length), b = "\x3cBuckets" + (a.notNull(this.defaultStyle) ? ' default_style\x3d"' + this.defaultStyle.getStyleName() + '"' : ""), b = b + "\x3e", Ka = null, Xa = null, h = "", Ka = Ka = "", eb = 0; eb < c; eb += 1)
				Ka = this.buckets[eb], Xa = this.styles[eb], Ka instanceof a.style.CollectionBucket ? Ka = h = a.isNull(Ka) ? "" : Ka.toXMLString(Xa.getStyleName()) : (h = a.isNull(Ka) ? "" : Ka.toXMLString(), Ka = a.isNull(Ka) ? "" : Xa.getStyleName(), Ka = h.substring(0, h.length - 2) + ' style\x3d"' + Ka + '"/\x3e'), a.isNull(h) || (b += Ka);
			return b = '\x3cstyle name\x3d"' + this.styleName +
				'"\x3e\x3cAdvancedStyle\x3e\x3cBucketStyle\x3e' + (b + "\x3c/Buckets\x3e") + "\x3c/BucketStyle\x3e\x3c/AdvancedStyle\x3e\x3c/style\x3e"
		},
		toXMLString: function () {
			var a = this.toXMLString_adv();
			return this.toXMLString_substyles() + a
		}
	});
	a.style.ColorScheme = a.style.BucketStyle.extend({
		initialize: function Za(b) {
			b.styleType = "ColorScheme";
			Za.base.call(this, b);
			this.baseColor = a.notNull(b.baseColor) ? b.baseColor : null;
			this.fromColor = a.notNull(b.fromColor) ? b.fromColor : null;
			this.toColor = a.notNull(b.toColor) ? b.toColor : null;
			this.fillOpacity = a.notNull(b.fillOpacity) ? b.fillOpacity : 1;
			this.stroke = a.notNull(b.stroke) ? b.stroke : null;
			this.strokeOpacity = a.notNull(b.strokeOpacity) ? b.strokeOpacity : 1;
			this.strokeThickness = a.notNull(b.strokeThickness) ? parseFloat(b.strokeThickness) : 1;
			this.calculateColorStops()
		},
		calculateColorStops: function () {
			this.styles && 0 < this.styles.length || (this.fromColor && this.toColor ? this.calculateMultiHueStops() : this.baseColor ? this.calculateSingleHueStops() : a.util.Logger.warning("MAPVIEWER_9025", "OM.style.ColorScheme.calculateColorStops",
					""))
		},
		calculateSingleHueStops: function () {
			for (var b = a.style.ColorScheme.rgbStringParse(this.baseColor), b = a.style.Style.rgbToHsv(b), c = b.v / this.numClasses, h = 0; h < this.numClasses; h++) {
				var Cb = a.style.Style.hsvToRgb({
					h: b.h,
					s: b.s,
					v: b.v - h * c
				}),
				eb = Cb.r.toString(16);
				2 !== eb.length && (eb = "0" + eb);
				var wb = Cb.g.toString(16);
				2 !== wb.length && (wb = "0" + wb);
				Cb = Cb.b.toString(16);
				2 !== Cb.length && (Cb = "0" + Cb);
				eb = new a.style.Color({
					fill: "#" + eb + wb + Cb,
					fillOpacity: this.fillOpacity,
					stroke: this.stroke,
					strokeThickness: this.strokeThickness,
					strokeOpacity: this.strokeOpacity
				});
				this.styles.push(eb)
			}
		},
		calculateMultiHueStops: function () {
			for (var b = a.style.ColorScheme, c = b.rgbStringParse(this.fromColor), h = a.style.Style.rgbToHsv(c), c = b.rgbStringParse(this.toColor), Cb = a.style.Style.rgbToHsv(c), b = (Cb.h - h.h) / this.numClasses, c = (Cb.s - h.s) / this.numClasses, Cb = (Cb.v - h.v) / this.numClasses, eb = 0; eb < this.numClasses; eb++) {
				var wb = a.style.Style.hsvToRgb({
					h: h.h + b * eb,
					s: h.s + c * eb,
					v: h.v + Cb * eb
				}),
				ob = wb.r.toString(16);
				2 !== ob.length && (ob = "0" + ob);
				var ya = wb.g.toString(16);
				2 !== ya.length && (ya = "0" + ya);
				wb = wb.b.toString(16);
				2 !== wb.length && (wb = "0" + wb);
				ob = new a.style.Color({
					fill: "#" + ob + ya + wb,
					fillOpacity: this.fillOpacity,
					stroke: this.stroke,
					strokeThickness: this.strokeThickness,
					strokeOpacity: this.strokeOpacity
				});
				this.styles.push(ob)
			}
		},
		getColorStops: function () {
			var a = [];
			if (!this.styles)
				return a;
			for (var b = this.styles.length, c = 0; c < b; c++)
				a.push(this.styles[c].fill);
			return a
		}
	});
	a.style.ColorScheme.rgbStringParse = function (b) {
		var c = {};
		b = a.$.trim(b);
		c.r = parseInt(b[1] + b[2], 16);
		c.g = parseInt(b[3] +
				b[4], 16);
		c.b = parseInt(b[5] + b[6], 16);
		return c
	};
	a.style.HeatMap = a.style.Style.extend({
		initialize: function Ka(b) {
			b = b || {};
			b.styleType = "HeatMap";
			Ka.base.call(this, b);
			this.colorStops = a.notNull(b.colorStops) ? b.colorStops : null;
			this.opacity = a.notNull(b.opacity) ? b.opacity : 1;
			this.containerVectorLayer = a.notNull(b.containerVectorLayer) ? b.containerVectorLayer : null;
			this.lengthUnit = a.notNull(b.lengthUnit) ? b.lengthUnit : "pixel";
			"pixel" === this.lengthUnit ? this.spotlightRadius = a.notNull(b.spotlightRadius) ? b.spotlightRadius :
				5 : this.unitSpotlightRadius = a.notNull(b.spotlightRadius) ? b.spotlightRadius : 5;
			this.maxValue = a.notNull(b.maxValue) ? b.maxValue : null;
			this.minValue = a.notNull(b.minValue) ? b.minValue : null;
			this.sampleFactor = a.notNull(b.sampleFactor) ? b.sampleFactor : 2;
			this.isTop = a.notNull(b.isTop) ? b.isTop : !1
		},
		getBindables: function () {
			return this.bindableAttrs ? this.bindableAttrs : this.bindableAttrs = ["Heat"]
		},
		getDataValueFromBinding: function (a) {
			return this.bindings && 0 !== this.bindings.length ? this.resolveDataValue(this.bindings[0],
				a) : null
		},
		getIsTop: function () {
			return this.isTop
		},
		setIsTop: function (a) {
			this.isTop = a
		}
	});
	a.style.RadialGradient = a.style.Gradient.extend({
		initialize: function Xa(a) {
			a = a || {};
			a.styleType = "RadialGradient";
			Xa.base.call(this, a);
			this.cx = a.cx || 0;
			this.cy = a.cy || 0;
			this.radius = a.radius || 0
		},
		createStyle: function (a) {
			this.createGradientStop(a);
			this.fill = new a.oui.style.RadialGradient({
				cx: this.cx,
				cy: this.cy,
				radius: this.radius,
				stops: this.stops
			})
		}
	});
	a.style.PieSlice = function (a, b) {
		this.name = a;
		this.color = b
	};
	a.style.PieChart =
		a.style.Style.extend({
			initialize: function Cb(b) {
				b.styleType = "PieChart";
				if (b && b.pieSlices && !(1 > b.pieSlices.length)) {
					Cb.base.call(this, b);
					var c = b.pieSlices.length;
					this.colors = [];
					this.names = [];
					for (var ob = 0; ob < c; ob++) {
						var ya = b.pieSlices[ob];
						this.colors.push(ya.color);
						this.names.push(ya.name)
					}
					this.stroke = a.notNull(b.stroke) ? b.stroke : "#000000";
					this.strokeThickness = a.notNull(b.strokeThickness) ? parseFloat(b.strokeThickness) : 1;
					this.startingAngle = a.notNull(b.startingAngle) ? parseFloat(b.startingAngle) : 0;
					this.direction =
						a.notNull(b.direction) ? b.direction : "CCW";
					this.radius = a.notNull(b.radius) ? b.radius : 50;
					this.width = 2 * this.radius;
					this.height = 2 * this.radius;
					this.lengthUnit = a.notNull(b.lengthUnit) ? b.lengthUnit : "pixel";
					this.enableHighlight = b.enableHighlight ? b.enableHighlight : !1;
					this.maxlength = b.radiusPixelRange && b.radiusPixelRange.max ? 2 * b.radiusPixelRange.max : 5E3;
					this.minlength = b.radiusPixelRange && b.radiusPixelRange.min ? 2 * b.radiusPixelRange.min : 0;
					this.showOnPoint = 1
				}
			},
			resolve: function (a) {
				if (!this.bindings || 0 === this.bindings.length)
					return this;
				for (var b = 0, c = this.bindings.length; b < c; b++) {
					var ob = this.bindings[b],
					ya = this.resolveBinding(ob, a);
					"RADIUS" === ob.attribute ? (this.radius = ya, this.width = 2 * this.radius, this.height = 2 * this.radius) : "SIZE" === ob.attribute && (this.radius = ya / 2, this.height = this.width = ya)
				}
				return this
			},
			draw: function (b, c, h) {
				if (b.attributes) {
					this.resolve(b);
					var ob = c.getGraphics(),
					ya = h.sPoint,
					lb = this.colors,
					fa = this.names;
					if (fa && !(1 > fa.length)) {
						for (var ea = fa.length, ia = Array(ea), ta = 0; ta < ea; ta++) {
							var ka = b.getAttributeValue(fa[ta]);
							if (a.notNull(ka))
								ia[ta] =
									parseFloat(ka);
							else
								return
						}
						a.style.Style.calculateStyleSize(this, c);
						c = {
							cx: ya.x,
							cy: ya.y,
							width: this.realWidth,
							height: this.realHeight
						};
						h.stroke = this.stroke;
						h.strokeThickness = this.strokeThickness;
						this.enableHighlight && (h.plugable = !0, h.description = fa);
						h.offsetAngle = this.startingAngle;
						h.orientation = "CW" === this.direction ? 2 : 1;
						b.shape = ob.drawPieChart(c, ia, lb, h)
					}
				}
			},
			getBindables: function () {
				return this.bindableAttrs ? this.bindableAttrs : this.bindableAttrs = ["Radius", "Size"]
			}
		});
	a.style.VariableMarker = a.style.BucketStyle.extend({
		initialize: function eb(b) {
			b.styleType =
				"VariableMarker";
			eb.base.call(this, b);
			this.marker = a.notNull(b.marker) ? b.marker : null;
			this.startSize = a.notNull(b.startSize) ? b.startSize : 7;
			this.increament = a.notNull(b.increment) ? b.increment : 3;
			this.createAllMarkerStyles()
		},
		createAllMarkerStyles: function () {
			if (!(this.styles && 0 < this.styles.length))
				if (this.marker instanceof a.style.Marker) {
					this.styles = [];
					for (var b = 0; b < this.numClasses; b++) {
						var c = this.marker.clone();
						c.width = this.startSize + this.increament * b;
						c.height = c.width;
						c.calculateVectorMarkerScale();
						this.styles.push(c)
					}
				} else
					a.util.Logger.warning("MAPVIEWER_9024",
						a.style.VariableMarker.createAllMarkerStyles, "")
		}
	});
	a.style.Bar = function (a, b) {
		this.name = a;
		this.color = b
	};
	a.style.BarChart = a.style.Style.extend({
		initialize: function wb(b) {
			b.styleType = "BarChart";
			if (b && b.bars && !(1 > b.bars.length)) {
				wb.base.call(this, b);
				var ya = b.bars.length;
				this.colors = [];
				this.names = [];
				for (var lb = 0; lb < ya; lb++) {
					var c = b.bars[lb];
					this.colors.push(c.color);
					this.names.push(c.name)
				}
				this.stroke = a.notNull(b.stroke) ? b.stroke : "#000000";
				this.strokeThickness = a.notNull(b.strokeThickness) ? parseFloat(b.strokeThickness) :
					1;
				this.showXAxis = a.notNull(b.showXAxis) ? b.showXAxis : !1;
				this.showYAxis = a.notNull(b.showYAxis) ? b.showYAxis : !1;
				this.backGround = a.notNull(b.background) ? b.background : null;
				this.width = a.notNull(b.width) ? parseFloat(("" + b.width).replace(/[^\d.]/g, "")) : 100;
				this.height = a.notNull(b.height) ? parseFloat(("" + b.height).replace(/[^\d.]/g, "")) : 100;
				a.isNull(b.lengthUnit) ? this.lengthUnit = a.notNull(b.width) ? ("" + b.width).replace(/[0-9.]/g, "") : "pixel" : this.lengthUnit = b.lengthUnit;
				if (a.isNull(this.lengthUnit) || 0 === this.lengthUnit.length)
					this.lengthUnit =
						"pixel";
				this.enableHighlight = a.notNull(b.enableHighlight) ? b.enableHighlight : !1;
				this.maxlength = b.lengthPixelRange && b.lengthPixelRange.max ? b.lengthPixelRange.max : 5E3;
				this.minlength = b.lengthPixelRange && b.lengthPixelRange.min ? b.lengthPixelRange.min : 0;
				this.showOnPoint = 1
			}
		},
		resolve: function (a) {
			if (!this.bindings || 0 === this.bindings.length)
				return this;
			for (var b = 0, ya = this.bindings.length; b < ya; b++) {
				var lb = this.bindings[b],
				c = this.resolveBinding(lb, a);
				"SIZE" === lb.attribute ? this.origConfig.width && this.origConfig.height &&
				this.origConfig.width !== this.origConfig.height ? (this.height = this.origConfig.height * c / this.origConfig.width, this.width = c) : this.height = this.width = c : "WIDTH" === lb.attribute ? this.width = c : "HEIGHT" === lb.attribute && (this.height = c)
			}
			return this
		},
		draw: function (b, c, ya) {
			this.resolve(b);
			if (b.attributes) {
				var lb = c.getGraphics(),
				fa = ya.sPoint,
				ea = this.colors,
				ia = this.names;
				if (ia && !(1 > ia.length)) {
					for (var ta = ia.length, ka = Array(ta), oa = 0; oa < ta; oa++) {
						var xa = b.getAttributeValue(ia[oa]);
						if (a.notNull(xa))
							ka[oa] = parseFloat(xa);
						else
							return
					}
					a.style.Style.calculateStyleSize(this, c);
					c = {
						cx: fa.x,
						cy: fa.y,
						width: this.realWidth,
						height: this.realHeight
					};
					ya.stroke = this.stroke;
					ya.strokeThickness = this.strokeThickness;
					this.enableHighlight && (ya.plugable = !0, ya.description = ia);
					b.shape = lb.drawBarChart(c, ka, ea, ya)
				}
			}
		},
		getBindables: function () {
			return this.bindableAttrs ? this.bindableAttrs : this.bindableAttrs = ["Size", "Width", "Height"]
		}
	});
	a.style.Line = a.style.Style.extend({
		initialize: function ob(b) {
			b = b || {};
			b.styleType = "Line";
			ob.base.call(this, b);
			var lb = a.util.ValidationUtil.getColor,
			c = a.PaintTypes.NO_PAINT;
			this.stroke = b.stroke && lb(b.stroke) ? lb(b.stroke) : a.PaintTypes.NO_PAINT;
			this.strokeOpacity = a.notNull(b.strokeOpacity) ? parseFloat(b.strokeOpacity) : 1;
			this.strokeDash = b.strokeDash || [];
			this.strokeLineCap = b.strokeLineCap || a.LineCaps.ROUND;
			this.strokeLineJoin = b.strokeLineJoin || a.LineJoins.ROUND;
			this.fill = a.notNull(b.fill) && lb(b.fill) ? lb(b.fill) : c;
			this.fillOpacity = a.notNull(b.fillOpacity) ? parseFloat(b.fillOpacity) : 1;
			this.centerLine = a.notNull(b.centerLine) &&
				lb(b.centerLine) ? lb(b.centerLine) : c;
			this.markerPattern = b.markerPattern || null;
			a.notNull(b.startMarker) && (b.startMarker.vectorDef && b.startMarker.getFNFormat() ? this.markerStart = b.startMarker.getFNFormat() : b.startMarker.d ? this.markerStart = b.startMarker : this.startMarker = b ? b.startMarker : null);
			a.notNull(b.endMarker) && (b.endMarker.vectorDef && b.endMarker.getFNFormat() ? this.markerEnd = b.endMarker.getFNFormat() : b.endMarker.d ? this.markerEnd = b.endMarker : this.endMarker = b ? b.endMarker : null);
			this.oriented = b ? b.orientedMarker :
				!1;
			this.centerLineDash = b.centerLineDash || [];
			this.cased = !1;
			this.lengthUnit = b.lengthUnit ? b.lengthUnit : "pixel";
			"pixel" === this.lengthUnit ? (this.fillWidth = b && a.notNull(b.fillWidth) && this.fill !== c ? parseFloat(b.fillWidth) : 0, this.centerLineWidth = b && a.notNull(b.centerLineWidth) && this.centerLine !== c ? parseFloat(b.centerLineWidth) : 0, this.strokeThickness = b && a.notNull(b.strokeThickness) && this.stroke !== c ? parseFloat(b.strokeThickness) : 1) : (this.unitFillWidth = b && a.notNull(b.fillWidth) && this.fill !== c ? parseFloat(b.fillWidth) :
					0, this.unitCenterLineWidth = b && a.notNull(b.centerLineWidth) && this.centerLine !== c ? parseFloat(b.centerLineWidth) : 0, this.unitStrokeThickness = b && a.notNull(b.strokeThickness) && this.stroke !== c ? parseFloat(b.strokeThickness) : 1);
			this.calculateRealSize()
		},
		calculateRealSize: function () {
			var b = null;
			this.stylelist = [];
			var ya = a.PaintTypes.NO_PAINT;
			this.stroke !== ya && 0 < this.strokeThickness && (b = {
					stroke: this.stroke,
					strokeThickness: 0 < this.fillWidth ? 2 * this.strokeThickness + this.fillWidth : this.strokeThickness,
					strokeLineCap: this.strokeLineCap,
					strokeLineJoin: this.strokeLineJoin,
					strokeDashArray: this.strokeDash,
					strokeOpacity: this.strokeOpacity
				}, this.markerStart && (b.markerStart = this.markerStart), this.markerEnd && (b.markerEnd = this.markerEnd), this.stylelist.push(b));
			this.fill !== ya && 0 < this.fillWidth && (b = {
					stroke: this.fill,
					strokeThickness: this.fillWidth,
					strokeLineCap: this.strokeLineCap,
					strokeLineJoin: this.strokeLineJoin,
					strokeDashArray: this.strokeDash,
					strokeOpacity: this.fillOpacity
				}, this.markerStart && (b.markerStart = this.markerStart), this.markerEnd &&
				(b.markerEnd = this.markerEnd), this.stylelist.push(b));
			this.centerLine !== ya && 0 < this.centerLineWidth && (0 === this.fillWidth || this.fill !== this.centerLine) && (b = {
					stroke: this.centerLine,
					strokeThickness: this.centerLineWidth,
					strokeLineCap: this.strokeLineCap,
					strokeLineJoin: this.strokeLineJoin,
					strokeDashArray: this.centerLineDash
				}, this.stylelist.push(b));
			(this.startMarker || this.endMarker) && this.stylelist.push({})
		},
		resolve: function (a) {
			if (!this.bindings || 0 === this.bindings.length)
				return this;
			for (var b = 0, lb = this.bindings.length; b <
				lb; b++) {
				var c = this.bindings[b],
				ea = this.resolveBinding(c, a);
				"FILL" === c.attribute ? this.fill = ea : "FILLWIDTH" === c.attribute && (this.fillWidth = ea)
			}
			this.calculateRealSize();
			return this
		},
		draw: function (b, ya, lb) {
			this.resolve(b);
			var c = this.origConfig;
			a.notNull(c.startMarker) && c.startMarker.vectorDef && c.startMarker.getFNFormat && (this.markerStart = c.startMarker.getFNFormat(b));
			a.notNull(c.endMarker) && c.endMarker.vectorDef && c.endMarker.getFNFormat && (this.markerEnd = c.endMarker.getFNFormat(b));
			var ea = b.geo,
			c = lb.type ?
				lb.type : ea.type;
			if ("Point" !== c && "OrientedPoint" !== c && "MultiPoint" !== c && "OrientedMultiPoint" !== c) {
				var ia = ya.getGraphics();
				lb.screenPoints ? ea = lb.screenPoints : (b.screenPoints || b.transformGeometry(ea), ea = b.screenPoints);
				if (ea && 0 !== ea.length) {
					var ta,
					ka;
					a.style.Style.calculateStyleSize(this, ya);
					if ("LineString" === c || "Polygon" === c)
						"LineString" === c && (this.totalLengthInPx = this.calcLength(ea[0])), this.drawLine(ya, ea, lb.group, "Polygon" === c, b);
					else if ("Rectangle" === c)
						this.drawLine(ya, [[ea.x, ea.y, ea.x + ea.width,
									ea.y, ea.x + ea.width, ea.y + ea.height, ea.x, ea.y + ea.height, ea.x, ea.y]], lb.group, !0, b);
					else if ("MultiLineString" === c || "MultiPolygon" === c) {
						if (this.cased) {
							ta = [];
							ka = lb.group.length;
							for (var oa = 0; oa < ka; oa++)
								ta[oa] = ia.createGroup(), lb.group[oa].appendChild(ta[oa])
						} else
							ta = ia.createGroup(), lb.group.appendChild(ta);
						ka = ea.length;
						this.totalLengthInPx = 0;
						if ("MultiLineString" === c)
							for (lb = 0; lb < ka; lb++)
								this.totalLengthInPx += this.calcLength(ea[lb][0]);
						for (lb = 0; lb < ka; lb++)
							this.drawLine(ya, ea[lb], ta, "MultiPolygon" === c, b);
						b.shapeGroup = ta
					}
					b.shapeGroup && 0 < b.shapeGroup.length ? (b.shape = b.shapeGroup[0], 1 === b.shapeGroup.length && (b.shapeGroup = null)) : (b.shape = b.shapeGroup, b.shapeGroup = null)
				}
			}
		},
		drawLine: function (b, ya, c, fa, ea) {
			var ia = this.stylelist,
			ta = ia.length,
			ka = {
				group: c
			},
			oa = b.getGraphics();
			ea.shapeGroup = [];
			for (var xa = 0; xa < ta; xa++) {
				var Ma = ia[xa];
				Ma.stroke && (this.cased && (ka.group = c[xa]), Ma = {
						stroke: Ma.stroke,
						strokeThickness: Ma.strokeThickness,
						strokeLineCap: Ma.strokeLineCap.toLowerCase(),
						strokeDashArray: Ma.strokeDashArray,
						strokeOpacity: Ma.strokeOpacity,
						markerStart: Ma.markerStart,
						markerEnd: Ma.markerEnd
					}, fa && (Ma.fill = a.PaintTypes.NO_PAINT, Ma.fillOpacity = 0), ea.shapeGroup.push(oa.drawPath(ya, Ma, ka)))
			}
			c = c.length ? c[xa - 1] : c;
			this.startMarker && !this.markerStart && (ka = Math.atan2(ya[0][3] - ya[0][1], ya[0][2] - ya[0][0]), this.drawMarker(this.startMarker, ea, b, c, {
					x: ya[0][0],
					y: ya[0][1],
					angle: ka
				}));
			this.endMarker && !this.markerEnd && (fa = ya[0].length, ka = Math.atan2(ya[0][fa - 1] - ya[0][fa - 3], ya[0][fa - 2] - ya[0][fa - 4]), this.drawMarker(this.endMarker, ea, b, c, {
					x: ya[0][fa - 2],
					y: ya[0][fa -
						1],
					angle: ka
				}));
			if (a.notNull(this.markerPattern) && a.notNull(this.markerPattern.markers) && 0 < this.markerPattern.markers.length)
				if (oa = [], fa = ya[0], !0 === this.markerPattern.serverLineArrow)
					if (!0 === this.markerPattern.startAndEndMarers)
						ia = this.markerPattern.markers[0], ia.height = this.markerPattern.markerHeight, ia.width = this.markerPattern.markerWidth, ia.lengthUnit = this.markerPattern.lengthUnit, ia.max_size_in_px = this.markerPattern.max_size_in_px, ia.vectorDef && ia.calculateVectorMarkerScale(), ka = Math.atan2(ya[0][3] -
								ya[0][1], ya[0][2] - ya[0][0]), this.drawMarker(ia, ea, b, c, {
							x: ya[0][0],
							y: ya[0][1],
							angle: ka
						}), fa = ya[0].length, ka = Math.atan2(ya[0][fa - 1] - ya[0][fa - 3], ya[0][fa - 2] - ya[0][fa - 4]), this.drawMarker(ia, ea, b, c, {
							x: ya[0][fa - 2],
							y: ya[0][fa - 1],
							angle: ka
						});
					else if (a.notNull(this.markerPattern.percent) && 0 < this.markerPattern.percent) {
						ka = a.util.GeomUtil;
						ia = oa = 0;
						for (ta = fa.length; ia < ta - 3; ia += 2)
							oa += ka.getSegmentLength(fa[ia], fa[ia + 1], fa[ia + 2], fa[ia + 3]);
						ia = oa * this.markerPattern.percent;
						fa = ya[0];
						oa = this.getMarkerDrawPosition(ia,
								fa);
						ya = {};
						ya.height = this.markerPattern.markerHeight;
						ya.width = this.markerPattern.markerWidth;
						ya.lengthUnit = this.markerPattern.lengthUnit;
						ya.max_size_in_px = this.markerPattern.max_size_in_px;
						!0 !== this.markerPattern.multipleMarker ? 0 < oa.length && (0 < oa.length && oa.splice(0, 1), 1 < oa.length && oa.splice(1, oa.length - 1)) : 0 < oa.length && oa.splice(0, 1);
						this.drawMarkers({
							feature: ea,
							mapContext: b,
							pointArray: oa,
							group: c,
							oriented: this.markerPattern.oriented,
							serverLineArrowSize: ya
						})
					} else {
						if (!0 === this.markerPattern.vertexes) {
							oa =
								[];
							ia = 0;
							for (ta = fa.length; ia < ta - 2; ia += 2)
								ka = ia + 3 < ta ? Math.atan2(fa[ia + 3] - fa[ia + 1], fa[ia + 2] - fa[ia]) : 0, ya = {
									x: fa[ia],
									y: fa[ia + 1],
									angle: ka
								},
							oa.push(ya);
							ya = {};
							ya.height = this.markerPattern.markerHeight;
							ya.width = this.markerPattern.markerWidth;
							ya.lengthUnit = this.markerPattern.lengthUnit;
							ya.max_size_in_px = this.markerPattern.max_size_in_px;
							this.drawMarkers({
								feature: ea,
								mapContext: b,
								pointArray: oa,
								group: c,
								oriented: this.markerPattern.oriented,
								serverLineArrowSize: ya
							})
						}
					}
				else {
					ka = a.util.GeomUtil;
					if (a.isNull(this.markerPattern.intervalUnit) ||
						"" === this.markerPattern.intervalUnit)
						this.markerPattern.intervalUnit = "pixel";
					ia = this.markerPattern.interval / ka.getCurrentDistancePerPixel(b, this.markerPattern.intervalUnit);
					oa = this.getMarkerDrawPosition(ia, fa);
					this.drawMarkers({
						feature: ea,
						mapContext: b,
						pointArray: oa,
						group: c,
						oriented: this.markerPattern.oriented
					})
				}
		},
		getMarkerDrawPosition: function (b, ya) {
			for (var c = [], fa = 0, ea = a.util.GeomUtil, ia = 0, ta = ya.length; ia < ta - 3; ) {
				var ka = null,
				oa = ea.getSegmentLength(ya[ia], ya[ia + 1], ya[ia + 2], ya[ia + 3]),
				xa = b * c.length;
				fa + oa >= xa ? (ka = (xa - fa) / oa, ka = {
						x: ya[ia] + (ya[ia + 2] - ya[ia]) * ka,
						y: ya[ia + 1] + (ya[ia + 3] - ya[ia + 1]) * ka
					}, ka.angle = Math.atan2(ya[ia + 3] - ya[ia + 1], ya[ia + 2] - ya[ia])) : (fa += oa, ia += 2);
				ka && c.push(ka)
			}
			return c
		},
		drawMarkers: function (b) {
			var ya = b.feature,
			c = b.mapContext,
			fa = b.pointArray,
			ea = b.group;
			b = b.serverLineArrowSize;
			for (var ia = this.totalLengthInPx, ta = 0; ta < fa.length; ta++) {
				var ka = {
					group: ea,
					markerPoint: fa[ta]
				},
				oa = this.markerPattern.markers[ta % this.markerPattern.markers.length];
				a.notNull(b) && (oa.height = b.height, oa.width =
						b.width, oa.lengthUnit = b.lengthUnit, oa.max_size_in_px = b.max_size_in_px, oa.noShowCap = ia, oa.vectorDef && oa.calculateVectorMarkerScale());
				a.notNull(oa) && a.notNull(oa.draw) && oa.draw(ya, c, ka)
			}
		},
		drawMarker: function (a, b, c, fa, ea) {
			fa = {
				group: fa,
				markerPoint: ea
			};
			a.noShowCap = this.totalLengthInPx;
			a.draw(b, c, fa)
		},
		getBindables: function () {
			return this.bindableAttrs ? this.bindableAttrs : this.bindableAttrs = ["Fill", "FillWidth"]
		},
		getOverallThickness: function () {
			1 > this.strokeThickness && (this.strokeThickness = 1);
			var a = 1;
			return a =
				0 < this.fillWidth ? 2 * this.strokeThickness + this.fillWidth : this.strokeThickness
		},
		getOverallLine: function () {
			var b = this.getOverallThickness(),
			ya = "",
			c = "#000000",
			c = a.notNull(this.fill) && 0 < this.fillWidth ? this.fill : this.stroke,
			ya = ya + ("fill:" + c + ";") + (a.notNull(this.strokeThickness) ? "stroke-width:" + b + ";" : ""),
			ya = ya + (a.notNull(this.strokeOpacity) ? "fill-opacity:" + Math.min(Math.round(255 * this.strokeOpacity), 255) + ";" : "");
			return ya += a.notNull(this.strokeLineCap) ? "stroke-linecap:" + this.strokeLineCap : ""
		},
		getOverallLine_strokeDash: function () {
			var b =
				this.getOverallThickness(),
			ya = "",
			c = "#000000",
			c = a.notNull(this.fill) && 0 < this.fillWidth ? this.fill : this.stroke,
			ya = ya + ("fill:" + c + ";");
			0 < this.strokeDash.length && (a.isNull(this.fill) || 0 === this.fillWidth) && (ya += "fill-opacity:0;");
			ya += a.notNull(this.strokeThickness) ? "stroke-width:" + b + ";" : "";
			return ya += a.notNull(this.strokeLineCap) ? "stroke-linecap:" + this.strokeLineCap : ""
		},
		getParallelLine: function () {
			var b = "";
			a.notNull(this.fill) && 0 < this.fillWidth ? (b = '\x3cline class\x3d"parallel"' + (' style\x3d"fill:' + this.stroke +
						";stroke-width:" + this.strokeThickness + '"'), b += "/\x3e") : a.notNull(this.centerLine) && 0 < this.centerLineWidth && (b = Math.max((this.strokeThickness - this.centerLineWidth) / 2, 0), b = '\x3cline class\x3d"parallel"' + (' style\x3d"fill:' + this.stroke + ";stroke-width:" + b + '"/\x3e'), b += "/\x3e");
			return b
		},
		getParallelLine_strokeDash: function () {
			var b = "",
			ya;
			a.notNull(this.fill) && 0 < this.fillWidth ? (b = '\x3cline class\x3d"parallel" style\x3d"fill:' + this.stroke, b += a.notNull(this.strokeOpacity) ? ";fill-opacity:" + Math.min(Math.round(255 *
						this.strokeOpacity), 255) + ";" : "", b += ";stroke-width:" + this.strokeThickness + '"', b += "/\x3e") : a.notNull(this.centerLine) && 0 < this.centerLineWidth && (ya = Math.max((this.strokeThickness - this.centerLineWidth) / 2, 0), b = '\x3cline class\x3d"parallel" style\x3d"fill:' + this.stroke, b += a.notNull(this.strokeOpacity) ? ";fill-opacity:" + Math.min(Math.round(255 * this.strokeOpacity), 255) + ";" : "", b += ";stroke-width:" + ya + '"', 0 < this.strokeDash.length && (b += ' dash\x3d"' + this.strokeDash[0] + "," + this.strokeDash[1] + '"'), b += "/\x3e/\x3e");
			return b
		},
		getCenterLine: function () {
			var b = "";
			a.notNull(this.centerLine) && 0 < this.centerLineWidth ? (b = '\x3cline class\x3d"base" style\x3d"fill:' + this.centerLine + ";stroke-width:" + this.centerLineWidth + '"', 0 < this.centerLineDash.length && (b += ' dash\x3d"' + this.centerLineDash[0] + "," + this.centerLineDash[1] + '"'), b += "/\x3e") : a.notNull(this.fill) && 0 < this.fillWidth ? (b = '\x3cline class\x3d"base" style\x3d"fill:' + this.fill + ";stroke-width:" + this.fillWidth + '"', 0 < this.centerLineDash.length && (b += ' dash\x3d"' + this.centerLineDash[0] +
					"," + this.centerLineDash[1] + '"'), b += "/\x3e") : b = '\x3cline class\x3d"base"/\x3e';
			return b
		},
		getCenterLine_strokeDash: function () {
			var b = "";
			2 === this.strokeDash.length ? (b = '\x3cline class\x3d"base" style\x3d"fill:' + this.stroke + ";", b += a.notNull(this.strokeOpacity) ? "fill-opacity:" + Math.min(Math.round(255 * this.strokeOpacity), 255) + ";" : "", b += "stroke-width:" + this.strokeThickness + '"', b += ' dash\x3d"' + this.strokeDash[0] + "," + this.strokeDash[1] + '"', b += "/\x3e") : b = '\x3cline class\x3d"base"/\x3e';
			return b
		},
		getCenterLine_centerLineDash: function () {
			var a =
				"";
			2 === this.centerLineDash.length ? (a = '\x3cline class\x3d"base" style\x3d"fill:' + this.centerLine + ";", a += "stroke-width:" + this.centerLineWidth + '"', a += ' dash\x3d"' + this.centerLineDash[0] + "," + this.centerLineDash[1] + '"', a += "/\x3e") : a = '\x3cline class\x3d"base"/\x3e';
			return a
		},
		toXMLString: function () {
			var a = "",
			b = "",
			c = "";
			0 === this.strokeDash.length && 0 === this.centerLineDash.length ? (a = this.getOverallLine(), b = this.getParallelLine(), c = this.getCenterLine()) : 0 !== this.strokeDash.length && 0 === this.centerLineDash.length ?
			(a = this.getOverallLine_strokeDash(), b = this.getParallelLine(), c = this.getCenterLine_strokeDash()) : (0 === this.strokeDash.length && 0 !== this.centerLineDash.length ? a = this.getOverallLine() : (a = this.getOverallLine_strokeDash(), b = this.getParallelLine_strokeDash()), c = this.getCenterLine_centerLineDash());
			var fa = '\x3cstyle name\x3d"' + this.getStyleName() + '"\x3e';
			return fa + ('\x3cg class\x3d"line" style\x3d"' + a + '"\x3e' + b + c + "\x3c/g\x3e\x3c/style\x3e")
		},
		calcLength: function (a) {
			for (var b = 0, c, fa, ea = 2, ia = a.length; ea < ia; ea +=
				2)
				c = a[ea] - a[ea - 2], fa = a[ea + 1] - a[ea - 1], b += Math.sqrt(c * c + fa * fa);
			return b
		}
	});
	a.style.Marker = a.style.Style.extend({
		initialize: function ya(b) {
			b = b || {};
			b.styleType = "Marker";
			ya.base.call(this, b);
			this.width = a.notNull(b.width) ? b.width : null;
			this.height = a.notNull(b.height) ? b.height : null;
			this.max_size_in_px = a.notNull(b.max_size_in_px) ? b.max_size_in_px : null;
			this.xOffset = a.notNull(b.xOffset) ? b.xOffset : 0;
			this.yOffset = a.notNull(b.yOffset) ? b.yOffset : 0;
			this.lengthUnit = a.notNull(b.lengthUnit) ? b.lengthUnit : "pixel";
			this.src =
				a.notNull(b.src) ? b.src : null;
			this.textStyle = a.notNull(b.textStyle) ? b.textStyle : null === b.textStyle ? null : c;
			this.gradient = a.notNull(b.gradient) ? b.gradient : null;
			this.src && (a.isNull(this.width) || a.isNull(this.height)) && this.loadImgFromSource();
			this.nullFill = a.notNull(b.nullFillSrc) ? b.nullFillSrc : null;
			if (this.vectorDef = a.notNull(b.vectorDef) ? b.vectorDef : null)
				this.normalizeSVGPaths(), this.calculateVectorMarkerScale();
			this.textOffset = b.textOffset ? b.textOffset : null;
			this.showOnPoint = 2;
			this.realHeightInPx = this.realWidthInPx =
				null
		},
		normalizeSVGPaths: function () {
			if (this.vectorDef && 0 < this.vectorDef.length)
				for (var b = this.vectorDef.length, c = 0; c < b; c++) {
					var fa = this.vectorDef[c].shape;
					if (fa && "svg" === fa.type) {
						var ea = fa.svgPath,
						ia = a.util.PathUtils.createPathArray(ea),
						ea = a.util.PathUtils.getBBox(ea),
						ia = a.util.PathUtils.transformPath(ia, 0 - ea.minX, 0 - ea.minY, 1, 1);
						fa.svgPath = ia
					}
				}
		},
		loadImgFromSource: function () {
			var b = this,
			c = new Image;
			c.src = this.src;
			c.onload = function () {
				a.isNull(b.width) && (b.width = c.width);
				a.isNull(b.height) && (b.height =
						c.height);
				b.origConfig && (b.origConfig.width = c.width, b.origConfig.height = c.height)
			}
		},
		resolve: function (b) {
			if (!this.bindings || 0 === this.bindings.length)
				return this;
			for (var c = 0, fa = this.bindings.length; c < fa; c++) {
				var ea = this.bindings[c],
				ia = this.resolveBinding(ea, b);
				if ("FILL" === ea.attribute || "SVGPATH" === ea.attribute) {
					var ta = this.vectorDef && 0 < this.vectorDef.length ? this.vectorDef[0] : null;
					ta && ("FILL" === ea.attribute ? (ta.style.fill = ia, this.isBound("FILL") && 1 === this.bindings.length && (this.width = ia === a.PaintTypes.NO_PAINT ?
									0 : a.notNull(this.origConfig.width) ? this.origConfig.width : null)) : (ta.shape = {}, ta.shape.type = "svg", ta.shape.svgPath = ia))
				} else
					"SIZE" === ea.attribute ? this.origConfig.width && this.origConfig.height && this.origConfig.width !== this.origConfig.height ? (this.height = this.origConfig.height * ia / this.origConfig.width, this.width = ia) : this.height = this.width = ia : "WIDTH" === ea.attribute ? this.width = ia : "HEIGHT" === ea.attribute ? this.height = ia : "SOURCE" === ea.attribute && (this.src = ia, this.loadImgFromSource())
			}
			(a.isNull(this.width) ||
				isNaN(this.width)) && a.notNull(this.origConfig.width) && (this.width = this.origConfig.width);
			(a.isNull(this.height) || isNaN(this.height)) && a.notNull(this.origConfig.height) && (this.height = this.origConfig.height);
			this.calculateVectorMarkerScale();
			return this
		},
		draw: function (b, c, fa) {
			this.resolve(b);
			var ea = b.geo,
			ia = b.geo.type,
			ta;
			if (fa.markerPoint && b.shapeGroup)
				c = this.drawMarker(c, fa.group, fa.markerPoint, b.markerText), a.notNull(c) && b.shapeGroup.push(c);
			else if (fa.sPoint)
				b.shape = this.drawMarker(c, fa.group, fa.sPoint,
						b.markerText);
			else if ("LineString" === ia || "MultiLineString" === ia)
				a.isNull(b.screenPoints) && (b.labelBox ? ta = new a.geometry.Point((b.labelBox[0] + b.labelBox[2]) / 2, (b.labelBox[1] + b.labelBox[3]) / 2, ea.srid) : (ta = ea.mbr || ea.getMBR(), ta = new a.geometry.Point((ta.getMinX() + ta.getMaxX()) / 2, (ta.getMinY() + ta.getMaxY()) / 2, ea.srid)), b.screenPoints = b.transformGeometry(ta)), b.shape = this.drawMarker(c, fa.group, b.screenPoints, b.markerText);
			else if ("string" === typeof this.nullFill && (this.nullFill = c.getGraphics().createFillPattern(this.nullFill)),
				"Polygon" === ia || "MultiPolygon" === ia)
				b.screenPoints || (ta = null, b.labelBox ? ta = new a.geometry.Point((b.labelBox[0] + b.labelBox[2]) / 2, (b.labelBox[1] + b.labelBox[3]) / 2, ea.srid) : ea.mbr && (ta = new a.geometry.Point((ea.mbr.getMinX() + ea.mbr.getMaxX()) / 2, (ea.mbr.getMinY() + ea.mbr.getMaxY()) / 2, ea.srid)), ta = b.transformGeometry(ta), b.screenPoints || (b.screenPoints = ta)), b.shape = this.drawMarker(c, fa.group, b.screenPoints, b.markerText);
			else if (b.screenPoints || b.transformGeometry(ea), "Point" === ia || "OrientedPoint" === ia)
				b.renderingStyle &&
				b.renderingStyle.textStyle ? (ea = b.markerText, a.isNull(ea) && (b.renderingStyle.textStyle.from_marker_hints && b.labelStyleName === b.styleName && b.attributes ? ea = b.attributes._LABEL_ : !1 === b.renderingStyle.textStyle.isServerSide && a.notNull(b.parentLayer) && b.parentLayer.type === a.layer.VectorLayer.TYPE_DATAPACK && (ea = b.attributes._LABEL_)), b.shape = this.drawMarker(c, fa.group, b.screenPoints, ea)) : b.shape = this.drawMarker(c, fa.group, b.screenPoints, b.markerText), a.isNull(b.renderingStyle) || (b.markerWidth = this.realWidthInPx,
					b.markerHeight = this.realWidthInPx), this.markerText && this.drawMarker(c, ta, b.screenPoints, b.markerText);
			else if ("MultiPoint" === ia || "OrientedMultiPoint" === ia) {
				ta = c.getGraphics().createGroup();
				fa.group.appendChild(ta);
				fa = 0;
				for (ea = b.screenPoints.length; fa < ea; fa++)
					this.drawMarker(c, ta, b.screenPoints[fa], b.markerText);
				b.shape = ta
			}
		},
		drawMarker: function (b, c, fa, ea) {
			if (0 !== this.width && 0 !== this.height) {
				var ia = {
					group: c,
					xOffset: this.isSVGType ? this.svg_xOffset + this.xOffset : this.xOffset,
					yOffset: this.isSVGType ? this.svg_yOffset +
					this.yOffset : this.yOffset
				};
				fa.angle && (ia.angle = fa.angle);
				var ta = b.getGraphics(),
				ka = {
					lengthUnit: this.lengthUnit,
					width: this.width,
					height: this.height,
					max_size_in_px: this.max_size_in_px
				},
				oa,
				xa;
				if (this.src) {
					ka.width = this.width;
					ka.height = this.height;
					ka.src = this.src;
					ia.enableCache = !0;
					a.style.Style.calculateStyleSize(ka, b);
					this.realWidthInPx = ka.realWidth;
					this.realHeightInPx = ka.realHeight;
					b = this.noShowCap;
					var Ma = this.realWidthInPx,
					rb = this.realHeightInPx;
					if (!(a.isNull(b) || b > Ma && b > rb))
						return;
					ka.width = ka.realWidth;
					ka.height = ka.realHeight;
					ia = ta.drawImageMarker({
						x: fa.x,
						y: fa.y
					}, ka, ia)
				} else {
					ka.vectorDef = this.vectorDef;
					this.vectorDef && this.vectorDef[0] && this.vectorDef[0].shape || (oa = a.gv, xa = oa.defaultMarkerStyleWidth, Ma = oa.defaultMarkerStyleHeight, a.isNull(ka.width) && (ka.width = xa), a.isNull(ka.height) && (ka.height = Ma), ka.vectorDef = [{
								shape: {
									type: "circle",
									cx: ka.width / 2,
									cy: ka.height / 2,
									width: ka.width,
									height: ka.height,
									scaleX: 1,
									scaleY: 1
								},
								style: a.$.extend(!0, {}, oa.defaultMarkerStyle, ka)
							}
						]);
					a.style.Style.calculateStyleSize(ka,
						b);
					ka && ka.vectorDef && 1 === ka.vectorDef.length && (xa = ka.vectorDef[0], xa.shape && "circle" === xa.shape.type && xa.style && xa.style.strokeDash && (oa = xa.style.strokeDash, xa = xa.style, 2 === oa.length ? (xa.dash = oa[0], xa.dash_gap = oa[1]) : 3 === oa.length && (xa.dash = oa[0], xa.dash_gap = oa[1], 1 === oa[2] && (xa.in_deg = !0))));
					b = {};
					a.$.extend(!0, b, ka.vectorDef);
					b.length = ka.vectorDef.length;
					ia.width = ka.realWidth;
					ia.height = ka.realHeight;
					this.realWidthInPx = ka.realWidth;
					this.realHeightInPx = ka.realHeight;
					oa = this.noShowCap;
					xa = this.realWidthInPx;
					Ma = this.realHeightInPx;
					if (!(a.isNull(oa) || oa > xa && oa > Ma))
						return;
					oa = ka.realWidth / ka.width * b[0].shape.scaleX;
					xa = ka.realHeight / ka.height * b[0].shape.scaleY;
					b[0].style.strokeThickness && (b[0].style.strokeThickness /= oa);
					b[0].style.insetThickness && (b[0].style.insetThickness /= oa);
					if (a.isNull(b[0].style.fill) && a.notNull(this.nullFill) || b[0].style.fill === a.PaintTypes.NO_PAINT && a.notNull(this.nullFill))
						b[0].style.fill = this.nullFill, "string" === typeof b[0].style.fill && (b[0].style.fill = ta.createFillPattern(b[0].style.fill));
					oa && xa && (ia.xScale = oa, ia.yScale = xa);
					a.notNull(this.gradient) && ("object" === typeof this.gradient ? ia.gradient = this.gradient : "radial" === this.gradient && (Ma = this.getRadialGradient(ta, this.vectorDef[0].style.fill), ia.gradient = Ma));
					ia = ta.drawVectorMarker({
						x: fa.x,
						y: fa.y
					}, b, ia)
				}
				if (ea) {
					ea = ta.createTextNode(ea, this.textStyle, 0, 0);
					b = ta.getWidthHeight(ea);
					if (ka.src)
						return ka = ta.createGroup(), ka.appendChild(ia), ka.appendChild(ea), c.appendChild(ka), c = fa.x - b.w / 2, fa = fa.y + (b.h - 4) / 2, this.textOffset && (c += this.textOffset.x ?
							this.textOffset.x : 0, fa += this.textOffset.y ? this.textOffset.y : 0), ea.translate(c, fa), ka;
					ia.appendChild(ea);
					fa = ka.realWidth ? ka.realWidth : ka.width;
					c = ka.realHeight ? ka.realHeight : ka.height;
					fa = (fa - b.w) / 2;
					c = (c + b.h - 4) / 2;
					this.textOffset && (fa += this.textOffset.x ? this.textOffset.x : 0, c += this.textOffset.y ? this.textOffset.y : 0);
					ea.scale(1 / oa, 1 / xa);
					ea.translate(fa, c)
				}
				return ia
			}
		},
		getRadialGradient: function (b, c) {
			if (a.isNull(b) || a.isNull(c))
				return null;
			var fa = b.oui;
			return new fa.style.RadialGradient({
				cx: .3,
				cy: .3,
				radius: .5,
				stops: [new fa.style.GradientStop({
						offset: 0,
						color: "#ffffff"
					}), new fa.style.GradientStop({
						offset: .8,
						color: c
					})]
			})
		},
		calculateVectorMarkerScale: function () {
			(a.isNull(this.height) || a.isNull(this.width)) && this.vectorDef && 0 < this.vectorDef.length && a.isNotNull(this.vectorDef[0].shape) && a.isNotNull(this.vectorDef[0].shape.width) && a.isNotNull(this.vectorDef[0].shape.height) && (this.height = this.vectorDef[0].shape.height, this.width = this.vectorDef[0].shape.width);
			if (this.vectorDef && 0 <= this.width && 0 <= this.height &&
				a.isNotNull(this.width) && a.isNotNull(this.height)) {
				var b,
				c,
				fa = -Number.MAX_VALUE,
				ea = -Number.MAX_VALUE,
				ia = Number.MAX_VALUE,
				ta = Number.MAX_VALUE;
				this.isSVGType = !1;
				var ka;
				for (b = 0; b < this.vectorDef.length; b++)
					if (c = this.vectorDef[b].shape, c.width = c.width ? c.width : this.width, c.height = c.height ? c.height : this.height, "circle" === c.type) {
						if (a.isNull(c.cx) || a.isNull(c.cy) || 0 === c.cx && 0 === c.cy)
							c.cx = c.width / 2, c.cy = c.height / 2;
						ia = Math.min(ia, c.cx - c.width / 2);
						ta = Math.min(ta, c.cy - c.height / 2);
						fa = Math.max(fa, c.cx + c.width / 2);
						ea = Math.max(ea, c.cy + c.height / 2)
					} else if ("rectangle" === c.type)
						a.isNull(c.x) && (c.x = 0), a.isNull(c.y) && (c.y = 0), c.scaleX = 1, c.scaleY = 1, ia = Math.min(ia, c.x), ta = Math.min(ta, c.y), fa = Math.max(fa, c.x + c.width), ea = Math.max(ea, c.y + c.height);
					else if ("svg" === c.type)
						(ka = a.util.PathUtils.getBBox(c.svgPath)) && a.notNull(ka.minX) && (ia = Math.min(ia, ka.minX), ta = Math.min(ta, ka.minY), fa = Math.max(fa, ka.minX + ka.width), ea = Math.max(ea, ka.minY + ka.height)), this.isSVGType = !0;
					else {
						c = c.coords[0];
						for (var oa = 0, xa = c.length; oa < xa; oa += 2)
							c[oa] *=
							1, c[oa + 1] *= 1, c[oa] < ia && (ia = c[oa]), c[oa] > fa && (fa = c[oa]), c[oa + 1] < ta && (ta = c[oa + 1]), c[oa + 1] > ea && (ea = c[oa + 1])
					}
				b = fa - ia;
				ta = ea - ta;
				0 >= b && (b = 1);
				0 >= ta && (ta = 1);
				ea = this.width / b;
				ta = this.height / ta;
				this.isSVGType && (ea = Math.min(ea, ta), 0 >= ea && (ea = 1), ta = ea, ka = Math.min(ka.minX, ka.minY), this.svg_xOffset = -ka * ea, this.svg_yOffset = -ka * ta);
				for (b = 0; b < this.vectorDef.length; b++)
					c = this.vectorDef[b].shape, c.scaleX = ea, c.scaleY = ta, a.notNull(this.vectorDef[b].style) && a.notNull(this.vectorDef[b].style.strokeThickness) && (this.vectorDef[b].style.strokeThickness =
							parseFloat(this.vectorDef[b].style.strokeThickness))
			}
		},
		getFNFormat: function (a) {
			if (this.src || !this.vectorDef || 0 === this.vectorDef.length || !this.vectorDef[0].shape || "path" !== this.vectorDef[0].shape.type || !this.vectorDef[0].shape.coords || 1 > this.vectorDef[0].shape.coords.length || 4 > this.vectorDef[0].shape.coords[0].length)
				return null;
			for (var b = this.vectorDef[0].shape, c = b.coords[0], ea = "M " + c[0] + " " + c[1], ia = 2, ta = c.length; ia < ta; ia += 2)
				ea += " L " + c[ia] + " " + c[ia + 1];
			a ? this.resolve(a) : this.calculateVectorMarkerScale();
			this.vectorDef[0].style && !this.vectorDef[0].style.fill && (this.vectorDef[0].style.fillOpacity = 0);
			return {
				height: b.scaleY,
				width: b.scaleX,
				d: ea,
				refX: this.xOffset,
				refY: this.yOffset,
				paint: this.vectorDef[0].style,
				strokeUnits: !1
			}
		},
		getBindables: function () {
			return this.bindableAttrs ? this.bindableAttrs : this.bindableAttrs = this.src ? ["Size", "Width", "Height", "Source"] : ["Fill", "Size", "Width", "Height", "SVGPath"]
		},
		getShapeString: function (b) {
			var c = "",
			fa = "";
			if (b && "circle" === b.type)
				c = '\x3ccircle cx\x3d"' + b.cx + '" cy\x3d"' +
					b.cy + '" r\x3d"0"/\x3e';
			else if (b && "rectangle" === b.type)
				fa = "" + b.x + "," + b.y + ",", fa += b.x + b.width + "," + b.y + ",", fa += b.x + b.width + "," + (b.y + b.height) + ",", fa += b.x + "," + (b.y + b.height) + ",", fa += b.x + "," + b.y, c = '\x3cpolygon points\x3d"' + fa + '"/\x3e';
			else if (b && "path" === b.type) {
				fa = "";
				b = b.coords[0];
				4 > b.length && a.util.Logger.warning("MAPVIEWER_9106", "OM.style.Marker.getShapeString", "It only contains [" + b.length + "] vertexes.");
				for (var c = 0, ea = b.length; c < ea; c += 1)
					fa += b[c], c < b.length - 1 && (fa += ",");
				c = '\x3cpolygon points\x3d"' +
					fa + '"/\x3e'
			}
			return c
		},
		getAnchorString: function () {
			var b,
			c,
			fa = c = b = "";
			a.isNull(this.xOffset) || 0 === this.xOffset ? b = "0.5" : (b = (this.width + this.xOffset) / this.width, b = Math.max(0, b), b = Math.min(1, b), b = "" + b);
			a.isNull(this.yOffset) || 0 === this.yOffset ? c += "0.5" : (c = (this.height + this.yOffset) / this.height, c = Math.max(0, c), c = Math.min(1, c), c = "" + c);
			if ("0.5" !== b || "0.5" !== c)
				fa = '\x3canchor x\x3d"' + b + '" y\x3d"' + c + '"/\x3e';
			return fa
		},
		getImageSrcString: function (b) {
			var c = "";
			if (a.notNull(b)) {
				var fa,
				ea = b.lastIndexOf(".");
				0 < ea &&
				(fa = b.substring(ea + 1));
				0 > b.lastIndexOf("http") ? (ea = document.URL, a.notNull(ea) ? (ea = ea.substring(0, ea.lastIndexOf("/") + 1), b = ea + b, c = "\x3cimage" + (a.notNull(fa) && 0 < fa.trim().length ? ' markerType\x3d"' + fa + '"' : "") + ' href\x3d"' + b + '"/\x3e') : a.util.Logger.warning("MAPVIEWER_9107", "OM.style.Marker.getImageSrcString")) : c = "\x3cimage" + (a.notNull(fa) && 0 < fa.trim().length ? ' markerType\x3d"' + fa + '"' : "") + ' href\x3d"' + b + '"/\x3e'
			}
			return c
		},
		toXMLString: function () {
			var b = "",
			c = "",
			fa = -1,
			ea = -1,
			ia = "",
			ta = "",
			ka = "",
			oa = "";
			a.notNull(this.lengthUnit) &&
			"pixel" !== this.lengthUnit && (ia = this.lengthUnit);
			if (a.notNull(this.vectorDef)) {
				this.vectorDef && this.vectorDef[0] && this.vectorDef[0].style && (b = this.vectorDef[0].style.fill, a.notNull(this.vectorDef[0].style.fillOpacity) && (fa = Math.min(Math.round(255 * this.vectorDef[0].style.fillOpacity), 255)), c = this.vectorDef[0].style.stroke, a.notNull(this.vectorDef[0].style.strokeOpacity) && (ea = Math.min(Math.round(255 * this.vectorDef[0].style.strokeOpacity), 255)));
				var xa = this.vectorDef[0].shape;
				xa && (ta = this.getShapeString(xa),
					ka = this.getAnchorString())
			} else
				a.notNull(this.src) && (oa = this.getImageSrcString(this.src));
			xa = "" + ('\x3cstyle name\x3d"' + this.getStyleName() + '"\x3e');
			xa += '\x3cg class\x3d"marker"' + (a.notNull(this.max_size_in_px) ? ' max_size_in_px\x3d"' + this.max_size_in_px + '"' : "") + ' style\x3d"';
			xa += a.notNull(c) && 0 < c.length ? "stroke:" + c + ";" : "";
			xa += a.notNull(ea) && 0 <= ea ? "stroke-opacity:" + ea + ";" : "";
			xa += a.notNull(b) && 0 < b.length ? "fill:" + b + ";" : "";
			xa += a.notNull(fa) && 0 <= fa ? "fill-opacity:" + fa + ";" : "";
			xa += a.notNull(this.width) &&
			0 < this.width ? "width:" + this.width + ia + ";" : "";
			xa += a.notNull(this.height) && 0 < this.height ? "height:" + this.height + ia + ";" : "";
			xa = xa + '"\x3e' + ta;
			xa += ka;
			xa += oa;
			return xa += "\x3c/g\x3e\x3c/style\x3e"
		},
		enableNullFillPattern: function (b) {
			a.notNull(b) ? this.nullFill = b : this.nullFill = null
		}
	});
	a.style.Marker.isSameShape = function (a, b) {
		if (a.type === b.type)
			if ("circle" === a.type) {
				if (a.cx === b.cx && a.cy === b.cy && a.width === b.width && a.height === b.height)
					return !0
			} else if ("rectangle" === a.type) {
				if (a.x === b.x && a.y === b.y && a.width === b.width &&
					a.height === b.height)
					return !0
			} else {
				var c = a.coords[0],
				ea = b.coords[0];
				if (c.length !== ea.length)
					return !1;
				for (var ia = 0, ta = c.length; ia < ta; ia += 2)
					if (c[ia] !== ea[ia])
						return !1;
				return !0
			}
		return !1
	};
	a.style.StyleStore = a.style.StyleStore || {};
	a.style.StyleStore.styleCache = a.style.StyleStore.styleCache || {};
	a.style.StyleStore.styleCachePromises = a.style.StyleStore.styleCachePromises || {};
	a.style.StyleStore.getServerSideStyle = function (b, c, fa) {
		var ea = a.style.StyleStore.styleCachePromises;
		if (!b || !c)
			return a.util.Logger.alert("MAPVIEWER_9018",
				"OM.style.StyleStore.getServerSideStyle", "dataSource:" + b + " styleName:" + c), null;
		var ia = a.style.StyleStore.getCachedStyle(b, c);
		if (a.isNull(ia)) {
			if (!fa || !fa.callback)
				return a.util.Logger.alert("MAPVIEWER_9018", "OM.style.StyleStore.getServerSideStyle", "options.callback:" + fa.callback), null;
			var ta,
			ia = function (ea) {
				if (a.isNull(ea) && fa && fa.callback)
					fa.callback(null);
				else {
					var ia = null;
					try {
						ia = a.style.StyleStore.parseXMLStyle(ea, c, b, ta)
					} catch (rb) {
						ia = a.style.StyleStore.parseJSONStyle(ea, c)
					}
					a.notNull(ia) && (ia.isServerSide =
							!0, a.style.StyleStore.putStyle(b, c, ia));
					fa && fa.callback && ("__Invalid__" === ia.styleName ? (fa.callback(null), ia = null) : a.notNull(fa.styleIdx) ? fa.callback(fa.styleIdx, ia) : fa.callback(ia));
					return ia
				}
			},
			ka = {
				xml_request: '\x3cnon_map_request\x3e\x3cget_style_definition data_source\x3d"' + b + '" style\x3d"' + c + '"/\x3e\x3c/non_map_request\x3e'
			};
			ta = fa && fa.url ? fa.url + "/omserver" : a.gv.localbaseURL() + "/omserver";
			var oa = a.style.StyleStore.getKey(b, c);
			ea[oa] || (ea[oa] = a.$.Deferred(function (b) {
					a.util.HttpRequest.send(ta,
						ka, function (a) {
						b.resolve(a)
					}, "text", function () {
						a.util.Logger.warning("MAPVIEWER_9023", "OM.style.StyleStore.getServerSideStyle");
						b.reject()
					})
				}).promise());
			return ea[oa].done(ia).fail(ia)
		}
		if ("__Invalid__" === ia.styleName)
			return fa && fa.callback && fa.callback(null), null;
		fa && fa.callback && (a.notNull(fa.styleIdx) ? fa.callback(fa.styleIdx, ia) : fa.callback(ia));
		return ia
	};
	a.style.StyleStore.parseXMLStyle = function (b, c, fa, ea) {
		"string" === typeof b && (b = a.$.trim(b), b = a.$.parseXML(b));
		b = a.$(b);
		a.notNull(b.find("oms_error")[0]) ?
		(c = new a.style.Style({
				styleName: "__Invalid__"
			}), a.util.Logger.alert("MAPVIEWER_9023", "OM.style.StyleStore.parseXMLStyle", b.find("oms_error").text())) : c = a.style.StyleStore.createStyle(b, c, fa, ea);
		a.isNull(c) && (c = new a.style.Style({
				styleName: "__Invalid__"
			}));
		return c
	};
	a.style.StyleStore.parseJSONStyle = function (b, c) {
		"string" === typeof b && (b = a.$.parseJSON(b));
		if (!b.type)
			return null;
		var fa = b.type,
		ea = b.def;
		ea.styleName = c;
		var ia;
		switch (fa) {
		case "color":
			ia = new a.style.Color(ea);
			break;
		case "marker":
			ia = new a.style.Marker(ea);
			break;
		case "pulse_animation":
			ia = new a.style.PulseAnimation(ea);
			break;
		case "color_animation":
			fa = {};
			fa.styleName = c;
			b.beginColorDef && (fa.beginColor = new a.style.Color(b.beginColorDef.def));
			b.endColorDef && (fa.endColor = new a.style.Color(b.endColorDef.def));
			ea.duration && (fa.duration = ea.duration);
			ea.movingDashLine && (fa.enableMovingDashLine = ea.movingDashLine);
			ia = new a.style.AnimationColor(fa);
			break;
		case "bar_chart":
			ia = b.barArr;
			for (var ta = ia.length, ka = [], fa = 0; fa < ta; fa++)
				ka.push(new a.style.Bar(ia[fa].name,
						ia[fa].color));
			ea.bars = ka;
			ia = new a.style.BarChart(ea);
			break;
		case "pie_chart":
			ia = b.pieArr;
			ta = ia.length;
			ka = [];
			for (fa = 0; fa < ta; fa++)
				ka.push(new a.style.PieSlice(ia[fa].name, ia[fa].color));
			ea.pieSlices = ka;
			ia = new a.style.PieChart(ea)
		}
		return ia
	};
	a.style.StyleStore.createStyle = function (b, c, fa, ea) {
		var ia = a.style.StyleStore,
		ta;
		b = b.find("non_map_response \x3e style");
		for (var ka = 0; ka < b.length; ka++) {
			var oa = b.eq(ka),
			xa = oa.attr("name"),
			oa = ia.createSingleStyle(oa, fa, ea);
			a.notNull(oa) && (a.style.StyleStore.putStyle(fa,
					xa, oa), xa == c && (ta = oa))
		}
		if (a.notNull(ta) && a.notNull(ta.markerPattern) && a.notNull(ta.markerPattern.markers))
			for (c = ta.markerPattern.markers, ta.markerPattern.markers = [], ea = 0; ea < c.length; ea++)
				ta.markerPattern.markers.push(a.style.StyleStore.getCachedStyle(fa, c[ea]));
		return ta
	};
	a.style.StyleStore.createSingleStyle = function (b, c, fa) {
		var ea = a.style.StyleStore,
		ia = b.find("AdvancedStyle")[0];
		return a.isNull(ia) ? ea.createSimpleStyle({
			dataSource: c,
			data: b,
			url: fa
		}) : ea.createAdvancedStyle(b.parent(), c, fa)
	};
	a.style.StyleStore.createAdvancedStyle =
	function (b, c, fa) {
		var ea = b.find("AdvancedStyle")[0],
		ia = a.style.StyleStore;
		switch (a.$(ea).children()[0].tagName) {
		case "PieChartStyle":
			return ia.createPieChartStyle(b);
		case "BarChartStyle":
			return ia.createBarChartStyle(b);
		case "ColorSchemeStyle":
			return ia.createColorSchemeStyle(b);
		case "HeatMapStyle":
			return ia.createHeatMapStyle(b, c);
		case "BucketStyle":
			return ia.createBucketStyle(b, c, fa);
		case "VariableMarkerStyle":
			return ia.createVariableMarkerStyle(b, c, fa)
		}
	};
	a.style.StyleStore.getCachedStyle = function (b,
		c) {
		var fa = a.style.StyleStore.styleCache,
		ea = a.style.StyleStore.getKey(b, c);
		return fa[ea]
	};
	a.style.StyleStore.putStyle = function (b, c, fa) {
		var ea = a.style.StyleStore.styleCache;
		a.isNull(b) || a.isNull(c) || (b = a.style.StyleStore.getKey(b, c), ea[b] = fa)
	};
	a.style.StyleStore.getKey = function (b, c) {
		a.isNull(b) && (b = "");
		a.isNull(c) && (c = "");
		return b.toLowerCase() + "__" + c.toLowerCase()
	};
	a.style.StyleStore._styleStringToArray = function (a) {
		a = a.attr("style").split(";");
		for (var b = [], c = 0, ea = a.length; c < ea; c++) {
			var ia = a[c].split(":");
			ia && ia[0] && (b[ia[0]] = ia[1])
		}
		return b
	};
	a.style.StyleStore._maxSizeInPx = function (b) {
		b = b.attr("max_size_in_px");
		a.isNull(b) ? b = "" : b.trim();
		return b
	};
	a.style.StyleStore.createSimpleStyle = function (b) {
		var c = b.data,
		fa = b.dataSource;
		b = b.url;
		var ea = c.find("g"),
		ia = a.style.StyleStore;
		if (a.notNull(ea[0]))
			switch (ea.attr("class")) {
			case "color":
				return ia.createColorStyle(c);
			case "line":
				return ia.createLineStyle(c);
			case "area":
				return ia.createAreaStyle(fa, b, c);
			case "marker":
				return ia.createMarkerStyle(fa, b, c);
			case "text":
				return ia.createTextStyle(c);
			default:
				return null
			}
		else
			return null
	};
	a.style.StyleStore.createColorStyle = function (b) {
		var c = {},
		fa = a.style.StyleStore;
		c.styleName = b.attr("name");
		b.find("g").each(function (b, ia) {
			var ta = a.$(ia),
			ta = fa._styleStringToArray(ta);
			c.fill = "function" !== typeof ta.fill ? ta.fill : null;
			c.fillOpacity = ta["fill-opacity"] ? parseInt(ta["fill-opacity"]) / 255 : 1;
			c.stroke = ta.stroke;
			c.strokeThickness = ta["stroke-width"];
			c.strokeOpacity = ta["stroke-opacity"] ? parseInt(ta["stroke-opacity"]) / 255 : 1
		});
		return new a.style.Color(c)
	};
	a.style.StyleStore.createLineStyle =
	function (b) {
		var c = {},
		fa = a.style.StyleStore;
		c.styleName = b.attr("name");
		b.find("g").each(function (b, ia) {
			var ta = a.$(ia),
			ka = fa._styleStringToArray(ta);
			c.fill = "function" !== typeof ka.fill ? ka.fill : null;
			c.fillOpacity = ka["fill-opacity"] ? parseInt(ka["fill-opacity"]) / 255 : 1;
			c.fillWidth = ka["stroke-width"];
			c.strokeLineCap = ka["stroke-linecap"];
			c.strokeLineJoin = ka["stroke-linejoin"];
			c.cased = "true" === ta.attr("cased") ? !0 : !1;
			if (a.notNull(ka["marker-name"])) {
				c.markerPattern = {};
				c.markerPattern.serverLineArrow = !0;
				c.markerPattern.oriented =
					!0;
				var oa = ka["marker-name"];
				c.markerPattern.markers = [];
				c.markerPattern.markers.push(oa);
				var ya;
				if (a.notNull(ka["marker-size"]))
					ya = ka["marker-size"], oa = parseFloat(ya.replace(/[^0-9.]/g, "")), ya = ya.replace(/[0-9.]/g, ""), c.markerPattern.markerWidth = oa, c.markerPattern.markerHeight = oa, c.markerPattern.lengthUnit = ya;
				else if (a.notNull(ka["marker-width"])) {
					ya = ka["marker-width"];
					var Ma = ka["marker-height"],
					oa = parseFloat(ya.replace(/[^0-9.]/g, "")),
					Ma = parseFloat(Ma.replace(/[^0-9.]/g, ""));
					ya = ya.replace(/[0-9.]/g,
							"");
					c.markerPattern.markerWidth = oa;
					c.markerPattern.markerHeight = Ma;
					c.markerPattern.lengthUnit = ya
				}
				oa = ka["marker-position"];
				0 < oa.length && 0 === oa.replace(/[0-9.]/g, "").length ? c.markerPattern.percent = parseFloat(oa) : "all_points" === oa.toLowerCase() ? c.markerPattern.vertexes = !0 : "end_points" === oa.toLowerCase() && (c.markerPattern.startAndEndMarers = !0);
				oa = ka["multiple-marker"];
				a.notNull(oa) && "true" === oa.toLowerCase() && (c.markerPattern.multipleMarker = !0);
				ka = ka["max-size-in-px"];
				a.notNull(ka) && (c.markerPattern.max_size_in_px =
						parseInt(ka.replace(/[^0-9]/g, "")))
			}
			ta.find("line").each(function (b, x) {
				var z = a.$(x);
				if ("parallel" === z.attr("class")) {
					var p = fa._styleStringToArray(z);
					c.stroke = "function" !== typeof p.fill ? p.fill : null;
					c.strokeThickness = p["stroke-width"];
					c.strokeDash = fa.splitDashArray(z.attr("dash"))
				} else
					"base" === z.attr("class") && (p = fa._styleStringToArray(z), c.centerLine = "function" !== typeof p.fill ? p.fill : null, c.centerLineWidth = p["stroke-width"], c.centerLineOpacity = p["fill-opacity"] ? parseInt(p["fill-opacity"]) / 255 : 1, c.centerLineDash =
							fa.splitDashArray(z.attr("dash")))
			});
			ta.find("marker-pattern").each(function (b, x) {
				var z = a.$(x),
				p = z.attr("offset") || "",
				l = z.attr("interval") || "";
				c.markerPattern = {};
				c.markerPattern.offset = parseInt(p);
				c.markerPattern.offsetUnit = p.replace(/[0-9]/g, "");
				c.markerPattern.interval = parseInt(l);
				c.markerPattern.intervalUnit = l.replace(/[0-9]/g, "");
				c.markerPattern.markers = [];
				z.find("marker").each(function (x, b) {
					var z = a.$(b);
					c.markerPattern.markers.push(z.html())
				})
			})
		});
		a.isNull(c.fillWidth) && a.isNull(c.strokeThickness) &&
		a.notNull(c.centerLineWidth) && (c.stroke = c.centerLine, c.strokeThickness = c.centerLineWidth, c.strokeDash = c.centerLineDash, c.strokeOpacity = c.centerLineOpacity, c.centerLineWidth = 0);
		return new a.style.Line(c)
	};
	a.style.StyleStore.createAreaStyle = function (b, c, fa) {
		var ea = {},
		ia = a.style.StyleStore;
		ea.styleName = fa.attr("name");
		fa.find("g").each(function (fa, ka) {
			var oa = a.$(ka),
			oa = ia._styleStringToArray(oa);
			oa.fill && "function" !== typeof oa.fill && (ea.fill = oa.fill);
			ea.stroke = oa.stroke;
			ea.strokeThickness = oa["stroke-width"];
			ea.strokeOpacity = oa["stroke-opacity"] ? parseInt(oa["stroke-opacity"]) / 255 : 1;
			ea.fillOpacity = oa["fill-opacity"] ? parseInt(oa["fill-opacity"]) / 255 : 1;
			a.isNull(ea.fill) && (ea.src = c + "?sty\x3d" + ea.styleName + "\x26ds\x3d" + b + "\x26w\x3d10\x26h\x3d10");
			oa["line-style"] && (ea.bordarLineStyleName = oa["line-style"], ea.bordarLineStyleDSName = b)
		});
		0 !== fa.find("base64image").length && (fa = fa.find("base64image").attr("img"), a.notNull(fa) && (ea.src = "data:image/png;base64," + fa));
		return a.notNull(ea.fill) ? new a.style.Color(ea) :
		new a.style.Area(ea)
	};
	a.style.StyleStore.createMarkerStyle = function (b, c, fa) {
		var ea = {},
		ia = a.style.StyleStore,
		ta = {},
		ka = {},
		oa = {},
		xa = {};
		ea.styleName = fa.attr("name");
		fa.find("g").each(function () {
			var x = a.$(this),
			b = ia._maxSizeInPx(x);
			!a.isNull(b) && 0 < b.length && (ea.max_size_in_px = parseInt(b));
			x = ia._styleStringToArray(x);
			b = a.util.MiscUtil.parseNumberAndUnit(x.width);
			a.notNull(b.value) ? ea.width = 1 * b.value : ea.width = 1 * x.width;
			a.notNull(b.unit) && (ea.lengthUnit = b.unit);
			b = a.util.MiscUtil.parseNumberAndUnit(x.height);
			a.notNull(b.value) ? ea.height = 1 * b.value : ea.height = 1 * x.height;
			a.notNull(b.unit) && (ea.lengthUnit = b.unit);
			x.fill && "function" !== typeof x.fill && (ka.fill = x.fill);
			x["fill-opacity"] && (ka.fillOpacity = x["fill-opacity"] ? parseInt(x["fill-opacity"]) / 255 : 1);
			x.stroke && (ka.stroke = x.stroke);
			x["stroke-width"] && (ka.strokeThickness = x["stroke-width"]);
			x["stroke-opacity"] && (ka.strokeOpacity = x["stroke-opacity"] ? parseInt(x["stroke-opacity"]) / 255 : 1);
			x["font-family"] && (xa.isServerSide = !0, xa.fontFamily = x["font-family"], xa.fontStyle =
					x["font-style"] ? x["font-style"] : null);
			x["font-fill"] && (xa.fill = x["font-fill"] ? x["font-fill"] : "#000000");
			x["font-weight"] && (xa.fontWeight = x["font-weight"]);
			x["font-size"] && (x = parseInt(x["font-size"] ? x["font-size"] : 0), xa.fontSize = x);
			0 < ea.width && 0 < ea.height && 0 < xa.fontSize && (ea.textStyle = new a.style.Text(xa), ea.textStyle.from_marker_hints = !0)
		});
		var Ma,
		rb = !1;
		if (0 !== fa.find("image").length)
			"dummy.gif" === fa.find("image").attr("href") ? ea.src = c + "?w\x3d" + ea.width + "\x26h\x3d" + ea.height + "\x26sty\x3d" + ea.styleName +
				"\x26ds\x3d" + b : ea.src = fa.find("image").attr("href");
		else if (0 !== fa.find("svgSymbol").length)
			ea.src = c + "?w\x3d" + ea.width + "\x26h\x3d" + ea.height + "\x26sty\x3d" + ea.styleName + "\x26ds\x3d" + b;
		else if (0 !== fa.find("ttfSymbol").length)
			rb = !0, ea.src = c + "?w\x3d" + ea.width + "\x26h\x3d" + ea.height + "\x26sty\x3d" + ea.styleName + "\x26ds\x3d" + b;
		else {
			if (0 !== fa.find("circle").length)
				oa.type = "circle", oa.cx = 1 * fa.find("circle").attr("cx"), oa.cy = 1 * fa.find("circle").attr("cy"), oa.width = ea.width, oa.height = ea.height;
			else if (0 !== fa.find("rect").length) {
				oa.type =
					"rectangle";
				b = fa.find("rect").attr("points").split(",");
				Ma = 0;
				for (c = b.length; Ma < c; Ma++)
					b[Ma] *= 1;
				oa.width = ea.width;
				oa.height = ea.height;
				oa.x = b[0];
				oa.y = b[1]
			} else {
				b = fa.find("polygon").attr("points") || fa.find("polyline").attr("points");
				oa.type = "path";
				b = b.split(",");
				if (fa.find("polygon").attr("points")) {
					2 <= b.length && (b.push(b[0]), b.push(b[1]));
					var x = b.length,
					z = Number.MAX_VALUE,
					p = Number.MAX_VALUE;
					for (c = 0; c < x; c += 2)
						z = Math.min(z, b[c]), p = Math.min(p, b[c + 1]);
					for (c = 0; c < x; c += 2)
						b[c] -= z, b[c + 1] -= p
				}
				oa.coords = [b]
			}
			ta.shape =
				oa
		}
		oa = fa.find("anchor").attr("x");
		fa = fa.find("anchor").attr("y");
		a.notNull(oa) && a.notNull(ea.width) && (ea.xOffset =  - (Number(oa) - .5) * ea.width);
		a.notNull(fa) && a.notNull(ea.height) && (ea.yOffset =  - (Number(fa) - .5) * ea.height);
		if (rb)
			ta = new a.style.Marker(ea);
		else {
			for (Ma in ka) {
				ta.style = ka;
				break
			}
			if (ta.shape || ta.style)
				ea.vectorDef = [ta];
			ta = new a.style.Marker(ea);
			ta.calculateVectorMarkerScale()
		}
		return ta
	};
	a.style.StyleStore.createTextStyle = function (b) {
		var c = {};
		c.styleName = b.attr("name");
		b.find("g").each(function (b,
				ea) {
			var ia = a.$(ea),
			ta = a.Text,
			ia = a.style.StyleStore._styleStringToArray(ia);
			c.fill = "function" !== typeof ia.fill ? ia.fill : null;
			c.fontStyle = "italic" === ia["font-style"] ? ta.FONTSTYLE_ITALIC : ta.FONTSTYLE_NORMAL;
			c.fontFamily = ia["font-family"];
			var ka = ia["font-size"];
			if (ka) {
				var oa = a.util.MiscUtil.parseNumberAndUnit(ka);
				a.notNull(oa.value) ? c.fontSize = 1 * oa.value : c.fontSize = parseInt(ka);
				a.notNull(oa.unit) && (c.sizeUnit = oa.unit, "pt" === oa.unit && (c.fontSize = parseInt(96 * c.fontSize / 72), c.sizeUnit = null))
			}
			c.fontWeight =
				"bold" === ia["font-weight"] ? ta.FONTWEIGHT_BOLD : ta.FONTWEIGHT_NORMAL
		});
		return new a.style.Text(c)
	};
	a.style.StyleStore.createPieChartStyle = function (b) {
		var c = {
			pieSlices: []
		};
		c.styleName = b.find("style").attr("name");
		c.radius = b.find("PieChartStyle").attr("pieradius");
		b.find("PieSlice").each(function (b, ea) {
			var ia = a.$(ea),
			ta = ia.attr("color"),
			ia = ia.attr("name");
			c.pieSlices.push(new a.style.PieSlice(ia, ta))
		});
		return new a.style.PieChart(c)
	};
	a.style.StyleStore.createBarChartStyle = function (b) {
		var c = {
			bars: []
		};
		c.styleName = b.find("style").attr("name");
		var fa = b.find("BarChartStyle");
		c.width = fa.attr("width");
		c.height = fa.attr("height");
		c.showXAxis = fa.attr("show_x_axis");
		c.maxSize = fa.attr("max_value");
		b.find("Bar").each(function (b, ia) {
			var fa = a.$(ia),
			ka = fa.attr("color"),
			fa = fa.attr("name");
			c.bars.push(new a.style.Bar(fa, ka))
		});
		return new a.style.BarChart(c)
	};
	a.style.StyleStore.createColorSchemeStyle = function (b) {
		var c = a.style.StyleStore.createBucketConfig(b);
		b = b.find("ColorSchemeStyle");
		c.baseColor = b.attr("basecolor");
		var fa = b.attr("basecolor_opacity");
		c.baseColorOpacity = fa ? parseInt(fa) / 255 : 1;
		c.stroke = b.attr("strokecolor");
		b.attr("strokewidth") && (c.strokeThickness = 1 * b.attr("strokewidth"));
		fa = b.attr("strokecolor_opacity");
		c.strokeOpacity = fa ? parseInt(fa) / 255 : 1;
		return new a.style.ColorScheme(c)
	};
	a.style.StyleStore.createHeatMapStyle = function (b, c) {
		var fa = {},
		ea = b.find("spot_light_radius").text();
		fa.styleName = b.find("style").attr("name");
		var ia = b.find("container_theme").text();
		ia && (fa.containerVectorLayer = new a.layer.VectorLayer("container", {
				def: {
					type: a.layer.VectorLayer.TYPE_PREDEFINED,
					dataSource: c,
					theme: ia,
					loadOnDemand: !1
				}
			}));
		fa.spotlightRadius = 1 * ea.match(/\d+\.?\d+/g);
		(ea = ea.match(/[a-z]+/g)) && 0 < ea.length && (fa.lengthUnit = ea[0]);
		ea = b.find("color_stops");
		ia = ea.attr("alpha");
		fa.opacity = 1;
		ia && (fa.opacity = parseFloat(ia / 256));
		for (var ea = a.$.trim(ea.text()).split(","), ia = 0, ta = ea.length; ia < ta; ia++)
			ea[ia] = a.util.ValidationUtil.getColor(ea[ia]);
		fa.colorStops = ea;
		return new a.style.HeatMap(fa)
	};
	a.style.StyleStore.createBucketStyle = function (b,
		c, fa) {
		b = a.style.StyleStore.createBucketConfig(b, c, fa);
		return new a.style.BucketStyle(b)
	};
	a.style.StyleStore.createBucketConfig = function (b, c, fa) {
		var ea = {};
		ea.styleName = b.find("style:has('AdvancedStyle')").attr("name");
		var ia = b.find("Buckets"),
		ta = a.style.StyleStore,
		ka = ia.attr("default_style");
		ka && (ea.defaultStyle = ta.getSubStyleByName(b, ka, c, fa));
		ea.buckets = [];
		ea.styles = [];
		var oa,
		ka = ia.find("RangedBucket");
		if (0 < ka.length)
			return oa = a.style.RangedBucket, ka.each(function () {
				ea.classification = "custom";
				var x =
					a.$(this),
				z = {};
				z.seq = 1 * x.attr("seq");
				z.label = x.attr("label");
				var p = 1 * x.attr("low"),
				l = 1 * x.attr("high");
				z.low = isNaN(p) ? Number.NEGATIVE_INFINITY : p;
				z.high = isNaN(l) ? Number.POSITIVE_INFINITY : l;
				x = x.attr("style");
				x = ta.getSubStyleByName(b, x, c, fa);
				z = new oa(z);
				ea.buckets.push(z);
				x && ea.styles.push(x)
			}), ea.numClasses = ea.buckets.length, ea;
		ka = ia.find("CollectionBucket");
		if (0 < ka.length)
			return oa = a.style.CollectionBucket, ka.each(function () {
				ea.classification = "custom";
				var x = a.$(this),
				z = {};
				z.seq = 1 * x.attr("seq");
				z.label =
					x.attr("label");
				var p = x.attr("style"),
				p = ta.getSubStyleByName(b, p, c, fa),
				l = x.attr("label_style");
				z.labelStyle = ta.getSubStyleByName(b, l, c, fa);
				z.keepWhiteSpace = x.attr("keep_white_space");
				l = x.attr("type");
				z.dataType = l;
				var Q = x.attr("delimiter");
				Q || (Q = ",");
				for (var x = x.text().split(Q), Q = x.length, A = 0; A < Q; A++)
					if ("integer" === l || "short" === l)
						x[A] = parseInt(x[A]);
					else if ("double" == l || "long" === l)
						x[A] = parseFloat(x[A]);
				z.values = x;
				z = new oa(z);
				ea.buckets.push(z);
				p && ea.styles.push(p)
			}), ea.numClasses = ea.buckets.length,
			ea;
		if (ka = ia.attr("styles"))
			for (var ka = ka.split(","), xa = 0, Ma = ka.length; xa < Ma; xa++) {
				var rb = ta.getSubStyleByName(b, ka[xa], c, fa);
				ea.styles.push(rb)
			}
		ka = ia.attr("low");
		xa = ia.attr("high");
		ka && (ea.low = 1 * ka);
		xa && (ea.high = 1 * xa);
		ia = ia.attr("nbuckets");
		ea.numClasses = ia ? 1 * ia : null;
		return ea
	};
	a.style.StyleStore.createVariableMarkerStyle = function (b, c, fa) {
		var ea = a.style.StyleStore.createBucketConfig(b, c, fa),
		ia = b.find("VariableMarkerStyle"),
		ta = a.style.StyleStore,
		ka = ia.attr("basemarker");
		ea.marker = ta.getSubStyleByName(b,
				ka, c, fa);
		b = ia.attr("startsize");
		ia = ia.attr("increment");
		b && (ea.startSize = 1 * b);
		ia && (ea.increament = 1 * ia);
		return new a.style.VariableMarker(ea)
	};
	a.style.StyleStore.getSubStyleByName = function (b, c, fa, ea) {
		b = b.find('style[name\x3d"' + c + '"]')[0];
		b = a.$(b);
		return a.style.StyleStore.createSimpleStyle({
			dataSource: fa,
			url: ea,
			data: b
		})
	};
	a.style.StyleStore.splitDashArray = function (a) {
		if (a) {
			a = a.split(",");
			for (var b = a.length, c = 0; c < b; c++)
				a[c] = parseInt(a[c]);
			return a
		}
		return null
	};
	a.style.StyleStore.defaultMarkerStyle = new a.style.Marker({
		width: 50,
		height: 50,
		src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAG3klEQVRoQ+2XaWwUZRzG37n26LWUAi0toi1IImhiggqioiEhqYkJH5SEIyECMSAYTCiKHAot5xflC2CQ+EFEjgBRULlrLeEoJKACBakNaaDHUloshXZLa3d8nndmyrZAod3tasgOeTvnzjy///P83xkU8ZgsymPCIWIg/zcnY47EHOmhCsSi1UOF7fZtY450u3Q99MOYI/6bzSMVoWWHW2BTtO5P87mKwr1PtxwpqWjcXXOrafSvl81eQphtGhTczZS7vK0prH0Fa1Med86HHn89U63rk+g5MiQjblw4MF0GKa9t/vzQ6bIZeQUivqG00NLcyRIMEqTjRdi3D7XUVYg18yY0jB3+5IYBKa6c7sJ0GaSkMlD88ffXhx4vPNBWZefhJsoO2VKkaartNYXAKArOWdZJyGfTVPHl/PEXhqR7h0UN5PK1pqqpm6rSLp46bD3TSlFbhSWAs++Ix76qqnYIuQNcRM5E5FRFFxneRrFj5RR/Vqqnf1RBpn3rT7tw6pD1TOiSuulCEBC2x9Yxxsp2BiCOA5Zr1oUm1unegNi1fHL0QaZvrkorPglH7D5HXe9xQfaFqt0VDyAnbmh96ZBc4E4GQHbkTYg+CKNFR6RYRsSxoYMDKsUzUkEahX8QLbd0AuJ3ckaDIx5EK/cdgLijGy2nR6QTVl5k88oYaYrMPY9JoXRFJo5rjdw4bzllOWaKAeiR7YvH+TOjDSKjVZR/1wlqoig6IsVqQtGgnk7ogCIEz2nctvuI7xU7XhlxAbF9wZv/Dcj5ol+cXhcaBEoAiKQ4RcU+QUzbAd2Q0FbjwzHu0xruIW7p7gax7ZOx/sx+RvSjdeEkQDiN2pU2IZKRsqJkOaKohnSDYPKY3SPsG4XXYvpV4F66+5bYkjM6+iCM1vmTBTIqrLEJwW1iIUw1AMA+oXgZM+zLbSt6ElZOEtbsxWbfPOdFgOjRdUT2yCl8njAamtvKOsSzoRXdJYXLinNtO8N9XAiD6AbiJd2y3iMZntti08znogtSWhW48v626if+IAgqyxlINVzSAUUHFPJP0TxmCkO6QwdUuBcEKB1QNDiCbzD2FN/uWQmNYsPUQVcH9dUHWtNZ15cuf2uV+gNb1hXenLh1D16IsicIABBUXzM8gHPJZlawVhgxVJ4QcsZizOx+ke8TvlDRN28NaRWzRidvHZyqT+o6gvWLLoNU1jUPr6hpyJ+xrc5XVXoa1adoCDbcEIxtwKgciJyAK4rtitXsgJIuBuWrR8Of3nFCZD+tiKkjvLmpPm1p1ED4IMJU1gTyZ+6s91WW/AZHLPEOhIZ9xkwwaoBT4ZhB4UiUm5Oa/EA2RYpXFa8NNsS7L+i5ZqBxfVpaYnVUQdpgapsAc9tXVXYJIF6hQbjq9iJdcRCPmAFCh3oPetztUoROGGzrIEnG6VcGGWLi8+FDdCtaoRWTztTeyZ/9wx2fv7xMaG7kBECMFd1xGbqIhxX8EIlDGxFExydML1w26ilDZGcFVu/e/t3Xc+fOvt6JE+ykVox/7DW37/631P5hl3uk4wMlzI2W/A/2mL5qf4VQ3PFwxit0lyHi3Ypwo6O9hircaCOCJCNxI7J0MVQr2bgqd+HOfft++rsTCHzkiBaMAMYtjNsYTTZQO5iwQSji0tWal+pb4g/N39eadLW2QTridasiAeI9cIQghmoiTooYmamLlBtHdy7/bNHBM2eKbj4AgiIJ0YzRiMHrajEI3WC7E1EQFoJfgolr1m18Y1T25G9WFAQTSmuDMlLxBtzQAaGbom+cKiHiyg/uXbls4ZHic+dY4dDFEUYAB4KiCVGDwfjdsB3h+XZLOI44EAm4Y1+M1PdmzRkxPWd13hdHgt6yOlMkoi84S/VLUMXLgPBc+fngquVLjv1Z3A6CAM5g/jnu2E7U2wDXbAhG7B4IEoUDws8sJF4kY/SzYXpPmjJt2Jwla+etPx70XqkLiv5Jmng1SxMJ5XtDIZzoOI3sNDP7gRAUTAg6QDfqHuSEY0skQJJwsxSM3jZUAmCe+XDp2nlfnTC9w9I10af6wP5Vyz49evH8WcbEqTpFcybimr1AADYyIdjUBOFgvHj+npnKgQjXERaBriBAgvHy2YNgibt+PDzlL++otzPrC/esWLqg4OzZ31lVinaqTnEUTfEOABvbOUYwgnYK4MCE40joPRwgvCEEQZLGjHlz4EeLl4zPW5Sz/8SJY5xtKCpUNAWHgjgOPZLwUDfCdaTjvbjvAHmxTSiu+T50ZiEHxKn2fV9u97vxw45FwpEHARGKUzMXpy/uO+M8TOSjnO8pkEd5dkSviYFEtJwRuFnMkQgUMaK3iDkS0XJG4GaPjSP/Al31T1GL6r+HAAAAAElFTkSuQmCC",
		yOffset: -12,
		xOffset: 2
	});
	a.style.StyleStore.defaultLineStyle = new a.style.Line({
		stroke: "#000000",
		strokeThickness: 1
	});
	a.style.StyleStore.defaultPolygonStyle = new a.style.Color({
		stroke: "#000000",
		strokeThickness: 1,
		fill: "#bebebe"
	});
	a.style.StyleStore.defaulTextStyle = new a.style.Text({
		fontSize: 12,
		fill: "#000000"
	});
	a.style.BasicAnimation = a.style.Style.extend({
		initialize: function lb(b) {
			lb.base.call(this, b);
			this.duration = a.notNull(b.duration) ? b.duration : 5;
			this.repeatCount = b.repeatCount ? b.repeatCount : Number.MAX_VALUE
		},
		isRepeat: function () {
			return 0 < this.repeatCount
		},
		getDuration: function () {
			return this.duration
		}
	});
	a.style.AnimationColor = a.style.BasicAnimation.extend({
		initialize: function fa(b) {
			b = b || {};
			b.styleType = "AnimationColor";
			fa.base.call(this, b);
			this.beginColor = a.notNull(b.beginColor) ? b.beginColor : new a.style.Color({
				strokeThickness: 1,
				stroke: "#000000",
				fill: "#ffffff"
			});
			this.endColor = a.notNull(b.endColor) ? b.endColor : new a.style.Color({
				strokeThickness: 1,
				stroke: "#ffffff",
				fill: "#000000"
			});
			if (this.movingDashLine = a.notNull(b.enableMovingDashLine) ?
					b.enableMovingDashLine : !1)
				this.beginColor.strokeDashArray = [10, 10];
			a.isNull(b.repeat) || b.repeat ? this.repeatCount = Number.POSITIVE_INFINITY : this.repeatCount = 1
		},
		draw: function (a, b, c) {
			this.beginColor.draw(a, b, c)
		},
		createAnimation: function (a, b, c) {
			this.target = a;
			if (this.beginColor && this.endColor) {
				var ta = [],
				ka = {};
				this.beginColor.stroke !== this.endColor.stroke && (ka.stroke = {
						beginValue: this.covertColor(this.beginColor.stroke, b),
						endValue: this.covertColor(this.endColor.stroke, b),
						interpolator: b.oui.anim.interpolateColor
					});
				this.beginColor.strokeThickness !== this.endColor.strokeThickness && (ka.strokeThickness = {
						beginValue: this.beginColor.strokeThickness,
						endValue: this.endColor.strokeThickness
					});
				c || (this.beginColor.fill !== this.endColor.fill && (ka.fill = {
							beginValue: this.covertColor(this.beginColor.fill, b),
							endValue: this.covertColor(this.endColor.fill, b),
							interpolator: b.oui.anim.interpolateColor
						}), this.beginColor.fillOpacity !== this.endColor.fillOpacity && (ka.fillOpacity = {
							beginValue: this.beginColor.fillOpacity,
							endValue: this.endColor.fillOpacity
						}),
					this.beginColor.strokeOpacity !== this.endColor.strokeOpacity && (ka.strokeOpacity = {
							beginValue: this.beginColor.strokeOpacity,
							endValue: this.endColor.strokeOpacity
						}));
				this.movingDashLine && (ka.strokeDashArray = {
						beginValue: [10, 10],
						endValue: [10, 10],
						interpolator: function (a, b, c) {
							a = parseInt(100 * c) % 20;
							b = [10, 10];
							10 < a ? b = [a - 10, 10, 20 - a, .1] : 0 < a && (b = 10 - a, b = [.1, a, 10, 0 === b ? .1 : b]);
							return b
						}
					});
				a = new b.oui.anim.AnimateStyle({
					targetNode: a,
					dur: this.duration,
					animValues: ka,
					repeatCount: this.repeatCount
				});
				ta.push(a);
				return ta
			}
		},
		covertColor: function (a, b) {
			var c = parseInt(a.substring(1, 3), 16),
			ta = parseInt(a.substring(3, 5), 16),
			ka = parseInt(a.substring(5), 16);
			return new b.oui.style.Color(c, ta, ka)
		}
	});
	a.style.PulseAnimation = a.style.BasicAnimation.extend({
		initialize: function ea(b) {
			b = b || {};
			b.styleType = "PulseAnimation";
			ea.base.call(this, b);
			this.beginSize = a.notNull(b.beginSize) ? b.beginSize : 10;
			this.endSize = a.notNull(b.endSize) ? b.endSize : 20;
			this.stroke = a.notNull(b.stroke) ? b.stroke : "#000000"
		},
		draw: function (a, b, c) {
			var ka = a.geo,
			oa = ka.type;
			if ("LineString" !== oa && "MultiLineString" !== oa && "Polygon" !== oa && "MultiPolygon" !== oa) {
				b = b.getGraphics();
				a.screenPoints || a.transformGeometry(ka);
				var ka = a.screenPoints,
				xa = [{
						shape: {
							type: "circle",
							cx: 0,
							cy: 0,
							width: this.beginSize,
							height: this.beginSize,
							scaleX: 1,
							scaleY: 1
						},
						style: {
							stroke: this.stroke
						}
					}
				];
				if ("MultiPoint" === oa || "OrientedMultiPoint" === oa) {
					oa = b.createGroup();
					c.group.appendChild(oa);
					c.group = oa;
					for (var Ma = 0, rb = ka.length; Ma < rb; Ma++)
						b.drawVectorMarker({
							x: ka[Ma].x,
							y: ka[Ma].y
						}, xa, c);
					a.shape = oa
				} else
					a.shape =
						b.drawVectorMarker({
							x: ka.x,
							y: ka.y
						}, xa, c)
			}
		},
		createAnimation: function (a, b) {
			this.target = a;
			var c = [],
			ka = new b.oui.anim.AnimateStyle({
				targetNode: a,
				dur: this.duration,
				repeatCount: this.repeatCount,
				animValues: {
					width: {
						beginValue: this.beginSize,
						endValue: this.endSize
					},
					height: {
						beginValue: this.beginSize,
						endValue: this.endSize
					},
					strokeOpacity: {
						beginValue: 1,
						endValue: 0
					}
				}
			});
			ka.addEventListener(b.oui.SyncEvents.END, this.endListener);
			c.push(ka);
			return c
		},
		endListener: function (a) {
			var b = a.target;
			a = b.getTargetNode();
			b = b.getAnimValues();
			a.applyStyle({
				width: b.width.beginValue,
				height: b.height.beginValue,
				strokeOpacity: 1
			})
		}
	});
	a.style.Area = a.style.Style.extend({
		initialize: function ia(b) {
			b = b || {};
			b.styleType = "Area";
			ia.base.call(this, b);
			var c = a.util.ValidationUtil.getColor;
			this.stroke = a.notNull(b.stroke) && c(b.stroke) ? c(b.stroke) : a.PaintTypes.NO_PAINT;
			this.src = a.notNull(b.src) ? b.src : a.PaintTypes.NO_PAINT;
			this.strokeThickness = a.notNull(b.strokeThickness) ? parseFloat(b.strokeThickness) : 1;
			this.fillOpacity = a.notNull(b.fillOpacity) ? b.fillOpacity :
				1;
			this.strokeOpacity = a.notNull(b.strokeOpacity) ? b.strokeOpacity : 1;
			this.strokeDashArray = a.notNull(b.strokeDash) ? b.strokeDash : [];
			this.repeatPattern = a.notNull(b.repeatPattern) ? b.repeatPattern : !0;
			a.notNull(this.src) && this.loadImgFromSource();
			a.isNull(b.strokeThickness) && b.bordarLineStyleName && b.bordarLineStyleDSName && (b = a.style.StyleStore.getCachedStyle(b.bordarLineStyleDSName, b.bordarLineStyleName), a.notNull(b) && (this.stroke = a.notNull(b.stroke) ? b.stroke : a.PaintTypes.NO_PAINT, this.strokeThickness = a.notNull(b.strokeThickness) ?
						b.strokeThickness : 1, this.strokeOpacity = a.notNull(b.strokeOpacity) ? b.strokeOpacity : 1, this.strokeDashArray = a.notNull(b.strokeDash) ? b.strokeDash : []))
		},
		loadImgFromSource: function () {
			var b = this,
			c = new Image;
			c.src = this.src;
			c.onload = function () {
				a.isNull(b.width) && (b.width = c.width);
				a.isNull(b.height) && (b.height = c.height);
				b.origConfig && (b.origConfig.width = c.width, b.origConfig.height = c.height)
			}
		},
		createStyle: function (a) {
			this.fill = new a.oui.style.PatternPaint({
				src: this.src
			})
		},
		createFixedImageStyle: function (b, c,
			ka) {
			c = {
				src: this.src,
				x: ka.x,
				y: ka.y,
				width: ka.width,
				height: ka.height,
				preserveAspectRatio: !0,
				opacity: this.fillOpacity
			};
			try {
				var oa = b.createImage(c);
				this.imgGroup = b.createGroup();
				this.imgGroup.appendChild(oa)
			} catch (xa) {
				a.util.Logger.warning("MAPVIEWER", "OM.style.Area", "Cannot create fixed image. Using pattern fill"),
				this.fill = b.createFillPattern(this.src)
			}
		},
		draw: function (b, c, ka) {
			var oa = b.geo,
			xa = a.notNull(ka.type) ? ka.type : oa.type;
			c = c.getGraphics();
			ka.screenPoints ? oa = ka.screenPoints : (b.screenPoints || b.transformGeometry(oa),
					oa = b.screenPoints);
			var Ma,
			rb,
			x;
			if (("LineString" === xa || "MultiLineString" === xa) && oa && 0 < oa.length)
				if (x = {
						stroke: this.stroke,
						strokeOpacity: this.strokeOpacity,
						strokeThickness: this.strokeThickness,
						strokeDashArray: this.strokeDashArray
					}, "LineString" === xa)
					b.shape = c.drawPath(oa, x, ka);
				else {
					xa = c.createGroup();
					ka.group.appendChild(xa);
					ka.group = xa;
					Ma = 0;
					for (rb = oa.length; Ma < rb; Ma++)
						c.drawPath(oa[Ma], x, ka);
					b.shape = xa
				}
			else if (this.repeatPattern && a.isNull(this.fill) && (this.fill = c.createFillPattern(this.src)), "Point" ===
				xa || "OrientedPoint" === xa || "MultiPoint" === xa || "OrientedMultiPoint" === xa)
				if (x = a.gv.defaultMarkerStyleWidth, Ma = a.gv.defaultMarkerStyleHeight, x = [{
							shape: {
								type: "circle",
								cx: x / 2,
								cy: Ma / 2,
								width: x,
								height: Ma,
								scaleX: 1,
								scaleY: 1
							},
							style: this
						}
					], "MultiPoint" === xa || "OrientedMultiPoint" === xa) {
					xa = c.createGroup();
					ka.group.appendChild(xa);
					ka.group = xa;
					Ma = 0;
					for (rb = oa.length; Ma < rb; Ma++)
						c.drawVectorMarker({
							x: oa[Ma].x,
							y: oa[Ma].y
						}, x, ka);
					b.shape = xa
				} else
					b.shape = c.drawVectorMarker({
						x: oa.x,
						y: oa.y
					}, x, ka);
			else if (oa && 0 !== oa.length)
				if (x = {
						stroke: this.stroke,
						strokeOpacity: this.strokeOpacity,
						strokeThickness: this.strokeThickness,
						strokeDashArray: this.strokeDashArray,
						fill: this.fill,
						fillOpacity: this.fillOpacity
					}, "Rectangle" === xa)
					if (!1 === this.repeatPattern) {
						x.fill = null;
						xa = {
							src: this.src,
							x: oa.x,
							y: oa.y,
							width: oa.width,
							height: oa.height,
							preserveAspectRatio: !0,
							opacity: this.fillOpacity
						};
						Ma = c.createGroup("imageGroup");
						ka.group.appendChild(Ma);
						ka.group = Ma;
						ka.enableCache = !0;
						try {
							c.drawImage(oa, xa, ka)
						} catch (z) {
							a.util.Logger.warning("MAPVIEWER", "OM.style.Area",
								"Cannot create nonpattern area style:"),
							a.util.Logger.warning("MAPVIEWER", z)
						}
						xa = ka.group;
						Ma = c.createGroup();
						ka.group.appendChild(Ma);
						ka.group = Ma;
						c.drawRectangle(oa, x, ka);
						Ma.appendChild(xa);
						b.shape = xa
					} else
						b.shape = c.drawRectangle(oa, x, ka);
				else if ("Polygon" === xa)
					b.shape = c.drawPath(oa, x, ka);
				else if ("MultiPolygon" === xa) {
					xa = c.createGroup();
					ka.group.appendChild(xa);
					ka.group = xa;
					Ma = 0;
					for (rb = oa.length; Ma < rb; Ma++)
						c.drawPath(oa[Ma], x, ka);
					b.shape = xa
				}
		},
		toXMLString: function () {
			var b;
			b = "" + ('\x3cstyle name\x3d"' +
					this.getStyleName() + '"\x3e');
			b = b + '\x3cg class\x3d"area" style\x3d"' + (a.notNull(this.stroke) ? "stroke:" + this.stroke + ";" : "");
			b += a.notNull(this.strokeOpacity) ? "stroke-opacity:" + Math.min(Math.round(255 * this.strokeOpacity), 255) + ";" : "";
			b += a.notNull(this.fill) ? "fill:" + this.fill + ";" : "";
			b += a.notNull(this.fillOpacity) ? "fill-opacity:" + Math.min(Math.round(255 * this.fillOpacity), 255) + ";" : "";
			return b += '"\x3e\x3c/g\x3e\x3c/style\x3e'
		}
	});
	a.style.Formatter = a.Class.extend({
		initialize: function (b) {
			this.scale = b && b.scale ||
				"logarithm";
			this.style = b ? b.style : null;
			this.numClasses = b && b.numClasses || 7;
			a.isNull(this.numClasses) && (this.numClasses = 0)
		},
		resolve: function (a, b, c) {
			return null
		},
		getScale: function () {
			return this.scale
		},
		getStyle: function () {
			return this.style
		},
		getNumClasses: function () {
			return this.numClasses
		}
	});
	a.style.ColorFormatter = a.style.Formatter.extend({
		initialize: function ta(b) {
			ta.base.call(this, b);
			this.baseColors = b.colors;
			a.isNull(this.baseColors) && (this.baseColors = a.style.colorbrewer.PuBuGn["7"]);
			this.defaultColor =
				b.defaultColor;
			a.isNull(this.defaultColor) && (a.notNull(this.style) && a.notNull(this.style.fill) ? this.defaultColor = this.style.fill : this.defaultColor = a.PaintTypes.NO_PAINT)
		},
		resolve: function (b, c) {
			var oa = this.baseColors,
			xa = this.numClasses || oa.length;
			if (a.isNull(b) || "" === b)
				return this.defaultColor;
			if (this.scale && 0 === this.scale.indexOf("log"))
				var Ma = c.getMin(), rb = c.getMax(), Ma = Math.log(Ma), xa = parseInt((Math.log(b) - Ma) / ((Math.log(rb) - Ma) / xa));
			else
				xa = (c.getMax() - c.getMin()) / xa, xa = parseInt((b - c.getMin()) /
						xa);
			return isNaN(xa) ? this.defaultColor : xa >= oa.length ? oa[oa.length - 1] : oa[xa]
		},
		getBaseColors: function (a) {
			return this.baseColors
		},
		setColors: function (a) {
			this.baseColors = a
		},
		getDefaultColor: function () {
			return this.defaultColor
		},
		setDefaultColor: function (a) {
			this.defaultColor = a
		}
	});
	a.style.SizeFormatter = a.style.Formatter.extend({
		initialize: function ka(b) {
			ka.base.call(this, b);
			this.startingSize = b.startingSize;
			a.isNull(this.startingSize) && (a.notNull(this.style) ? this.startingSize = this.style.origConfig.width : this.startingSize =
					15);
			this.defaultSize = b.defaultSize;
			a.isNull(this.defaultSize) && (this.defaultSize = 0);
			this.delta = b.delta || 5;
			this.lengthUnit = a.notNull(b.lengthUnit) ? b.lengthUnit : "pixel"
		},
		resolve: function (b, c, xa) {
			b = this.doResolve(b, c);
			c = this.lengthUnit.toLowerCase();
			"pixel" !== c && a.notNull(xa) && a.notNull(xa.parentLayer) && a.notNull(xa.parentLayer.parentMap) && (xa = a.util.GeomUtil.getCurrentDistancePerPixel(xa.parentLayer.parentMap.getMapContext()), c = a.gv.getUnitFactor(c), 0 !== c && (xa /= c), b /= xa);
			return b
		},
		doResolve: function (b,
			c) {
			if (a.isNull(b) || "" === b)
				return this.defaultSize;
			var xa = this.delta,
			Ma = this.numClasses,
			rb = this.startingSize;
			if (this.scale && 0 === this.scale.indexOf("log")) {
				var x = c.getMin(),
				z = c.getMax();
				if (0 >= x) {
					var p = 1 - x,
					x = x + p,
					z = z + p;
					b += p
				}
				x = Math.log(x);
				Ma = (Math.log(z) - x) / Ma;
				Ma = parseInt((Math.log(b) - x) / Ma)
			} else
				Ma = (c.getMax() - c.getMin()) / Ma, Ma = parseInt((b - c.getMin()) / Ma);
			isNaN(Ma) && (Ma = 0);
			return rb + xa * Ma
		},
		getStartingSize: function () {
			return this.minSize
		},
		getDefaultSize: function () {
			return this.defaultSize
		}
	});
	a.style.Div =
		a.style.Style.extend({
			initialize: function oa(b) {
				oa.base.call(this, b);
				b = b || {};
				this.showOnPoint = 1;
				this.lengthUnit = a.notNull(b.lengthUnit) ? b.lengthUnit : "pixel";
				this.width = b.width;
				this.height = b.height;
				this.callback = b.customRenderer;
				this.html = b.html
			},
			draw: function (b, c, Ma) {
				!1 !== this.applicable(b) && (Ma = this.getCustomLayerDiv(b), this.setPosition(Ma, b, c), a.notNull(this.html) ? Ma.html(this.html) : this.callback(Ma[0], b))
			},
			applicable: function (a) {
				switch (a.getGeometry().getType()) {
				case "Point":
				case "MultiPoint":
				case "OrientedMultiPoint":
				case "Polygon":
				case "MultiPolygon":
					return !0
				}
				return !1
			},
			resolve: function (b, c) {
				if (this.bindings && 0 !== this.bindings.length) {
					for (var Ma = 0, rb = this.bindings.length; Ma < rb; Ma++) {
						var x = this.bindings[Ma],
						z = this.resolveBinding(x, b);
						"SIZE" === x.attribute ? this.origConfig.width && this.origConfig.height && this.origConfig.width !== this.origConfig.height ? (this.height = this.origConfig.height * z / this.origConfig.width, this.width = z) : this.height = this.width = z : "WIDTH" === x.attribute ? this.width = z : "HEIGHT" === x.attribute && (this.height = z)
					}
					(a.isNull(this.width) || isNaN(this.width)) && a.notNull(this.origConfig.width) &&
					(this.width = this.origConfig.width);
					(a.isNull(this.height) || isNaN(this.height)) && a.notNull(this.origConfig.height) && (this.height = this.origConfig.height);
					this.realWidth = this.width;
					this.realHeight = this.height
				} else
					a.style.Style.calculateStyleSize(this, c)
			},
			setPosition: function (a, b, c) {
				this.resolve(b, c);
				var rb = this.realWidth,
				x = this.realHeight,
				z = c.getTransform(),
				p = b.parentLayer;
				c = c.getCenterPoint();
				var l = this.getCenterPoint(b);
				b = z.toScreenXLength(l.getX() - c.getX()) + p.orgWidth / 2;
				var l = z.toScreenYLength( - (l.getY() -
							c.getY())) + p.orgHeight / 2,
				Q = z.toScreenXLength(p.dataBufferWindow.x + p.dataBufferWindow.w / 2 - c.getX()),
				z = z.toScreenYLength( - (p.dataBufferWindow.y + p.dataBufferWindow.h / 2 - c.getY()));
				a.parent().css({
					left: Q,
					top: z
				});
				a.css({
					left: b - Q + "px",
					top: l - z + "px",
					width: rb + "px",
					height: x + "px"
				})
			},
			getCenterPoint: function (b) {
				b = b.getGeometry().getMIR();
				return new a.geometry.Point((b.getMinX() + b.getMaxX()) / 2, (b.getMinY() + b.getMaxY()) / 2, b.srid)
			},
			getCustomLayerDiv: function (b) {
				var c = b.parentLayer,
				h = c.getDivId("f_" + b.id),
				rb = a.$("#" +
						h);
				0 >= rb.length && a.notNull(c.parentMap) && (h = a.$("\x3cdiv id\x3d'" + h + "' style\x3d'position:absolute;overflow:hidden'\x3e"), h.css({
						display: "block"
					}), c.getCustomLayerDiv().append(h), rb = b.$customDiv = h);
				rb.data("f", b);
				return rb
			},
			getBindables: function () {
				return this.bindableAttrs ? this.bindableAttrs : this.bindableAttrs = ["Size", "Width", "Height"]
			}
		});
	a.style.SourceImageFormatter = a.style.Formatter.extend({
		initialize: function xa(b) {
			xa.base.call(this, b);
			this.defaultSource = b ? b.defaultSource : null;
			a.isNull(this.defaultSource) &&
			(a.notNull(this.style) && a.notNull(this.style.src) ? this.defaultSource = this.style.src : this.defaultSource = a.PaintTypes.NO_PAINT);
			this.baseSources = b ? b.sources : null;
			a.isNull(this.baseSources) && (this.baseSources = [this.defaultSource])
		},
		resolve: function (a, b, c) {},
		getBaseSources: function (a) {
			return this.baseSources
		},
		setSources: function (a) {
			this.baseSources = a
		},
		getDefaultSource: function () {
			return this.defaultSource
		},
		setDefaultSource: function (a) {
			this.defaultSource = a
		}
	});
	a.style.StackedMarker = a.style.Marker.extend({
		initialize: function Ma(b) {
			b =
				b || {};
			b.styleType = "StackedMarker";
			Ma.base.call(this, b);
			b.styleType = "StackedMarker";
			this.width = a.notNull(b.width) ? b.width : null;
			this.height = a.notNull(b.height) ? b.height : null;
			this.xOffset = a.notNull(b.xOffset) ? b.xOffset : 0;
			this.yOffset = a.notNull(b.yOffset) ? b.yOffset : 0;
			this.lengthUnit = a.notNull(b.lengthUnit) ? b.lengthUnit : "pixel";
			this.src = a.notNull(b.src) ? b.src : null;
			this.textStyle = a.notNull(b.textStyle) ? b.textStyle : null === b.textStyle ? null : c;
			if (this.src && (a.isNull(this.width) || a.isNull(this.height))) {
				var x =
					this,
				z = new Image;
				z.src = this.src;
				z.onload = function () {
					a.isNull(x.width) && (x.width = z.width);
					a.isNull(x.height) && (x.height = z.height);
					x.origConfig && (x.origConfig.width = z.width, x.origConfig.height = z.height)
				}
			}
			(this.markerArray = a.notNull(b.markerArray) ? b.markerArray : null) ? this.validateMarkers() : a.util.Logger.warning(null, "OM.style.StackedMarker", "ERROR: Invalid marker array");
			this.textOffset = b.textOffset ? b.textOffset : null;
			this.showOnPoint = 2
		},
		validateMarkers: function () {
			for (var b = 0; b < this.markerArray.length; b++) {
				if (!this.markerArray[b]instanceof
					a.style.Marker) {
					a.util.Logger.warning(null, "OM.style.StackedMarker", "ERROR: Invalid marker array");
					break
				}
				this.markerArray[b].calculateVectorMarkerScale()
			}
		},
		resolve: function () {
			return this
		},
		draw: function (b, c, x) {
			for (var z = c.getGraphics().createGroup(), p = 0; p < this.markerArray.length; p++) {
				var l = this.markerArray[p];
				l.resolve(b);
				var Q = b.geo,
				A = b.geo.type;
				if (x.markerPoint && b.shapeGroup)
					x.group.appendChild(z), 0 !== l.width && 0 !== l.height && l.drawMarker(c, z, x.markerPoint, b.markerText);
				else if (x.sPoint)
					x.group.appendChild(z),
					l.drawMarker(c, z, x.sPoint, b.markerText);
				else {
					if ("LineString" === A || "MultiLineString" === A)
						break;
					if ("Polygon" === A || "MultiPolygon" === A)
						b.screenPoints || (A = null, b.labelBox ? A = new a.geometry.Point((b.labelBox[0] + b.labelBox[2]) / 2, (b.labelBox[1] + b.labelBox[3]) / 2, Q.srid) : Q.mbr && (A = new a.geometry.Point((Q.mbr.getMinX() + Q.mbr.getMaxX()) / 2, (Q.mbr.getMinY() + Q.mbr.getMaxY()) / 2, Q.srid)), A = b.transformGeometry(A), b.screenPoints || (b.screenPoints = A)), x.group.appendChild(z), l.drawMarker(c, z, b.screenPoints, b.markerText);
					else if (b.screenPoints || b.transformGeometry(Q), "Point" === A || "OrientedPoint" === A)
						if (x.group.appendChild(z), l.drawMarker(c, z, b.screenPoints, b.markerText), l.markerText)
							l.drawMarker(c, z, b.screenPoints, b.markerText);
						else if ("MultiPoint" === A || "OrientedMultiPoint" === A)
							for (x.group.appendChild(z), p = 0, Q = b.screenPoints.length; p < Q; p++)
								l.drawMarker(c, z, b.screenPoints[p], b.markerText)
				}
			}
			b.shape = z
		}
	});
	a.style.GlyphMarker = a.style.Marker.extend({
		initialize: function rb(b) {
			b = b || {};
			b.styleType = "GlyphMarker";
			rb.base.call(this,
				b);
			b.styleType = "GlyphMarker";
			this.width = a.notNull(b.width) ? b.width : null;
			this.height = a.notNull(b.height) ? b.height : null;
			this.xOffset = a.notNull(b.xOffset) ? b.xOffset : 0;
			this.yOffset = a.notNull(b.yOffset) ? b.yOffset : 0;
			this.lengthUnit = a.notNull(b.lengthUnit) ? b.lengthUnit : "pixel";
			this.src = a.notNull(b.src) ? b.src : null;
			this.textStyle = a.notNull(b.textStyle) ? b.textStyle : null === b.textStyle ? null : c;
			this.glyph = a.notNull(b.glyph) ? b.glyph : "?";
			if (this.src && (a.isNull(this.width) || a.isNull(this.height))) {
				var z = this,
				p = new Image;
				p.src = this.src;
				p.onload = function () {
					a.isNull(z.width) && (z.width = p.width);
					a.isNull(z.height) && (z.height = p.height);
					z.origConfig && (z.origConfig.width = p.width, z.origConfig.height = p.height)
				}
			}
			this.textOffset = b.textOffset ? b.textOffset : null;
			this.showOnPoint = 2;
			this.calculateSurrogates(b.glyph)
		},
		calculateSurrogates: function (a) {
			if ("U" === a.charAt(0) && "+" === a.charAt(1)) {
				a = "0x" + a.substr(2, a.length - 1);
				a = parseInt(a);
				var b = Math.floor((a - 65536) / 1024) + 55296,
				b = "0x" + b.toString(16);
				a = "0x" + ((a - 65536) % 1024 + 56320).toString(16);
				b = String.fromCharCode(b);
				this.glyph = b += String.fromCharCode(a)
			}
		},
		drawMarker: function (a, b, z, p) {
			if (0 !== this.width && 0 !== this.height)
				return a = a.getGraphics().createTextNode(this.glyph, this.textStyle, z.x, z.y), b.appendChild(a), a
		}
	});
	a.Column = a.Class.extend({
		mixin: a.event.EventSource,
		initialize: function (b) {
			this.keyGetter = b.keyGetter;
			this.valueGetter = b.valueGetter;
			this.valueType = b.type || "number";
			this.measureName = b.measureName || "Measure";
			this.measureIndex = a.isNull(b.measureIndex) ? 1 : b.measureIndex;
			b = b.data;
			var x;
			this.numRows = b.length;
			this.hash = [];
			this.min = Number.POSITIVE_INFINITY;
			this.max = Number.NEGATIVE_INFINITY;
			for (var z, p = 0, l = b.length; p < l; p++)
				x = b[p], z = this.keyGetter.call(x), x = this.valueGetter.call(x, this.measureIndex), a.isNull(x) || (this.hash[z] = x, x < this.min && (this.min = x), x > this.max && (this.max = x))
		},
		getSize: function () {
			return this.numRows
		},
		getValueOfRow: function (b) {
			return a.isNull(b) || a.isNull(this.hash) ? null : this.hash[b]
		},
		getValueType: function () {
			return this.valueType
		},
		getMin: function () {
			return this.min
		},
		getMax: function () {
			return this.max
		},
		getAverage: function () {
			return 0
		},
		getKeys: function () {
			return []
		},
		getKeyNames: function () {},
		isMeasure: function () {
			return !0
		},
		getSampleData: function (a) {},
		getMeasureName: function () {
			return this.measureName
		},
		getMeasureIndex: function () {
			return this.measureIndex
		}
	});
	a.Feature = a.Class.extend({
		mixin: a.event.EventSource,
		initialize: function (b, x, z) {
			this.id = b;
			this.activeIdx = null;
			this.geo = x ? x : null;
			this.geo instanceof a.geometry.Geometry || !this.geo || (this.geo = a.geometry.Geometry.createGeometry(this.geo,
						this.geo.srid));
			this.shape = this.group = this.graphics = null;
			this.attributes = z && a.notNull(z.attributes) ? z.attributes : null;
			this.renderingStyle = z && a.notNull(z.renderingStyle) ? z.renderingStyle : null;
			this.selectivity = z && a.notNull(z.selectivity) ? z.selectivity : 0;
			this.label = z && a.notNull(z.label) ? z.label : null;
			this.labelStyle = z && a.notNull(z.labelStyle) ? z.labelStyle : null;
			this.labelStyleName = z && a.notNull(z.labelStyleName) ? z.labelStyleName : null;
			this.draggable = z && a.notNull(z.draggable) ? z.draggable : null;
			this.customContent =
				z && a.notNull(z.customContent) ? z.customContent : null;
			this.displayed = !1;
			this.visible = !0;
			this.editable = !1;
			this.screenTransformObj = null;
			this.labelOffsetY = this.labelOffsetX = 2;
			this.hover = this.selected = !1;
			this.tooltipNode = this.tooltipCache = null;
			this.scaleY = this.scaleX = 1;
			if (this.attributes)
				for (var p in this.attributes)
					b = p.toUpperCase(), b !== p && (this.attributes[b] = this.attributes[p], this.attributes[p] = null, delete this.attributes[p]);
			this.columnMap = null;
			this.tiledFeature = !1;
			this.tileGeometries = {};
			this.clipMap = {};
			this.zoomLevelsGeometries = {};
			this.zoomLevelsGeomClipArea = {}
		},
		setGeometry: function (b) {
			if (a.isNull(b))
				return !1;
			a.notNull(this.parentLayer) && this.parentLayer.useRTree && this.parentLayer.removeFromRtree(this);
			if (!this.displayed)
				return this.geo = b, this.screenPoints = null, !0;
			var x = this.geo.srid;
			if (b.srid !== x) {
				var z = this;
				b.transform(x, function (a) {
					z.setGeometry(a)
				});
				return !0
			}
			this.clearInfoWindow();
			this.geo = b;
			this.getShapeIndex();
			this.remove();
			this.screenPoints = null;
			b = this.parentLayer;
			var x = [],
			p = b.getFeatureStyles(this);
			p && x.push(p);
			b.otherStyles && (x = x.concat(b.otherStyles));
			if (0 === x.length)
				if (p = b.getDefaultRenderingStyle(this.geo.type))
					x.push(p);
				else
					return !1;
			x = this.getAllStyles(x);
			if (b.featureGroupArr && 0 < b.featureGroupArr.length)
				for (this.shapeArray = [], p = 0; p < b.featureGroupArr.length; p++) {
					if (a.isNull(this.activeIdx) || this.activeIdx === p)
						this.group = b.featureGroupArr[p], this.displayFeature(x, -1), this.shapeArray[p] = this.labelShape
				}
			else
				this.displayFeature(x, -1);
			b.parentMap.wraparound && b.refresh();
			this.startAnimation();
			return !0
		},
		getGeometry: function () {
			var b = a.geometry.Geometry;
			this.geo instanceof b || !this.geo || (this.geo = b.createGeometry(this.geo, this.geo.srid));
			return this.geo
		},
		getAttributes: function () {
			return this.attributes
		},
		upperKeys: function (b) {
			if (!a.isNull(b)) {
				for (var x, z = Object.keys(b), p = z.length, l = {}; p--; )
					x = z[p], l[x.toUpperCase()] = b[x];
				return l
			}
		},
		getAttributeValue: function (b) {
			if ("string" !== typeof b || !this.attributes)
				return null;
			var x = this.attributes,
			z = this.upperKeys(x),
			p = b.toUpperCase();
			return a.notNull(x[b]) ?
			x[b] : a.notNull(z[p]) ? z[p] : (b = this.getAliasColumnName(b)) ? (b = b.toUpperCase(), x[b]) : null
		},
		hasAttributes: function () {
			return this.attributes ? !0 : !1
		},
		getAliasColumnName: function (b) {
			if ("string" !== typeof b || !this.columnMap)
				return null;
			var x = this.columnMap || this.parentLayer.columnMap;
			b = b.toUpperCase();
			return x && a.notNull(x[b]) ? x[b] : null
		},
		getRealColumnName: function (a) {
			if ("string" !== typeof a)
				return null;
			var b = this.columnMap;
			a = a.toUpperCase();
			if (b)
				for (var z in b)
					if (b.hasOwnProperty(z) && b[z].toUpperCase() === a)
						return z;
			return null
		},
		getAllStyles: function (b) {
			for (var x = [], x = [], z = 0; z < b.length; z++)
				a.notNull(b[z].animation) && x.push(b[z].animation);
			return x = b.concat(x)
		},
		setRenderingStyle: function (b) {
			if ((!a.isNull(b) || !a.isNull(this.parentLayer) && !a.isNull(this.parentLayer.otherStyles) && 0 !== this.parentLayer.otherStyles.length) && this.renderingStyle !== b && (this.renderingStyle = b, this.displayed)) {
				this.getShapeIndex();
				var x = this;
				a.notNull(this.shape) && this.shape.addEventListener(a.event.MouseEvent.MOUSE_OUT, function (a) {
					try {
						a.target =
							x.shape,
						x.shape.dispatchEvent(a)
					} catch (b) {}
				});
				this.remove();
				b = [b];
				this.parentLayer && this.parentLayer.otherStyles && (b = b.concat(this.parentLayer.otherStyles));
				b = this.getAllStyles(b);
				if (this.parentLayer && this.parentLayer.featureGroupArr && 0 < this.parentLayer.featureGroupArr.length) {
					this.shapeArray = [];
					for (var z = 0; z < this.parentLayer.featureGroupArr.length; z++)
						if (a.isNull(this.activeIdx) || this.activeIdx === z)
							this.group = this.parentLayer.featureGroupArr[z], this.displayFeature(b, -1), this.shapeArray[z] = this.shape
				} else
					this.displayFeature(b,
						-1);
				this.setShapeIndex()
			}
		},
		getRenderingStyle: function () {
			return this.renderingStyle
		},
		setLabel: function (b) {
			a.isNull(b) || (this.label = b, this.applyToolTip())
		},
		setLabelingStyle: function (b) {
			a.isNull(b) || (this.labelStyle = b)
		},
		getLabelingStyle: function () {
			return this.labelStyle
		},
		isVisible: function () {
			return this.visible
		},
		setVisible: function (b) {
			if (!a.isNull(b))
				if (this.visible = b, this.displayed) {
					var x = this.graphics;
					x.setVisible(this.shape, b);
					this.ghostShape && x.setVisible(this.ghostShape, b);
					this.labelShape && x.setVisible(this.labelShape,
						b)
				} else
					b && this.displayFeature(this.renderingStyle)
		},
		bringForward: function () {
			this.parentLayer && this.parentLayer.bringFeatureForward(this)
		},
		sendBackward: function () {
			this.parentLayer && this.parentLayer.sendFeatureBackward(this)
		},
		bringToTop: function () {
			this.parentLayer && this.parentLayer.bringFeatureToTop(this)
		},
		sendToBottom: function () {
			this.parentLayer && this.parentLayer.sendFeatureToBottom(this)
		},
		displayFeature: function (b, x, z) {
			var p = this.geo,
			l = null,
			c = null;
			a.notNull(this.tooltipNode) && (this.tooltipCache =
					this.tooltipNode = null);
			this.tiledFeature && (l = this.parentLayer.parentMap.getMapContext(), c = l.getZoomLevel(), a.notNull(z) ? this.geo = this.tileGeometries[z][this.id] : this.geo = this.getGeometry());
			var l = this.geo,
			A = this.typeIs(l);
			if ((!this.editing || "OrientedPoint" !== A) && b && 0 !== b.length) {
				var B = b[0];
				if (B && !(B instanceof a.style.Style) && B.dataSource && B.name) {
					var G = this;
					b = B.url;
					a.isNull(b) && (b = this.parentLayer.type === a.layer.VectorLayer.TYPE_JDBC || this.parentLayer.type === a.layer.VectorLayer.TYPE_PREDEFINED ? this.parentLayer.serverURL :
							this.parentLayer.parentMap.mapviewerURL);
					a.style.StyleStore.getServerSideStyle(B.dataSource, B.name, {
						url: b,
						callback: function (a) {
							G.displayFeature([a], x, z)
						}
					})
				} else {
					var B = this.graphics,
					Y = this.renderingStyle && this.renderingStyle.cased ? this.parentLayer.getLineGroup() : this.group,
					W = this.screenTransformObj;
					if (!(a.isNull(B) || a.isNull(Y) || a.isNull(l) || a.isNull(W))) {
						1 < b.length && (W = B.createGroup(), Y.appendChild(W), Y = W);
						var W = b.length,
						K = [],
						q = null;
						a.notNull(z) && a.notNull(this.clipMap) && a.notNull(this.clipMap[z]) &&
						(q = this.transformGeometry(this.clipMap[z]));
						for (var t = 0; t < W; t++) {
							var I = a.$.extend({}, b[t]),
							aa = I.styleType;
							if (I.showOnPoint)
								I.realWidth = null, I.realHeight = null, K.push(I);
							else {
								if ("GeometryCollection" === A) {
									var ba = this.zoomLevelsGeomClipArea["zoomlevel_" + c],
									R = B.createGroup(),
									qa = R;
									Y.appendChild(R);
									for (var ua = 0, Ca = l.geometries.length; ua < Ca; ua++) {
										var pa = this.transformGeometry(l.geometries[ua]);
										a.isNull(z) && this.tiledFeature && (q = this.transformGeometry(ba[ua]), R = B.createGroup(), qa.appendChild(R));
										a.notNull(q) &&
										R.setClip([q.x, q.y, q.width + .5, q.height + .5]);
										I.draw(this, this.parentLayer.parentMap.getMapContext(), {
											group: R,
											type: l.geometries[ua].type,
											screenPoints: pa
										})
									}
									this.shape = qa
								} else
									ba = null, a.notNull(z) && this.tiledFeature && (ba = this.shape, a.isNull(ba) && (ba = B.createGroup(), Y.appendChild(ba)), Y = B.createGroup(), ba.appendChild(Y)), a.notNull(q) && Y.setClip([q.x, q.y, q.width + .5, q.height + .5]), I.draw(this, this.parentLayer.parentMap.getMapContext(), {
										group: Y,
										idx: x
									}), a.notNull(q) && Y.setClip(null), a.notNull(z) && this.tiledFeature &&
									(this.shape = ba);
								"AnimationColor" != aa && "PulseAnimation" != aa || !a.notNull(this.shape) || (this.animations = [], this.createAnimation(this.shape, I, "MultiLineString" == A || "LineString" == A))
							}
						}
						0 < K.length && (c = this.parentLayer.parentMap.getMapContext().getUniverse().getSRID(), a.notNull(z) && this.tiledFeature ? (a.isNotNull(this.chartGroup) && (this.chartGroup.parentNode && this.chartGroup.parentNode.removeChild(this.chartGroup), this.chartGroup = null), this.chartGroup = B.createGroup(), Y.appendChild(this.chartGroup), Y = this.chartGroup,
								this.labelBox = null, this.createLabelBox(p), this.getPointPosition(K, this.labelBox, Y, c, p)) : (a.isNull(this.labelBox) && this.createLabelBox(), this.getPointPosition(K, this.labelBox, Y, c)));
						1 < W && (this.shape = Y);
						this.displayed = !0;
						this.ghostGeom && (this.drawGhostGeom(this.ghostGeom, b), this.drawGhostLabel(this.ghostGeom));
						if (this.shapeGroup && !this.visible)
							for (t = 1; t < this.shapeGroup.length; t++)
								this.graphics.setVisible(this.shapeGroup[t], !1);
						else
							this.shape && !this.visible && this.graphics.setVisible(this.shape, !1);
						this.ghostShape && !this.visible && this.graphics.setVisible(this.ghostShape, !1);
						this.resumeMoveAnimation();
						a.notNull(this.parentLayer) && this.parentLayer.useRTree && (this.tiledFeature ? a.notNull(z) && (this.parentLayer.addToRtree(this, l), this.parentLayer.updatedSearchWindow(this, A)) : (this.parentLayer.addToRtree(this), this.parentLayer.updatedSearchWindow(this, A)));
						this.tiledFeature && (this.geo = p)
					}
				}
			}
		},
		getFeatureScreenPosition: function () {
			return this.featurePosition
		},
		transformGeometry: function (a) {
			var b = this.parentLayer.parentMap.getMapContext().getTransform(),
			z = a.dim ? a.dim : 2,
			p = a.type,
			l = a.coordinates,
			c,
			A,
			B,
			G,
			Y,
			W;
			if ("Point" === p)
				c = b.toScreenPoint(l[0], l[1]);
			else if ("OrientedPoint" === p)
				c = b.toScreenPoint(l[0], l[1]), A = l[z], B = l[z + 1], A = -Math.atan2(B, A), c.angle = A;
			else if ("MultiPoint" === p || "OrientedMultiPoint" === p)
				for (c = [], G = 0, W = l.length; G < W; G++)
					Y = b.toScreenPoint(l[G][0], l[G][1]), "OrientedMultiPoint" === p && (A = l[G][z], B = l[G][z + 1], A = -Math.atan2(B, A), Y.angle = A), c.push(Y);
			else if ("LineString" === p)
				c = (A = b.transformSegment(l, 2, z)) ? [A] : null;
			else if ("MultiLineString" === p)
				for (c =
						[], Y = 0, p = l.length; Y < p; Y++)
					(A = b.transformSegment(l[Y], 2, z)) && c.push([A]);
			else if ("Polygon" == p)
				for (c = [], G = 0, W = l.length; G < W; G++)
					(A = b.transformSegment(l[G], 1, z)) && c.push(A);
			else if ("MultiPolygon" === p)
				for (c = [], Y = 0, p = l.length; Y < p; Y++) {
					B = [];
					G = 0;
					for (W = l[Y].length; G < W; G++)
						(A = b.transformSegment(l[Y][G], 2, z)) && B.push(A);
					0 < B.length && c.push(B)
				}
			else
				"Rectangle" === p && (Y = b.toScreenPoint(l[0], l[3]), z = b.toScreenXLength(l[2] - l[0]), b = b.toScreenYLength(l[3] - l[1]), c = {
						x: Y.x,
						y: Y.y,
						width: z,
						height: b
					});
			this.geo === a && (this.screenPoints =
					c);
			return this.featurePosition = c
		},
		drawSinglePoint: function (a, b, z, p) {
			var l = {
				group: b,
				id: "pot"
			};
			z.angle && (l.angle = z.angle);
			l.xOffset = p.xOffset;
			l.yOffset = p.yOffset;
			var c;
			p && p.src ? (l.enableCache = !0, c = a.drawImageMarker({
					x: z.x,
					y: z.y
				}, p, l)) : p && p.resolve && (p.resolve(this), c = p.drawMarker(this.parentLayer.parentMap.getMapContext(), b, z, null));
			return c
		},
		drawRectangle: function (a, b, z, p, l) {
			var c,
			A,
			B,
			G;
			if (!this.screenPoints || l)
				z = z.coordinates, A = this.screenTransformObj.toScreenPoint(z[0], z[3]), c = A.x, A = A.y, B = this.screenTransformObj.toScreenXLength(z[2] -
						z[0]), G = this.screenTransformObj.toScreenYLength(z[3] - z[1]), l || (this.screenPoints = {
						x: c,
						y: A,
						width: B,
						height: G
					});
			B = a.drawRectangle({
				x: c,
				y: A,
				width: B,
				height: G
			}, p, {
				group: b,
				id: "rec"
			});
			z = (this.geo.getMBR().getMinX() + this.geo.getMBR().getMaxX()) / 2;
			G = (this.geo.getMBR().getMinY() + this.geo.getMBR().getMaxY()) / 2;
			z = this.screenTransformObj.toScreenPoint(z, G);
			this.parentLayer.leadLine && (this.line = a.drawPath([[c, A, z.x, z.y]], p, {
					group: b
				}), this.line.feature = this);
			l || (this.shape = B);
			return B
		},
		remove: function () {
			var a = this.shape;
			if (a) {
				this.graphics.remove(a);
				this.shape = null;
				if (this.shapeGroup)
					for (var a = this.shapeGroup.length, b = 0; b < a; b++)
						this.shapeGroup[b] && this.graphics.remove(this.shapeGroup[b]);
				this.shapeGroup = null;
				if (this.shapeArray) {
					a = this.shapeArray.length;
					for (b = 0; b < a; b++)
						this.shapeArray[b] && (this.shapeArray[b].feature = null, this.graphics.remove(this.shapeArray[b]));
					this.shapeArray = null
				}
			}
		},
		typeIs: function (b) {
			var x = a.geometry;
			return b instanceof x.Circle ? "Circle" : b instanceof x.Rectangle ? "Rectangle" : b.type
		},
		move: function (b,
			x, z) {
			var p = this.parentLayer;
			a.notNull(p) && p.removeFromRtree(this);
			b = -b;
			var l,
			c;
			if (this.displayed) {
				c = this.geo.type;
				if ("GeometryCollection" != c) {
					var A = this.screenPoints;
					l = c;
					if ("Point" === l || "OrientedPoint" === l || "Rectangle" === l)
						A.x += b, A.y -= x;
					else if ("MultiPoint" === l || "OrientedMultiPoint" === l) {
						var B = A.length;
						for (l = 0; l < B; l++)
							A[l].x += b, A[l].y -= x
					} else
						a.util.GeomUtil.moveCoordinates(A, b, -x, null, null, this.parentLayer.parentMap.getMapContext())
				}
				b *= z.resolution;
				A = x * z.resolution * z.stretchRatio;
				if (this.geo instanceof
					a.geometry.Geometry)
					this.geo.move(b, A, this.parentLayer.parentMap.getMapContext());
				else if ("GeometryCollection" != c)
					a.util.GeomUtil.moveCoordinates(this.geo.coordinates, b, A, "OrientedPoint" == c || "OrientedMultiPoint" == c ? !0 : !1, this.geo.dim, this.parentLayer.parentMap.getMapContext());
				else
					for (l = this.geo.geometries, z = l.length, x = 0; x < z; x++)
						c = l[x].type, c = "OrientedPoint" == c || "OrientedMultiPoint" == c ? !0 : !1, a.util.GeomUtil.moveCoordinates(l[x].coordinates, b, A, c, l[x].dim, this.parentLayer.parentMap.getMapContext());
				this.labelBox && (this.labelBox = [this.labelBox[0] + b, this.labelBox[1] + A, this.labelBox[2] + b, this.labelBox[3] + A]);
				a.notNull(p) && p.addToRtree(this);
				return this.geo
			}
		},
		addLabel: function (b) {
			if (this.displayed && this.parentLayer) {
				if (!this.label) {
					if (!this.attributes)
						return;
					this.label = this.parentLayer.labelColumn ? this.attributes[this.parentLayer.labelColumn.toUpperCase()] : this.attributes._LABEL_
				}
				if (this.label) {
					var x = this.getLabelingStyle();
					a.isNull(x) ? this.renderingStyle && "Marker" === this.renderingStyle.styleType &&
					a.notNull(this.renderingStyle.textStyle && this.renderingStyle.textStyle.from_marker_hints) || !a.style.StyleStore || (x = a.style.StyleStore.defaulTextStyle, this.setLabelingStyle(x)) : this.renderingStyle && "Marker" === this.renderingStyle.styleType && a.notNull(this.renderingStyle.textStyle) && this.renderingStyle.textStyle.from_marker_hints && this.renderingStyle.styleName === x.styleName && (x = null);
					var z = this.geo.type;
					if (a.notNull(x))
						if (x.resolve(this), a.style.Style.calculateStyleSize(this.labelStyle, this.parentLayer.parentMap.getMapContext()),
							"Point" === z || "OrientedPoint" === z)
							this.addPointLabel(b);
						else if ("Polygon" === z || "MultiPolygon" === z || "Rectangle" === z) {
							if (this.addPolygonLabel(b), !this.labelShape && (b = this.parentLayer.createShadowGeometry(this)))
								this.drawGhostGeom(b, [this.renderingStyle]), this.drawGhostLabel(b)
						} else
							"LineString" !== z && "MultiLineString" !== z || this.addLineLabel(b);
					else
						a.util.Logger.info(null, "Feature", "No labeling style present for feature")
				}
			}
		},
		addPointLabel: function (b) {
			var x = this.graphics;
			if (!a.isNull(x)) {
				var z = x.getTextSize(this.label,
						this.labelStyle);
				z.w = parseInt(z.w) - 2;
				z.h = parseInt(z.h) - 4;
				a.isNull(this.screenPoints) && a.notNull(this.geo) && a.notNull(this.geo.type) && ("Point" === this.geo.type || "OrientedPoint" === this.geo.type) && this.screenTransformObj && 2 <= this.geo.coordinates.length && (this.screenPoints = this.screenTransformObj.toScreenPoint(this.geo.coordinates[0], this.geo.coordinates[1]));
				if (!a.isNull(this.screenPoints)) {
					var p = this.screenPoints.x,
					l = this.screenPoints.y,
					c = this.markerSize ? this.markerSize.w : this.renderingStyle.width,
					A =
						this.markerSize ? this.markerSize.h : this.renderingStyle.height;
					a.isNull(c) && !a.isNull(this.markerWidth) && (c = this.markerWidth);
					a.isNull(c) && (c = a.gv.defaultMarkerStyleWidth);
					a.isNull(A) && !a.isNull(this.markerHeight) && (A = this.markerHeight);
					a.isNull(A) && (A = a.gv.defaultMarkerStyleHeight);
					var B;
					"OrientedPoint" === this.geo.type && (B = -Math.atan2(this.geo.getOrientationY(), this.geo.getOrientationX()));
					var x = {},
					G = p - c / 2 - this.labelOffsetX,
					Y = G - z.w,
					W = l - z.h / 2,
					K = l + z.h / 2;
					x.L = [Y, W, G, K];
					B && (0 >= B && B >= -Math.PI / 2 && (Y = p - (c /
									2 + this.labelOffsetX + z.w) * Math.cos(-B), W = l + (c / 2 + this.labelOffsetX) * Math.sin(-B), G = p - (c / 2 + this.labelOffsetX) * Math.cos(-B), K = l + (c / 2 + this.labelOffsetX + z.w) * Math.sin(-B), x.L = [Y, W, G, K], x.LL = [Y, K]), B >= -Math.PI && B < -Math.PI / 2 && (Y = p + (c / 2 + this.labelOffsetX) * Math.cos(Math.PI + B), W = l + (c / 2 + this.labelOffsetX) * Math.sin(Math.PI + B), G = p + (c / 2 + this.labelOffsetX + z.w) * Math.cos(Math.PI + B), K = l + (c / 2 + this.labelOffsetX + z.w) * Math.sin(Math.PI + B), x.L = [Y, W, G, K], x.LL = [Y, W]), B <= Math.PI && B >= Math.PI / 2 && (Y = p + (c / 2 + this.labelOffsetX) * Math.cos(Math.PI -
									B), W = l - (c / 2 + this.labelOffsetX + z.w) * Math.sin(Math.PI - B), G = p + (c / 2 + this.labelOffsetX + z.w) * Math.cos(Math.PI - B), K = l - (c / 2 + this.labelOffsetX) * Math.sin(Math.PI - B), x.L = [Y, W, G, K], x.LL = [Y, K]), B < Math.PI / 2 && 0 < B && (Y = p - (c / 2 + this.labelOffsetX + z.w) * Math.cos(B), W = l - (c / 2 + this.labelOffsetX + z.w) * Math.sin(B), G = p - (c / 2 + this.labelOffsetX) * Math.cos(B), K = l - (c / 2 + this.labelOffsetX) * Math.sin(B), x.L = [Y, W, G, K], x.LL = [Y, W]));
					Y = p + c / 2 + this.labelOffsetX;
					G = Y + z.w;
					x.R = [Y, W, G, K];
					B && (0 >= B && B >= -Math.PI / 2 && (Y = p + (c / 2 + this.labelOffsetX) * Math.cos(-B),
							W = l - (c / 2 + this.labelOffsetX + z.w) * Math.sin(-B), G = p + (c / 2 + this.labelOffsetX + z.w) * Math.cos(-B), K = l - (c / 2 + this.labelOffsetX) * Math.sin(-B), x.R = [Y, W, G, K], x.RR = [Y, K]), B >= -Math.PI && B < -Math.PI / 2 && (Y = p - (c / 2 + this.labelOffsetX + z.w) * Math.cos(B + Math.PI), W = l - (c / 2 + this.labelOffsetX + z.w) * Math.sin(B + Math.PI), G = p - (c / 2 + this.labelOffsetX) * Math.cos(B + Math.PI), K = l - (c / 2 + this.labelOffsetX) * Math.sin(B + Math.PI), x.R = [Y, W, G, K], x.RR = [Y, W]), B <= Math.PI && B >= Math.PI / 2 && (Y = p - (c / 2 + this.labelOffsetX + z.w) * Math.cos(Math.PI - B), W = l + (c / 2 + this.labelOffsetX) *
								Math.sin(Math.PI - B), G = p - (c / 2 + this.labelOffsetX) * Math.cos(Math.PI - B), K = l + (c / 2 + this.labelOffsetX + z.w) * Math.sin(Math.PI - B), x.R = [Y, W, G, K], x.RR = [Y, K]), B < Math.PI / 2 && 0 < B && (Y = p + (c / 2 + this.labelOffsetX) * Math.cos(B), W = l + (c / 2 + this.labelOffsetX) * Math.sin(B), G = p + (c / 2 + this.labelOffsetX + z.w) * Math.cos(B), K = l + (c / 2 + this.labelOffsetX + z.w) * Math.sin(B), x.R = [Y, W, G, K], x.RR = [Y, W]));
					Y = p - z.w / 2;
					G = Y + z.w;
					K = l - A / 2 - this.labelOffsetY;
					W = K - z.h;
					x.T = [Y, W, G, K];
					Y = p - z.w / 2;
					G = Y + z.w;
					W = l + A / 2 + this.labelOffsetY;
					K = W + z.h;
					x.B = [Y, W, G, K];
					l = a.gv.labelDisplayOrder;
					p = a.gv.orientedLabelDisplayOrder;
					if (B)
						for (l = 0; l < p.length && (z = x[p[l]], G = x[p[l] + p[l]], !this.addLabelNode(b, z, G[0], G[1], {
									angle: B,
									w: c,
									h: A
								})); l++);
					else
						for (B = 0; B < l.length && (z = x[l[B]], !this.addLabelNode(b, z, z[0], z[3] - 1)); B++);
				}
			}
		},
		createLabelBox: function (b) {
			var x = null;
			if (x = a.notNull(b) ? b.getMIR() : this.getGeometry().getMIR())
				this.labelBox = [x.getMinX(), x.getMinY(), x.getMaxX(), x.getMaxY()]
		},
		addPolygonLabel: function (a) {
			this.labelBox || this.createLabelBox();
			if (this.labelBox) {
				var b = this.graphics.getTextSize(this.label,
						this.labelStyle),
				z = 0 < this.label.indexOf("\n") ? !0 : !1;
				b.w = parseInt(b.w) - 2;
				b.h = parseInt(b.h) - 4;
				var p = this.screenTransformObj.toScreenPoint((this.labelBox[0] + this.labelBox[2]) / 2, (this.labelBox[1] + this.labelBox[3]) / 2),
				l = p.x,
				c = p.y,
				A = l - b.w / 2,
				B = l + b.w / 2,
				p = c - b.h / 2,
				G = c + b.h / 2,
				Y = this.screenTransformObj.toScreenPoint(this.labelBox[0], this.labelBox[1]),
				W = this.screenTransformObj.toScreenPoint(this.labelBox[2], this.labelBox[3]),
				K = W.x - Y.x,
				Y = Y.y - W.y;
				this.labelStyle.sticky && (K *= 3, Y *= 1.5);
				if (!(b.h > Y || (b.w <= K && b.h <= Y &&
							!z && (B = [A - 5, p - 5, B + 5, G + 5], this.addLabelNode(a, B, A, G - 1), this.labelShape && (this.labelShape.feature = this)), this.labelShape))) {
					A = this.label.split(" ");
					B = G = 0;
					for (W = A.length; B < W; B++)
						b = this.graphics.getTextSize(A[B], this.labelStyle), b.w > G && (G = b.w);
					if (G > K)
						if (this.labelStyle.sticky && z)
							K *= 3, Y *= 1.5;
						else
							return;
					z = this.graphics.createTextBlock(this.label, this.labelStyle, l, c, K);
					z.h > Y || (B = [l - z.w / 2 - 5, p - 5, l + z.w / 2 + 5, p + z.h + 5], a.conflicts(B) || (a.insert(B), z.node.translate(0, (b.h - z.h) / 2), this.parentLayer.labelGroup.appendChild(z.node),
							this.labelShape = z.node, this.labelShape.feature = this))
				}
			}
		},
		addLineLabel: function (a) {
			var b,
			z,
			p;
			if (this.labelStyle && "Marker" == this.labelStyle.styleType) {
				b = this.labelStyle.width / 2;
				z = this.labelStyle.height / 2;
				p = 4 * Math.max(b, z);
				p = this.getLabelMarkerPos(p);
				for (var l = 0, c = p ? 3 < p.length ? 3 : p.length : 0; l < c; l++)
					this.addMarkerLabelNode(a, [p[l].x - b, p[l].y - z, p[l].x + b, p[l].y + z], p[l])
			} else
				z = this.graphics.getTextSize(this.label, this.labelStyle), b = z.w / 2, z = z.h / 2 - 2, p = 4 * Math.max(b, z), this.getLineTextPos(p, b, z, a)
		},
		addLabelNode: function (b,
			x, z, p, l) {
			l && l.angle && (x = [x[0] + 3, x[1] + 3, x[2], x[3]]);
			if (b.conflicts(x))
				return !1;
			var c,
			A = this.label,
			B = 0;
			l && l.angle ? (c = new this.graphics.oui.geom.Matrix, B = l.angle, l.angle >= -Math.PI && l.angle < -Math.PI / 2 && (B = l.angle + Math.PI, A = this.label.split(" ").reverse().join(" ")), l.angle < Math.PI && l.angle >= Math.PI / 2 && (B = l.angle - Math.PI, A = this.label.split(" ").reverse().join(" ")), c.rotate(B, z, p)) : l && l.transform && (c = l.transform);
			0 <= A.indexOf("\n") ? (A = x[3] - x[1], z += (x[2] - x[0]) / 2, z = this.graphics.createTextBlock(this.label,
						this.labelStyle, z, p - A / 2).node) : z = this.graphics.createTextNode(A, this.labelStyle, z, p);
			a.notNull(c) && z.applyStyle({
				transform: c
			});
			b.insert(x);
			l && l.group ? l.group.appendChild(z) : (this.parentLayer.labelGroup.appendChild(z), this.labelShape = z);
			return !0
		},
		addMarkerLabelNode: function (a, b, z) {
			if (a.conflicts(b))
				return !1;
			this.labelShape = this.graphics.createGroup();
			this.parentLayer.labelGroup.appendChild(this.labelShape);
			this.labelShape.feature = this;
			this.labelShape.applyStyle({
				cursor: this.parentLayer.mouseCursor
			});
			this.drawSinglePoint(this.graphics, this.labelShape, z, this.labelStyle);
			if (null !== this.labelStyle.textStyle) {
				var p = this.graphics.getTextSize(this.label, {});
				z = this.graphics.createTextNode(this.label, this.labelStyle.textStyle, z.x - p.w / 2, z.y + p.h / 2 - 2);
				this.labelShape.appendChild(z);
				a.insert(b)
			}
			return !0
		},
		getTip: function () {
			if ("string" === typeof this.id && 0 === this.id.indexOf("_mul"))
				return null;
			var b = this.parentLayer;
			return !a.isNull(b) && b.showToolTip ? b.toolTipCustomizer ? (b = b.toolTipCustomizer(this), "string" ===
				typeof b ? b + "" : b) : this.label ? this.label + "" : b.labelColumn && a.notNull(this.attributes) && a.notNull(this.attributes[b.labelColumn.toUpperCase()]) ? this.attributes[b.labelColumn.toUpperCase()] + "" : this.attributes && a.notNull(this.attributes._LABEL_) ? this.attributes._LABEL_ + "" : null : null
		},
		applyToolTip: function () {
			if (this.displayed) {
				var b,
				x = this.getTip();
				a.notNull(x) && (x instanceof Object ? a.isNull(this.tooltipCache) || JSON.stringify(this.tooltipCache) !== JSON.stringify(x) ? (this.tooltipCache = x, this.tooltipNode = b =
							this.buildVaTooltip(x)) : b = this.tooltipNode : b = a.isNull(this.tooltipNode) || this.tooltipNode !== x ? this.tooltipNode = x : this.tooltipNode);
				if (this.shapeGroup)
					for (x = 0; x < this.shapeGroup.length; x++)
						!b || this.renderingStyle && this.renderingStyle.enableHighlight || this.shapeGroup[x].applyStyle({
							tooltip: b
						}), this.shapeGroup[x].feature = this;
				else
					this.shape && (!b || this.renderingStyle && this.renderingStyle.enableHighlight || this.shape.applyStyle({
							tooltip: b
						}), this.shape.feature = this)
			}
		},
		buildVaTooltip: function (b) {
			var x = this.graphics;
			a.isNull(x) && (x = this.parentLayer.parentMap.getMapContext().getGraphics());
			var z = x.createGroup({
				opacity: 1,
				visibility: "visible"
			}),
			p,
			l,
			c;
			if (a.isNull(b) || a.isNull(b.titlesArray) || a.isNull(b.headersArray) || a.isNull(b.contentsArray))
				return null;
			p = b.titlesArray;
			l = b.headersArray;
			c = b.contentsArray;
			Array.isArray(p) || (p = [], p.push(b.title));
			Array.isArray(l) || (l = [], l.push(b.title));
			Array.isArray(c) || (c = [], c.push(b.title));
			if (c.length !== l.length)
				return null;
			var A = x.getInnerTooltipStyle(),
			B = A.titleStyle;
			b = A.headerStyle;
			for (var A = A.contentStyle, G = {
					hAlign: b.hAlign
				}, Y = {
					hAlign: A.hAlign
				}, x = x.oui.load({
					name: "mainVBox",
					type: "vbox",
					children: [{
							name: "titleBox",
							type: "hbox",
							layout: {
								hAlign: B.hAlign
							}
						}, {
							name: "headerAndContentBox",
							type: "hbox",
							children: [{
									name: "headerBox",
									type: "vbox"
								}, {
									name: "contentBox",
									type: "vbox"
								}
							]
						}
					]
				}), W = 0, K = p.length; W < K; W++)
				x.titleBox.load([{
							type: "text",
							textValue: p[W] + " ",
							fontWeight: B.fontWeight,
							fontFamily: B.fontFamily,
							fontStyle: B.fontStyle,
							fontSize: B.fontSize,
							fill: B.fill
						}
					]);
			p = 0;
			for (B = l.length; p < B; p++)
				x.headerAndContentBox.headerBox.load([{
							type: "text",
							textValue: l[p] + " ",
							fontWeight: b.fontWeight,
							fontFamily: b.fontFamily,
							fontStyle: b.fontStyle,
							fontSize: b.fontSize,
							fill: b.fill,
							layout: G
						}
					]), x.headerAndContentBox.contentBox.load([{
							type: "text",
							textValue: c[p] + " ",
							fontWeight: A.fontWeight,
							fontFamily: A.fontFamily,
							fontStyle: A.fontStyle,
							fontSize: A.fontSize,
							fill: A.fill,
							layout: Y
						}
					]);
			z.appendChild(x);
			return z
		},
		createAnimation: function (a, b, z) {
			if (a.hasChildNodes())
				for (a = a.firstChild; a; )
					this.createAnimation(a, b, z), a = a.nextSibling;
			else
				Array.prototype.push.apply(this.animations,
					b.createAnimation(a, this.graphics, z))
		},
		startAnimation: function () {
			if (this.animations)
				for (var a = this.animations.length, b = 0; b < a; b++)
					this.animations[b].beginAt(0)
		},
		stopAnimation: function () {
			if (this.animations)
				for (var a = this.animations.length, b = 0; b < a; b++)
					this.animations[b].endAt(0)
		},
		clearAnimation: function () {
			if (this.animations)
				for (var a = this.animations.length, b = 0; b < a; b++)
					this.animations[b].unplug(), this.animations[b].endAt(0)
		},
		animateToNewLocation: function (b, x) {
			if (this.moveAnimation)
				this.stopMoveAnimation();
			else {
				this.originalGeo = this.geo;
				var z = b.coordinates,
				p,
				l,
				c;
				if ("Point" == b.type || "OrientedPoint" == b.type)
					this.movePoints = [z[0], z[1]];
				else if ("MultiPoint" == b.type || "OrientedMultiPoint" == b.type) {
					p = z.length;
					l = [];
					for (c = 0; c < p; c++)
						l = l.concat(z[c][0], z[c][1]);
					this.movePoints = l
				} else if ("LineString" == b.type || "MultiLineString" == b.type) {
					p = z.length;
					l = [];
					for (c = 0; c < p; c++)
						l.push(z[c]);
					this.movePoints = l
				}
				z = 1;
				try {
					var A = this.parentLayer.parentMap,
					B = A.getMapContext(),
					G = B.getUniverse(),
					Y = B.getZoomLevel();
					if (G && G.zoomLevels)
						var Y =
							A.checkZoomLevel(Y), W = G.zoomLevels[Y].resolution, z = Math.sqrt(Math.pow(W, 2) + Math.pow(W * G.zoomLevels[Y].stretchRatio, 2)) / 2
				} catch (K) {}
				(this.movePoints = a.util.GeomUtil.simplifyCoordinates(this.movePoints, z)) && 2 <= this.movePoints.length && (this.moveTime = x && a.notNull(x.time) ? x.time : 300, this.moveLoop = x && x.loop, this.moveBound = x && x.bounce, this.moveOriented = "OrientedPoint" === this.geo.type ? !0 : !1, this.moveStep = x && x.step ? x.step : 5, this.animateToNewPoint(0))
			}
		},
		animateToNewPoint: function (b) {
			var x = this.movePoints[b],
			z = this.movePoints[b + 1];
			this.currentTarget = b;
			if (this.displayed && this.shape) {
				var p = this.screenPoints,
				l = this.screenTransformObj.toScreenPoint(x, z);
				b = l.x - p.x;
				l = l.y - p.y;
				if (Math.abs(b) <= this.moveStep && Math.abs(l) <= this.moveStep)
					this.movePoints && !this.reverse && this.movePoints.length >= this.currentTarget + 4 ? this.animateToNewPoint(this.currentTarget + 2) : this.movePoints && this.reverse && 0 < this.currentTarget ? this.animateToNewPoint(this.currentTarget - 2) : (this.geo = this.moveOriented ? new a.geometry.Point(x, z, this.geo.srid,
								this.geo.coordinates[2], this.geo.coordinates[3]) : new a.geometry.Point(x, z, this.geo.srid), this.finishAnimation());
				else {
					var c;
					if (this.moveOriented) {
						this.geo = new a.geometry.Point(this.geo.getX(), this.geo.getY(), this.geo.srid, b, -l);
						var A = this.parentLayer;
						c = A.getFeatureStyles(this);
						if (a.notNull(this.animations) && 0 < this.animations.length) {
							this.screenPoints = null;
							for (var B = {}, G = 0; G < this.animations.length; G++) {
								var Y = this.animations[G].getTargetNode();
								a.notNull(Y) && (B[Y.parentNode._id] = Y.parentNode._id)
							}
							G =
								new this.graphics.oui.geom.Matrix;
							a.style.Style.calculateStyleSize(c, A.parentMap.getMapContext());
							for (var W, A = 0; A < this.shape.childrenCount; A++)
								if (Y = this.shape.getChildAt(A), a.isNull(B[Y._id])) {
									W = Y;
									break
								}
							B = W.getLocalBounds();
							G.rotate(Math.atan2(l, b), B.x + c.realWidth / 2, B.y + c.realHeight / 2);
							W.setTransformMatrix(G);
							this.displayed = !0
						} else
							this.remove(), this.screenPoints = null, c.draw(this, this.parentLayer.parentMap.getMapContext(), {
								group: this.group
							}), this.displayed = !0, this.applyToolTip()
					}
					c = this.shape._style;
					W = p.x;
					if (c.width || c.x)
						W -= c.width / 2 + c.x;
					p = p.y;
					if (c.height || c.y)
						p -= c.height / 2 + c.y;
					this.moveAnimationDef = {
						startX: W,
						startY: p,
						endX: W + b,
						endY: p + l,
						moveX: b,
						moveY: l
					};
					p = Math.sqrt(b * b + l * l) / 10 * this.moveTime / 1E3;
					c = this.shape.getTransformMatrix();
					W = c.clone();
					this.moveOriented ? (this.moveAnimationDef.angleInRadius = Math.atan2(l, b), 1 != this.scaleX && 1 != this.scaleY ? (B = this.renderingStyle.realWidth / 2, G = this.renderingStyle.realHeight / 2, W.rotate(-this.moveAnimationDef.angleInRadius, B, G), W.translate(b / this.scaleX, l / this.scaleY),
							W.rotate(this.moveAnimationDef.angleInRadius, B, G)) : 1 === c.a && 0 === c.b && 0 === c.c && 1 === c.d ? W.translate(b, l) : (this.dis = Math.sqrt(b * b + l * l), W.translate(this.dis, 0))) : W.translate(b / this.scaleX, l / this.scaleY);
					this.moveAnimation = new this.graphics.oui.anim.AnimateStyle({
						targetNode: this.shape,
						dur: p,
						animValues: {
							transform: {
								beginValue: c,
								endValue: W,
								interpolator: function (a, b, x) {
									var z = a.tx,
									z = (b.tx - z) * x + z,
									l = a.ty;
									x = (b.ty - l) * x + l;
									a = a.clone();
									a.tx = z;
									a.ty = x;
									a.b = b.b;
									a.c = b.c;
									a.a = b.a;
									a.b = b.b;
									return a
								}
							}
						}
					});
					this.moveAnimation.beginAt(0);
					var K = this;
					this.moveAnimation.addEventListener(this.graphics.oui.SyncEvents.END, function () {
						if (!a.isNull(K.moveAnimation)) {
							var b = K.moveAnimationDef,
							l = 0,
							p = 0,
							c;
							if (a.notNull(K.progress)) {
								l = parseInt(b.moveX * K.progress);
								p = parseInt(b.moveY * K.progress);
								if (0 !== l || 0 !== p)
									c = b.startX + l, b = b.startY + p, K.shape && K.moveOriented && (new K.graphics.oui.geom.Matrix).translate(c, b), K.parentLayer && K.parentLayer.parentMap && K.screenTransformObj && (c = K.parentLayer.parentMap.getMapContext(), c = c.getUniverse().getZoomLevels(0)[c.getZoomLevel()],
										b = K.getGeometry(), l = b.getX() + l * c.resolution, p = b.getY() - p * c.resolution * c.stretchRatio, K.moveOriented ? (c = K.moveAnimationDef.angleInRadius, c = K.getOrientation(c), K.geo = new a.geometry.Point(l, p, K.geo.srid, c.x, c.y)) : K.geo = new a.geometry.Point(l, p, K.geo.srid), K.screenPoints = K.screenTransformObj.toScreenPoint(K.geo.getX(), K.geo.getY()));
								K.progress = null
							} else
								K.screenTransformObj && (K.screenPoints = K.screenTransformObj.toScreenPoint(x, z)), K.moveOriented ? (c = K.moveAnimationDef.angleInRadius, K.screenPoints.angle =
										c, c = K.getOrientation(c), K.geo = new a.geometry.Point(x, z, K.geo.srid, c.x, c.y)) : K.geo = new a.geometry.Point(x, z, K.geo.srid), K.moveAnimation = null, K.movePoints && !K.reverse && K.movePoints.length >= K.currentTarget + 4 ? K.animateToNewPoint(K.currentTarget + 2) : K.movePoints && K.reverse && 0 < K.currentTarget ? K.animateToNewPoint(K.currentTarget - 2) : K.finishAnimation()
						}
					})
				}
			}
		},
		finishAnimation: function () {
			if ((this.moveLoop || this.moveBound) && 4 <= this.movePoints.length)
				if (this.moveBound)
					(this.reverse = !this.reverse) ? this.animateToNewPoint(this.movePoints.length -
						2) : this.moveLoop ? this.animateToNewPoint(2) : this.currentTarget = this.moveTime = this.movePoints = null;
				else {
					var b = this.screenTransformObj.toScreenPoint(this.movePoints[0], this.movePoints[1]),
					x = b.x - this.screenPoints.x,
					z = b.y - this.screenPoints.y;
					this.screenPoints.angle && this.shape.rotate(180 * -this.screenPoints.angle / Math.PI, 12.5, 5);
					this.shape.translate(x / this.scaleX, z / this.scaleY);
					this.screenPoints = b;
					this.screenPoints.angle = 0;
					this.geo = new a.geometry.Point(this.movePoints[0], this.movePoints[1], this.geo.srid);
					this.animateToNewPoint(2)
				}
			else
				this.currentTarget = this.moveTime = this.movePoints = null
		},
		pauseMoveAnimation: function () {
			if (this.displayed && this.shape && this.moveAnimation) {
				var a = this.moveAnimation._progress(),
				b = this.graphics.getLeftTop(this.shape);
				this.shape.stopPos = b;
				this.moveAnimation.endAt(0, !1);
				this.progress = a
			}
		},
		resumeMoveAnimation: function () {
			this.movePoints && a.notNull(this.currentTarget) && this.animateToNewPoint(this.currentTarget)
		},
		stopMoveAnimation: function () {
			this.pauseMoveAnimation();
			this.moveAnimation =
				this.currentTarget = this.moveTime = null;
			a.notNull(this.originalGeo) && this.setGeometry(this.originalGeo);
			this.progress = this.movePoints = this.originalGeo = null
		},
		getOrientation: function (a) {
			var b = 0,
			z = 0,
			z = Math.PI / 2;
			a > -z && a < z ? (b = 1, z = b * Math.tan(a)) : a > z || a < -z ? (b = 1, z = b * Math.tan(a)) : z = a == z ? 1 : -1;
			return {
				x: b,
				y: z
			}
		},
		getPointPosition: function (b, x, z, p, l) {
			var c = null,
			c = a.notNull(l) ? l.type : this.geo.type;
			this.tiledFeature && "GeometryCollection" === c && (c = this.parentLayer.getFeatureGeometryType());
			var A,
			B,
			G,
			Y = b.length,
			W = this.parentLayer.parentMap.getMapContext();
			if ("LineString" === c || "MultiLineString" === c)
				a.notNull(x) && (B = (x[0] + x[2]) / 2, G = (x[1] + x[3]) / 2, x = new a.geometry.Point(B, G, p), x = this.transformGeometry(x), b[0].draw(this, W, {
						group: z,
						sPoint: x
					}));
			else if ("Point" === c || "MultiPoint" === c || "OrientedPoint" === c || "OrientedMultiPoint" === c)
				for (A = 0; A < Y; A++)
					if (1 === b[A].showOnPoint) {
						p = this.geo;
						this.tiledFeature && a.notNull(l) && "GeometryCollection" === l.type && (p = l.geometries[0]);
						x = this.transformGeometry(p);
						if ("MultiPoint" === p.type || "OrientedMultiPoint" === p.type)
							x = x[0];
						b[A].draw(this,
							this.parentLayer.parentMap.getMapContext(), {
							group: z,
							sPoint: x
						})
					} else
						b[A].draw(this, this.parentLayer.parentMap.getMapContext(), {
							group: z
						});
			else if (!a.isNull(x))
				if (2 > Y)
					B = (x[0] + x[2]) / 2, G = (x[1] + x[3]) / 2, x = new a.geometry.Point(B, G, p), x = this.transformGeometry(x), b[0].draw(this, W, {
						group: z,
						sPoint: x
					});
				else {
					var K = 0,
					q = 0,
					t = 0;
					for (A = c = 0; A < Y; A++) {
						a.style.Style.calculateStyleSize(b[A], this.parentLayer.parentMap.getMapContext());
						var K = K + b[A].realWidth,
						q = q + b[A].realHeight,
						I = b[A].realWidth * b[A].realHeight;
						I > t && (t = I, c =
								A)
					}
					A = W.getUniverse().getZoomLevels()[W.getZoomLevel()];
					var I = (x[2] - x[0]) / A.resolution,
					aa = (x[3] - x[1]) / A.resolution / A.stretchRatio,
					t = 0,
					ba;
					K <= I ? (ba = "H", t = (I - K) / (Y + 1)) : q <= aa ? (ba = "V", t = (aa - q) / (Y + 1)) : ba = K - I > q - aa ? "V" : "H";
					Y = [];
					a.$.extend(!0, Y, x);
					"H" == ba ? (K = b[c].realWidth / 2 * A.resolution, B = I > b[c].realWidth ? x[0] + K + t * A.resolution : (x[0] + x[2]) / 2 - K, G = (x[1] + x[3]) / 2, Y[0] = B + K) : "V" == ba && (K = b[c].realHeight / 2 * A.resolution * A.stretchRatio, G = aa > b[c].realHeight ? x[1] + K + t * A.resolution : (x[1] + x[3]) / 2 - K, B = (x[0] + x[2]) / 2, Y[1] = G +
							K);
					x = new a.geometry.Point(B, G, p);
					x = this.transformGeometry(x);
					b[c].draw(this, W, {
						group: z,
						sPoint: x
					});
					this.displayed = !0;
					this.applyToolTip();
					b.splice(c, 1);
					this.getPointPosition(b, Y, z, p, l)
				}
		},
		enableFeatureEditing: function (b) {
			if (this.editable != b) {
				if ("Rectangle" === this.geo.type) {
					var x = this.geo.coordinates[0],
					z = this.geo.coordinates[1],
					p = this.geo.coordinates[2],
					l = this.geo.coordinates[3];
					this.geo = new a.geometry.Polygon([[x, z, p, z, p, l, x, l, x, z]], this.geo.srid, this.geo.dim)
				}
				(this.editable = b) ? (this.startDrag || (b =
							new a.layer.EditableFeature, this.init = b.init, this.startDrag = b.startDrag, this.featureDragging = b.featureDragging, this.endDrag = b.endDrag, this.addEditProperties = b.addEditProperties, this.startEditing = b.startEditing, this.endEditing = b.endEditing, this.deleteEditingProperties = b.deleteEditingProperties, this.shapePointMoved = b.shapePointMoved, this.possiblePointMoved = b.possiblePointMoved, this.deleteShapePoint = b.deleteShapePoint, this.featurePointMoved = b.featurePointMoved, this.featurePointMoved_PointType = b.featurePointMoved_PointType,
						this.addEditProperties_OrientedPoint = b.addEditProperties_OrientedPoint, this.showContextMenu = b.showContextMenu, this.shapePointMoving = b.shapePointMoving, this.possiblePointMoving = b.possiblePointMoving, this.featurePointMoving = b.featurePointMoving, this.calRelatedFeature = b.calRelatedFeature, this.setParentThat = b.setParentThat, this.addResizeHandles = b.addResizeHandles, this.calDistance = b.calDistance, this.isEditProperties = b.isEditProperties, this.focusProperties = b.focusProperties, this.registerUpdate = b.registerUpdate,
						this.hideEditVertices = b.hideEditVertices, this.init(), this.setParentThat(this)), this.startEditing()) : (this.setParentThat(this), this.endEditing(), this.relatedFeature = this.edit = null)
			}
		},
		enableFeatureDragging: function (b) {
			this.draggable && (b = new a.layer.EditableFeature, this.init = b.init, this.startDrag = b.startDrag, this.featureDragging = b.featureDragging, this.endDrag = b.endDrag, this.addEditProperties = b.addEditProperties, this.startEditing = b.startEditing, this.endEditing = b.endEditing, this.deleteEditingProperties =
					b.deleteEditingProperties, this.shapePointMoved = b.shapePointMoved, this.possiblePointMoved = b.possiblePointMoved, this.deleteShapePoint = b.deleteShapePoint, this.featurePointMoved = b.featurePointMoved, this.featurePointMoved_PointType = b.featurePointMoved_PointType, this.showContextMenu = b.showContextMenu, this.shapePointMoving = b.shapePointMoving, this.possiblePointMoving = b.possiblePointMoving, this.featurePointMoving = b.featurePointMoving, this.calRelatedFeature = b.calRelatedFeature, this.setParentThat = b.setParentThat,
				this.addResizeHandles = b.addResizeHandles, this.calDistance = b.calDistance, this.isEditProperties = b.isEditProperties, this.focusProperties = b.focusProperties, this.registerUpdate = b.registerUpdate, this.init(), this.setParentThat(this))
		},
		isEditable: function () {
			return this.editable
		},
		clone: function () {
			var b = {};
			a.$.extend(!0, b, this.geo);
			var x = {};
			a.$.extend(!0, x, this.attributes);
			b = this.text ? new a.TextFeature(this.id, b, this.text, this.renderingStyle) : new a.Feature(this.id, b, {
				attributes: x,
				renderingStyle: this.renderingStyle,
				label: this.label,
				labelStyle: this.labelStyle,
				labelStyleName: this.labelStyleName
			});
			this.columns && (b.columns = {}, a.$.extend(!0, b.columns, this.columns));
			!this.renderingStyle && this.styleName && (b.styleName = this.styleName);
			this.mapping && (b.mapping = !0);
			return b
		},
		clearInfoWindow: function () {
			var a = this.parentLayer.parentMap;
			a.infoLayer && a.infoLayer.deleteInfoWindows()
		},
		getLabelMarkerPos: function (b) {
			if (!this.parentLayer.mask) {
				var x = this.parentLayer.parentMap.getMapContext(),
				z = x.getCenterPoint(),
				x = x.getDeviceWindow(),
				z = this.screenTransformObj.toScreenPoint(z.getX(), z.getY());
				this.parentLayer.mask = {
					minX: z.x - x.w,
					minY: z.y - x.h,
					maxX: z.x + x.w,
					maxY: z.y + x.h
				}
			}
			if (this.screenPoints && (z = "LineString" == this.geo.type ? a.util.GeomUtil.clipLine(this.parentLayer.mask, [this.screenPoints]) : a.util.GeomUtil.clipLine(this.parentLayer.mask, this.screenPoints), 0 < z.length))
				return a.util.GeomUtil.getPointByPercent(z, .5, b)
		},
		getLineTextPos: function (b, x, z, p) {
			if (!this.parentLayer.mask) {
				var l = this.parentLayer.parentMap.getMapContext(),
				c = l.getCenterPoint(),
				l = l.getDeviceWindow(),
				c = this.screenTransformObj.toScreenPoint(c.getX(), c.getY());
				this.parentLayer.mask = {
					minX: c.x - l.w,
					minY: c.y - l.h,
					maxX: c.x + l.w,
					maxY: c.y + l.h
				}
			}
			if (this.screenPoints) {
				c = "LineString" == this.geo.type ? a.util.GeomUtil.clipLine(this.parentLayer.mask, [this.screenPoints]) : a.util.GeomUtil.clipLine(this.parentLayer.mask, this.screenPoints);
				this.labelShape = this.graphics.createGroup();
				this.parentLayer.labelGroup.appendChild(this.labelShape);
				for (var l = [], A = c.length, B, G = 0; G < A; G++) {
					B = a.util.GeomUtil.getScreenLength(c[G]);
					for (var Y = !1, W = 0, K = l.length; W < K; W++)
						if (B > l[W].len) {
							Y = !0;
							l.splice(W, 0, {
								idx: G,
								len: B
							});
							break
						}
					Y || l.push({
						idx: G,
						len: B
					})
				}
				G = A = 0;
				for (Y = l.length; G < Y && (W = c[l[G].idx], B = l[G].len, B < b / 2 || (this.testLabelByPercent(W, B, .5, x, z, p) ? A++ : this.testLabelByPercent(W, B, .4, x, z, p) ? A++ : this.testLabelByPercent(W, B, .6, x, z, p) && A++, !(3 < A))); G++);
				return !!A
			}
			return !1
		},
		testLabelByPercent: function (b, x, z, p, l, c) {
			z = a.util.GeomUtil.getPointByLength(x * z, b);
			var A = z.pos,
			B,
			G;
			if (z.len > 2 * p) {
				x = (b[A] + b[A + 2]) / 2;
				z = (b[A + 1] + b[A + 3]) / 2;
				b = -Math.atan2(b[A +
							1] - b[A + 3], b[A + 2] - b[A]);
				if (b < -Math.PI / 2 || b >= Math.PI / 2)
					b += Math.PI;
				var Y = new this.graphics.oui.geom.Matrix;
				Y.rotate(b, x, z);
				G = [x - p, z - l, x + p, z + l];
				G = Y.transformAll([G[0], G[1], G[0], G[3], G[2], G[3], G[2], G[1]]);
				b = Math.ceil(Math.min(G[0], G[2], G[4], G[6]));
				B = Math.floor(Math.max(G[0], G[2], G[4], G[6]));
				A = Math.ceil(Math.min(G[1], G[3], G[5], G[7]));
				G = Math.floor(Math.max(G[1], G[3], G[5], G[7]));
				G = [b, A, B, G];
				return this.addLabelNode(c, G, x - p, z + l, {
					transform: Y,
					group: this.labelShape
				})
			}
			Y = a.util.GeomUtil;
			x = Y.getPoinsByLength(b,
					A, z.x, z.y, 4 * p, -2);
			var W = Y.getPoinsByLength(b, A, z.x, z.y, 4 * p, 2);
			x.x > W.x && (b = x, x = W, W = b);
			if (z.x < x.x || z.x > W.x || x.y > W.y && (z.y > x.y || z.y < W.y) || x.y < W.y && (z.y < x.y || z.y > W.y))
				return !1;
			b = Math.min(x.x, W.x, z.x);
			B = Math.max(x.x, W.x, z.x);
			A = Math.min(x.y, W.y, z.y);
			G = Math.max(x.y, W.y, z.y);
			var K = Math.max(p / 4, l);
			G = [b - K, A - K, B + K, G + K];
			return c.conflicts(G) ? !1 : (c.insert(G), c = Y.getCircle(x.x, x.y, z.x, z.y, W.x, W.y), this.addLabelAlongCurve(c, p, l, -Math.atan2((x.y - W.y) / (W.x - x.x))), !0)
		},
		addLabelAlongCurve: function (a, b, z, p) {
			var l = this.label.length;
			if (!(2 > l) && a.eAngle && a.sAngle) {
				p = (a.eAngle - a.sAngle) / (l - 1);
				b /= l;
				for (var c = 0; c < l; c++) {
					var A = a.sAngle + p * c,
					A = this.graphics.createTextNode(this.label[c], this.labelStyle, Math.cos(A) * a.r + a.x - b, Math.sin(A) * a.r + a.y + z - 1),
					B = new this.graphics.oui.geom.Matrix;
					A.applyStyle({
						transform: B
					});
					this.labelShape.appendChild(A)
				}
			}
		},
		getLabelPosBySlope: function (a) {
			for (var b = [], z = 0, c = a.length; z < c; z++) {
				for (var l = a[z], Q = l.length, A = (l[Q - 2] - l[0]) / (l[Q - 1] - l[1]), B = Number.POSITIVE_INFINITY, G = 0, Y = 0; Y < Q - 1; Y += 2) {
					var W = (l[Y + 2] - l[Y]) /
					(l[Y + 3] - l[Y + 1]);
					Math.abs(A - W) < B && (B = Math.abs(A - W), G = Y)
				}
				Q = (l[G] + l[G + 2]) / 2;
				A = (l[G + 1] + l[G + 3]) / 2;
				l = -Math.atan2(l[G + 1] - l[G + 3], l[G + 2] - l[G]);
				if (l <= -Math.PI / 2 || l > Math.PI / 2)
					l += Math.PI;
				b.push({
					x: Q,
					y: A,
					angle: l
				})
			}
			return b
		},
		isCluster: function () {
			return this.id && 0 === this.id.indexOf("-CL") && this.cluster ? !0 : !1
		},
		getFeaturesInCluster: function () {
			return this.isCluster() ? this.cluster.featureArray : null
		},
		drawGhostGeom: function (b, x) {
			if (b && x && 0 !== x.length) {
				this.removeGhostShape();
				var z = {};
				this.ghostGeom = b;
				a.$.extend(!0, z,
					x[0]);
				this.ghostShape = this.drawRectangle(this.graphics, this.group, b, z, !0);
				this.ghostShape.feature = this;
				z = this.getTip();
				this.ghostShape.applyStyle({
					tooltip: z
				})
			}
		},
		drawGhostLabel: function (a) {
			if (a && this.label) {
				var b = (a.getMinX() + a.getMaxX()) / 2;
				a = (a.getMinY() + a.getMaxY()) / 2;
				b = this.screenTransformObj.toScreenPoint(b, a);
				this.labelShape = this.graphics.createTextNode(this.label, this.labelStyle, b.x, b.y);
				b = this.graphics.getWidthHeight(this.labelShape);
				this.labelShape.translate(-b.w / 2, b.h / 2 - 2);
				this.parentLayer.labelGroup.appendChild(this.labelShape);
				this.labelShape.feature = this
			}
		},
		removeGhostShape: function () {
			this.ghostShape && (this.ghostShape.feature = null, this.graphics.remove(this.ghostShape), this.graphics.remove(this.line), this.parentLayer.leadLine && (this.line = this.line.feature = null), this.ghostShape = this.ghostShape.feature = null, this.labelShape && (this.graphics.remove(this.labelShape), this.labelShape = this.labelShape.feature = null))
		},
		enableMarkerDraggable: function (a) {
			this.draggable = a
		},
		setMarkerText: function (a) {
			this.markerText = a
		},
		getMarkerText: function () {
			return this.markerText
		},
		setInfoWindowContent: function (a) {
			this.InfoHtml = a
		},
		getShapeIndex: function () {
			this.idx = this.shape && this.shape.parentNode ? this.shape.parentNode.getChildIndex(this.shape) : -1
		},
		setShapeIndex: function () {
			if (this.shape && this.shape.parentNode && 0 <= this.idx && this.shape.parentNode.getChildIndex(this.shape) != this.idx)
				if (this.shapeGroup && 1 < this.shapeGroup.length)
					for (var a = this.shapeGroup.length - 1; -1 < a; a--)
						this.shapeGroup[a].parentNode.setChildIndex(this.shapeGroup[a], this.idx);
				else
					this.shape.parentNode.setChildIndex(this.shape,
						this.idx)
		},
		isInCluster: function () {
			return this.inCluster && this.clusterId ? !0 : !1
		},
		getClusterId: function () {
			return this.inCluster && this.clusterId ? this.clusterId : null
		},
		getParentLayer: function () {
			return this.parentLayer
		},
		getClusterFeature: function () {
			var b = this.clusterFeature;
			return a.isNull(b) ? null : b
		},
		getClusteredFeatures: function () {
			var b = this.cluster;
			return a.notNull(b) ? b.featureArray : null
		},
		setOldStyle: function (a) {
			this.oldStyle = a
		},
		getOldStyle: function () {
			return this.oldStyle
		}
	});
	a.MapMarker = a.Feature.extend({
		initialize: function x(b) {
			var c;
			a.notNull(b) ? (b.position && (c = a.isNull(b.position.srid) ? 8307 : b.position.srid, c = new a.geometry.Point(b.position.x, b.position.y, c)), this.markerText = b && a.notNull(b.markerText) ? b.markerText : null, this.markerTextStyle = b && a.notNull(b.markerTextStyle) ? b.markerTextStyle : null, x.base.call(this, b.id, c, {
					renderingStyle: b.renderingStyle,
					label: b.label,
					labelStyle: b.labelStyle,
					draggable: b.draggable
				}), b.dragStart && (this.dragStartListener = b.dragStart), b.dragEnd && (this.dragEndListener = b.dragEnd), b.dragging && (this.draggingListener =
						b.dragging)) : x.base.call(this)
		},
		getLabel: function () {
			return this.label
		},
		setMarkerTextStyle: function (a) {
			this.renderingStyle && (this.renderingStyle.textStyle = a)
		},
		setID: function (b) {
			a.notNull(b) && "" !== b && (this.id = b)
		},
		getID: function () {
			return this.id
		},
		isDraggable: function () {
			return !0 === this.draggable
		},
		setDraggable: function (a) {
			this.draggable = !0 === a
		},
		setStyle: function (b) {
			a.notNull(b) && "" !== b && (this.renderingStyle = b)
		},
		getStyle: function () {
			return this.renderingStyle
		},
		setPosition: function (b, z, c) {
			var l,
			Q;
			a.notNull(b) &&
			a.notNull(z) ? (l = b, Q = z, b = a.isNull(c) ? 8307 : c, l = new a.geometry.Point(l, Q, b), this.setGeometry(l)) : a.util.Logger.warning("MAPVIEWER_9073", "OM.MapMarker.setPosition", "The [" + l + "," + Q + "],values are not properly specified.")
		},
		getPosition: function () {
			return {
				x: this.getGeometry().getX(),
				y: this.getGeometry().getY(),
				srid: this.getGeometry().getSRID()
			}
		},
		getMarkerX: function () {
			return this.getGeometry().getX()
		},
		getMarkerY: function () {
			return this.getGeometry().getY()
		},
		getMarkerSRID: function () {
			return this.getGeometry().getSRID()
		},
		setDragStartListener: function (a) {
			this.dragStartListener = a
		},
		setDraggingListener: function (a) {
			this.draggingListener = a
		},
		setDragEndListener: function (a) {
			this.dragEndListener = a
		},
		toJSON: function () {
			return {
				position: {
					x: this.getGeometry().getX(),
					y: this.getGeometry().getY(),
					srid: this.getGeometry().getSRID()
				},
				renderingStyle: a.isNull(this.renderingStyle) ? "undefined" : this.renderingStyle,
				draggable: a.isNull(this.draggable) ? "undefined" : this.draggable,
				label: a.isNull(this.label) ? "" : this.label,
				labelStyle: a.isNull(this.labelStyle) ?
				null : this.labelStyle,
				markerText: a.isNull(this.markerText) ? "" : this.markerText,
				markerTextStyle: a.isNull(this.markerTextStyle) ? null : this.markerTextStyle
			}
		}
	});
	a.TextFeature = a.Feature.extend({
		initialize: function (b, z, c, l) {
			this.id = b;
			this.geo = z;
			this.text = c;
			this.renderingStyle = l ? l : new a.style.Text(a.gv.defaultTextStyleConfig);
			this.editRenderingStyle = a.layer.EditableFeature.textStyle;
			l instanceof a.style.Style || (this.attributes = l && a.notNull(l.attributes) ? l.attributes : null, this.renderingStyle = l.style ? l.style :
					new a.style.Text(a.gv.defaultTextStyleConfig), this.editRenderingStyle = l.editStyle ? l.editStyle : a.layer.EditableFeature.textStyle);
			this.displayed = !1;
			this.visible = !0;
			this.editable = !1
		},
		setText: function (b) {
			a.notNull(b) && "" !== b && (this.text = b, this.displayed && (this.remove(), this.displayFeature()))
		},
		getText: function () {
			return this.text
		},
		setGeometry: function (a) {
			!a || "Point" !== a.type && "OrientedPoint" !== a.type || (this.geo = a, this.displayed && (this.remove(), this.screenPoints = null, this.displayFeature()))
		},
		setRenderingStyle: function (b) {
			if ((!a.isNull(b) ||
					!a.isNull(this.parentLayer) && !a.isNull(this.parentLayer.otherStyles) && 0 !== this.parentLayer.otherStyles.length) && this.renderingStyle !== b && (this.renderingStyle = b, this.displayed)) {
				this.getShapeIndex();
				var z = this;
				a.notNull(this.shape) && this.shape.addEventListener(a.event.MouseEvent.MOUSE_OUT, function (a) {
					try {
						a.target = z.shape,
						z.shape.dispatchEvent(a)
					} catch (b) {}
				});
				this.remove();
				b = [b];
				this.parentLayer.otherStyles && (b = b.concat(this.parentLayer.otherStyles));
				b = this.getAllStyles(b);
				if (this.parentLayer.featureGroupArr &&
					0 < this.parentLayer.featureGroupArr.length) {
					this.shapeArray = [];
					for (var c = 0; c < this.parentLayer.featureGroupArr.length; c++)
						if (a.isNull(this.activeIdx) || this.activeIdx === c)
							this.group = this.parentLayer.featureGroupArr[c], this.displayFeature(b, -1), this.shapeArray[c] = this.shape
				} else
					this.displayFeature(b, -1);
				this.setShapeIndex()
			}
		},
		setEditRenderingStyle: function (b) {
			a.notNull(b) && b instanceof a.style.Text && (this.editRenderingStyle = b)
		},
		displayFeature: function (b, z) {
			var c = this.geo,
			l = this.typeIs(c);
			if ((!this.editing ||
					"OrientedPoint" !== l) && b && 0 !== b.length) {
				var Q = b[0];
				if (Q && !(Q instanceof a.style.Style) && Q.dataSource && Q.name) {
					var A = this,
					l = Q.url;
					a.isNull(l) && (l = this.parentLayer.type === a.layer.VectorLayer.TYPE_JDBC || this.parentLayer.type === a.layer.VectorLayer.TYPE_PREDEFINED ? this.parentLayer.serverURL : this.parentLayer.parentMap.mapviewerURL);
					a.style.StyleStore.getServerSideStyle(Q.dataSource, Q.name, {
						url: l,
						callback: function (a) {
							A.displayFeature([a], z)
						}
					})
				} else {
					var B = this.graphics,
					Q = this.renderingStyle && this.renderingStyle.cased ?
						this.parentLayer.getLineGroup() : this.group,
					G = this.screenTransformObj;
					if (!(a.isNull(B) || a.isNull(Q) || a.isNull(c) || a.isNull(G))) {
						1 < b.length && (c = B.createGroup(), Q.appendChild(c), Q = c);
						c = b.length;
						B = [];
						for (G = 0; G < c; G++) {
							var Y = b[G],
							W = Y.styleType;
							Y.showOnPoint ? (Y.realWidth = null, Y.realHeight = null, B.push(Y)) : (Y.draw(this, this.parentLayer.parentMap.getMapContext(), {
									group: Q,
									idx: z
								}), "AnimationColor" !== W && "PulseAnimation" !== W || !a.notNull(this.shape) || (this.animations = [], this.createAnimation(this.shape, Y, "MultiLineString" ==
										l || "LineString" == l)))
						}
						0 < B.length && (G = this.parentLayer.parentMap.getMapContext().getUniverse().getSRID(), a.isNull(this.labelBox) && this.createLabelBox(), this.getPointPosition(B, this.labelBox, Q, G));
						1 < c && (this.shape = Q);
						this.displayed = !0;
						this.applyToolTip();
						this.ghostGeom && (this.drawGhostGeom(this.ghostGeom, b), this.drawGhostLabel(this.ghostGeom));
						if (this.shapeGroup && !this.visible)
							for (G = 1; G < this.shapeGroup.length; G++)
								this.graphics.setVisible(this.shapeGroup[G], !1);
						else
							this.shape && !this.visible && this.graphics.setVisible(this.shape,
								!1);
						this.ghostShape && !this.visible && this.graphics.setVisible(this.ghostShape, !1);
						this.resumeMoveAnimation();
						a.notNull(this.parentLayer) && this.parentLayer.useRTree && (this.parentLayer.addToRtree(this), this.parentLayer.updatedSearchWindow(this, l))
					}
				}
			}
		},
		remove: function () {
			var a = this.shape;
			if (a) {
				this.graphics.remove(a);
				this.shape = null;
				if (this.shapeGroup)
					for (var a = this.shapeGroup.length, b = 0; b < a; b++)
						this.shapeGroup[b] && this.graphics.remove(this.shapeGroup[b]);
				this.shapeGroup = null;
				if (this.shapeArray) {
					a = this.shapeArray.length;
					for (b = 0; b < a; b++)
						this.shapeArray[b] && (this.shapeArray[b].feature = null, this.graphics.remove(this.shapeArray[b]));
					this.shapeArray = null
				}
			}
		},
		toJSON: function () {
			var b = {
				id: this.id,
				styleConfig: this.getRenderingStyle().getConfig(),
				text: this.getText()
			};
			b.geometry = this.geo instanceof a.geometry.Geometry ? this.geo.toJSON() : this.geo;
			return b
		}
	});
	a.Map = a.Class.extend({
		mixin: a.event.EventSource,
		initialize: function (b, z) {
			z && a.notNull(z.autoLoadCss) && !1 === z.autoLoadCss || (a.util.Logger.info("MAPVIEWER_9050", "OM.Map.initialize",
					"Auto loading " + a.gv.cssResourcePath() + "oraclemapsv2.css"), a.util.LoadFileUtil.LoadCss(a.gv.cssResourcePath() + "oraclemapsv2.css"));
			a.gv.msgLoaded || a.gv.loadMessage();
			var c = this;
			this._decoration = {};
			this.wraparound = !1;
			z && !0 === z.wraparound && (this.wraparound = z.wraparound);
			this.mapBBox = [];
			a.gv.addMapInstance(this, b);
			z ? (this.vectorlayerInfoWindowMouseEType = z.vectorlayerInfoWindowTrigger === a.event.MouseEvent.MOUSE_OVER || z.vectorlayerInfoWindowTrigger === a.event.MouseEvent.MOUSE_MOVE ? a.event.MouseEvent.MOUSE_MOVE :
					a.event.MouseEvent.MOUSE_CLICK, this.hiDPI = z.hiDPI, this.applicationID = z.applicationID) : this.vectorlayerInfoWindowMouseEType = a.event.MouseEvent.MOUSE_CLICK;
			this.$containerDiv = a.$(b);
			this.$containerDiv.empty();
			this.zoomComplete = !0;
			this.utfgridHTMLArray = [];
			this.vctinfoHTMLArray = [];
			this.vctinfoFeatures = {};
			this.searchTolerance = a.gv.searchTolerance;
			this.snapTolerance = a.gv.snapTolerance;
			this.lastMouseDown = null;
			"CSS1Compat" === document.compatMode && (0 === this.$containerDiv.width() && (a.isNull(a.util.DomUtil.css(a.$("html")).width) &&
					(a.util.Logger.info("MAPVIEWER_9050", "OM.Map.initialize", "Set html width to 100%"), a.$("html").css("width", "100%")), a.isNull(a.util.DomUtil.css(a.$("body")).width) && (a.util.Logger.info("MAPVIEWER_9050", "OM.Map.initialize", "Set body width to 100%"), a.$("body").css("width", "100%"))), 0 === this.$containerDiv.height() && (a.isNull(a.util.DomUtil.css(a.$("html")).height) && (a.util.Logger.info("MAPVIEWER_9050", "OM.Map.initialize", "Set html height to 100%"), a.$("html").css("height", "100%")), a.isNull(a.util.DomUtil.css(a.$("body")).height) &&
					(a.util.Logger.info("MAPVIEWER_9050", "OM.Map.initialize", "Set body height to 100%"), a.$("body").css("height", "100%"))));
			0 !== this.$containerDiv.width() && 0 !== this.$containerDiv.height() || a.util.Logger.warning("MAPVIEWER_9050", "OM.Map.initialize", "Size is " + this.$containerDiv.width() + "*" + this.$containerDiv.height());
			this.$containerDiv.css("-webkit-user-select", "none");
			this.$containerDiv.css({
				"-moz-user-select": "none"
			});
			this.$containerDiv.css({
				"-ms-touch-action": "none"
			});
			a.browser.touchSupported && this.$containerDiv.css({
				"-webkit-tap-highlight-color": "rgba(0, 0, 0, 0)"
			});
			"absolute" !== this.$containerDiv.css("position") && this.$containerDiv.css("position", "relative");
			this.mapInstanceId = this.generateMapInstanceId();
			var l = "\x3cdiv id\x3d'oracleMapDiv" + this.mapInstanceId + "' ";
			this._rootDivPos = {
				normal: "position:relative; width:100%; height:100%;",
				va: "width:100%; height:100%;"
			};
			l += "style\x3d'" + this._rootDivPos.normal + "left:0px; top:0px; -moz-user-select: none;-webkit-user-select:none; overflow: hidden;z-index:auto;opacity:1'\x3e\x3c/div\x3e";
			this.$oracleMapDiv = a.$(l);
			this.$oracleMapDiv.addClass("omapsv2-root");
			this.$oracleMapDiv.css("position", "relative");
			this.$containerDiv.append(this.$oracleMapDiv);
			this.$topLayerDIV = a.$("\x3cdiv id \x3d'topLayerDIV" + this.mapInstanceId + "'\x3e\x3c/div\x3e");
			this.$fkGraphicLayersDiv = a.$("\x3cdiv id \x3d'fkGraphicLayersDiv" + this.mapInstanceId + "'\x3e\x3c/div\x3e");
			this.$tileLayersDiv = a.$("\x3cdiv id \x3d'tileLayersDiv" + this.mapInstanceId + "'\x3e\x3c/div\x3e");
			this.$oracleMapDiv.append(this.$tileLayersDiv);
			this.$oracleMapDiv.append(this.$fkGraphicLayersDiv);
			this.$oracleMapDiv.append(this.$topLayerDIV);
			this.$topLayerDIV.css({
				"z-index": "auto",
				position: "absolute",
				left: "0px",
				top: "0px",
				width: "100%",
				height: "100%"
			});
			this.$fkGraphicLayersDiv.css({
				"z-index": "4",
				position: "absolute",
				left: "0px",
				top: "0px",
				width: "100%",
				height: "100%",
				overflow: "hidden"
			});
			this.$tileLayersDiv.css({
				"z-index": "1",
				position: "absolute",
				left: "0px",
				top: "0px",
				width: "100%",
				height: "100%",
				overflow: "hidden"
			});
			for (var l = [], Q, A = 1; 6 >= A; A += 1)
				Q = "\x3cdiv id\x3d'omv2_anchorBox" + A + "_" + this.mapInstanceId + "' class\x3d'omv2_anchorBox" + A + "'\x3e\x3c/div\x3e",
				l.push(Q);
			this.anchors = [a.$(l[0]), a.$(l[1]), a.$(l[2]), a.$(l[3]), a.$(l[4]), a.$(l[5])];
			this.$heatMapDiv = a.$("\x3cdiv id \x3d'heatMapDiv" + this.mapInstanceId + "'\x3e\x3c/div\x3e");
			this.$oracleMapDiv.append(this.$heatMapDiv);
			this.$heatMapDiv.css({
				"z-index": "2",
				position: "absolute",
				left: "0px",
				top: "0px",
				width: "100%",
				height: "100%",
				overflow: "hidden"
			});
			this.graphics = new a.Graphics(this.$fkGraphicLayersDiv[0], {
				hiDPI: this.hiDPI,
				mapInstanceId: this.mapInstanceId
			});
			this.$fkGraphicLayersDiv.find("svg,canvas").attr("unselectable",
				"on");
			this.$fkGraphicLayersDiv.find("svg,canvas").css({
				outline: "none"
			});
			this.draggableGroup = this.graphics.createGroup();
			this.fixedGroup = this.graphics.createGroup();
			this.blockerGroup = this.graphics.createGroup();
			this.graphics.addGroup(this.fixedGroup);
			this.graphics.addGroup(this.draggableGroup);
			this.graphics.addGroup(this.blockerGroup);
			this.useRTree = a.notNull(z && z.useRTree) ? z.useRTree : a.gv.useRTree;
			(this.updateBlocker = function () {
				if (c.useRTree && !a.isNull(c.blockerGroup)) {
					0 === c.blockerGroup.childrenCount &&
					c.graphics.drawRectangle({
						x: 0,
						y: 0,
						width: c.$containerDiv.width(),
						height: c.$containerDiv.height()
					}, {
						fill: "orange",
						fillOpacity: 0
					}, {
						group: c.blockerGroup
					});
					var b = c.blockerGroup.firstChild;
					a.notNull(b) && b.applyStyle({
						x: 0,
						y: 0,
						width: c.$containerDiv.width(),
						height: c.$containerDiv.height()
					})
				}
			}).call();
			c.iterateVectorLayers = function (a) {
				for (var b = c.svgLayers, x = b.length - 1; 0 <= x && !0 !== a(b[x]); x--);
			};
			c.search = function (b) {
				var x = null;
				c.iterateVectorLayers(function (c) {
					if (c.isVisible() && (x = c.findFeature(b, !1), a.notNull(x)))
						return !0
				});
				a.isNull(x) && c.iterateVectorLayers(function (c) {
					if (c.isVisible() && (x = c.findFeature(b, !0), a.notNull(x)))
						return !0
				});
				return x
			};
			var B = "none",
			G = function (b, x) {
				if (!a.isNull(b) && (B !== b._id || "mouseUp" !== x.type || 2 !== x.button) && (B = b._id, a.notNull(b))) {
					for (var c = b, z = c.feature; a.isNull(z) && c.parentNode; )
						c = c.parentNode, z = c.feature;
					!a.isNull(z) && a.notNull(x.target) && (z.shape === b || z === b.feature ? a.notNull(z.shape) && (z.shape.feature = z, z.shape.dispatchEvent(x)) : (a.notNull(z.shape) && z.shape.dispatchEvent(x), b.dispatchEvent(x)))
				}
			};
			c.mouseEventListener = function (b) {
				var x = c.search(b),
				z = x && x.parentLayer && x.parentLayer.getPointerSensitivity(),
				l = x ? x.fkNode : null;
				a.notNull(x) && a.isNull(l) && a.notNull(x.shape) && (l = x.fkNode = x.shape, l.feature = x);
				a.notNull(x) ? z && c.graphics.setCursor(c.blockerGroup, x.parentLayer.mouseCursor) : c.graphics.setCursor(c.blockerGroup, c.cursorStyleDefault);
				a.notNull(x) && z && x.parentLayer.isVisible() && G(l, b);
				b.type === a.event.MouseEvent.MOUSE_MOVE ? (x = l, x !== c.lastMoveTarget && (a.notNull(c.lastMoveTarget) && (b.target =
								c.lastMoveTarget, b.relatedTarget = x, G(c.lastMoveTarget, a.$.extend({}, b, {
									type: a.event.MouseEvent.MOUSE_OUT
								})), G(c.lastMoveTarget, a.$.extend({}, b, {
									type: a.event.MouseEvent.MOUSE_LEAVE
								}))), a.notNull(x) && (b.target = x, b.relatedTarget = c.lastMoveTarget, G(x, a.$.extend({}, b, {
									type: a.event.MouseEvent.MOUSE_ENTER
								})), G(x, a.$.extend({}, b, {
									type: a.event.MouseEvent.MOUSE_OVER
								})))), c.lastMoveTarget = x) : b.type === a.event.MouseEvent.MOUSE_LEAVE && (c.lastMoveTarget = null)
			};
			c.lastMoveTarget = null;
			!0 === c.useRTree && (a.browser.touchSupported &&
				(this.graphics.attachEventListener(a.event.MouseEvent.TOUCH_TAP, c.mouseEventListener, this.blockerGroup), this.graphics.attachEventListener(a.event.MouseEvent.TOUCH_LONG_PRESS, c.mouseEventListener, this.blockerGroup), this.graphics.attachEventListener(a.event.MouseEvent.TOUCH_END, c.mouseEventListener, this.blockerGroup), this.graphics.attachEventListener(a.event.MouseEvent.TOUCH_START, c.mouseEventListener, this.blockerGroup)), this.graphics.attachEventListener(a.event.MouseEvent.MOUSE_MOVE, c.mouseEventListener,
					this.blockerGroup), this.graphics.attachEventListener(a.event.MouseEvent.MOUSE_CLICK, c.mouseEventListener, this.blockerGroup), this.graphics.attachEventListener(a.event.MouseEvent.MOUSE_RIGHT_CLICK, c.mouseEventListener, this.blockerGroup), this.graphics.attachEventListener(a.event.MouseEvent.MOUSE_UP, c.mouseEventListener, this.blockerGroup), this.graphics.attachEventListener(a.event.MouseEvent.MOUSE_DOWN, c.mouseEventListener, this.blockerGroup), this.graphics.attachEventListener(a.event.MouseEvent.MOUSE_LEAVE,
					c.mouseEventListener, this.blockerGroup));
			this.divTop = this.divLeft = 0;
			this.undoManager = new a.UndoManager;
			this.mouseWheelZoomBehavior = a.Map.ZOOM_KEEP_MOUSE_POINT;
			z && z.mapviewerURL && (this.mapviewerURL = z.mapviewerURL);
			l = function (b) {
				b ? a.util.Logger.warning(0, "OM.Map.initialize", b.responseText) : a.util.Logger.warning(0, "OM.Map.initialize", "")
			};
			try {
				a.notNull(this.mapviewerURL) && a.isNull(a.gv.defaultDataSource) && a.util.HttpRequest.send(this.mapviewerURL + "/omserver", {
					xml_request: '\x3c?xml version\x3d"1.0" standalone\x3d"yes"?\x3e\x3cnon_map_request\x3e\x3clist_data_sources/\x3e\x3c/non_map_request\x3e'
				},
					function (b) {
					b = a.$(b).find("map_data_source");
					a.notNull(b) && (a.gv.defaultDataSource = b.attr("name"))
				}, "xml", l)
			} catch (t) {
				a.util.Logger.warning(0, "OM.Map.initialize", t.stack ? t.message + "\nStack: " + t.stack : t.message)
			}
			a.isNull(this.mapviewerURL) ? this.mapviewerURL = a.gv.localbaseURL() : a.gv.setBaseMapViewerURL(this.mapviewerURL);
			this.disableOverviewMap = !0;
			z && !1 === z.disableOverviewMap && (this.disableOverviewMap = z.disableOverviewMap);
			this.getMapContextToken = function () {
				var a = {
					_instanceId: c.mapInstanceId
				};
				return function () {
					return a
				}
			}
			();
			this._mapContextObj = a.MapContext(c);
			this.getMapContext = function () {
				return c._mapContextObj
			};
			var Y = this.getMapContextToken();
			Y.universe = {};
			Y.graphics = this.graphics;
			z && z.universe && (Y.universe = z.universe);
			Y.deviceWindow = {
				x: 0,
				y: 0,
				w: this.$containerDiv.width(),
				h: this.$containerDiv.height()
			};
			this.typeArray = [];
			this.nameArray = [];
			this.divLayers = [];
			this.svgLayers = [];
			this.layerQueue = [];
			this.touchStartLocs = [];
			this.touchStartLocs_backup = [];
			this.mLocY = this.mLocX = null;
			this.decorationArray = [];
			this.toolFeatureLayer =
				this.defaultFeatureLayer = null;
			this.enableMapAction = {
				mouse: !0,
				click: !0,
				drag: !0,
				dbclick: !0,
				mousewheel: !0
			};
			this.zoomEnabled = !0;
			this._mapCenter = this._zoomLevel = null;
			this.universeLayerIndex = -1;
			this.boundingLayerName = null;
			this.hasExternal = this.resetTag = this.moveflag = this.boundingThemeLoaded = this.boundingThemeLoading = this.initialized = this.displayed = this.inited = !1;
			this.tileLayerZoomAnimation = !0;
			this.maskOutInfoWindow = this.infoWindowEventPropogation = !1;
			this.over = z && z.over ? !0 : !1;
			this.template = null;
			this.cursorStyleDragging =
				a.CursorTypes.MOVE;
			this.cursorStyleDefault = a.CursorTypes.DEFAULT;
			if (!1 === this.over && "undefined" === typeof this.mainmap && (a.isNull(z) || a.notNull(z) && a.isNull(z.magnifier)))
				for (l = 0; l < this.anchors.length; l++)
					this.$topLayerDIV.append(this.anchors[l]);
			this.resizeFun = function () {
				if (!c.over && c.$containerDiv && (Y.deviceWindow.w !== c.$containerDiv.width() || Y.deviceWindow.h != c.$containerDiv.height())) {
					var b = c.$containerDiv.width(),
					x = c.$containerDiv.height();
					Y.deviceWindow.w = b;
					Y.deviceWindow.h = x;
					0 < b && 0 < x && (c.updateBlocker(),
						c.redrawMap(), b = new a.event.MapEvent(a.event.MapEvent.MAP_RESIZED, c), c.fire(b.type, b))
				}
			};
			this.resizeTimer = setInterval(this.resizeFun, 300);
			this.map_mouseOverListener = function (b) {
				var x = a.event,
				x = new x.MapEvent(x.MouseEvent.MOUSE_OVER, c);
				x.evt = b;
				c.fire(x.type, x)
			};
			this.map_mouseOutListener = function (b) {
				var x = a.event,
				x = new x.MapEvent(x.MouseEvent.MOUSE_OUT, c);
				x.evt = b;
				c.fire(x.type, x)
			};
			this.$oracleMapDiv[0].addEventListener("mouseover", this.map_mouseOverListener, !0);
			this.$oracleMapDiv[0].addEventListener("mouseout",
				this.map_mouseOutListener, !0);
			if (!z || !z.magnifier) {
				this.$oracleMapDiv.dblclick(function (b) {
					c.isStoppedEvent(b) || (c.displayed && c.enableMapAction.dbclick && c.setMapCenterAndZoomLevel(c.getCursorLocation(), Y.zoomLevel + 1, !0), b = new a.event.MapEvent(a.event.MouseEvent.MOUSE_DOUBLE_CLICK, c), c.fire(b.type, b))
				});
				this.$oracleMapDiv[0].oncontextmenu = function (a) {
					a.preventDefault()
				};
				var W = !1;
				this.mousewheelHander = function (a) {
					!c.isStoppedEvent(a) && c.enableMapAction.mousewheel && (a.preventDefault(), W || K(a, a.deltaY ||
							-1 * a.originalEvent.deltaY || -1 * a.originalEvent.detail))
				};
				this.$oracleMapDiv.on("mousewheel DOMMouseScroll", this.mousewheelHander);
				var K = function (b, x) {
					W = !0;
					setTimeout(function () {
						W = !1;
						var z = c.getMapContext(),
						l = z.getUniverse(),
						K = l.getZoomLevels(),
						q = z.getZoomLevel(),
						A = q;
						0 < x ? q++ : q--;
						if (!(0 > q || q >= K.length)) {
							b.preventDefault();
							var Q = c.getCursorLocation();
							if (l.srid === a.util.BaiduUtil.SRID && (q = a.util.BaiduUtil.getValidZoomLevel(q), !a.util.GeomUtil.isWithinBBox(Q.getX(), Q.getY(), l.bound.getMinX(), l.bound.getMinY(),
										l.bound.getMaxX(), l.bound.getMaxY())))
								return;
							a.isNull(c.getMouseWheelZoomBehavior()) && c.setMouseWheelZoomBehavior(a.Map.ZOOM_KEEP_MOUSE_POINT);
							Q = z.getCenterPoint();
							switch (c.getMouseWheelZoomBehavior()) {
							case a.Map.ZOOM_CENTER_ON_MOUSE:
								Q = c.getCursorLocation();
								break;
							case a.Map.ZOOM_KEEP_CENTER:
								Q = z.getCenterPoint();
								break;
							default:
								if (c.graphics) {
									var Q = K[q].resolution,
									K = K[A].resolution,
									z = z.getCenterPoint(),
									B = c.getCursorLocation(),
									A = B.getX(),
									B = B.getY(),
									ga = new c.graphics.oui.geom.Matrix;
									ga.translate(A, B);
									ga.scale(Q / K);
									ga.translate(-A, -B);
									Q = ga.transform(z.getX(), z.getY());
									Q = new a.geometry.Point(Q.x, Q.y, l.srid)
								}
							}
							c.setMapCenterAndZoomLevel(Q, q, !0);
							l = new a.event.MapEvent(a.event.MouseEvent.WHEEL_SCROLL, c);
							l.delta = x;
							c.fire(l.type, l)
						}
					}, 350)
				};
				this.$oracleMapDiv.mousedown(function (b) {
					if (!c.isStoppedEvent(b)) {
						0 === b.button && c.enableMapAction.drag && (c.moveflag = !0);
						c.mLocX = b.pageX - c.$oracleMapDiv.offset().left;
						c.mLocY = b.pageY - c.$oracleMapDiv.offset().top;
						c.mouseDownLocX = c.mLocX;
						c.mouseDownLocY = c.mLocY;
						var x =
							new a.event.MapEvent(a.event.MouseEvent.MOUSE_DOWN, c);
						x.evt = b;
						c.fire(x.type, x);
						c.lastMouseDown = Date.now()
					}
				});
				this.$oracleMapDiv.mousemove(function (b) {
					if (!c.isStoppedEvent(b)) {
						var x = b.pageX - c.$topLayerDIV.offset().left - c.mLocX,
						z = b.pageY - c.$topLayerDIV.offset().top - c.mLocY;
						c.mLocX = b.pageX - c.$oracleMapDiv.offset().left;
						c.mLocY = b.pageY - c.$oracleMapDiv.offset().top;
						c.moveflag && c.enableMapAction.drag && (c.changeCursor(c.cursorStyleDragging), c.pan(x, z, !1));
						var l = new a.event.MapEvent(a.event.MouseEvent.MOUSE_MOVE,
								c);
						l.evt = b;
						c.fire(l.type, l);
						c.utfgridMouseEType !== a.event.MouseEvent.MOUSE_MOVE || 0 === x && 0 === z || c.utfgridMouseEListener(a.event.MouseEvent.MOUSE_MOVE);
						c.vectorlayerInfoWindowMouseEType !== a.event.MouseEvent.MOUSE_MOVE || 0 === x && 0 === z || c.vectorLayerInfoWindowListener(a.event.MouseEvent.MOUSE_MOVE)
					}
				});
				this.$oracleMapDiv.mouseup(function (b) {
					if (!c.isStoppedEvent(b)) {
						var x = a.event,
						z = new x.MapEvent(x.MouseEvent.MOUSE_UP, c);
						z.evt = b;
						c.fire(z.type, z);
						c.mouseUpLocX = c.mLocX;
						c.mouseUpLocY = c.mLocY;
						c.mouseDownLocX &&
						c.mouseDownLocY && c.moveflag && c.enableMapAction.drag && (1 < Math.abs(c.mouseUpLocX - c.mouseDownLocX) || 1 < Math.abs(c.mouseUpLocY - c.mouseDownLocY)) ? (z = new x.MapEvent(x.MapEvent.MAP_RECENTERED, c), c.fire(z.type, z)) : c.mouseDownLocX && c.mouseDownLocY && c.mouseUpLocX === c.mouseDownLocX && c.mouseUpLocY === c.mouseDownLocY && c.lastMouseDown && Date.now() - c.lastMouseDown < 2 * a.event.MouseEvent.DEBOUNCE_MILI_SEC && (c.lastMouseDown = null, c.handleMouseClick(b, c));
						c.mouseDownLocX = null;
						c.mouseDownLocY = null;
						c.moveflag = !1;
						c.changeCursor(c.cursorStyleDefault)
					}
				});
				c.displayUTFGridInfoWindow = function () {
					var b = null,
					x = 0,
					z = function () {
						if (c.utfgridHTMLArray.length < c.utfgrid_lyr_cnt)
							10 <= x ? (clearTimeout(b), a.util.Logger.warning("MAPVIEWER_9081", "OM.Map.initialize")) : (clearTimeout(b), b = setTimeout(z, 50), x += 1);
						else {
							for (var l = "", K = 0, W = c.utfgridHTMLArray.length; K < W; K++) {
								var q = c.utfgridHTMLArray[K];
								!a.isNull(q) && 0 < q.trim().length && (l += q.trim())
							}
							0 < l.trim().length ? (l = "\x3ctable align\x3d'left' cellspacing\x3d'4' style\x3d'margin: auto;border-collapse: separate;'\x3e" + l + "\x3c/table\x3e",
								K = c.getCursorLocation(), c.displayInfoWindow(K, l, {
									title: "Feature Info",
									builtInInfoWindow: !0
								})) : c.closeInfoWindows();
							c.utfgridHTMLArray = []
						}
					};
					z()
				};
				c.displayVectorLayersInfoWindow = function (b) {
					var x = !1;
					if (a.isNull(b) || 1 > b.length)
						c.closeInfoWindows();
					else {
						var z,
						l;
						if (!0 === c.showAllVecFeatureInfo)
							for (z = 0, l = b.length; z < l; z += 1)
								b[z] && b[z].feature_layer && !0 === b[z].feature_layer.getEnableInfoWindow() && b[z].feature_layer.insertFeatureInfo(b[z]);
						else
							for (z = b.length - 1; 0 <= z; --z)
								if (b[z] && b[z].feature_layer && !0 === b[z].feature_layer.getEnableInfoWindow()) {
									b[z].feature_layer.insertFeatureInfo(b[z]);
									break
								}
						b = "";
						z = 0;
						for (l = c.vctinfoHTMLArray.length; z < l; z++) {
							var K = c.vctinfoHTMLArray[z];
							!a.isNull(K) && 0 < K.trim().length && (b += K.trim())
						}
						0 < b.trim().length && (b = "\x3ctable align\x3d'left' cellspacing\x3d'4' style\x3d'margin: auto;border-collapse: separate;'\x3e" + b + "\x3c/table\x3e", x = c.getCursorLocation(), c.displayInfoWindow(x, b, {
								title: "Feature Info",
								builtInInfoWindow: !0
							}), x = !0);
						c.vctinfoHTMLArray = [];
						c.vctinfoFeatures = {};
						return x
					}
				};
				c.fireUTFGridEvent = function (b) {
					for (var x = 0; x < c.divLayers.length; x++) {
						var z =
							c.divLayers[x];
						if ((z.layerType === a.LayerTypes.TILE || z.layerType === a.LayerTypes.DYNAMIC_TILE) && !0 === z.enableUTFGrid && z.mouseETypeUTFGrid === b && !0 === z.getEnableInfoWindow()) {
							var l = new a.event.MapEvent(z.mouseETypeUTFGrid, z);
							z.fire(l.type, z)
						}
					}
				};
				c.getVectorLayerHitFeatures = function (b, x) {
					a.isNull(x) && (x = {
							type: b,
							clientX: c.mLocX,
							clientY: c.mLocY
						});
					for (var z = [], l, K, W, q = 0; q < c.svgLayers.length; q++)
						if (l = c.svgLayers[q], l.isVisible() && (K = l.findFeatures(x), !a.isNull(K))) {
							var A,
							Q;
							A = 0;
							for (Q = K.length; A < Q; A++)
								W = K[A],
								a.isNull(W) || W.cluster || (W.feature_layer = l, z.push(W))
						}
					return z
				};
				this.mapDragOutDiv = function () {
					if (c.moveflag && c.enableMapAction.drag) {
						if (c.mouseDownLocX && c.mouseDownLocY && c.moveflag && c.enableMapAction.drag && (1 < Math.abs(c.mouseUpLocX - c.mouseDownLocX) || 1 < Math.abs(c.mouseUpLocY - c.mouseDownLocY))) {
							var b = new a.event.MapEvent(a.event.MapEvent.MAP_RECENTERED, c);
							c.fire(b.type, b)
						}
						c.moveflag = !1;
						c.changeCursor(c.cursorStyleDefault);
						c.mouseDownLocX = null;
						c.mouseDownLocY = null
					}
				};
				a.$(document).mouseup(this.mapDragOutDiv).mouseout(this.mapDragOutDiv);
				this.$fkGraphicLayersDiv.mouseout(function (a) {
					a.stopPropagation()
				});
				this.map_oui_rootNode_mouseleaveHandler = function () {
					c.graphics.oui && c.graphics.oui.tree && c.graphics.oui.tree.canvas && (c.graphics.oui.tree.canvas.style.cursor = c.cursorStyleDefault)
				};
				this.graphics.oui.rootNode.addEventListener(a.event.MouseEvent.MOUSE_LEAVE, this.map_oui_rootNode_mouseleaveHandler);
				a.browser.touchSupported && (this.$oracleMapDiv.on("touchstart", function (a) {
						c.isStoppedEvent(a) || c.touchStart(a)
					}), this.$oracleMapDiv.on("touchmove",
						function (a) {
						a.preventDefault();
						c.isStoppedEvent(a) || c.touchMove(a)
					}), this.$oracleMapDiv.on("touchend", function (a) {
						c.isStoppedEvent(a) || c.touchEnd(a)
					}));
				if (a.gv.isWin8Touch) {
					var q = this;
					a.Hammer(this.$oracleMapDiv[0]).on("transformstart", function (a) {
						q.touchStartLocs = [];
						q.pinchZoomScale = 1;
						var b = q.touchStartLocs;
						b[0] = {
							x: a.gesture.touches[0].pageX,
							y: a.gesture.touches[0].pageY
						};
						b[1] = {
							x: a.gesture.touches[1].pageX,
							y: a.gesture.touches[1].pageY
						};
						a = b[1].x - b[0].x;
						b = b[1].y - b[0].y;
						q.pinchZoomStartDist = Math.sqrt(a *
								a + b * b)
					});
					a.Hammer(this.$oracleMapDiv[0]).on("pinch", function (b) {
						var x = a.util.DomUtil,
						c = x.getTouchesScale(b);
						a.isNull(c) && (b = x.getTouchesPosition(b.gesture), c = b[0].x - b[1].x, b = b[0].y - b[1].y, c = Math.sqrt(c * c + b * b) / q.pinchZoomStartDist);
						q.pinchZoomScale = c;
						if (!(1 === c || 0 >= c || (b = q.zoomLevel, 1 < c && b >= q.maxZoom || 1 > c && 0 >= b)))
							for (q.pinchZooming = !0, q.graphics.setVisible(q.draggableGroup, !1), q.$heatMapDiv.css({
									visibility: "hidden"
								}), b = 0; b < q.divLayers.length; b++)
								q.divLayers[b].zoomControl && q.divLayers[b].zoomControl.scaleTiles(c)
					});
					a.Hammer(this.$oracleMapDiv[0]).on("transformend", function () {
						var a = q.pinchZoomScale;
						q.pinchZooming && (a = q.getScaleZoomLevel(a), q.setMapZoomLevel(a), q.pinchZoomScale = 1, q.pinchZooming = !1, q.graphics.setVisible(q.draggableGroup, !0), q.doubleTap = !1)
					})
				}
				this._keyboardSupport = {
					xPanOffset: 5,
					yPanOffset: 5,
					useSmoothPan: !1,
					actionMap: {
						tab: function () {},
						zoomIn: function () {
							c.zoomIn()
						},
						zoomOut: function () {
							c.zoomOut()
						},
						panLeft: function () {
							c.pan(c._keyboardSupport.xPanOffset, 0, c._keyboardSupport.useSmoothPan)
						},
						panUp: function () {
							c.pan(0,
								c._keyboardSupport.yPanOffset, c._keyboardSupport.useSmoothPan)
						},
						panRight: function () {
							c.pan(-c._keyboardSupport.xPanOffset, 0, c._keyboardSupport.useSmoothPan)
						},
						panDown: function () {
							c.pan(0, -c._keyboardSupport.yPanOffset, c._keyboardSupport.useSmoothPan)
						},
						toggleOverview: function () {
							var a = c.overview;
							a.minimized ? a.restore() : a.collapse()
						},
						toggleLayerControl: function () {},
						toggleDecoration: function () {}
					},
					keyMap: {
						107: "zoomIn",
						109: "zoomOut",
						37: "panLeft",
						38: "panUp",
						39: "panRight",
						40: "panDown",
						79: "toggleOverview"
					}
				};
				l = function (a) {
					if (!c.isStoppedEvent(a) && "keydown" === a.type) {
						var b = c._keyboardSupport.actionMap;
						if ((a = c._keyboardSupport.keyMap[a.keyCode]) && b[a])
							b[a]()
					}
				};
				this.$oracleMapDiv.keypress(l);
				this.$oracleMapDiv.keydown(l);
				this.$oracleMapDiv.keyup(l)
			}
			this.newLayerConfigLoaded = function (b) {
				b.target instanceof a.layer.Layer && (b.target.lastEvent = b.type);
				c.initLayers(b)
			};
			this.listenerElocationCopyright = function () {
				var b = new a.control.CopyRight({
					anchorPosition: a.control.MapDecoration.POSITION_LOWER_RIGHT,
					textValue: '\x26copy; 2023 Oracle Corporation \x26nbsp;\x26nbsp; \x3ca target\x3d"_blank" href\x3d"https://elocation.oracle.com/elocation/legal.html"\x3eTerms\x3c/a\x3e \x26nbsp;\x26nbsp; Map data \x26copy; HERE',
					fontSize: 10,
					fontFamily: "Arial",
					fontColor: "black"
				});
				c.addMapDecoration(b);
				this.deleteListener(a.event.LayerEvent.FINISH_GOT_CONFIG, c.listenerElocationCopyright)
			};
			this.listenerOSMCopyright = function () {
				var b = new a.control.CopyRight({
					anchorPosition: a.control.MapDecoration.POSITION_LOWER_RIGHT,
					textValue: '\x3ca target\x3d"_blank" href\x3d"http://openmaptiles.org"\x3e \x26copy; OpenMapTiles \x3c/a\x3e \x26nbsp; \x3ca target\x3d"_blank" href\x3d"https://www.openstreetmap.org/copyright"\x3e \x26copy; OpenStreetMap contributors \x3c/a\x3e',
					fontSize: 10,
					fontFamily: "Arial",
					fontColor: "black"
				});
				c.addMapDecoration(b);
				this.deleteListener(a.event.LayerEvent.FINISH_GOT_CONFIG, c.listenerOSMCopyright)
			};
			this.layerFeaturesLoaded = function (b) {
				if (!(a.util.Logger.currentLevel > a.util.Logger.LEVELS.info)) {
					var x = b.type,
					c = b.target;
					a.isNull(c) || (b.type === a.event.LayerEvent.FEATURES_LOADED ? (b = c.size(), a.util.Logger.info("", "OM.Map.layerFeaturesLoaded", "layer [" + c.name + "] FEATURES_LOADED loaded [" + b + "] features")) : a.util.Logger.info("", "OM.Map.layerFeaturesLoaded",
							"layer [" + c.name + "]; etype: " + x))
				}
			};
			this.layerLoaded = function (b) {
				if (!(a.util.Logger.currentLevel < a.util.Logger.LEVELS.info)) {
					var x = b.type,
					c = b.target;
					a.isNull(c) || (b.type === a.event.LayerEvent.FINISH_LOAD ? a.util.Logger.info("", "OM.Map.layerLoaded", "layer [" + c.name + "] FINISH_LOAD ") : a.util.Logger.info("", "OM.Map.layerLoaded", "layer [" + c.name + "]; etype:  " + x))
				}
			};
			this.layerDisplayed = function (b) {
				a.util.Logger.currentLevel < a.util.Logger.LEVELS.info || a.isNull(b.target)
			};
			this.layerFinish = function (b) {
				b.target.loaded =
					!0;
				b.target.lastEvent = b.type;
				b.target.name !== c.boundingLayerName || a.Map.isTileLayer(b.target.layerType) || (c.boundingThemeLoaded = !0);
				var x;
				if (a.Map.isTileLayer(b.target.layerType)) {
					if (!c.divLayers)
						return;
					for (x = 0; x < c.divLayers.length; x++)
						if (!c.divLayers[x].loaded)
							return;
					b = new a.control.CopyRight({
						anchorPosition: 6,
						textValue: b.target.tileLayerConfig.copyright,
						fontSize: 12,
						fontFamily: "Arial"
					});
					!c.over && a.isNull(b.textValue) && 0 < b.textValue.trim().length && c.addMapDecoration(b);
					"CopyRight" === b.type && (c.copyRight =
							b);
					c.graphics && c.graphics.setVisible(c.draggableGroup, !0);
					c.$heatMapDiv && c.$heatMapDiv.css({
						visibility: "visible"
					})
				}
				if (c.divLayers)
					for (x = 0; x < c.divLayers.length; x++)
						if (!c.divLayers[x].loaded)
							return;
				if (c.svgLayers)
					for (x = 0; x < c.svgLayers.length; x++)
						if (!c.svgLayers[x].loaded && !c.svgLayers[x].loadError)
							return;
				c.boundingLayerName = null;
				c.boundingThemeLoaded = !1;
				try {
					c.refreshVectorLayerLabels(),
					c.getToolFeatureLayer()
				} catch (z) {
					a.util.Logger.warning(0, "OM.Map.layerFinish", z.stack ? z.message + "\nStack: " + z.stack :
						z.message)
				} finally {
					b = new a.event.MapEvent(a.event.MapEvent.MAP_AFTER_REFRESH, c),
					c.fire(b.type, b)
				}
			};
			this.layerErr = function (b) {
				c.overviewLayer === b.target && (c.overviewLayerErr = !0);
				c.removeLayer(b.target);
				a.Map.isTileLayer(b.target.layerType) ? 0 < c.divLayers.length && c.divLayers[c.universeLayerIndex].getLayerConfig() : (b.target.isBoundingTheme() && (c.boundingLayerName = null, 0 <= c.universeLayerIndex && c.divLayers[c.universeLayerIndex].getLayerConfig()), c.layerFinish(b), 0 > c.universeLayerIndex && c.overviewLayerErr &&
					c.overview && 0 < c.svgLayers.length && (c.overviewLayer = c.svgLayers[c.svgLayers.length - 1], c.overview.setOverviewMapOptions({
							overviewLayer: c.overviewLayer
						}), c.overview.errLoadLayer()))
			};
			this.layerStyleChanged = function (b) {
				var x = new a.event.MapEvent(a.event.MapEvent.MAP_STYLE_CHANGED, c);
				x.affectLayer = b.target;
				x.newStyle = b.newStyle;
				x.attributes = b.attributes;
				c.fire(x.type, x)
			};
			this.nsdpMapped = function (b) {
				var x = new a.event.MapEvent(a.event.MapEvent.I_MAP_NSDP_MAPPED, c);
				x.affectLayer = b.target;
				c.fire(x.type, x)
			};
			this.disableOverviewMap || z.magnifier || (this.overview = new a.control.OverviewMap({}), this.overview.mainmap = this, this.addMapDecoration(this.overview), l = this.overview, Q = a.event.MapEvent, this.$topLayerDIV.append(this.overview.$DecorationDiv), this.on(Q.MAP_RECENTERED, this.overview.setCenterAndZoomlevel, l), this.on(Q.I_MAP_CENTER_ZOOM, this.overview.setCenterAndZoomlevel, l), this.on(Q.I_MAP_DRAGGING, this.overview.setRectangleFeature, l), this.on(Q.MAP_BEFORE_REFRESH, this.overview.setCenterAndZoomlevel, l), this.on(Q.MAP_RESIZED,
					this.overview.resize, l), this.on(Q.MAP_STYLE_CHANGED, this.overview.styleChange, l), this.on(Q.I_MAP_NSDP_MAPPED, this.overview.nsdpMapped, l), this.on(Q.LAYER_DELETED, this.overview.layerDel, l), this.on(a.event.MapEvent.MAP_DESTROY, this.overview.destroy), this.overviewLayer = null);
			l = a.event.MapEvent;
			this.on(l.MAP_INITIALIZED, function () {
				var b = c.getLabelGridBox();
				c.grid = new a.util.CoverageGrid(b);
				for (b = 0; b < c.svgLayers.length; b++)
					c.svgLayers[b].loaded = !1
			}, this);
			this.on(l.LAYER_REORDERED, this.changeOverView, this);
			this.getToolFeatureLayer();
			!1 === this.over && "undefined" === typeof this.mainmap && (a.isNull(z) || a.notNull(z) && a.isNull(z.magnifier)) && (this.progressService = new a.util.Progress, this.progressBar = new a.util.ProgressBar(this), "function" === typeof this.progressService.subscribe && (this.progressService.subscribe(this.progressBar.updateUi.bind(this.progressBar), "progress"), this.progressService.subscribe(this.progressBar.switchMode.bind(this.progressBar), "mode")));
			a.event.EventSource.initProcessedEventStatus()
		},
		setUTFGridMouseEType: function (b) {
			for (var c = 0; c < this.divLayers.length; c++) {
				var p = this.divLayers[c];
				p.layerType !== a.LayerTypes.TILE && p.layerType !== a.LayerTypes.DYNAMIC_TILE || !0 !== p.enableUTFGrid || !0 !== p.getEnableInfoWindow() || (this.utfgridMouseEType = b === a.event.MouseEvent.MOUSE_OVER || b === a.event.MouseEvent.MOUSE_MOVE ? a.event.MouseEvent.MOUSE_MOVE : a.event.MouseEvent.MOUSE_CLICK)
			}
		},
		updateUTFGridLayerListener: function () {
			this.utfgrid_lyr_cnt = this.getUTFGridLayerCount();
			this.utfgridMouseEType = this.getUTFGridMouseEType();
			this.utfgridMouseEListener = a.util.MiscUtil.debounce(function (a) {
				a === this.utfgridMouseEType && 0 < this.utfgrid_lyr_cnt && (this.fireUTFGridEvent(a), setTimeout(this.displayUTFGridInfoWindow(), 10))
			}, 500)
		},
		vectorLayerInfoWindowListener: a.util.MiscUtil.debounce(function (a) {
			this.displayVectorLayersInfoWindow(this.getVectorLayerHitFeatures(a))
		}, 500),
		updateUTFGridLayerCount: function () {
			this.utfgrid_lyr_cnt = this.getUTFGridLayerCount()
		},
		generateMapInstanceId: function () {
			var a = 0;
			return function () {
				return  + ++a
			}
		}
		(),
		getUndoManager: function () {
			return this.undoManager
		},
		initLayers: function (b) {
			var c = this,
			p = a.event,
			l = this.getMapContextToken(),
			Q = function () {
				for (var b, x = [], W = 0; a.notNull(c.layerQueue) && W < c.layerQueue.length; W++) {
					b = c.layerQueue[W];
					if (a.Map.isTileLayer(b[0].layerType)) {
						for (var I = b[0].getZIndex() - 1, p = !1, A = 0; A < I; A++)
							if (!c.divLayers[A].initCalled) {
								p = !0;
								break
							}
						if (p) {
							x.push(c.layerQueue[W]);
							continue
						} else {
							if (!b[1].equals(l.universe)) {
								c.resetUniverse(b[1], b[0], b[0].tileLayerConfig);
								return
							}
							if (c.divLayers[c.universeLayerIndex] == b[0] && !c.boundingLayerName && !c.extentRect &&
								b[0].initCalled) {
								a.util.Logger.config("", "OM.Map.initLayers.deLayerQueue", "[" + b[0].name + "] layer's initLayer() skipped");
								continue
							}
						}
					}
					b[0].initLayer()
				}
				c.overviewLayerErr && c.overview && (-1 !== c.universeLayerIndex ? c.overviewLayer = c.divLayers[c.universeLayerIndex] : 0 < c.svgLayers.length && (c.overviewLayer = c.svgLayers[c.svgLayers.length - 1]), c.overview.setOverviewMapOptions({
						overviewLayer: c.overviewLayer
					}), c.overview.errLoadLayer());
				c.layerQueue = x
			},
			A = function (b) {
				if (!a.isNull(c.layerQueue)) {
					for (var x = 0; x < c.layerQueue.length; x++)
						if (c.layerQueue[x][0].name ===
							b.target.name)
							return;
					x = [b.target];
					a.Map.isTileLayer(b.target.layerType) && a.notNull(b.config) && x.push(new a.universe.Universe(b.config));
					c.layerQueue.push(x)
				}
			};
			c.extentRect && (c.boundingLayerName = null);
			var B,
			G;
			if (a.notNull(c.extentRect) && -1 !== c.universeLayerIndex)
				if (c.displayed || c.divLayers[c.universeLayerIndex] != b.target)
					if (!b && c.displayed)
						c.checkCenter(), B = new p.MapEvent(p.MapEvent.MAP_INITIALIZED, c), c.initialized = !0, c.inited = !1, c.fire(B.type, B), Q();
					else if (c.initialized) {
						if (a.Map.isTileLayer(b.target.layerType) &&
							(A = new a.universe.Universe(b.config), !A.equals(l.universe))) {
							c.resetUniverse(A, b.target, b.config);
							return
						}
						b.target.initLayer();
						Q()
					} else
						A(b);
				else
					l.universe = (new a.universe.Universe(b.config)).copy(l.universe), c.displayed = !0, c.setAllInitialParams(), l.zoomLevel = c.checkZoomLevel(l.zoomLevel), A(b), c.zoomToExtent(c.extentRect);
			else if (a.notNull(c.extentRect))
				c.displayed ? !b && c.displayed ? (B = new p.MapEvent(p.MapEvent.MAP_INITIALIZED, c), c.initialized || (c.initialized = !0, c.inited = !1, c.fire(B.type, B)), Q()) : c.initialized ?
				b.target.initLayer() : A(b) : (c.displayed = !0, l.zoomLevel = c.checkZoomLevel(l.zoomLevel), c.setAllInitialParams(), A(b), c.zoomToExtent(c.extentRect));
			else if (c.boundingLayerName && -1 != c.universeLayerIndex)
				if (c.divLayers[c.universeLayerIndex] != b.target || c.displayed)
					if (c.boundingLayerName == b.target.name && c.displayed)
						c.boundingThemeLoading ? (B = b.bbox, B = b.target.calculateCenterAndZoomLevel(B[0], B[1], B[2], B[3]), c.initialized ? (c.setMapCenterAndZoomLevel(B[1], B[0]), b.target.initLayer()) : (l.centerPoint = B[1], l.homeCenter =
									l.centerPoint, l.zoomLevel = c.checkZoomLevel(B[0]), l.homeMapCenter || (l.homeMapCenter = l.homeCenter), c.wraparound && (l.roundMapCenterPoint = l.homeCenter.clone()), l.homeMapZoomlevel || (l.homeMapZoomlevel = l.zoomLevel), c.checkCenter(), c.boundingThemeLoaded = !0, B = new p.MapEvent(p.MapEvent.MAP_INITIALIZED, c), c.initialized = !0, c.inited = !1, c.fire(B.type, B), A(b)), Q(), c.boundingThemeLoading = !1) : (c.boundingThemeLoading = !0, b.target.loadBoundingTheme());
					else if (c.initialized && c.boundingThemeLoaded) {
						if (a.Map.isTileLayer(b.target.layerType) &&
							(A = new a.universe.Universe(b.config), !A.equals(l.universe))) {
							c.resetUniverse(A, b.target, b.config);
							return
						}
						b.target.initLayer();
						Q()
					} else
						A(b);
				else
					for (l.universe = (new a.universe.Universe(b.config)).copy(l.universe), c.displayed = !0, A(b), A = 0; A < c.layerQueue.length; A++) {
						if (B = c.layerQueue[A], B[0].layerType == a.LayerTypes.VECTOR && B[0].name == c.boundingLayerName) {
							c.boundingThemeLoading = !0;
							B[0].loadBoundingTheme();
							break
						}
					}
			else if (-1 != c.universeLayerIndex)
				if (c.divLayers && c.divLayers[c.universeLayerIndex] === b.target &&
					!c.displayed)
					if (l.universe = (new a.universe.Universe(b.config)).copy(l.universe), l.zoomLevel = c.checkZoomLevel(l.zoomLevel), c.displayed = !0, G = function () {
						c.checkCenter();
						var a = new p.MapEvent(p.MapEvent.MAP_INITIALIZED, c);
						c.initialized || (c.initialized = !0, c.inited = !1, c.resetTag && (a = new p.MapEvent(p.MapEvent.MAP_RESET_UNIVERSE, c)), c.fire(a.type, a));
						b.target.initLayer();
						Q()
					}, c.setAllInitialParams(), l.centerPoint.srid === l.universe.srid)
						l.homeCenter = l.centerPoint.clone(), c.wraparound && (l.roundMapCenterPoint =
								l.homeCenter.clone()), G();
					else if (l.universe.srid === a.util.BaiduUtil.SRID)
						a.notNull(c.bdutil) && a.util.BaiduUtil.transformGeom({
							geom: l.centerPoint,
							toSrid: a.util.BaiduUtil.SRID,
							callBack: function (a) {
								l.centerPoint = a;
								l.homeCenter = l.centerPoint.clone();
								c.wraparound && (l.roundMapCenterPoint = l.homeCenter.clone());
								G()
							},
							map: c
						});
					else if (l.centerPoint.srid === a.util.BaiduUtil.SRID) {
						var Y = function (a) {
							l.centerPoint = a;
							l.homeCenter = l.centerPoint.clone();
							c.wraparound && (l.roundMapCenterPoint = a);
							G()
						};
						a.util.BaiduUtil.transformGeom({
							geom: l.centerPoint,
							toSrid: 8307,
							callBack: function (a) {
								a.transform(l.universe.srid, Y)
							},
							map: c
						})
					} else
						l.centerPoint.transform(l.universe.srid, function (a) {
							l.centerPoint = a;
							l.homeCenter = l.centerPoint.clone();
							c.wraparound && (l.roundMapCenterPoint = a);
							G()
						});
				else if (c.initialized) {
					if (a.Map.isTileLayer(b.target.layerType)) {
						B = b.target.getZIndex() - 1;
						for (var W = 0; W < B; W++)
							if (!c.divLayers[W].initCalled) {
								A(b);
								return
							}
						A = new a.universe.Universe(b.config);
						if (!A.equals(l.universe)) {
							c.resetUniverse(A, b.target, b.config);
							return
						}
					}
					b.target.initLayer();
					Q()
				} else
					A(b);
			else
				c.boundingLayerName ? b.target.name == c.boundingLayerName && b.bbox ? (c.displayed = !0, l.homeMapCenter = l.centerPoint, l.homeMapZoomlevel = l.zoomLevel, a.notNull(b.bbox[0]) && a.notNull(b.bbox[1]) && a.notNull(b.bbox[2]) && a.notNull(b.bbox[3]) ? (B = b.target.calculateCenterAndZoomLevel(b.bbox[0], b.bbox[1], b.bbox[2], b.bbox[3]), l.homeCenter = B[1], l.homeMapCenter || (l.homeMapCenter = B[1]), l.homeMapZoomlevel || (l.homeMapZoomlevel = B[0]), c.setMapCenterAndZoomLevel(B[1], B[0])) : c.setMapZoomLevel(0), c.checkCenter(),
					c.boundingThemeLoaded = !0, B = new p.MapEvent(p.MapEvent.MAP_INITIALIZED, c), c.initialized || (c.initialized = !0, c.inited = !1, c.fire(B.type, B)), a.notNull(b.bbox[0]) && a.notNull(b.bbox[1]) && a.notNull(b.bbox[2]) && a.notNull(b.bbox[3]) && A(b), Q()) : b.target.name == c.boundingLayerName ? (c.boundingThemeLoading = !0, b.target.loadBoundingTheme()) : c.initialized && c.boundingThemeLoaded ? (b.target.initLayer(), Q()) : A(b) : (A = this.getMapContext().getUniverse(), c.displayed = !0, l.zoomLevel = c.checkZoomLevel(l.zoomLevel), c.setAllInitialParams(),
					G = function () {
					var a = new p.MapEvent(p.MapEvent.MAP_INITIALIZED, c);
					c.checkCenter();
					c.initialized || (c.initialized = !0, c.inited = !1, c.fire(a.type, a));
					b && b.target.initLayer();
					Q()
				}, l.centerPoint.srid == A.srid ? (l.homeCenter = l.centerPoint.clone(), c.wraparound && (l.roundMapCenterPoint = l.homeCenter.clone()), G()) : l.centerPoint.transform(A.srid, function (a) {
						l.centerPoint = a;
						l.homeCenter = l.centerPoint.clone();
						c.wraparound && (l.roundMapCenterPoint = l.homeCenter.clone());
						G()
					}))
		},
		init: function () {
			this.on(a.event.MapEvent.MAP_INITIALIZED,
				function (a) {
				var b = a.target;
				b.getMapContext().getTransform();
				b.changeCursor(b.cursorStyleDefault);
				a = b.getMapContext().getUniverse().getMapBounds().getWidth();
				for (var c = b.getMapContext().getWholeMapNum(), b = b.getMapContext().getBaseWholeMapIndex(), x = 0; x < c; x++)
					this.mapBBox[x] = {
						minX: (x - b) * a - a / 2,
						maxX: (x - b) * a + a / 2
					}
			});
			var b = a.event,
			c = this.getMapContextToken();
			this.layerQueue = [];
			if (this.initialized)
				this.cleanMap();
			else {
				var p = this.getMapContextToken();
				a.notNull(p.centerPoint) && (p.homeMapCenter = p.centerPoint);
				this.wraparound && a.notNull(p.homeMapCenter) && (c.roundMapCenterPoint = p.homeMapCenter.clone());
				p.homeMapZoomlevel = p.zoomLevel
			}
			if (0 === this.divLayers.length && 0 === this.svgLayers.length)
				this.displayed = !0, c.zoomLevel = this.checkZoomLevel(c.zoomLevel), this.initialized || (this.initialized = !0, this.inited = !1, c = new b.MapEvent(b.MapEvent.MAP_INITIALIZED, this), this.resetTag && (c = new b.MapEvent(b.MapEvent.MAP_RESET_UNIVERSE, this)), this.fire(c.type, c));
			else {
				if (-1 !== this.universeLayerIndex && 0 < this.divLayers.length)
					for (b =
							this.divLayers[this.universeLayerIndex], b.layerType === a.LayerTypes.EXTERNAL && (b.loaded = !0, b.setContainer(this.$tileLayersDiv[0])), a.isNull(this.overviewLayer) && (this.overviewLayer = b), b.getLayerConfig(), c = this.universeLayerIndex + 1; c < this.divLayers.length; c++)
						b = this.divLayers[c], b.layerType === a.LayerTypes.EXTERNAL && (b.loaded = !0, b.setContainer(this.$tileLayersDiv[0])), b.getLayerConfig();
				for (c = 0; c <= this.svgLayers.length - 1; c++)
					a.isNull(this.overviewLayer) && this.svgLayers[c] !== this.toolFeatureLayer && this.svgLayers[c] !==
					this.defaultFeatureLayer && (this.overviewLayer = this.svgLayers[c]), this.svgLayers[c].getLayerConfig();
				this.inited = !0;
				this.updateUTFGridLayerListener()
			}
		},
		validateUTFGridLayerTriggers: function () {
			for (var b = null, c = 0; c < this.divLayers.length; c++) {
				var p = this.divLayers[c];
				p.layerType !== a.LayerTypes.TILE && p.layerType !== a.LayerTypes.DYNAMIC_TILE || !0 !== p.enableUTFGrid || !0 !== p.getEnableInfoWindow() || !a.notNull(p.mouseETypeUTFGrid) || (a.isNull(b) ? b = p.mouseETypeUTFGrid : (p.mouseETypeUTFGrid = b, a.util.Logger.warning("",
								"OM.Map.getUTFGridMouseEType", "UTFGrid info window trigger is set to:[" + b + "]")))
			}
		},
		getUTFGridMouseEType: function () {
			for (var b = 0; b < this.divLayers.length; b++) {
				var c = this.divLayers[b];
				if ((c.layerType === a.LayerTypes.TILE || c.layerType === a.LayerTypes.DYNAMIC_TILE) && !0 === c.enableUTFGrid && !0 === c.getEnableInfoWindow() && a.notNull(c.mouseETypeUTFGrid))
					return c.mouseETypeUTFGrid
			}
			return a.event.MouseEvent.MOUSE_CLICK
		},
		getUTFGridLayerCount: function () {
			for (var b = 0, c = 0; c < this.divLayers.length; c++) {
				var p = this.divLayers[c];
				p.layerType !== a.LayerTypes.TILE && p.layerType !== a.LayerTypes.DYNAMIC_TILE || !0 !== p.enableUTFGrid || !0 !== p.getEnableInfoWindow() || !0 !== p.isVisible() || (b += 1)
			}
			return b
		},
		refreshMap: function () {
			if (this.initialized) {
				var b = new a.event.MapEvent(a.event.MapEvent.MAP_BEFORE_REFRESH, this);
				this.fire(b.type, b)
			}
		},
		redrawMap: function () {
			if (this.initialized) {
				this.getMapContextToken().transform = null;
				this.getMapContext().getTransform();
				this.wraparound && (this.getMapContextToken().roundMapCenterPoint = this.getMapContextToken().centerPoint);
				this.graphics.setLeftTop(this.draggableGroup, 0, 0);
				var b = new a.event.MapEvent(a.event.MapEvent.MAP_REDRAW, this);
				this.fire(b.type, b)
			}
		},
		removeMapDecorations: function () {
			if (this.decorationArray && 0 !== this.decorationArray.length) {
				for (var a = this.decorationArray.length - 1; 0 <= a; a--)
					this.removeMapDecoration(this.decorationArray[a]);
				this.decorationArray = []
			}
		},
		removeAllLayers: function () {
			var a,
			b = this.svgLayers;
			for (a = b.length - 1; 0 <= a; a--)
				this.removeLayer(b[a]);
			b = this.divLayers;
			for (a = b.length - 1; 0 <= a; a--)
				this.removeLayer(b[a])
		},
		destroyMap: function () {
			a.util.Logger.info(null, "Destorying map instance " + this.mapInstanceId);
			var b = new a.event.MapEvent(a.event.MapEvent.MAP_DESTROY, this);
			this.fire(b.type, b);
			this.removeMapDecorations();
			this.removeAllLayers();
			clearInterval(this.resizeTimer);
			this.$oracleMapDiv && (this.$oracleMapDiv[0].removeEventListener("mouseover", this.map_mouseOverListener), this.$oracleMapDiv[0].removeEventListener("mouseout", this.map_mouseOutListener), this.$oracleMapDiv[0].oncontextmenu = null, this.$oracleMapDiv.unbind(),
				this.$oracleMapDiv.off());
			a.gv.isWin8Touch && (a.Hammer(this.parentMap.$oracleMapDiv[0]).off("transformstart"), a.Hammer(this.parentMap.$oracleMapDiv[0]).off("pinch"));
			h.OM_finishLoadBingJsV7 = null;
			a.notNull(this.$fkGraphicLayersDiv) && this.$fkGraphicLayersDiv.off();
			a.notNull(this.graphics) && (this.graphics.oui.rootNode.removeEventListener(a.event.MouseEvent.MOUSE_LEAVE, this.map_oui_rootNode_mouseleaveHandler), !0 === this.useRTree && (a.browser.touchSupported && (this.graphics.detachEventListener(a.event.MouseEvent.TOUCH_TAP,
							this.mouseEventListener, this.blockerGroup), this.graphics.detachEventListener(a.event.MouseEvent.TOUCH_LONG_PRESS, this.mouseEventListener, this.blockerGroup), this.graphics.detachEventListener(a.event.MouseEvent.TOUCH_END, this.mouseEventListener, this.blockerGroup), this.graphics.detachEventListener(a.event.MouseEvent.TOUCH_START, this.mouseEventListener, this.blockerGroup)), this.graphics.detachEventListener(a.event.MouseEvent.MOUSE_MOVE, this.mouseEventListener, this.blockerGroup), this.graphics.detachEventListener(a.event.MouseEvent.MOUSE_CLICK,
						this.mouseEventListener, this.blockerGroup), this.graphics.detachEventListener(a.event.MouseEvent.MOUSE_RIGHT_CLICK, this.mouseEventListener, this.blockerGroup), this.graphics.detachEventListener(a.event.MouseEvent.MOUSE_UP, this.mouseEventListener, this.blockerGroup), this.graphics.detachEventListener(a.event.MouseEvent.MOUSE_DOWN, this.mouseEventListener, this.blockerGroup), this.graphics.detachEventListener(a.event.MouseEvent.MOUSE_LEAVE, this.mouseEventListener, this.blockerGroup)));
			this.getMapContextToken =
				this._mapContextObj = null;
			this.deleteAllListeners();
			this.template && this.template.destroy();
			try {
				this.graphics && (this.graphics.clearGroup(this.draggableGroup), this.graphics.clearGroup(this.blockerGroup), this.graphics.clearGroup(this.fixedGroup), this.graphics.removeAll())
			} catch (c) {
				a.util.Logger.warning("", "Map.destroyMap", "destroy [" + this.mapInstanceId + "] did not clear graphics properly")
			}
			this.graphics = this.fixedGroup = this.blockerGroup = this.draggableGroup = null;
			this.undoManager && this.undoManager.destroy();
			this.undoManager = null;
			this.loadingIcon && a.$(this.loadingIcon).remove();
			this.$topLayerDIV && this.$topLayerDIV.remove();
			this.$fkGraphicLayersDiv && this.$fkGraphicLayersDiv.remove();
			this.$tileLayersDiv && this.$tileLayersDiv.remove();
			this.$heatMapDiv && this.$heatMapDiv.remove();
			this.loadingIcon && a.$(this.loadingIcon).empty();
			this.$oracleMapDiv && this.$oracleMapDiv.remove();
			this.$containerDiv && this.$containerDiv.unbind().empty();
			this.mapDragOutDiv && a.$(document).unbind("mouseup", this.mapDragOutDiv).unbind("mouseout",
				this.mapDragOutDiv);
			this.dropOnDoc && a.$(document).unbind("drop", this.dropOnDoc);
			this.$heatMapDiv = this.$containerDiv = this.$oracleMapDiv = this.$tileLayersDiv = this.$fkGraphicLayersDiv = this.$topLayerDIV = this.loadingIcon = this.dropOnDoc = this.mapDragOutDiv = null;
			this.divLayers = [];
			this.svgLayers = [];
			this.typeArray = [];
			this.nameArray = [];
			this.overview = this.overviewLayer = this.toolFeatureLayer = this.defaultFeatureLayer = null;
			this.decorationArray = [];
			this.layerQueue = [];
			for (var b = a.gv.mapInstances, z = b.length, p = 0; p < z; p++)
				if (b[p] ==
					this) {
					b.splice(p, 1);
					break
				}
		},
		getUniverse: function () {
			return this.getMapContext().getUniverse()
		},
		setMapCenter: function (a, b) {
			!1 !== b && (b = !0);
			this.wraparound ? this.setMapCenterAndZoomLevel(a, this.getMapContext().getZoomLevel(), b) : this.setMapCenterAndZoomLevel(a, null, b)
		},
		getMapCenter: function (b) {
			if (a.isNull(b))
				return this.getMapContext().getCenterPoint();
			this._noZoomInOut = !0;
			this.zoomToExtent(b);
			this._noZoomInOut = !1;
			return this._mapCenter
		},
		setMapZoomLevel: function (a) {
			this.setMapCenterAndZoomLevel(null, a,
				!0)
		},
		getMapZoomLevel: function (b) {
			if (a.isNull(b))
				return this.getMapContext().getZoomLevel();
			this._noZoomInOut = !0;
			this.zoomToExtent(b);
			this._noZoomInOut = !1;
			return this._zoomLevel
		},
		setMapScale: function (b, c) {
			var p = this,
			l = function () {
				p.deleteListener(a.event.MapEvent.MAP_INITIALIZED, l);
				var Q = p.getMapContext().getUniverse().getSRID();
				p.setMapResolution(8307 === Q || 8265 === Q || 4326 === Q ? .0254 * b / 111195 / a.gv.DPI : .0254 * b / a.gv.DPI, c)
			};
			if (this.initialized)
				l();
			else
				this.on(a.event.MapEvent.MAP_INITIALIZED, l)
		},
		getMapScale: function () {
			var b =
				this.getMapContext(),
			c = b.getZoomLevel(),
			c = b.getUniverse().getZoomLevels()[c].resolution,
			b = b.getUniverse().getSRID();
			return 8307 === b || 8265 === b || 4326 === b ? a.gv.DPI * c * 111195 / .0254 : a.gv.DPI * c / .0254
		},
		getPixelResolution: function () {
			try {
				var b = this.getMapContext(),
				c = b.getZoomLevel();
				return b.getUniverse().getZoomLevels()[c].resolution
			} catch (p) {
				return a.util.Logger.warning("", "OM.Map.getPixelResolution", "Failed to get actual pixel resolution, returning 1 instead."),
				1
			}
		},
		setMapResolution: function (a, b, c) {
			var l =
				this.getMapContext().getUniverse().getZoomLevels();
			b || (b = null);
			if (a > l[0].resolution)
				this._zoomLevel = 0, this._noZoomInOut || this.setMapCenterAndZoomLevel(b, 0);
			else {
				for (var Q = 0; Q < l.length - 1; Q++)
					if (l[Q + 1].resolution <= a && l[Q].resolution >= a) {
						c ? (this._zoomLevel = Q, this._noZoomInOut || this.setMapCenterAndZoomLevel(b, Q)) : a / l[Q].resolution >= l[Q + 1].resolution / a ? (this._zoomLevel = Q, this._noZoomInOut || this.setMapCenterAndZoomLevel(b, Q)) : (this._zoomLevel = Q + 1, this._noZoomInOut || this.setMapCenterAndZoomLevel(b, Q + 1));
						return
					}
				this._zoomLevel = Q;
				this._noZoomInOut || this.setMapCenterAndZoomLevel(b, Q)
			}
		},
		zoomToExtent: function (b) {
			var c = this,
			p = this.getMapContextToken(),
			l = p.universe;
			if (0 !== b.getWidth() && 0 !== b.getHeight()) {
				var Q = function (a) {
					var b = a.getWidth() / p.deviceWindow.w,
					x = a.getHeight() * l.zoomLevels[p.zoomLevel].stretchRatio / p.deviceWindow.h;
					c._mapCenter = a.getCenter();
					b > x ? c.setMapResolution(b, a.getCenter(), !0) : c.setMapResolution(x, a.getCenter(), !0);
					c.initialized || c.initLayers()
				};
				c.extentRect = b;
				this.displayed && (b.srid ===
					l.srid ? Q(b) : b.srid !== a.util.BaiduUtil.SRID && l.srid !== a.util.BaiduUtil.SRID ? b.transform(l.srid, function (a) {
						Q(a)
					}) : b.transform(l.srid, function (a) {
						Q(a)
					}, null, null, {
						map: c,
						inputIsBD09LonLat: !0
					}))
			}
		},
		zoom_debounce: a.util.MiscUtil.debounce(function (b) {
			this.curZmLvl = null;
			a.notNull(this.minZoomLevelLimit) && b < this.minZoomLevelLimit ? a.util.Logger.warning("", "OM.Map.zoom", "zoom reached the min level allowed: " + this.minZoomLevelLimit) : a.notNull(this.maxZoomLevelLimit) && b > this.maxZoomLevelLimit ? a.util.Logger.warning("",
				"OM.Map.zoom", "zoom reached the max level allowed: " + this.maxZoomLevelLimit) : this.setMapZoomLevel(b)
		}, 500),
		zoomIn: function () {
			a.isNull(this.curZmLvl) && (this.curZmLvl = this.getMapContext().getZoomLevel());
			var b = parseInt(this.curZmLvl);
			this.zoom_debounce(b + 1)
		},
		zoomOut: function () {
			a.isNull(this.curZmLvl) ? this.curZmLvl = this.getMapContext().getZoomLevel() : --this.curZmLvl;
			this.zoom_debounce(this.curZmLvl - 1)
		},
		setZoomLevelRange: function (b, c) {
			if (a.isNull(b))
				a.util.Logger.warning("", "OM.Map.setZoomLevelRange",
					"The required input parameter for min zoom level is not specified.");
			else {
				this.minZoomLevelLimit = Math.max(Math.round(b), 0);
				a.notNull(c) && (this.maxZoomLevelLimit = c, this.maxZoomLevelLimit < this.minZoomLevelLimit && (this.maxZoomLevelLimit = null, a.util.Logger.warning("", "OM.Map.setZoomLevelRange", "The max zoom level is ignored. It must be larger than the min zoom level.")));
				var p = this.getMapZoomLevel();
				this.minZoomLevelLimit && p < this.minZoomLevelLimit ? this.zoom_debounce(this.minZoomLevelLimit) : this.maxZoomLevelLimit &&
				p > this.maxZoomLevelLimit && this.zoom_debounce(this.maxZoomLevelLimit)
			}
		},
		setMapDataBounds: function (b) {
			if (!a.isNull(b)) {
				this.mapBoundsLimit = b;
				b = this.getMapCenter();
				var c,
				p;
				if (a.notNull(b)) {
					var l = this.mapBoundsLimit.clone(),
					l = l.transform(b.getSRID());
					b.getX() < l.getMinX() ? (c = l.getMinX(), p = b.getY()) : b.getX() > l.getMaxX() && (c = l.getMaxX(), p = b.getY());
					b.getY() < l.getMinY() ? (c = b.getX(), p = l.getMinY()) : b.getY() > l.getMaxY() && (c = b.getX(), p = l.getMaxY())
				}
				a.notNull(c) && a.notNull(p) && this.setMapCenter(new a.geometry.Point(c,
						p, b.getSRID()))
			}
		},
		pan: function (b, c, p) {
			if (0 !== b || 0 !== c) {
				var l = b,
				Q = c,
				A = 0,
				B = this.getMapContextToken(),
				G = B.universe,
				Y = B.zoomLevel,
				W = G.zoomLevels[Y].resolution,
				Y = G.zoomLevels[Y].stretchRatio,
				K = b * W,
				q = c * W * Y,
				t = G.bound.getMinX(),
				I = G.bound.getMaxX(),
				A = G.bound.getMinY(),
				aa = G.bound.getMaxY(),
				ba,
				R,
				qa,
				ua;
				a.notNull(this.mapBoundsLimit) && (this.mapBoundsLimit.getSRID() !== G.getSRID() && (this.mapBoundsLimit = this.mapBoundsLimit.transform(G.getSRID())), ba = this.mapBoundsLimit.getMinX(), R = this.mapBoundsLimit.getMaxX(), qa =
						this.mapBoundsLimit.getMinY(), ua = this.mapBoundsLimit.getMaxY(), t = Math.max(t, ba), I = Math.min(I, R), A = Math.max(A, qa), aa = Math.min(aa, ua));
				ba = B.centerPoint.clone();
				R = new a.geometry.Point(B.centerPoint.getX() - K, B.centerPoint.getY() + q, G.srid);
				var Ca;
				this.wraparound && (Ca = new a.geometry.Point(B.roundMapCenterPoint.getX() - K, B.roundMapCenterPoint.getY() + q, G.srid));
				ua = B.deviceWindow;
				qa = ua.w * W;
				var pa = ua.h * W * Y;
				ua = B.universe.getMapBounds().getWidth();
				if (this.wraparound) {
					if (R.getY() < A || R.getY() > aa)
						return
				} else if (R.getX() <
					t || R.getX() > I || R.getY() < A || R.getY() > aa)
					return;
				if (R.getX() + qa / 2 < I && R.getY() + pa / 2 < aa && R.getX() - qa / 2 > t && R.getY() - pa / 2 > A || this.wraparound) {
					if (this.wraparound) {
						if (R.getY() > ua / 6 || R.getY() < -ua / 6)
							if (R.getY() < A + pa / 2 || R.getY() > aa - pa / 2)
								return;
						R = B.centerPoint.getX() > ua / 2 ? new a.geometry.Point(B.centerPoint.getX() - K - ua, B.centerPoint.getY() + q, G.srid) : B.centerPoint.getX() < -ua / 2 ? new a.geometry.Point(B.centerPoint.getX() - K + ua, B.centerPoint.getY() + q, G.srid) : new a.geometry.Point(B.centerPoint.getX() - K, B.centerPoint.getY() +
								q, G.srid);
						B.roundMapCenterPoint = Ca
					}
					B.centerPoint = R;
					B.homeCenter = R.clone();
					l = this.getMapContext().getWholeMapNum();
					Q = this.getMapContext().getBaseWholeMapIndex();
					this.mapBBox = [];
					for (B = 0; B < l; B++)
						this.mapBBox[B] = {
							minX: (B - Q) * ua - ua / 2,
							maxX: (B - Q) * ua + ua / 2
						}
				} else
					Ca = R.getX(), G = R.getY(), 0 > c && R.getY() - pa / 2 < A ? (A = (ba.getY() - pa / 2 - A) / (W * Y), c = 0 < A ? -1 * Math.min(A, Math.abs(Q)) : 0, G = ba.getY() + c * W * Y) : 0 < c && R.getY() + pa / 2 > aa && (A = (aa - (ba.getY() + pa / 2)) / (W * Y), c = 0 < A ? Math.min(A, Q) : 0, G = ba.getY() + c * W * Y), 0 < b && R.getX() - qa / 2 < t ? this.wraparound ?
					(A = (t + qa / 2 - ba.getX()) / W * -1, Math.abs(A) < Math.abs(l) && (b = A, Ca = ba.getX() + b * W)) : (A = (ba.getX() - qa / 2 - t) / W, b = 0 < A ? Math.min(A, b) : 0, Ca = ba.getX() + -1 * b * W) : 0 > b && R.getX() + qa / 2 > I && (this.wraparound ? (A = (ba.getX() - (I - qa / 2)) / W, Math.abs(A) < Math.abs(l) && (b = A, Ca = ba.getX() + b * W)) : (A = (I - (ba.getX() + qa / 2)) / W, b = 0 < A ? -1 * Math.min(A, Math.abs(b)) : 0, Ca = ba.getX() + -1 * b * W)), B.centerPoint.setPoint(Ca, G), B.homeCenter.setPoint(Ca, G);
				0 === b && 0 === c || !this.initialized || (l = new a.event.MapEvent(a.event.MapEvent.I_MAP_DRAGGING, this), l.xOffset =
						b, l.yOffset = c, l.preCenter = ba, this.doSmoothPan(l, p))
			}
		},
		doSmoothPan: function (b, c) {
			var p = b.xOffset,
			l = b.yOffset,
			Q = this,
			A = this.graphics,
			B = null,
			G = 0,
			Y = 0,
			W = 0,
			K = function () {
				Q.graphics && (Math.abs(p) > q ? (b.xOffset = Math.abs(p) / p * q, p -= Math.abs(p) / p * q) : (b.xOffset = p, p = 0), Math.abs(l) > q ? (b.yOffset = Math.abs(l) / l * q, l -= Math.abs(l) / l * q) : (b.yOffset = l, l = 0), B = A.getLeftTop(Q.draggableGroup), A.setLeftTop(Q.draggableGroup, B.x + b.xOffset, B.y + b.yOffset), Q.fire(b.type, b), W++, W < Y ? setTimeout(K, 20) : Q.moveflag || (b = new a.event.MapEvent(a.event.MapEvent.MAP_RECENTERED,
								Q), Q.fire(b.type, b)))
			},
			q = Math.floor(a.MapContext(this).getDeviceWidth() / 10);
			!c || Math.abs(p) < q && Math.abs(l) < q ? (B = A.getLeftTop(Q.draggableGroup), Q.divLayers && 0 < Q.divLayers.length ? b.callback = function (a) {
				a ? (a = Q.getMapContextToken()) && b.preCenter && (a.centerPoint = b.preCenter, a.homeCenter = b.preCenter.clone()) : A.setLeftTop(Q.draggableGroup, B.x + p, B.y + l)
			}
				 : A.setLeftTop(Q.draggableGroup, B.x + p, B.y + l), Q.fire(b.type, b), Q.moveflag || (b = new a.event.MapEvent(a.event.MapEvent.MAP_RECENTERED, Q), Q.fire(b.type, b))) : (G =
					Math.abs(p) > Math.abs(l) ? p : l, Y = Math.abs(G / q), setTimeout(K, 20))
		},
		checkZoomLevel: function (b) {
			var c = this.getMapContextToken().universe;
			if (c && c.getZoomLevelNumber)
				if (a.notNull(b)) {
					var p = c.getZoomLevelNumber() - 1;
					b > p && (b = p);
					0 > b && (b = 0)
				} else
					b = 0;
			c.srid === a.util.BaiduUtil.SRID && (b = a.util.BaiduUtil.getValidZoomLevel(b));
			return b
		},
		getPreviousZoomLevel: function () {
			return this.previousZoomLevel
		},
		getPreviousCenterPoint: function () {
			return this.previousCenterPoint
		},
		setPreviousZoomLevel: function (a) {
			this.previousZoomLevel =
				a
		},
		setPreviousCenterPoint: function (a) {
			this.previousCenterPoint = a
		},
		setMapCenterAndZoomLevel: function (b, c, p) {
			this.zoomComplete = p = !1;
			if (a.notNull(c) && a.notNull(this.minZoomLevelLimit) && c < this.minZoomLevelLimit)
				c = this.minZoomLevelLimit;
			else if (a.notNull(c) && a.notNull(this.maxZoomLevelLimit) && c > this.maxZoomLevelLimit)
				c = this.maxZoomLevelLimit;
			else {
				a.notNull(c) && this.divLayers && 1 === this.divLayers.length && "google" === this.divLayers[0].tileSource && this.divLayers[0].mapType === a.layer.GoogleTileLayer.TYPE_SHADED &&
				15 <= c && (c = 14);
				this.divLayers && 1 === this.divLayers.length && !0 === this.divLayers[0].isBaiduMap && a.notNull(c) && !1 === a.util.BaiduUtil.isZoomLevelValid(c) && (c = a.util.BaiduUtil.getValidZoomLevel(c));
				if (!c && this.wraparound || !c && this.over)
					c = 0;
				var l = this,
				Q = this.getMapContextToken(),
				A = this.getMapCenter(),
				B = this.getMapZoomLevel();
				this.setPreviousZoomLevel(B);
				this.setPreviousCenterPoint(A);
				!this.initialized || a.isNull(b) || Q.centerPoint.srid === b.srid ? (Q = b, a.isNull(b) && (Q = A), this.do_setMapCenterAndZoomLevel(Q, c, p)) :
				b.srid !== a.util.BaiduUtil.SRID && Q.centerPoint.srid !== a.util.BaiduUtil.SRID ? b.transform(Q.universe.srid, function (a) {
					l.do_setMapCenterAndZoomLevel(a, c, p)
				}) : b.transform(Q.universe.srid, function (a) {
					l.do_setMapCenterAndZoomLevel(a, c, p)
				}, null, null, {
					map: l,
					inputIsBD09LonLat: !0
				});
				setTimeout(function () {
					if (l.wraparound)
						for (var b = 0; b < l.divLayers.length; b++)
							l.divLayers[b].mapType !== a.layer.BingTileLayer.TYPE_ROAD && l.divLayers[b].mapType !== a.layer.BingTileLayer.TYPE_AERIAL || l.redrawMap()
				}, 100)
			}
		},
		do_setMapCenterAndZoomLevel: function (b,
			c, p) {
			var l = null,
			l = null,
			Q = this.getMapContextToken(),
			A;
			this.on(a.event.MapEvent.MAP_AFTER_ZOOM, function () {
				this.wraparound && this.pan(0, 0);
				var a = Q.universe.getMapBounds().getWidth(),
				b = this.getMapContext().getWholeMapNum(),
				c = this.getMapContext().getBaseWholeMapIndex();
				this.mapBBox = [];
				for (var x = 0; x < b; x++)
					this.mapBBox[x] = {
						minX: (x - c) * a - a / 2,
						maxX: (x - c) * a + a / 2
					};
				this.zoomComplete = !0;
				this.resetTag = !1
			}, this);
			if (this.initialized) {
				if (!a.notNull(c) || !1 !== this.zoomEnabled)
					if (a.notNull(c) && this.checkZoomLevel(c) !== Q.zoomLevel ||
						!0 === this.resetTag) {
						this.grid && (this.grid.clear(), p = this.getLabelGridBox(c), this.grid.setBox(p));
						A = new a.event.MapEvent(a.event.MapEvent.I_MAP_CENTER_ZOOM, this);
						l = Q.zoomLevel;
						Q.transform = null;
						Q.zoomLevel = this.checkZoomLevel(c);
						A.beforeZoomLevel = l;
						A.afterZoomLevel = Q.zoomLevel;
						p = new a.event.MapEvent(a.event.MapEvent.MAP_BEFORE_ZOOM, this);
						p.beforeZoomLevel = l;
						p.afterZoomLevel = Q.zoomLevel;
						this.fire(p.type, p);
						A.preMapCenter = Q.centerPoint.clone();
						b && b != Q.homeCenter && (Q.centerPoint = b, Q.homeCenter = Q.centerPoint.clone(),
							this.wraparound && (Q.roundMapCenterPoint = b));
						this.checkCenter();
						for (c = 0; c < this.svgLayers.length; c++)
							this.svgLayers[c].loaded = !1, this.svgLayers[c].clearFeatureShapes();
						0 < this.divLayers.length && (this.graphics.setVisible(this.draggableGroup, !1), this.$heatMapDiv.css({
								visibility: "hidden"
							}));
						for (c = 0; c < this.divLayers.length; c++)
							this.divLayers[c].loaded = !1;
						this.graphics && this.graphics.clearToolTips();
						a.isNull(this.graphics) || (this.graphics.setLeftTop(this.draggableGroup, 0, 0), this.getMapContext().getTransform(),
							this.fire(A.type, A), p = new a.event.MapEvent(a.event.MapEvent.MAP_AFTER_ZOOM, this), p.beforeZoomLevel = l, p.afterZoomLevel = Q.zoomLevel, this.fire(p.type, p), 0 < this.divLayers.length && (this.graphics.setVisible(this.draggableGroup, !0), this.$heatMapDiv.css({
									visibility: "visible"
								})))
					} else {
						if (this.divLayers && 0 < this.divLayers.length)
							for (c = 0; c < this.divLayers.length; c += 1)
								if (A = this.divLayers[c], a.isNull(A) || A.layerType !== a.LayerTypes.EXTERNAL && A.isVisible() && a.isNull(A.jqLayerDiv))
									return;
						if (b) {
							l = Q.centerPoint.clone();
							Q.centerPoint = b;
							Q.homeCenter = Q.centerPoint.clone();
							this.wraparound && (Q.roundMapCenterPoint = b);
							b = this.checkCenter(Q.centerPoint);
							A = Q.centerPoint;
							c = Math.round((l.getX() - A.getX()) / Q.universe.zoomLevels[Q.zoomLevel].resolution);
							var B = Math.round((A.getY() - l.getY()) / Q.universe.zoomLevels[Q.zoomLevel].resolution * Q.universe.zoomLevels[Q.zoomLevel].stretchRatio);
							if (0 === c && 0 === B) {
								p = new a.event.MapEvent(a.event.MapEvent.MAP_RESTRICT_CENTER, this);
								this.fire(p.type, p);
								this.zoomComplete = !0;
								return
							}
							Math.abs(c) > Q.deviceWindow.w ||
							Math.abs(B) > Q.deviceWindow.h ? (this.graphics.setLeftTop(this.draggableGroup, 0, 0), Q.transform = null, A = new a.event.MapEvent(a.event.MapEvent.MAP_BEFORE_REFRESH, this), A.preMapCenter = l, A.restrictCenter = b, A.bigPan = !0, this.fire(A.type, A)) : (A = new a.event.MapEvent(a.event.MapEvent.I_MAP_DRAGGING, this), A.xOffset = Math.round(c), A.yOffset = Math.round(B), A.preCenter = l, A.restrictCenter = b, this.doSmoothPan(A, p))
						} else
							for (p = 0; p < this.divLayers.length; p++)
								this.divLayers[p].zoomControl && this.divLayers[p].zoomControl.reset &&
								this.divLayers[p].zoomControl.endScaling && (this.divLayers[p].zoomControl.reset(), this.divLayers[p].zoomControl.endScaling());
						this.zoomComplete = !0
					}
			} else
				this.zoomComplete = !0, b && (Q.centerPoint = b, Q.homeCenter = Q.centerPoint.clone(), this.wraparound && (Q.roundMapCenterPoint = b)), a.notNull(c) && (Q.zoomLevel = this.checkZoomLevel(c))
		},
		isElocationServer: function (a) {
			return (0 <= a.indexOf("//elocation.oracle.com") || 0 <= a.indexOf("//maps.oracle.com") || 0 <= a.indexOf("//elocation-stage.oracle.com") || 0 <= a.indexOf("//elocation-dr.oracle.com")) &&
			0 < a.indexOf("/mapviewer/mcserver") ? !0 : !1
		},
		forceBuiltinCopyright: function (a, b) {
			if (a && a.dataSource && a.tileLayer && a.serverURL) {
				var c = a.dataSource.toUpperCase(),
				l = a.tileLayer.toUpperCase(),
				Q = a.serverURL.toLowerCase();
				if (this.isElocationServer(Q)) {
					if ("ELOCATION_MERCATOR" !== c)
						return null;
					"WORLD_MAP" === l || "BI_WORLD_MAP" === l || "BI_WORLD_MAP_LIGHT" === l ? a.addListener(b.LayerEvent.FINISH_GOT_CONFIG, this.listenerElocationCopyright) : 0 === l.indexOf("OSM") ? a.addListener(b.LayerEvent.FINISH_GOT_CONFIG, this.listenerOSMCopyright) :
					a.addListener(b.LayerEvent.FINISH_GOT_CONFIG, this.listenerElocationCopyright)
				}
			}
		},
		addLayer: function (b, c, p) {
			var l = this;
			b.parentMap = this;
			if (l.inited && !l.initialized)
				setTimeout(function () {
					l.addLayer(b, c)
				}, 50);
			else if (this.getLayerByName(b.name))
				a.util.Logger.warning("MAPVIEWER_9102", "OM.Map.addLayer");
			else {
				a.isNull(c) && (c = "undefined");
				this.typeArray.push(c);
				b.customType = c;
				a.isNull(this.nameArray[c]) && (this.nameArray[c] = []);
				this.nameArray[c].push(b.name);
				var Q = a.event;
				this.on(Q.MapEvent.I_MAP_DRAGGING,
					b.panEvent, b);
				this.on(Q.MapEvent.MAP_RECENTERED, b.recenter, b);
				this.on(Q.MapEvent.I_MAP_CENTER_ZOOM, b.setCenterAndZoomlevel, b);
				this.on(Q.MapEvent.MAP_BEFORE_REFRESH, b.refreshEvent, b);
				this.on(Q.MapEvent.MAP_REDRAW, b.redraw, b);
				this.on(Q.MapEvent.MAP_DESTROY, b.destroy, b);
				if (b instanceof a.layer.VectorLayer && b.useRTree)
					this.on(Q.MapEvent.MAP_BEFORE_ZOOM, b.beforeZoom, b);
				b.addListener(Q.LayerEvent.FINISH_GOT_CONFIG, l.newLayerConfigLoaded);
				b.addListener(Q.LayerEvent.FINISH_LOAD, l.layerFinish);
				b.addListener(Q.LayerEvent.FEATURES_LOADED,
					l.layerFeaturesLoaded);
				b.addListener(Q.LayerEvent.FEATURES_DISPLAYED, l.layerDisplayed);
				b.addListener(Q.LayerEvent.FINISH_LOAD, l.layerLoaded);
				b.addListener(Q.LayerEvent.ALL_TILES_LOADED, l.layerDisplayed);
				b.addListener(Q.LayerEvent.INIT_ERROR, l.layerErr);
				b.addListener(Q.LayerEvent.RENDERING_STYLE_CHANGED, l.layerStyleChanged);
				b.addListener(Q.LayerEvent.NSDP_MAPPED, l.nsdpMapped);
				this.forceBuiltinCopyright(b, Q);
				a.isNull(b.serverURL) && (b.serverURL = this.mapviewerURL);
				if ("invalid url" === b.serverURL)
					a.util.Logger.alert("MAPVIEWER_9020",
						"OM.Map.addLayer", "");
				else {
					a.Map.isTileLayer(b.layerType) ? (b.layerType === a.LayerTypes.EXTERNAL && (this.hasExternal = !0), -1 === this.universeLayerIndex && (this.universeLayerIndex = this.divLayers.length), !a.isNull(p) && p < this.divLayers.length ? this.divLayers.splice(p, 0, b) : (this.divLayers.push(b), this.updateUTFGridLayerListener())) : (b.initGroup(), b.isBoundingTheme() && !this.initialized ? this.boundingLayerName = b.name : b.isBoundingTheme() && (this.boundingThemeLoading = this.boundingThemeLoaded = !1, this.boundingLayerName =
									b.name), b.getEnableInfoWindow() && b.addListener(this.vectorlayerInfoWindowMouseEType, b.insertFeatureInfo), this.svgLayers.push(b));
					this.initialized && (b.layerType == a.LayerTypes.EXTERNAL && (b.loaded = !0), b.layerType == a.LayerTypes.EXTERNAL && b.setContainer(this.$tileLayersDiv[0]), l.grid && l.grid.clear(), b.getLayerConfig(), this.overview && (this.changeOverView(), this.overview.overFeatureLayer && this.overview.overFeatureLayer.bringToTop()));
					p = null;
					p = a.Map.isTileLayer(b.layerType) ? this.divLayers.length : this.svgLayers.length +
						this.divLayers.length - 2;
					Q = new Q.MapEvent(Q.MapEvent.LAYER_ADDED, l);
					Q.affectedLayer = b;
					this.fire(Q.type, Q);
					for (Q = 0; Q < this.decorationArray.length; Q++) {
						var A = this.decorationArray[Q];
						"LayerControl" == A.type && (A.left = parseInt(A.$DecorationDiv.css("left")), A.top = parseInt(A.$DecorationDiv.css("top")), A.width = A.currentWidth, this.removeMapDecoration(A), this.addMapDecoration(A))
					}
					b.keyDown = function (c) {
						17 != c.keyCode && 91 != c.keyCode && 93 != c.keyCode || !b.selectionEnable || b.multiSelect || (b.backup_selectionMode = b.selectionMode,
							b.multiSelect = !0, b.enableFeatureSelection(!0, a.layer.VectorLayer.MULTIPLE_SELECTION));
						l.ctrl_cmd_key_down = !0
					};
					b.keyUp = function (a) {
						17 != a.keyCode && 91 != a.keyCode && 93 != a.keyCode || !b.selectionEnable || (b.multiSelect = !1, b.selectionMode = b.backup_selectionMode, b.enableFeatureSelection(!0, b.backup_selectionMode));
						l.ctrl_cmd_key_down = !1
					};
					this.$oracleMapDiv.on("keydown", b.keyDown);
					this.$oracleMapDiv.on("keyup", b.keyUp);
					this.resetTileLayerZIndex();
					return p
				}
			}
		},
		resetTileLayerZIndex: function () {
			var b;
			for (b = 0; b < this.divLayers.length; b++) {
				var c;
				this.divLayers[b].zIndex = b;
				c = this.divLayers[b].container;
				a.isNull(c) ? (c = this.divLayers[b].jqLayerDiv, a.isNull(c) || (c = c[0].style, a.isNull(c) || (c.zIndex = b))) : (c = c.style, a.isNull(c) || (c.zIndex = b))
			}
		},
		removeAllFeatureLayers: function () {
			for (var a = this.svgLayers, b = a.length - 1; 0 <= b; b--) {
				var c = a[b].name;
				"ii_oracle_maps_internal_editing" != c && "ii_oracle_maps_internal_others" != c && this.removeLayer(a[b])
			}
		},
		removeLayer: function (b) {
			var c,
			p,
			l;
			if (b) {
				var Q = b.parentMap;
				p = new a.event.MapEvent(a.event.MapEvent.LAYER_DELETED,
						Q);
				p.affectedLayer = b;
				b === this.overviewLayer && (this.userSetOL = !1);
				c = 0;
				for (l = this.svgLayers.length; c < l; c++)
					if (this.svgLayers[c] === b) {
						Q && Q.boundingLayerName && Q.boundingLayerName === b.name && (Q.boundingLayerName = null, Q.boundingThemeLoaded = !1, Q.boundingThemeLoading = !1);
						this.deleteLayerListener(b);
						Q = -1;
						for (l = 0; l < this.nameArray[this.svgLayers[c].customType].length; l++)
							this.nameArray[this.svgLayers[c].customType][l] === this.svgLayers[c].name && (Q = l);
						-1 < Q && this.nameArray[this.svgLayers[c].customType].splice(Q,
							1);
						this.svgLayers.splice(c, 1);
						this.fire(p.type, p);
						this.refreshVectorLayerLabels();
						for (c = 0; c < this.decorationArray.length; c++)
							p = this.decorationArray[c], "LayerControl" === p.type && (p.left = parseInt(p.$DecorationDiv.css("left")), p.top = parseInt(p.$DecorationDiv.css("top")), p.width = p.currentWidth, this.removeMapDecoration(p), this.addMapDecoration(p));
						this.$oracleMapDiv.off("keydown", b.keyDown);
						this.$oracleMapDiv.off("keyup", b.keyUp);
						return b
					}
				c = 0;
				for (l = this.divLayers.length; c < l; c++)
					if (this.divLayers[c] === b) {
						this.deleteLayerListener(b);
						this.divLayers.splice(c, 1);
						this.fire(p.type, p);
						for (l = 0; l < this.decorationArray.length; l++)
							p = this.decorationArray[l], "LayerControl" === p.type && (this.removeMapDecoration(p), this.addMapDecoration(p));
						for (l = 0; l < this.typeArray.length; l++)
							if (c = this.typeArray[l], this.nameArray[c][l] === b.name) {
								this.nameArray[c].splice(l, 1);
								this.typeArray.splice(l, 1);
								break
							}
						return b
					}
				c = 0;
				for (l = this.divLayers.length; c < l; c++)
					if (this.divLayers[c].layerType === a.LayerTypes.EXTERNAL) {
						this.hasExternal = !0;
						break
					} else
						this.hasExternal =
							!1;
				for (c = 0; c < this.decorationArray.length; c++)
					p = this.decorationArray[c], "LayerControl" === p.type && (this.removeMapDecoration(p), this.addMapDecoration(p))
			}
			this.resetTileLayerZIndex();
			this.updateUTFGridLayerListener()
		},
		deleteLayerListener: function (b) {
			if (b) {
				this.deleteListener(a.event.MapEvent.I_MAP_DRAGGING, b.panEvent, b);
				this.deleteListener(a.event.MapEvent.MAP_RECENTERED, b.recenter, b);
				this.deleteListener(a.event.MapEvent.I_MAP_CENTER_ZOOM, b.setCenterAndZoomlevel, b);
				this.deleteListener(a.event.MapEvent.MAP_BEFORE_REFRESH,
					b.refreshEvent, b);
				this.deleteListener(a.event.MapEvent.MAP_REDRAW, b.redraw, b);
				this.deleteListener(a.event.MapEvent.MAP_DESTROY, b.destroy, b);
				b instanceof a.layer.VectorLayer && b.useRTree && this.deleteListener(a.event.MapEvent.MAP_BEFORE_ZOOM, b.beforeZoom, b);
				var c = a.event.LayerEvent,
				p = a.event.MouseEvent;
				b.deleteListener(c.FINISH_GOT_CONFIG, this.newLayerConfigLoaded);
				b.deleteListener(c.FINISH_LOAD, this.layerFinish);
				b.deleteListener(c.FINISH_LOAD, this.layerLoaded);
				b.deleteListener(c.FEATURES_LOADED, this.layerFeaturesLoaded);
				b.deleteListener(c.FEATURES_DISPLAYED, this.layerDisplayed);
				b.deleteListener(c.ALL_TILES_LOADED, this.layerDisplayed);
				b.deleteListener(c.INIT_ERROR, this.layerErr);
				b.deleteListener(c.RENDERING_STYLE_CHANGED, this.layerStyleChanged);
				b.deleteListener(c.NSDP_MAPPED, this.nsdpMapped);
				b.deleteListener(a.event.MouseEvent.MOUSE_CLICK, b.updateActiveSelection);
				this.graphics.detachEventListener(p.MOUSE_OVER, b.mouseEventListener, b.group);
				this.graphics.detachEventListener(p.MOUSE_OUT, b.mouseEventListener, b.group);
				a.browser.touchSupported && (this.graphics.detachEventListener(p.TOUCH_TAP, b.mouseEventListener, b.group), this.graphics.detachEventListener(p.TOUCH_LONG_PRESS, b.mouseEventListener, b.group), this.graphics.detachEventListener(p.TOUCH_END, b.mouseEventListener, b.group), this.graphics.detachEventListener(p.TOUCH_START, b.touchStart, b.group));
				this.graphics.detachEventListener(p.MOUSE_CLICK, b.mouseEventListener, b.group);
				this.graphics.detachEventListener(p.MOUSE_RIGHT_CLICK, b.mouseEventListener, b.group);
				this.graphics.detachEventListener(p.MOUSE_UP,
					b.mouseEventListener, b.group);
				this.graphics.detachEventListener(p.MOUSE_DOWN, b.mouseEventListener, b.group);
				this.graphics.detachEventListener(p.MOUSE_DOWN, b.graphicsDown, b.group);
				this.graphics.detachEventListener(p.MOUSE_MOVE, b.mouseEventListener, b.group);
				b.clearLayer && b.clearLayer();
				b.destroy && b.destroy();
				c = new a.event.MapEvent(a.event.MapEvent.LAYER_DELETED, this);
				c.affectedLayer = b;
				this.fire(a.event.MapEvent.LAYER_DELETED, c)
			}
		},
		addToolBar: function (b) {
			a.notNull(b) && (b.map = this, a.$("#div_" + b.innerID).attr("id") !==
				c ? a.util.Logger.warning("MAPVIEWER-9048", "OM.Map.addToolBar", "Toolbar ID is already used, please pick a new ID.") : (this.addMapDecoration(b.toolBarDecoration), b.positionPending && b.setPosition(), b.initBuiltInTools(), b.initCustomBts(), this.on(a.event.MapEvent.MAP_CLEAN, b.clearTools, this)))
		},
		addMagnifier: function (b) {
			a.notNull(b) && (this.addMapDecoration(b), b.map = this)
		},
		removeToolbar: function (a) {
			this.removeMapDecoration(a.toolBarDecoration);
			a.destroy();
			a.map = null
		},
		addNavigationPanelBar: function () {
			var b =
				new a.control.NavigationPanelBar;
			this.addMapDecoration(b)
		},
		addScaleBar: function () {
			var b = new a.control.ScaleBar;
			this.addMapDecoration(b)
		},
		addScaleBarValue: function (b, c) {
			this.ScaleBar || this.addMapDecoration(c);
			c.$DecorationDiv.css({
				display: "none"
			});
			a.$(b).html(c.getTopScaleValue() + "\x3cbr\x3e" + c.getBottomScaleValue());
			this.on(a.event.MapEvent.MAP_AFTER_REFRESH, function () {
				a.$(b).html(c.getTopScaleValue() + "\x3cbr\x3e" + c.getBottomScaleValue())
			})
		},
		addScaleBarUnit: function (b, c) {
			this.ScaleBar || this.addMapDecoration(c);
			c.$DecorationDiv.css({
				display: "none"
			});
			a.$(b).html(c.getTopScaleUnit() + "\x3cbr\x3e" + c.getBottomScaleUnit());
			this.on(a.event.MapEvent.MAP_AFTER_REFRESH, function () {
				a.$(b).html(c.getTopScaleUnit() + "\x3cbr\x3e" + c.getBottomScaleUnit())
			})
		},
		addScaleBarDiv: function (b, c) {
			this.ScaleBar || this.addMapDecoration(c);
			c.$DecorationDiv.css({
				display: "none"
			});
			c.getBottomScaleBar() ? a.$(b).html(c.getTopScaleBar().prop("outerHTML") + c.getBottomScaleBar().prop("outerHTML")) : a.$(b).html(c.getTopScaleBar().prop("outerHTML"));
			this.on(a.event.MapEvent.MAP_AFTER_REFRESH, function () {
				c.getBottomScaleBar() ? a.$(b).html(c.getTopScaleBar().prop("outerHTML") + c.getBottomScaleBar().prop("outerHTML")) : a.$(b).html(c.getTopScaleBar().prop("outerHTML"))
			})
		},
		addMapDecoration: function (b, c) {
			c ? (this._decoration[b.type] = c, b.collapsible = !1, b.draggable = !1) : this._decoration[b.type] = null;
			if (this.graphics && a.notNull(b)) {
				this.decorationArray = this.decorationArray || [];
				for (var p = 0; p < this.decorationArray.length; p++)
					if (b.id === this.decorationArray[p].id ||
						b.mapType === this.decorationArray[p].mapType && "mapTypeControl" == b.mapType)
						return;
				this.decorationArray.push(b);
				b.map = this;
				this.initialized || "ToolBar" == b.type ? b.display() : ("CopyRight" === b.type && (this.copyRight = b), this.on(a.event.MapEvent.MAP_INITIALIZED, b.display, b), this.on(a.event.MapEvent.MAP_RESET_UNIVERSE, b.display, b));
				this.on(a.event.MapEvent.MAP_DESTROY, b.remove, b);
				this.on(a.event.MapEvent.MAP_CLEAN, b.clean, b)
			}
		},
		removeMapDecoration: function (b) {
			if (this.decorationArray && 0 !== this.decorationArray.length &&
				b)
				for (var c = 0; c < this.decorationArray.length; c++)
					if (this.decorationArray[c].id === b.id) {
						this.decorationArray.splice(c, 1);
						this.deleteListener(a.event.MapEvent.MAP_CLEAN, b._cleanMapDecoration);
						this.deleteListener(a.event.MapEvent.MAP_DESTROY, b._removeMapDecoration);
						this.deleteListener(a.event.MapEvent.MAP_INITIALIZED, b.display);
						this.deleteListener(a.event.MapEvent.MAP_RESET_UNIVERSE, b.display);
						b.remove();
						break
					}
		},
		showOverviewMap: function () {
			this.setOverviewMapOptions({
				display: !0
			})
		},
		hideOverviewMap: function () {
			this.setOverviewMapOptions({
				display: !1
			})
		},
		setOverviewMapOptions: function (a) {
			a && a.overviewLayer && (-1 == this.getLayerCurrentIndex(a.overviewLayer) ? a.overviewLayer = null : this.userSetOL = !0);
			this.overview && this.overview.setOverviewMapOptions(a)
		},
		getCursorLocation: function () {
			return this.getScreenPointLocation(this.mLocX, this.mLocY)
		},
		getAbsoluteCursorLocation: function () {
			return this.getScreenPointLocation(this.mLocX, this.mLocY, !0)
		},
		getACL: function (b, c) {
			var p = this.getMapContext(),
			l = p.getBaseWholeMapIndex(),
			p = p.getUniverse().getMapBounds().getWidth(),
			l = b.getX() + (c - l) * p;
			return new a.geometry.Point(l, b.getY(), b.srid)
		},
		getScreenPointLocation: function (b, c, p) {
			var l = this.getMapContext().getBaseWholeMapIndex(),
			Q = l,
			A = a.MapContext(this),
			B = A.getUniverse(),
			G = A.getZoomLevel(),
			Y = A.getCenterPoint();
			b -= A.getDeviceWidth() / 2;
			c -= A.getDeviceHeight() / 2;
			var W = null;
			if (B && B.zoomLevels) {
				var G = this.checkZoomLevel(G),
				K = B.zoomLevels[G].resolution,
				W = B.zoomLevels[G].stretchRatio;
				b = Y.getX() + b * K;
				c = Y.getY() - c * K * W;
				return this.wraparound ? (A = A.getUniverse().getMapBounds().getWidth(),
					b < -A / 2 && (Q = l + Math.floor((b + A / 2) / A)), b > A / 2 && (Q = l + Math.ceil((b - A / 2) / A)), p || (b < -A / 2 && (b -= A * Math.floor((b + A / 2) / A)), b > A / 2 && (b -= A * Math.ceil((b - A / 2) / A))), p = new a.geometry.Point(b, c, B.srid), p.setPointIndex(Q), p) : isNaN(b) || isNaN(c) ? null : new a.geometry.Point(b, c, B.srid)
			}
			return null
		},
		getScreenLocation: function (b) {
			var c = a.MapContext(this),
			p = c.getUniverse();
			if (p && p.zoomLevels) {
				var l = this.checkZoomLevel(c.getZoomLevel()),
				Q = p.zoomLevels[l].resolution,
				p = p.zoomLevels[l].stretchRatio,
				l = c.getCenterPoint(),
				A = b.getX();
				b = b.getY();
				A = (A - l.getX()) / Q + c.getDeviceWidth() / 2;
				c = (l.getY() - b) / Q * p + c.getDeviceHeight() / 2;
				return {
					x: Math.round(A),
					y: Math.round(c)
				}
			}
		},
		getMapWindowBoundingBox: function () {
			var b = a.MapContext(this).getDeviceWindow(),
			c = this.getScreenPointLocation(0, 0),
			b = this.getScreenPointLocation(b.w, b.h);
			return a.isNull(c) ? null : new a.geometry.Rectangle(c.getX(), c.getY(), b.getX(), b.getY(), b.srid)
		},
		getMaxResolution: function () {},
		getMinResolution: function () {},
		setMaxResolution: function () {},
		setMinResolution: function () {},
		backToHomeMap: function () {
			var b =
				this.getMapContextToken();
			a.isNull(b.homeMapZoomlevel) && (b.homeMapZoomlevel = b.zoomLevel);
			b.homeMapCenter || (b.homeMapCenter = b.centerPoint);
			this.setMapCenterAndZoomLevel(b.homeMapCenter, b.homeMapZoomlevel, !0)
		},
		setLayerIndex: function (b, c) {
			var p = this.divLayers.length,
			l = this.svgLayers.length,
			Q = this.getLayerCurrentIndex(b);
			if (Q == c)
				return c;
			if (a.Map.isTileLayer(b.layerType)) {
				if (1 >= c)
					return this.sendToBottom(b);
				if (c >= p)
					return this.bringToTop(b);
				Q--;
				this.divLayers.splice(Q, 1);
				this.divLayers.splice(c - 1, 0, b);
				for (p = 0; p < this.divLayers.length; p++)
					a.$("#tilelayer_" + this.divLayers[p].name).css({
						"z-index": p
					})
			} else {
				if (c <= p + 1)
					return this.sendToBottom(b);
				if (c >= p + l - 2)
					return this.bringToTop(b);
				if (a.isNotNull(b.heatMap) && null !== b.getRenderingStyle() && b.getRenderingStyle()instanceof a.style.HeatMap)
					return c < Q ? this.sendToBottom(b) : this.bringToTop(b);
				l = c - p - 1;
				this.svgLayers.splice(Q - p - 1, 1);
				this.svgLayers.splice(l, 0, b);
				this.graphics.setDisplayIndex(b.group, l)
			}
			p = new a.event.MapEvent(a.event.MapEvent.LAYER_REORDERED, this);
			p.affectedLayer = b;
			this.fire(p.type, p);
			return c
		},
		getLayerCurrentIndex: function (b) {
			var c,
			p;
			if (a.Map.isTileLayer(b.layerType)) {
				p = this.divLayers.length;
				if (0 === p)
					return -1;
				for (c = 0; c < p; c++)
					if (this.divLayers[c] === b)
						return c + 1
			} else {
				p = this.svgLayers.length;
				if (0 === p)
					return -1;
				for (c = 0; c < p; c++)
					if (this.svgLayers[c] === b)
						return c + this.divLayers.length + 1
			}
			return -1
		},
		bringForward: function (b) {
			var c = this.getLayerCurrentIndex(b);
			if (!(0 > c)) {
				var p = null,
				l = new a.event.MapEvent(a.event.MapEvent.LAYER_REORDERED, this);
				l.affectedLayer =
					b;
				if (a.Map.isTileLayer(b.layerType)) {
					if (this.divLayers[this.divLayers.length - 1] === b)
						return this.fire(l.type, l), this.divLayers.length;
					p = this.divLayers[c];
					this.divLayers[c] = b;
					this.divLayers[c - 1] = p;
					for (b = 0; b < this.divLayers.length; b++)
						a.$("#tilelayer_" + this.divLayers[b].name).css({
							"z-index": b
						});
					this.fire(l.type, l);
					return c + 1
				}
				if (!(3 > this.svgLayers.length)) {
					if (this.svgLayers[this.svgLayers.length - 3] == b)
						return this.fire(l.type, l), this.svgLayers.length - 3 + this.divLayers.length;
					if (a.isNotNull(b.heatMap) && null !==
						b.getRenderingStyle() && b.getRenderingStyle()instanceof a.style.HeatMap)
						return this.bringToTop(b);
					p = this.svgLayers[c - this.divLayers.length];
					this.svgLayers[c - this.divLayers.length] = b;
					this.svgLayers[c - 1 - this.divLayers.length] = p;
					this.graphics.bringForward(b.group);
					this.fire(l.type, l);
					return c + 1
				}
			}
		},
		sendBackward: function (b) {
			var c = this.getLayerCurrentIndex(b);
			if (!(0 > c)) {
				var p = new a.event.MapEvent(a.event.MapEvent.LAYER_REORDERED, this);
				p.affectedLayer = b;
				var l = null;
				if (a.Map.isTileLayer(b.layerType)) {
					if (this.divLayers[0] ==
						b)
						return this.fire(p.type, p), 1;
					l = this.divLayers[c - 2];
					this.divLayers[c - 2] = b;
					this.divLayers[c - 1] = l;
					for (b = 0; b < this.divLayers.length; b++)
						a.$("#tilelayer_" + this.divLayers[b].name).css({
							"z-index": b
						})
				} else {
					if (this.svgLayers[0] == b)
						return this.fire(p.type, p), 1 + this.divLayers.length;
					if (a.isNotNull(b.heatMap) && null !== b.getRenderingStyle() && b.getRenderingStyle()instanceof a.style.HeatMap)
						return this.sendToBottom(b);
					l = this.svgLayers[c - this.divLayers.length - 2];
					this.svgLayers[c - 2 - this.divLayers.length] = b;
					this.svgLayers[c -
						1 - this.divLayers.length] = l;
					this.graphics.sendBackward(b.group)
				}
				this.fire(p.type, p);
				return c - 1
			}
		},
		bringToTop: function (b, c) {
			var p = this.getLayerCurrentIndex(b, c);
			if (!(0 > p)) {
				var l = new a.event.MapEvent(a.event.MapEvent.LAYER_REORDERED, this);
				l.affectedLayer = b;
				if (a.Map.isTileLayer(b.layerType)) {
					if (this.divLayers[this.divLayers.length - 1] == b)
						return this.fire(l.type, l), this.divLayers.length;
					this.divLayers.splice(p - 1, 1);
					this.divLayers.push(b);
					for (p = 0; p < this.divLayers.length; p++)
						a.$("#tilelayer_" + this.divLayers[p].name).css({
							"z-index": p
						});
					this.fire(l.type, l);
					return this.divLayers.length
				}
				var Q = this.divLayers.length;
				if (this.svgLayers[this.svgLayers.length - 2] == b)
					return c || this.fire(l.type, l), this.svgLayers.length - 2 + Q;
				c ? (this.svgLayers.splice(p - Q - 1, 1), this.svgLayers.push(b)) : (this.svgLayers.splice(p - Q - 1, 1), this.svgLayers.splice(this.svgLayers.length - 2, 0, b));
				if (b.group)
					return this.graphics.bringToTop(b.group), a.isNotNull(b.heatMap) && null !== b.getRenderingStyle() && b.getRenderingStyle()instanceof a.style.HeatMap && this.orderHeatmapAboveVectorLayer(!0),
					c ? this.svgLayers.length + Q : (this.graphics.bringToTop(this.getDefaultFeatureLayer().group), this.graphics.bringToTop(this.getToolFeatureLayer().group), this.fire(l.type, l), this.svgLayers.length + Q - 2)
			}
		},
		sendToBottom: function (b) {
			var c = this.getLayerCurrentIndex(b);
			if (!(0 > c)) {
				var p = new a.event.MapEvent(a.event.MapEvent.LAYER_REORDERED, this);
				p.affectedLayer = b;
				if (a.Map.isTileLayer(b.layerType)) {
					if (this.divLayers[0] === b)
						return this.fire(p.type, p), 1;
					this.divLayers.splice(c - 1, 1);
					this.divLayers.splice(0, 0, b);
					for (b =
							0; b < this.divLayers.length; b++)
						a.$("#tilelayer_" + this.divLayers[b].name).css({
							"z-index": b
						});
					this.fire(p.type, p);
					return 1
				}
				var l = this.divLayers.length;
				if (2 < this.svgLayers.length && this.svgLayers[0] == b)
					return this.fire(p.type, p), 1 + l;
				if (2 > this.svgLayers.length)
					return -1;
				this.svgLayers.splice(c - l - 1, 1);
				this.svgLayers.splice(0, 0, b);
				this.graphics.sendToBottom(b.group);
				a.isNotNull(b.heatMap) && null !== b.getRenderingStyle() && b.getRenderingStyle()instanceof a.style.HeatMap && b.getRenderingStyle().setIsTop(!1);
				this.fire(p.type,
					p);
				return 1 + l
			}
		},
		setInfoWindowStyle: function (a) {
			this.infoWindowOptions = a
		},
		displayInfoWindow: function (b, c, p) {
			var l = this;
			l.isCustomInfoWindow = p && p.builtInInfoWindow ? !1 : !0;
			l.infoWindowOptions && a.$.each(l.infoWindowOptions, function (a, b) {
				p[a] || (p[a] = b)
			});
			l.infoLayer || (l.infoLayer = new a.infowindow.InfoWindow(l, "1", p));
			if (!b || !c)
				return null;
			var Q = function () {
				var A = l.getMapContext().getUniverse();
				l.deleteListener(a.event.MapEvent.MAP_INITIALIZED, Q);
				(p ? p : {}).universe = A;
				var B = function (a) {
					a && (b = a);
					l.infoLayer.showInfoWindow(c,
						b, p)
				};
				A.srid != b.srid ? b.transform(A.srid, B) : B()
			};
			if (l.initialized)
				Q();
			else
				l.on(a.event.MapEvent.MAP_INITIALIZED, Q);
			setTimeout(function () {
				l.graphics && l.graphics.clearToolTips()
			}, 100)
		},
		printReset: function () {
			this.$oracleMapDiv[0].className = "";
			this.$printMapDiv && this.$printMapDiv.empty()
		},
		getLabelGridBox: function (a) {
			var b = this.getMapContext();
			a = b.getUniverse();
			var b = b.getZoomLevel(),
			b = a.getZoomLevels()[b],
			c = a.bound;
			a = c.getWidth() / b.resolution;
			b = c.getHeight() / b.resolution / b.stretchRatio;
			return {
				minX: 0,
				minY: 0,
				maxX: a,
				maxY: b
			}
		},
		refreshVectorLayerLabels: function () {
			if (this.svgLayers && !(0 >= this.svgLayers.length)) {
				var a = !1,
				b = this.svgLayers.length,
				c;
				for (c = 0; c < b; c++)
					if (this.svgLayers[c].labelsVisible()) {
						a = !0;
						break
					}
				if (a) {
					this.grid && this.grid.clear();
					for (c = 0; c < b; c++)
						a = this.svgLayers[c], a.labelsVisible() && a.clearAllLabels(), a.addMarkerBoundToGrid();
					for (c = b - 1; -1 < c; c--)
						a = this.svgLayers[c], a.isVisible() && a.labelsVisible() && a.addLabels()
				}
			}
		},
		getLayerByName: function (a) {
			for (var b = this.svgLayers.length; b--; )
				if (this.svgLayers[b].name ===
					a)
					return this.svgLayers[b];
			for (b = this.divLayers.length; b--; )
				if (this.divLayers[b].name === a)
					return this.divLayers[b]
		},
		getFeatureLayers: function () {
			return this.svgLayers
		},
		getTileLayers: function () {
			return this.divLayers
		},
		getDefaultFeatureLayer: function () {
			if (!a.gv.internalLayersEnabled)
				return {};
			a.notNull(this.defaultFeatureLayer) ? this.defaultFeatureLayer.bringToTop(!0) : (this.defaultFeatureLayer = new a.layer.VectorLayer("ii_oracle_maps_internal_editing", {
					def: {
						type: a.layer.VectorLayer.TYPE_LOCAL
					}
				}), this.defaultFeatureLayer.selectionEnable =
					!1, this.defaultFeatureLayer.setBringToTopOnMouseOver(!1), this.addLayer(this.defaultFeatureLayer));
			return this.defaultFeatureLayer
		},
		getToolFeatureLayer: function () {
			if (!a.gv.internalLayersEnabled)
				return {};
			a.notNull(this.toolFeatureLayer) ? (this.toolFeatureLayer.bringToTop(!0), this.defaultFeatureLayer && this.getDefaultFeatureLayer()) : (this.toolFeatureLayer = new a.layer.VectorLayer("ii_oracle_maps_internal_others", {
					def: {
						type: a.layer.VectorLayer.TYPE_LOCAL
					}
				}), this.toolFeatureLayer.selectionEnable = !1, this.toolFeatureLayer.setBringToTopOnMouseOver(!1),
				this.toolFeatureLayer.enableFeatureEditing(!0), this.addLayer(this.toolFeatureLayer), this.getDefaultFeatureLayer());
			return this.toolFeatureLayer
		},
		touchStart: function (b) {
			b.preventDefault();
			var c = a.util.DomUtil;
			this.touchCount = c.getTouchCount(b);
			if (!(2 < this.touchCount)) {
				this.pinchZoomScale = 1;
				var p = this.touchStartLocs;
				if (1 == this.touchCount) {
					c = c.getTouchesPosition(b);
					p.length = 0;
					p.push(c);
					this.touchStartLocs_backup.push({
						x: c.x,
						y: c.y
					});
					var c = this.lastTouchTimeStamp,
					l = b.timeStamp;
					this.lastTouchTimeStamp =
						l;
					500 > l - c && this.initialized ? (this.doubleTap = !0, b.preventDefault()) : this.doubleTap = !1;
					this.tStartLocsX = p[0].x;
					this.tStartLocsY = p[0].y
				} else
					2 == this.touchCount && (b = c.getChangedTouchesPosition(b), 1 == b.length ? p.push(b[0]) : 2 == b.length && (p.length = 0, p.push(b[0]), p.push(b[1])), this.doubleTap = !1);
				2 == p.length && (b = p[1].x - p[0].x, c = p[1].y - p[0].y, this.pinchZoomStartDist = Math.sqrt(b * b + c * c));
				this.moveflag = !0;
				b = this.$oracleMapDiv.offset();
				this.mLocX = p[0].x - b.left;
				this.mLocY = p[0].y - b.top
			}
		},
		touchMove: function (b) {
			b.preventDefault();
			if (0 !== this.touchStartLocs.length) {
				var c = a.util.DomUtil,
				p = this.$oracleMapDiv.offset();
				this.mLocX = this.touchStartLocs[0].x - p.left;
				this.mLocY = this.touchStartLocs[0].y - p.top;
				if (2 == this.touchCount || c.getTouchesPosition(b).length) {
					if (p = c.getTouchesScale(b), a.isNull(p) && (b = c.getTouchesPosition(b), p = b[0].x - b[1].x, b = b[0].y - b[1].y, p = Math.sqrt(p * p + b * b) / this.pinchZoomStartDist), this.pinchZoomScale = p, !(1 == p || 0 >= p || (b = this.getMapZoomLevel(), 1 < p && b >= this.maxZoom || 1 > p && 0 >= b)))
						for (this.pinchZooming = !0, this.graphics.setVisible(this.draggableGroup,
								!1), this.$heatMapDiv.css({
								visibility: "hidden"
							}), b = 0; b < this.divLayers.length; b++)
							this.divLayers[b].zoomControl && this.divLayers[b].zoomControl.scaleTiles(p)
				} else
					p = c.getTouchesPosition(b), b = p.x - this.touchStartLocs[0].x, c = p.y - this.touchStartLocs[0].y, this.touchStartLocs[0].x = p.x, this.touchStartLocs[0].y = p.y, this.moveflag && this.enableMapAction.drag && this.pan(b, c, !1)
			}
		},
		touchEnd: function (b) {
			if (!(b.isDefaultPrevented() || (b.preventDefault(), this.touchCount -= a.util.DomUtil.getTouchCount(b), 0 < this.touchCount))) {
				var c =
					this.pinchZoomScale;
				this.pinchZooming ? (b = this.getScaleZoomLevel(c), this.setMapZoomLevel(b), this.pinchZoomScale = 1, this.pinchZooming = !1, this.graphics.setVisible(this.draggableGroup, !0), this.$heatMapDiv.css({
						visibility: "visible"
					}), this.doubleTap = !1) : (this.doubleTap && this.enableMapAction.dbclick ? (this.setMapCenterAndZoomLevel(this.getCursorLocation(), a.MapContext(this).getZoomLevel() + 1, !0), b.preventDefault()) : this.moveflag && (this.moveflag = !1, b = this.touchStartLocs_backup[0].x - this.touchStartLocs[0].x,
						c = this.touchStartLocs_backup[0].y - this.touchStartLocs[0].y, Math.sqrt(b * b + c * c) < a.gv.touchMoveThreshold && this.pan(b, c, !1), this.touchStartLocs_backup.length = 0, b = new a.event.MapEvent(a.event.MapEvent.MAP_RECENTERED, this), this.fire(b.type, b)), 1 === this.touchStartLocs.length && this.touchStartLocs[0] && Math.abs(this.tStartLocsX - this.touchStartLocs[0].x) < a.gv.touchMoveThreshold && Math.abs(this.tStartLocsY - this.touchStartLocs[0].y < a.gv.touchMoveThreshold) && this.handleTouchEnd(this));
				this.touchStartLocs.length =
					0
			}
		},
		getScaleZoomLevel: function (a) {
			var b = this.getMapContext(),
			c = b.getZoomLevel();
			if (0 < a && (1 > a && .9 < a || 1 < a && 1.1 > a))
				return c;
			var l = b.getUniverse().getZoomLevels(),
			Q = l.length - 1,
			b = l[c].resolution / a;
			if (1 > a) {
				for (a = c - 1; 0 <= a; a--)
					if (c = l[a].resolution, b <= c) {
						l = b / l[a + 1].resolution;
						b = c / b;
						if (l > b)
							return a;
						break
					}
				return a + 1
			}
			for (a = c + 1; a <= Q; a++)
				if (c = l[a].resolution, b >= c) {
					l = l[a - 1].resolution / b;
					b /= c;
					if (l > b)
						return a;
					break
				}
			return a - 1
		},
		cleanMap: function () {
			this.initialized = this.displayed = !1;
			var b = new a.event.MapEvent(a.event.MapEvent.MAP_CLEAN,
					this);
			this.fire(b.type, b);
			b = 0;
			if (this.graphics)
				for (this.graphics.clearGroup(this.draggableGroup), this.graphics.clearGroup(this.blockerGroup), this.graphics.clearGroup(this.fixedGroup), b = 0; b < this.svgLayers.length; b++)
					this.graphics.clearGroup(this.svgLayers[b].group);
			this.$tileLayersDiv.empty();
			this.$fkGraphicLayersDiv.unbind();
			for (b = 0; b < this.decorationArray.length; b++) {
				var c = this.decorationArray[b];
				"OverviewMap" === c.type && (c.$DecorationBtnDiv.remove(), c.$DecorationDiv.remove())
			}
		},
		checkCenter: function () {
			if (this.overview ||
				!this.hasExternal) {
				var b = this.getMapContextToken(),
				c = b.universe,
				p = b.zoomLevel,
				l = c.zoomLevels[p].resolution,
				p = c.zoomLevels[p].stretchRatio,
				Q = c.bound;
				b.homeCenter || (b.homeCenter = new a.geometry.Point((Q.getMinX() + Q.getMaxX()) / 2, (Q.getMinY() + Q.getMaxY()) / 2, c.srid));
				b.centerPoint = b.homeCenter.clone();
				this.wraparound && (b.roundMapCenterPoint = b.homeCenter.clone());
				var A = b.centerPoint,
				B = b.deviceWindow,
				G = A.getX() - B.w / 2 * l,
				Y = A.getX() + B.w / 2 * l,
				W = A.getY() - B.h / 2 * l * p,
				A = A.getY() + B.h / 2 * l * p,
				K = {
					x: !0,
					y: !0
				},
				q = b.centerPoint.getX(),
				t = b.centerPoint.getY(),
				I = !1,
				aa = !1;
				if (a.notNull(this.mapBoundsLimit)) {
					this.mapBoundsLimit.getSRID() !== c.getSRID() && (this.mapBoundsLimit = this.mapBoundsLimit.transform(c.getSRID()));
					var c = this.mapBoundsLimit.getMinX(),
					ba = this.mapBoundsLimit.getMaxX(),
					R = this.mapBoundsLimit.getMinY(),
					qa = this.mapBoundsLimit.getMaxY();
					q < c && (q = c, I = !0);
					q > ba && (q = ba, I = !0);
					t < R && (t = R, aa = !0);
					t > qa && (t = qa, aa = !0)
				}
				this.wraparound || (G < Q.getMinX() && Y > Q.getMaxX() || Y - G > Q.getWidth() ? (q = (Q.getMinX() + Q.getMaxX()) / 2, I = !0) : G < Q.getMinX() ? (q =
							Q.getMinX() + B.w / 2 * l, I = !0) : Y > Q.getMaxX() && (q = Q.getMaxX() - B.w / 2 * l, I = !0), K.x = I);
				W < Q.getMinY() && A > Q.getMaxY() || A - W > Q.getHeight() ? (t = (Q.getMinY() + Q.getMaxY()) / 2, aa = !0) : W < Q.getMinY() ? (t = Q.getMinY() + B.h / 2 * l * p, aa = !0) : A > Q.getMaxY() && (t = Q.getMaxY() - B.h / 2 * l * p, aa = !0);
				K.y = aa;
				b.centerPoint.setPoint(q, t);
				this.wraparound && b.roundMapCenterPoint.setPoint(q, t);
				return K
			}
		},
		resetUniverse: function (b, c) {
			var p = this.getMapContextToken();
			p.universe.srid !== b.srid && this.iterateVectorLayers(function (a) {
				a.rtree = null
			});
			p.universe =
				b;
			p.transform = null;
			this.graphics.setLeftTop(this.draggableGroup, 0, 0);
			for (var l = this.divLayers.length, l = c.getZIndex() - 1; 0 < l; )
				this.removeLayer(this.divLayers[0]), l--;
			this.universeLayerIndex = 0;
			for (var l = this.svgLayers.length, Q = 0; Q < l; Q++) {
				var A = this.svgLayers[Q];
				A.dataLoaded = !1;
				A.loaded = !1;
				A.heatMap = null;
				A.renderingStyle && "HeatMap" == A.renderingStyle.styleType && A.renderingStyle.containerVectorLayer && (A.renderingStyle.containerVectorLayer.dataLoaded = !1);
				A.boundingTheme && (A.loadedBoundingTheme = !1)
			}
			l = p.universe;
			if (this.overview) {
				var B = this.overview.submap.getMapContextToken(),
				Q = B.universe;
				if (this.overview.submap) {
					Q.zoomLevels = l.zoomLevels;
					Q.srid = l.srid;
					Q.bound = l.bound;
					this.overview.layer && this.overview.layer.parentMap && (l = this.overview.layer, l.copyFeatures && this.overview.mainmap.overviewLayer.deleteListener(a.event.LayerEvent.FEATURES_LOADED, l.copyFeatures), this.overview.submap.removeLayer(this.overview.layer));
					var G = this;
					p.centerPoint.transform(p.universe.srid, function (a) {
						p.centerPoint = a;
						B.centerPoint =
							p.centerPoint;
						B.homeCenter = p.centerPoint;
						B.zoomLevel = p.zoomLevel - G.overview.calMapZoomDiff()
					})
				}
			}
			this.boundingThemeLoaded = this.boundingThemeLoading = !1;
			this.extentRect = this.boundingLayerName = null;
			this.resetTag = !0;
			this.init()
		},
		getMapAsSVG: function (b) {
			var c = this.graphics,
			p = c.oui,
			l = p.viewportBounds,
			Q = l.width,
			A = l.height,
			B = this.divLayers.length,
			G = this,
			Y = c.createGroup({
				x: 0,
				y: 0
			}),
			W;
			for (W = 0; W < B; W++)
				this.divLayers[W].exportToSVG(Y, Q, A);
			var K = [Y, this.draggableGroup];
			for (W = 0; W < this.decorationArray.length; W++) {
				var q =
					this.decorationArray[W];
				(q instanceof a.control.ScaleBar || q instanceof a.control.CopyRight) && q.defaultGroup && K.push(q.defaultGroup)
			}
			var t = function () {
				if (G.graphics) {
					for (var a = 0; a < B; a++)
						if (0 !== G.divLayers[a].loadImg) {
							h.setTimeout(t, 200);
							return
						}
					a = (new p.io.svg.SVGExporter).snapshotNodes(K, l, Q, A);
					a.style = "overflow:hidden";
					a = p.io.XMLConverter.convert(a, "");
					c.clearGroup(Y);
					b(a)
				}
			};
			h.setTimeout(t, 0)
		},
		getFlattenedCanvas: function (b, z, p, l) {
			var Q = this.graphics.oui.viewportBounds,
			A = Math.round(Q.width),
			Q = Math.round(Q.height);
			z || (z = A);
			p || (p = Q);
			l = l || {};
			l.navigationPanelBar = l.navigationPanelBar || !1;
			l.scaleBar === c && (l.scaleBar = !0);
			this.getTileCanvas(z, p);
			var B = this;
			this.drawVectorInPrintCanvas(z, p, function (c) {
				B.drawImageEnd(z, p, c, function (c, l) {
					a.$("#printVC" + B.mapInstanceId).remove();
					b(c, l)
				})
			}, l)
		},
		getTileCanvas: function (a, b) {
			for (var c = 0, l = this.divLayers.length; c < l; c++)
				this.divLayers[c].isVisible() && (this.divLayers[c].canvas = document.createElement("canvas"), this.divLayers[c].canvas.width = a, this.divLayers[c].canvas.height =
						b, this.divLayers[c].drawTilesImages(a, b))
		},
		drawVectorInPrintCanvas: function (b, c, p, l) {
			var Q = a.$("\x3cdiv id \x3d'printVC" + this.mapInstanceId + "' style\x3d'visibility:hidden;width:" + b + "px;height:" + c + "px'\x3e\x3c/div\x3e");
			a.$(document.body).append(Q);
			for (var A = new a.Map(Q[0], {
					universe: this.getMapContext().getUniverse(),
					hiDPI: !0
				}), Q = this.svgLayers.length, B = 0, G = 0, Y = this.svgLayers.length; G < Y; G++) {
				var W = this.svgLayers[G];
				if (W.isVisible() && 0 < W.getAllFeatures().length) {
					if (W.clustering && W.dataBufferWindow) {
						var K =
							W.maxClusteringLevel,
						q = W.vCluster.minPointCount,
						t = W.vCluster.threshold,
						I = W.vCluster.clusterStyle,
						aa = W.zoomInLevels,
						ba;
						!1 === aa || 0 === aa ? (aa = 0, ba = !1) : ba = !0;
						W = W.clone();
						if ("undefined" !== typeof I) {
							var R = I.marker,
							R = new a.style.VariableMarker(I.origConfig);
							W.enableClustering(!0, {
								clusterStyle: R,
								minPointCount: q,
								maxClusteringLevel: K,
								threshold: t,
								enableZoomIn: ba,
								zoomInLevels: aa
							})
						} else
							a.util.Logger.severe("CLUSTER_ERROR", "OM.Map", "Cluster configuration lost")
					} else
						W = W.clone();
					A.addLayer(W);
					B++
				} else
					Q--
			}
			A.setMapCenter(this.getMapCenter());
			A.setMapZoomLevel(this.getMapZoomLevel());
			for (Q = 0; Q < this.decorationArray.length && !a.isNull(l); Q++)
				B = this.decorationArray[Q], l.navigationPanelBar && B instanceof a.control.NavigationPanelBar && B.isVisible() ? (G = new a.control.NavigationPanelBar({
						orientation: B.orientation,
						style: B.style,
						anchorPosition: B.anchorPosition
					}), G.setStyle({
						position: B.position,
						backgroundColor: B.backgroundColor,
						buttonColor: B.buttonColor
					}), A.addMapDecoration(G)) : l.scaleBar && B instanceof a.control.ScaleBar && B.isVisible() ? (G = new a.control.ScaleBar({
						format: B.format,
						anchorPosition: B.anchorPosition
					}), G.setStyle({
						fontSize: B.fontSize,
						scalebar_color: B.scalebar_color,
						thickness: B.thickness,
						maxLength: B.maxLength
					}), A.addMapDecoration(G)) : l.copyRight && B instanceof a.control.CopyRight && B.isVisible() && (B = new a.control.CopyRight({
						textValue: B.textValue,
						anchorPosition: B.anchorPosition,
						fontSize: B.fontSize,
						fontFamily: B.fontFamily,
						fill: B.fontColor
					}), A.addMapDecoration(B));
			A.on(a.event.MapEvent.MAP_AFTER_REFRESH, function () {
				A.getVectorCanvas(b, c, p, l)
			});
			A.init()
		},
		getVectorCanvas: function (b,
			c, p, l) {
			var Q = document.createElement("canvas");
			Q.width = b;
			Q.height = c;
			var A = Q.getContext("2d"),
			B,
			G,
			Y = this;
			B = 0;
			for (G = this.svgLayers.length; B < G; B++) {
				var W = this.svgLayers[B];
				W.checkVisible() && W.heatMap && (W = W.getHeatmapDivId() + "\x3ecanvas", W = a.$(W)[0], A.drawImage(W, W.offsetLeft, W.offsetTop))
			}
			var K = this.$fkGraphicLayersDiv.children()[0];
			if ("CANVAS" == K.tagName) {
				var q = [];
				for (B = 0; B < this.decorationArray.length; B++)
					if (b = this.decorationArray[B], l && !1 === l.navigationPanelBar && b instanceof a.control.NavigationPanelBar &&
						b.isVisible() || l && !1 === l.scaleBar && b instanceof a.control.ScaleBar && b.isVisible() || l && !1 === l.copyRight && b instanceof a.control.CopyRight && b.isVisible())
						b.setVisible(!1), q.push(b);
				setTimeout(function () {
					var a = 1;
					!1 !== this.hiDPI && (a = (h.devicePixelRatio || 1) / (A.webkitBackingStorePixelRatio || A.mozBackingStorePixelRatio || A.msBackingStorePixelRatio || A.oBackingStorePixelRatio || A.backingStorePixelRatio || 1));
					A.save();
					A.scale(1 / a, 1 / a);
					A.drawImage(K, K.offsetLeft, K.offsetTop);
					A.restore();
					for (a = q.pop(); a; )
						a.setVisible(!0),
						a = q.pop();
					2 !== Y.svgLayers.length || "ii_oracle_maps_internal_editing" !== Y.svgLayers[0].name && "ii_oracle_maps_internal_editing" !== Y.svgLayers[1].name || "ii_oracle_maps_internal_others" !== Y.svgLayers[0].name && "ii_oracle_maps_internal_others" !== Y.svgLayers[1].name || (Q = null);
					p(Q)
				}, 50)
			} else {
				B = [this.draggableGroup, this.fixedGroup];
				l = this.graphics.oui;
				B = (new l.io.svg.SVGExporter).snapshotNodes(B, l.viewportBounds, b, c);
				B.style = "overflow:hidden";
				l = l.io.XMLConverter.convert(B, "");
				try {
					A.drawSvg(l, 0, 0, b, c)
				} catch (t) {
					a.util.Logger.alert("MAPVIEWER_9040",
						"OM.Map.getMapAsImage")
				}
				p(Q)
			}
		},
		drawImageEnd: function (b, c, p, l) {
			var Q = document.createElement("canvas"),
			A = document.createElement("canvas"),
			B = !0,
			G = !0;
			Q.width = b;
			Q.height = c;
			A.width = b;
			A.height = c;
			var Y = Q.getContext("2d"),
			W = A.getContext("2d"),
			K = this,
			q = function () {
				for (var b = 0, c = K.divLayers.length; b < c; b++)
					if (K.divLayers[b].canvas && K.divLayers[b].loadingImg) {
						setTimeout(q, 100);
						return
					}
				b = 0;
				for (c = K.divLayers.length; b < c; b++)
					K.divLayers[b].canvas && (Y.drawImage(K.divLayers[b].canvas, 0, 0), B = !1);
				a.notNull(p) && (W.drawImage(p,
						0, 0), G = !1);
				!0 === B && (Q = null);
				!0 === G && (A = null);
				l(Q, A)
			};
			setTimeout(q, 100)
		},
		getMapAsServerImage: function (b, c, p, l) {
			var Q = this.mapviewerURL + "/omserver";
			this.getMapAsXML("GIF_URL", function (c) {
				a.util.HttpRequest.send(Q, {
					xml_request: c
				}, function (l) {
					l = a.$(l).find("map_content");
					a.isNull(l) ? a.util.Logger.alert("MAPVIEWER_9009", "OM.Map.getMapAsServerImage", c) : (l = l.attr("url"), b(l))
				}, "xml")
			}, c, p, l)
		},
		deleteFeatureInfoWindow: function (a) {
			this.infoLayer && this.infoLayer.deleteInfoWindowById(a)
		},
		build_decos_xml: function (b) {
			for (var c =
					"", p = 0; p < this.decorationArray.length; p++) {
				var l = this.decorationArray[p];
				"ScaleBar" != l.type || !a.isNull(b) && !1 === b.scaleBar || (c += this.build_scale_bar(l))
			}
			return a.notNull(c) && 0 < c.length ? "\x3cscale_bar" + c + "/\x3e" : ""
		},
		build_scale_bar: function (b) {
			var c = "";
			switch (b.anchorPosition) {
			case a.control.MapDecoration.POSITION_LOWER_LEFT:
				c += ' position\x3d"SOUTH_WEST"';
				break;
			case a.control.MapDecoration.POSITION_LOWER_RIGHT:
				c += ' position\x3d"SOUTH_EAST"';
				break;
			case a.control.MapDecoration.POSITION_UPPER_LEFT:
				c +=
				' position\x3d"NORTH_WEST"';
				break;
			case a.control.MapDecoration.POSITION_UPPER_RIGHT:
				c += ' position\x3d"NORTH_EAST"';
				break;
			case a.control.MapDecoration.POSITION_LOWER_CENTER:
				c += ' position\x3d"SOUTH"';
				break;
			case a.control.MapDecoration.POSITION_UPPER_CENTER:
				c += ' position\x3d"NORTH"'
			}
			c = "METRIC" === b.format ? c + ' mode\x3d"METRIC_MODE"' : "IMPERIAL" === b.format ? c + ' mode\x3d"US_MODE"' : c + ' mode\x3d"DUAL_MODES"';
			c += ' length_hint\x3d"' + b.maxLength + '"';
			c = c + ' label_font_family\x3d"Serif"' + (' label_font_size\x3d"' +
					(a.notNull(b.fontSize) ? b.fontSize : 12) + '"');
			c += ' color1\x3d"' + b.scaleBarColor + '"';
			c += ' label_color\x3d"' + b.fontColor + '"';
			return c += ' label_font_weight\x3d"' + b.fontWeight + '"'
		},
		build_copy_right: function () {
			return ""
		},
		getMapAsXML: function (b, c, p, l, Q) {
			var A = a.MapContext(this);
			b || (b = "GIF_URL");
			var B = A.getUniverse().getMapBounds().getWidth();
			if (A.getQueryWindow().getMinX() < -B / 2 || A.getQueryWindow().getMaxX() > B / 2)
				p = A.getZoomLevel(), p = this.getLabelGridBox(p).maxX;
			p || (p = A.getDeviceWidth());
			l || (l = A.getDeviceHeight());
			p = Math.round(p);
			l = Math.round(l);
			B = a.gv.defaultDataSource;
			a.isNull(B) && (Q && Q.dataSource ? B = Q.dataSource : a.util.Logger.warning("MAPVIEWER_9104", "OM.Map.getMapAsXML"));
			var G = '\x3c?xml version\x3d"1.0" standalone\x3d"yes"?\x3e',
			G = G + '\x3cmap_request datasource\x3d"' + B + '" format\x3d"' + b + '" width\x3d"' + p + '" height\x3d"' + l + '" antialiase\x3d"true" transparent\x3d"true" srid\x3d"' + A.getUniverse().getSRID() + '"';
			b = !1;
			for (var Y, B = this.divLayers.length - 1; -1 < B; B--) {
				var W = this.divLayers[B];
				if (W.isVisible() && W.getStaticMapURL &&
					W.layerType !== a.LayerTypes.DYNAMIC_TILE) {
					b = !0;
					Y = W.getStaticMapURL(p, l);
					break
				}
			}
			var K = this.getAndCombineDTLURLs(p, l),
			q = this.build_decos_xml(Q),
			A = A.getQueryWindow().getHeight(),
			B = this.getMapCenter(),
			t = '\x3ccenter size\x3d"' + A + '"\x3e\x3cgeoFeature\x3e\x3cgeometricProperty typeName\x3d"center"\x3e\x3cPoint\x3e\x3ccoordinates\x3e' + B.getX() + "," + B.getY() + "\x3c/coordinates\x3e\x3c/Point\x3e\x3c/geometricProperty\x3e\x3c/geoFeature\x3e\x3c/center\x3e";
			b ? (Y = Y.replace(/&/g, "\x26amp;"), Y = Y.replace(/</g, "\x26lt;"),
				Y = Y.replace(/>/g, "\x26gt;"), this.drawVectorInPrintCanvas(p, l, function (b) {
					G += " bgimage\x3d'" + Y + "'";
					a.isNull(K) || 0 === K.trim().length ? (G += a.notNull(b) ? ' bgimage2\x3d"' + b.toDataURL() + '"' : "", G += "\x3e" + t) : (G += a.notNull(b) ? ' fgimage\x3d"' + b.toDataURL() + '"' : "", G += "\x3e" + t + K);
					G += q + "\x3c/map_request\x3e";
					c(G)
				}, Q)) : this.getFlattenedCanvas(function (b, l) {
				a.isNull(K) || 0 === K.trim().length ? (a.notNull(b) ? (G += ' bgimage\x3d"' + b.toDataURL() + '"', a.notNull(l) && (G += ' fgimage\x3d"' + l.toDataURL() + '"')) : a.notNull(l) && (G +=
						' bgimage\x3d"' + l.toDataURL() + '"'), G += "\x3e" + t) : (a.notNull(b) && (G += ' bgimage\x3d"' + b.toDataURL() + '"'), a.notNull(l) && (G += ' fgimage\x3d"' + l.toDataURL() + '"'), G += "\x3e" + t + K);
				G += q + "\x3c/map_request\x3e";
				c(G)
			}, p, l, Q)
		},
		getDTLURLs: function (b, c) {
			for (var p = [], l = null, Q = 0; Q < this.divLayers.length; Q++)
				l = this.divLayers[Q], l.isVisible() && l.getStaticMapURL && l.layerType === a.LayerTypes.DYNAMIC_TILE && (l = l.getStaticMapURL(b, c), p.push(l));
			return p
		},
		getAndCombineDTLURLs: function (b, c) {
			var p = this.getDTLURLs(b, c);
			return a.layer.DynamicTileLayer.combineDTLURLs(p)
		},
		print: function () {
			a.$(document.body).css("cursor", "wait");
			this.$oracleMapDiv.css("cursor", "wait");
			var b = this;
			this.getMapAsSVG(function (c) {
				a.$(document.body).css("cursor", "");
				b.$oracleMapDiv.css("cursor", "");
				var p = h.open();
				p.document.write(c);
				p.print()
			})
		},
		_getMapActionState: function () {
			return {
				drag: this.enableMapAction.drag,
				mousewheel: this.enableMapAction.mousewheel,
				dbclick: this.enableMapAction.dbclick,
				mouse: this.enableMapAction.mouse,
				click: this.enableMapAction.click
			}
		},
		_restoreMapActionState: function (b) {
			a.isNull(b) ||
			(a.notNull(b.drag) && (this.enableMapAction.drag = b.drag), a.notNull(b.mousewheel) && (this.enableMapAction.mousewheel = b.mousewheel), a.notNull(b.dbclick) && (this.enableMapAction.dbclick = b.dbclick), a.notNull(b.mouse) && (this.enableMapAction.mouse = b.mouse), a.notNull(b.click) && (this.enableMapAction.click = b.click))
		},
		enableMapDrag: function (a) {
			this.enableMapAction.drag = a
		},
		enableMapWraparound: function (a) {
			this.wraparound = a
		},
		enableMouseWheelZooming: function (a) {
			this.enableMapAction.mousewheel = a
		},
		enableMapZoom: function (a) {
			this.zoomEnabled =
				a;
			this.overview && this.overview.enableOverViewMapZoom(a)
		},
		enableDoubleClick: function (a) {
			this.enableMapAction.dbclick = a
		},
		enableMapClick: function (a) {
			this.enableMapAction.click = a
		},
		getEnableMapClick: function () {
			return this.enableMapAction.click
		},
		setMouseWheelZoomBehavior: function (a) {
			this.mouseWheelZoomBehavior = a
		},
		getMouseWheelZoomBehavior: function () {
			return this.mouseWheelZoomBehavior
		},
		setHomeMap: function (a, b) {
			var c = this.getMapContextToken();
			a && (c.homeMapCenter = a);
			b && (c.homeMapZoomlevel = b)
		},
		enableZoomAnimation: function (a) {
			this.tileLayerZoomAnimation =
				a
		},
		setEnabledZoomLevels: function (b) {
			this.universe && (this.getMapContextToken().universe = this.universe);
			if (a.util.ValidationUtil.isNumberArray(b) && (b.sort(function (a, b) {
						return a - b
					}), this.enableZoomLevels = b, 0 === this.divLayers.length && 2 < this.svgLayers.length)) {
				b = {};
				for (var c = [], p, l, Q = this.getMapContext().getUniverse().getZoomLevels().length, A = 0; A < this.enableZoomLevels.length; A++)
					Q - 1 < this.enableZoomLevels[A] ? (p = this.getMapContext().getUniverse().getZoomLevels()[Q - 1].resolution, l = this.getMapContext().getUniverse().getZoomLevels()[Q -
								1].stretchRatio) : (p = this.getMapContext().getUniverse().getZoomLevels()[this.enableZoomLevels[A]].resolution, l = this.getMapContext().getUniverse().getZoomLevels()[this.enableZoomLevels[A]].stretchRatio), c[A] = new a.universe.ZoomLevel(p, {
							stretchRatio: l
						});
				b.zoomLevels = c;
				b.srid = this.getMapContext().getUniverse().getSRID();
				b.bounds = this.getMapContext().getUniverse().getMapBounds();
				b.numberOfZoomLevels = this.enableZoomLevels.length;
				b = new a.universe.Universe(b);
				this.universe = this.getMapContext().getUniverse();
				this.getMapContextToken().universe = b
			}
		},
		enableInfoWindowEventPropagation: function (a) {
			this.infoWindowEventPropogation = a
		},
		closeInfoWindows: function () {
			this.infoLayer && (this.infoLayer.closeInfoWindows(), this.isCustomInfoWindow = this.infoLayer = null)
		},
		replaceLayer: function (b, c) {
			for (var p = 0, l = this.divLayers.length; p < l; p++)
				if (this.divLayers[p] == b) {
					this.divLayers[p] = c;
					c.parentMap = this;
					this.overviewLayer = c;
					p = a.event.MapEvent;
					l = a.event.LayerEvent;
					this.on(p.I_MAP_DRAGGING, c.panEvent, c);
					this.on(p.MAP_RECENTERED,
						c.recenter, c);
					this.on(p.I_MAP_CENTER_ZOOM, c.setCenterAndZoomlevel, c);
					this.on(p.MAP_BEFORE_REFRESH, c.refreshEvent, c);
					this.on(p.MAP_REDRAW, c.redraw, c);
					this.on(p.MAP_DESTROY, c.destroy, c);
					c.addListener(l.FINISH_GOT_CONFIG, this.newLayerConfigLoaded);
					c.addListener(l.FINISH_LOAD, this.layerFinish);
					c.addListener(l.ALL_TILES_LOADED, this.layerLoaded);
					c.addListener(l.INIT_ERROR, this.layerErr);
					c.addListener(l.RENDERING_STYLE_CHANGED, this.layerStyleChanged);
					c.addListener(l.NSDP_MAPPED, this.nsdpMapped);
					c.setContainer &&
					c.setContainer(this.$tileLayersDiv[0]);
					this.deleteLayerListener(b);
					break
				}
		},
		setAllInitialParams: function () {
			var b = this.getMapContextToken();
			a.isNull(b.centerPoint) && (b.centerPoint = new a.geometry.Point((b.universe.bound.getMinX() + b.universe.bound.getMaxX()) / 2, (b.universe.bound.getMinY() + b.universe.bound.getMaxY()) / 2, b.universe.srid));
			a.isNull(b.homeCenter) && (b.homeCenter = b.centerPoint);
			a.isNull(b.zoomLevel) && (b.zoomLevel = 0);
			b.homeMapCenter || (b.homeMapCenter = b.centerPoint);
			b.homeMapZoomlevel || (b.homeMapZoomlevel =
					b.zoomLevel)
		},
		changeOverView: function () {
			if (!this.userSetOL && this.overview) {
				for (var b = this.divLayers.length - 1; 0 <= b; b--)
					if (a.notNull(this.divLayers[b].tileLayerConfig) && !this.divLayers[b].tileLayerConfig.isTransparentImage && this.overviewLayer !== this.divLayers[b] && (this.divLayers[b].layerType !== a.LayerTypes.DYNAMIC_TILE || !1 === this.divLayers[b].hideInOverviewMap) && this.divLayers[b].isVisible()) {
						this.overviewLayer = this.divLayers[b];
						this.overview.setOverviewMapOptions({
							overviewLayer: this.overviewLayer
						});
						return
					}
				if (0 < this.divLayers.length)
					this.overviewLayer !== this.divLayers[0] && (this.overviewLayer = this.divLayers[0], this.overview.setOverviewMapOptions({
							overviewLayer: this.overviewLayer
						}));
				else if (2 < this.svgLayers.length)
					for (var b = 0, c = this.svgLayers.length; b < c; b++)
						if (this.svgLayers[b] != this.toolFeatureLayer && this.svgLayers[b] != this.defaultFeatureLayer) {
							this.overviewLayer !== this.svgLayers[b] && (this.overviewLayer = this.svgLayers[b], this.overview.setOverviewMapOptions({
									overviewLayer: this.overviewLayer
								}));
							break
						}
			}
		},
		addVectorLayerByURL: function (b, c, p) {
			this.addLayer(new a.layer.VectorLayer(this.generateLayerName(), {
					def: {
						type: a.layer.VectorLayer.TYPE_DATAPACK,
						url: b
					},
					renderingStyle: c,
					boundingTheme: p
				}), "URL_Layer")
		},
		generateLayerName: function () {
			var a = 0;
			return function () {
				return "URL_Layer_" + ++a
			}
		}
		(),
		enableURLDragDrop: function (a, b) {
			this.drapDrop = a;
			b && (b.style && (this.ddStyle = b.style), b.zoomToTheme && (this.ddZoom = b.zoomToTheme))
		},
		setMouseCursorStyle: function (b, c) {
			"hand" === b && (b = a.CursorTypes.POINTER);
			"dragging" ===
			c ? this.cursorStyleDragging = b : "default" === c && (this.cursorStyleDefault = b, this.changeCursor(b))
		},
		changeCursor: function (a) {
			this.$oracleMapDiv.css("cursor", a);
			this.graphics.oui && this.graphics.oui.tree && this.graphics.oui.tree.canvas && (this.graphics.oui.tree.canvas.style.cursor = a)
		},
		isStoppedEvent: function (b) {
			return b.type && a.event.EventSource.stopEvents[b.type] ? (a.event.EventSource.stopEvents[b.type] = !1, !0) : !1
		},
		setStoppedEvent: function (b) {
			a.notNull(b) && (a.event.EventSource.stopEvents[b] = !0)
		},
		setTooltipStyle: function (b) {
			if (a.notNull(b)) {
				var c = {
					border: {},
					text: {},
					padding: {}
				},
				p = {
					titleStyle: {},
					headerStyle: {},
					contentStyle: {}
				};
				a.notNull(b.titleStyle) && (p.titleStyle = b.titleStyle, p.titleStyle.hAlign = "LEFT" == b.titleStyle.hAlign ? 0 : "CENTER" == b.titleStyle.hAlign ? .5 : 1);
				a.notNull(b.headerStyle) && (p.headerStyle = b.headerStyle, p.headerStyle.hAlign = "LEFT" == b.headerStyle.hAlign ? 0 : "CENTER" == b.headerStyle.hAlign ? .5 : 1);
				a.notNull(b.contentStyle) && (p.contentStyle = b.contentStyle, p.contentStyle.hAlign = "LEFT" == b.contentStyle.hAlign ? 0 : "CENTER" == b.contentStyle.hAlign ?
						.5 : 1);
				a.notNull(b.opacity) && (c.opacity = b.opacity);
				a.notNull(b.background) && (c.background = b.background);
				a.notNull(b.padding) && (c.padding = b.padding);
				a.notNull(b.borderColor) && (c.border.stroke = b.borderColor);
				a.notNull(b.textColor) && (c.text.fill = b.textColor);
				a.notNull(b.rx) && (c.border.rx = b.rx);
				a.notNull(b.ry) && (c.border.ry = b.ry);
				a.notNull(b.fontSize) && (c.text.fontSize = b.textSize);
				a.notNull(b.fontWeight) && (c.text.fontWeight = b.fontWeight);
				a.notNull(b.strokeThickness) && (c.border.strokeThickness = b.strokeThickness);
				a.notNull(b.shadow) ? c.shadow = b.shadow : c.shadow = null;
				this.graphics.setTooltipStyle(c);
				this.graphics.storeCustomTooltipTextStyle(p)
			}
		},
		appendUTFGridLayerHTML: function (b) {
			a.isNull(this.utfgridHTMLArray) ? a.util.Logger.warning("MAPVIEWER_9103", "OM.Map.appendUTFGridLayerHTML") : this.utfgridHTMLArray.push(b)
		},
		enableMultiLayerInfoWindow: function (a) {
			this.showAllVecFeatureInfo = a ? !0 : !1
		},
		setVectorLayerInfoWindowTrigger: function (b) {
			this.vectorlayerInfoWindowMouseEType = b === a.event.MouseEvent.MOUSE_OVER || b === a.event.MouseEvent.MOUSE_MOVE ?
				a.event.MouseEvent.MOUSE_MOVE : a.event.MouseEvent.MOUSE_CLICK
		},
		cleanupVctLyrSelections: function (b) {
			for (var c, p = 0; p < this.svgLayers.length; p++)
				c = this.svgLayers[p], !0 !== a.event.EventSource.isProcessedEvent(c, b) ? !0 !== this.ctrl_cmd_key_down && c.deselectFeatures() : a.event.EventSource.resetProcessedEvent(c, b)
		},
		handleTouchEnd: function (b) {
			var c = new a.event.MapEvent(a.event.MouseEvent.MOUSE_CLICK, b);
			b.fire(c.type, c);
			b.handleInfoWindow();
			b.cleanupVctLyrSelections(a.event.MouseEvent.MOUSE_CLICK)
		},
		handleMouseClick: function (b,
			c) {
			var p;
			2 === b.button ? (p = new a.event.MapEvent(a.event.MouseEvent.MOUSE_RIGHT_CLICK, c), c.fire(p.type, p)) : (!0 === c.getEnableMapClick() ? (p = new a.event.MapEvent(a.event.MouseEvent.MOUSE_CLICK, c), c.fire(p.type, p)) : (p = c.getVectorLayerHitFeatures(a.event.MouseEvent.MOUSE_CLICK)) && 0 < p.length && (p = new a.event.MapEvent(a.event.MouseEvent.MOUSE_CLICK, c), c.fire(p.type, p)), c.handleExternalTileLayerClickables(b), c.handleInfoWindow(), c.cleanupVctLyrSelections(a.event.MouseEvent.MOUSE_CLICK))
		},
		isVecLayerCustomInfoWindowDisplayed: function (b) {
			if (a.isNull(b) ||
				1 > b.length)
				return !1;
			var c,
			p;
			c = 0;
			for (p = b.length; c < p; c += 1)
				if (b[c] && b[c].feature_layer && !1 === b[c].feature_layer.getEnableInfoWindow()) {
					if (b[c].hasListener(a.event.MouseEvent.MOUSE_CLICK) && this.infoLayer && this.isCustomInfoWindow)
						return !0;
					var l = b[c].feature_layer;
					if ((l.hasListener(a.event.MouseEvent.MOUSE_CLICK) || this.hasListener(a.event.MouseEvent.MOUSE_CLICK)) && a.event.EventSource.isProcessedEvent(l, a.event.MouseEvent.MOUSE_CLICK) && this.infoLayer && this.isCustomInfoWindow)
						return !0
				}
			return !1
		},
		setMaskOutInfoWindow: function (b) {
			var c =
				this;
			!0 === b ? c.maskOutInfoWindow = !0 : setTimeout(function () {
				c.maskOutInfoWindow = !1
			}, 1.5 * a.event.MouseEvent.DEBOUNCE_MILI_SEC)
		},
		setMapStatus: function (a) {
			for (var b in a)
				this[b] = a[b]
		},
		isMapReady: function () {
			return this.inited && this.initialzied && this.displayed
		},
		getMaskOutInfoWindow: function () {
			return this.maskOutInfoWindow
		},
		isMVMapDecorationElem: function (b) {
			for (; a.notNull(b); ) {
				if (a.notNull(b.id) && 0 < b.id.trim().length && 0 <= b.id.trim().indexOf("topLayerDIV"))
					return !0;
				b = b.parentNode
			}
			return !1
		},
		handleExternalTileLayerClickables: function (b) {
			var c,
			p,
			l = [],
			Q,
			A;
			try {
				a.notNull(this.$fkGraphicLayersDiv) && (c = this.$fkGraphicLayersDiv.css("pointer-events"), this.$fkGraphicLayersDiv.css("pointer-events", "none"));
				a.notNull(this.$heatMapDiv) && (p = this.$heatMapDiv.css("pointer-events"), this.$heatMapDiv.css("pointer-events", "none"));
				for (var B = this.divLayers.length - 1; 0 <= B; --B)
					if (Q = this.divLayers[B], !a.isNull(Q) && Q.layerType !== a.LayerTypes.EXTERNAL) {
						var G;
						"string" === typeof Q.name ? G = Q.name : "object" === typeof Q.name && (G = Q.name.name);
						A = a.$("#tilelayer_" + G);
						if (a.notNull(A)) {
							var Y = {},
							W = A.css("pointer-events");
							a.notNull(W) && (Y[G] = W, l.push(Y), A.css("pointer-events", "none"))
						}
					}
				var K = $(document.elementFromPoint(b.clientX, b.clientY));
				a.notNull(K) && !this.isMVMapDecorationElem(K[0]) && K[0].click()
			} finally {
				a.notNull(c) && this.$fkGraphicLayersDiv.css("pointer-events", c),
				a.notNull(p) && this.$heatMapDiv.css("pointer-events", p),
				l.forEach(function (b) {
					for (var c in b) {
						var l = a.$("#tilelayer_" + c);
						a.notNull(l) && l.css({
							"pointer-events": b[c]
						})
					}
				})
			}
		},
		enableEditingContextMenu: function (b) {
			if (!a.isNull(b)) {
				var c =
					this.svgLayers;
				if (!(a.isNull(c) || 1 > c.length))
					for (var p = 0; p < c.length; p += 1) {
						var l = c[p];
						0 <= l.name.indexOf("ii_oracle_maps_internal") && l.enableEditingContextMenu(b)
					}
			}
		},
		setSearchTolerance: function (b) {
			a.isNull(b) ? a.util.Logger.warning("", "OM.Map.setSearchTolerance", "Search tolerance was not provided.") : isNaN(b) ? a.isNull(b.value) ? a.util.Logger.warning("", "OM.Map.setSearchTolerance", "Search tolerance was not properly defined.") : ((a.isNull(b.unit) || "px" !== b.unit) && a.util.Logger.warning("", "OM.Map.setSearchTolerance",
					"Tolerance unit is set to 'px'."), this.searchTolerance = {
					value: b.value,
					unit: "px"
				}) : this.searchTolerance = {
				value: b,
				unit: "px"
			}
		},
		getSearchTolerance: function () {
			return this.searchTolerance
		},
		setSnapTolerance: function (b) {
			(a.isNull(b) || isNaN(b)) && a.util.Logger.warning("", "OM.Map.setSnapTolerance", "Input parameter was invalid.");
			this.snapTolerance = {
				value: b,
				unit: "px"
			}
		},
		getSnapTolerance: function () {
			return this.snapTolerance
		},
		getSnapToleranceOnGround: function () {
			try {
				var a = this.getSnapTolerance().value,
				b = this.getPixelResolution();
				return a * b
			} catch (c) {
				return 0
			}
		},
		orderHeatmapAboveVectorLayer: function (a) {
			!0 === a ? this.$heatMapDiv.css({
				"z-index": "5"
			}) : this.$heatMapDiv.css({
				"z-index": "2"
			});
			return parseInt(this.$heatMapDiv.css("z-index"), 10)
		},
		handleInfoWindow: function () {
			var b = !1;
			if (!0 !== this.maskOutInfoWindow) {
				if (this.vectorlayerInfoWindowMouseEType === a.event.MouseEvent.MOUSE_CLICK) {
					var c = this.getVectorLayerHitFeatures(a.event.MouseEvent.MOUSE_CLICK);
					if (this.isVecLayerCustomInfoWindowDisplayed(c))
						return;
					c && 0 < c.length && (b = this.displayVectorLayersInfoWindow(c))
				}
				!1 ===
				b && this.closeInfoWindows();
				!0 !== b && this.utfgridMouseEType === a.event.MouseEvent.MOUSE_CLICK && (this.fireUTFGridEvent(a.event.MouseEvent.MOUSE_CLICK), this.displayUTFGridInfoWindow())
			}
		},
		disableBuiltinToolTooltip: function (b) {
			a.isNull(b) || !0 === b ? (a.Messages.map.MAPVIEWER_TB_TIP_CLEAR = "", a.Messages.map.MAPVIEWER_TB_TIP_CIRCLE = "", a.Messages.map.MAPVIEWER_TB_TIP_RECTANGLE = "", a.Messages.map.MAPVIEWER_TB_TIP_REDLINE = "", a.Messages.map.MAPVIEWER_TB_TIP_DISTANCE = "", a.Messages.map.MAPVIEWER_TB_TIP_ZOOM = "") : !1 ===
			b ? (a.Messages.map.MAPVIEWER_TB_TIP_CLEAR = "clear", a.Messages.map.MAPVIEWER_TB_TIP_CIRCLE = "circle", a.Messages.map.MAPVIEWER_TB_TIP_RECTANGLE = "rectangle", a.Messages.map.MAPVIEWER_TB_TIP_REDLINE = "redline", a.Messages.map.MAPVIEWER_TB_TIP_DISTANCE = "distance", a.Messages.map.MAPVIEWER_TB_TIP_ZOOM = "zoom") : a.util.Logger.warning("", "OM.Map.disableToolbarTooltip", "A boolean parameter (true or false) is required.")
		},
		setBuiltinToolTooltip: function (b) {
			if (!a.isNull(b))
				for (var c in b)
					if (b.hasOwnProperty(c)) {
						var p =
							b[c];
						switch (c.toUpperCase()) {
						case "TB_CLEAR":
							a.Messages.map.MAPVIEWER_TB_TIP_CLEAR = p;
							break;
						case "TB_CIRCLE":
							a.Messages.map.MAPVIEWER_TB_TIP_CIRCLE = p;
							break;
						case "TB_RECTANGLE":
							a.Messages.map.MAPVIEWER_TB_TIP_RECTANGLE = p;
							break;
						case "TB_REDLINE":
							a.Messages.map.MAPVIEWER_TB_TIP_REDLINE = p;
							break;
						case "TB_DISTANCE":
							a.Messages.map.MAPVIEWER_TB_TIP_DISTANCE = p;
							break;
						case "TB_ZOOM":
							a.Messages.map.MAPVIEWER_TB_TIP_ZOOM = p;
							break;
						default:
							a.util.Logger.warning("", "OM.Map.setBuiltinToolTooltip", "tool no recognized")
						}
					}
		}
	});
	a.Map.setProxyPath = function (b) {
		b && 0 === b.indexOf("/") && (a.gv.proxyPath = b)
	};
	a.Map.getProxyPath = function () {
		return a.gv.proxyPath
	};
	a.Map.isTileLayer = function (b) {
		return b === a.LayerTypes.TILE || b === a.LayerTypes.DYNAMIC_TILE || b === a.LayerTypes.WMTS_TILE || b === a.LayerTypes.EXTERNAL
	};
	a.Map.setErrorHandler = function (b) {
		a.util.Logger.errorHandler = b
	};
	a.Map.setAPIKey = function (b, c) {
		var p = a.util.HttpRequest.getDomain(c);
		a.gv.mvKeyMap[p] = b
	};
	a.Map.setLocale = function (b, c) {
		var p;
		p = a.notNull(c) ? b + "-" + c : b;
		a.gv.loadMessage(p)
	};
	a.Map.ZOOM_KEEP_MOUSE_POINT = 1;
	a.Map.ZOOM_CENTER_ON_MOUSE = 2;
	a.Map.ZOOM_KEEP_CENTER = 3;
	a.server.ServerMapRequest = a.Class.extend({
		initialize: function (b) {
			a.isNull(b) && (b = "http://" + document.location.host + "/mapviewer");
			this.baseURL = b;
			this.basemap = this.bgcolor = this.transparent = this.antialiase = this.datasource = null;
			this.themesArray = [];
			this.stylesArray = [];
			this.enableUTFGrid = this.format = this.tileServerURL = this.isclienttilereq = this.height = this.width = null;
			this.grid_res = 4;
			this.srid = this.maxY = this.maxX = this.minY =
				this.minX = null
		},
		setImageFormat: function (a) {
			this.format = a
		},
		setImageWidth: function (a) {
			this.width = a
		},
		setImageHeight: function (a) {
			this.height = a
		},
		setBasemap: function (a) {
			this.basemap = a
		},
		setUTFGridResolution: function (a) {
			this.grid_res = a
		},
		setClientTileRequest: function (a) {
			this.isclienttilereq = a
		},
		setBBox: function (b, c, p, l, Q) {
			this.minX = b;
			this.minY = c;
			this.maxX = p;
			this.maxY = l;
			this.srid = a.notNull(Q) ? Q : 8307
		},
		setEnableUTFGrid: function (a) {
			this.enableUTFGrid = a
		},
		setMapServerURL: function (a) {
			this.baseURL = a
		},
		validateTheme: function (b) {
			if (a.notNull(this.themesArray) &&
				0 < this.themesArray.length)
				for (var c = 0, p = this.themesArray.length; c < p; c++)
					if (b.name === this.themesArray[c].name)
						return a.util.Logger.warning("MAPVIEWER_9085", "OM.server.ServerMapRequest", "Theme [" + b.name + "] already existed."), !1;
			return !0
		},
		validateStyle: function (b) {
			if (a.notNull(this.stylesArray) && 0 < this.stylesArray.length)
				for (var c = 0, p = this.stylesArray.length; c < p; c++)
					if (b.styleName === this.stylesArray[c].styleName)
						return a.util.Logger.warning("MAPVIEWER_9086", "OM.server.ServerMapRequest", "Style [" + b.styleName +
							"] already existed."), !1;
			return !0
		},
		addTheme: function (b) {
			a.notNull(b) && "[object Object]" === Object.prototype.toString.call(b) ? this.validateTheme(b) && this.themesArray.push(b) : a.util.Logger.warning("MAPVIEWER_9087", "OM.server.ServerMapRequest", b)
		},
		addThemes: function (b) {
			if (a.notNull(b) && "[object Array]" === Object.prototype.toString.call(b))
				for (var c = 0, p = b.length; c < p; c++)
					this.addTheme(b[c]);
			else
				a.util.Logger.warning("MAPVIEWER_9088", "OM.server.ServerMapRequest", b.stringify())
		},
		addStyle: function (b) {
			a.notNull(b) &&
			"[object Object]" === Object.prototype.toString.call(b) ? this.validateStyle(b) && this.stylesArray.push(b) : a.util.Logger.warning("MAPVIEWER_9089", "OM.server.ServerMapRequest", b)
		},
		addStyles: function (b) {
			if (a.notNull(b) && "[object Array]" === Object.prototype.toString.call(b))
				for (var c = 0, p = b.length; c < p; c++)
					this.addStyle(b[c]);
			else
				a.util.Logger.warning("MAPVIEWER_9088", "OM.server.ServerMapRequest", b.stringify())
		},
		setProperties: function (a) {
			for (var b in a)
				if (a.hasOwnProperty(b))
					if ("datasource" === b || "dataSource" ===
						b)
						this.datasource = a[b];
					else if ("antialiase" === b || "antiAliase" === b)
						this.antialiase = a[b];
					else if ("transparent" === b)
						this.transparent = a[b];
					else if ("bgcolor" === b || "bgColor" === b)
						this.bgcolor = a[b];
					else if ("basemap" === b || "baseMap" === b)
						this.basemap = a[b];
					else if ("width" === b || "imageWidth" === b)
						this.width = Number(a[b]);
					else if ("height" === b || "imageHeight" === b)
						this.height = Number(a[b]);
					else if ("utfgridresolution" === b || "UTFGridResolution" === b)
						this.greid_res = a[b];
					else if ("enableutfgrid" === b || "enableUTFGrid" === b)
						this.enableUTFGrid =
							a[b];
					else if ("isclienttilereq" === b || "isClientTileReq" === b)
						this.isclienttilereq = a[b];
					else if ("applicationId" === b || "applicationID" === b)
						this.applicationID = a[b];
					else if ("tileserverurl" === b || "tileServerURL" === b)
						this.tileServerURL = a[b]
		},
		toXMLString_Themes: function (b) {
			if (a.isNull(this.themesArray) || 1 > this.themesArray.length)
				return "";
			for (var c = "\x3cthemes\x3e", p = 0, l = this.themesArray.length; p < l; p++) {
				var Q = this.themesArray[p];
				a.notNull(Q) && (c = Q.type === a.server.ServerTheme.TYPE_GEORASTER ? c + Q.toXMLString(b) :
						c + Q.toXMLString())
			}
			return c + "\x3c/themes\x3e"
		},
		toXMLString_Styles: function () {
			if (a.isNull(this.stylesArray) || 1 > this.stylesArray.length)
				return "";
			for (var b = "\x3cstyles\x3e", c = 0, p = this.stylesArray.length; c < p; c++)
				b += this.stylesArray[c].toXMLString();
			return b + "\x3c/styles\x3e"
		},
		hasTheme: function (b) {
			"string" !== typeof b && a.util.Logger.warning("MAPVIEWER_9090", "OM.server.ServerMapRequest", b);
			if (a.isNull(this.themesArray))
				return !1;
			for (var c = 0, p = this.themesArray.length; c < p; c++)
				if (this.themesArray[c].name.toLowerCase() ===
					b.toLowerCase())
					return !0
		},
		getTheme: function (b) {
			for (var c = 0, p = this.themesArray.length; c < p; c++)
				if (b === this.themesArray[c].name)
					return this.themesArray[c];
			a.util.Logger.warning("MAPVIEWER_9091", "OM.server.ServerMapRequest", "Theme [" + b + "] not found.");
			return null
		},
		getThemes: function () {
			return this.themesArray
		},
		setBindingParameters: function (b) {
			for (var c = null, p = 0, l = b.length; p < l; p++) {
				var c = b[p],
				Q;
				for (Q in c) {
					var A = this.getTheme(Q.trim());
					a.notNull(A) && A.setBindingParameters(c[Q.trim()])
				}
			}
		},
		clone: function () {
			var b = {};
			a.$.extend(b, this);
			return b
		},
		getServerURL: function () {
			return !0 === this.isclienttilereq || "true" === this.isclienttilereq ? a.notNull(this.tileServerURL) ? this.tileServerURL : this.baseURL + "/omserver" : a.isNull(this.baseURL) ? "http://" + document.location.host + "/mapviewer/omserver" : this.baseURL + "/omserver"
		},
		toXMLString: function () {
			var b = this.getServerURL(),
			c;
			c = '\x3cmap_request width\x3d"' + (a.notNull(this.width) ? this.width + '"' : '"600"');
			c += ' height\x3d"' + (a.notNull(this.height) ? this.height + '"' : '"400"');
			c += !0 ===
			this.isclienttilereq || "true" === this.isclienttilereq ? ' isclienttilereq\x3d"true"' : "";
			c += ' format\x3d"' + (a.isNull(this.format) ? 'PNG_STREAM"' : this.format + '"');
			c += a.isNull(this.datasource) ? "" : ' datasource\x3d"' + this.datasource + '"';
			c += a.isNull(this.bgcolor) ? "" : ' bgcolor\x3d"' + encodeURIComponent(this.bgcolor) + '"';
			c += a.isNull(this.basemap) ? "" : ' basemap\x3d"' + this.basemap + '"';
			c += a.isNull(this.transparent) ? "" : ' transparent\x3d"' + this.transparent + '"';
			c += a.isNull(this.antialiase) ? "" : ' antialiase\x3d"' + this.antialiase +
			'"';
			c += a.isNull(this.applicationID) ? "" : ' applicationID\x3d"' + this.applicationID + '"';
			c = c + "\x3e" + ('\x3cbox srsName\x3d"' + (a.isNull(this.srid) ? "SDO:8307" : "SDO:" + this.srid + '"\x3e'));
			c += "\x3ccoordinates\x3e" + this.minX + "," + this.minY + "," + this.maxX + "," + this.maxY + "\x3c/coordinates\x3e";
			c += "\x3c/box\x3e";
			var p = this.srid;
			a.isNull(p) && (p = 8307);
			var p = new a.geometry.Rectangle(this.minX, this.minY, this.maxX, this.maxY, p),
			p = this.toXMLString_Themes(p),
			l = this.toXMLString_Styles(),
			b = b + '?xml_request\x3d\x3c?xml version\x3d"1.0" standalone\x3d"yes"?\x3e' +
				c + encodeURIComponent(p) + encodeURIComponent(l);
			this.enableUTFGrid && (c = ' grid_id\x3d"' + a.util.MiscUtil.md5Hash(b) + '" grid_res\x3d"' + this.grid_res + '"', p = b.indexOf("PNG_STREAM"), b = b.substring(0, p + 11) + c + b.substring(p + 11));
			return b + "\x3c/map_request\x3e"
		}
	});
	a.server.ServerFeature = a.Class.extend({
		initialize: function (a) {
			this.name = a;
			this.dataSource = null
		},
		setDataSourceName: function (a) {
			this.dataSource = a
		},
		getDataSourceName: function () {
			return this.dataSource
		},
		toXMLString: function () {
			return "\x3cfeature /\x3e"
		}
	});
	a.server.ServerTheme = a.Class.extend({
		initialize: function (a, b) {
			this.name = a;
			this.type = b;
			this.dataSource = null
		},
		setDataSourceName: function (a) {
			this.dataSource = a
		},
		getDataSourceName: function () {
			return this.dataSource
		},
		setName: function (a) {
			this.name = a
		}
	});
	a.server.ServerTheme.TYPE_JDBC = "jdbc";
	a.server.ServerTheme.TYPE_PREDEFINED = "predefined";
	a.server.ServerTheme.TYPE_GEORASTER = "georaster";
	a.server.ServerTheme.TYPE_IMAGE = "image";
	a.server.ServerTheme.TYPE_NETWORK = "network";
	a.server.ServerTheme.TYPE_TOPOLOGY = "topology";
	a.server.ServerTheme.TYPE_WFS = "wfs";
	a.server.ServerTheme.TYPE_WMS = "wms";
	a.server.ServerTheme.TYPE_WMTS = "wmts";
	a.server.ServerTheme.TYPE_MAPCACHE = "mapcache";
	a.server.ServerPredefinedTheme = a.server.ServerTheme.extend({
		initialize: function z(b) {
			z.base.call(this, b, a.server.ServerTheme.TYPE_PREDEFINED);
			this.bindingParams = null
		},
		toXMLString: function () {
			var b = this.name;
			if (a.isNull(b))
				a.util.Logger.warning("MAPVIEWER_9092", "OM.server.ServerPredefinedTheme");
			else {
				var c = this.bindingParams,
				b = '\x3ctheme name\x3d"' +
					b.toUpperCase() + '"\x3e';
				if (a.notNull(c)) {
					for (var l = "", Q = 0, A = c.length; Q < A; Q++) {
						var B = c[Q],
						G = B.value,
						B = B.type;
						a.notNull(G) && a.notNull(B) ? l += '\x3cparameter value\x3d"' + G + '" type\x3d"' + B + '"/\x3e' : a.util.Logger.warning("MAPVIEWER_9093", "OM.server.ServerPredefinedTheme")
					}
					a.notNull(l) && (l = "\x3cbinding_parameters\x3e" + l + "\x3c/binding_parameters\x3e");
					b += l
				}
				return b + "\x3c/theme\x3e"
			}
		},
		setBindingParameters: function (b) {
			a.isNull(b) || 0 === b.length ? a.util.Logger.warning("MAPVIEWER_9094", "OM.server.ServerPredefinedTheme",
				b.stringify()) : this.bindingParams = b
		}
	});
	a.server.ServerJDBCTheme = a.server.ServerTheme.extend({
		initialize: function p(b) {
			p.base.call(this, b, a.server.ServerTheme.TYPE_JDBC);
			this.sql = this.label_style = this.label_column = this.jdbc_srid = this.yColumn = this.xColumn = this.geomColumn = null;
			this.executeAsis = !1;
			this.geomColumn = null;
			this.infoColumns = [];
			a.util.Logger.warning("MAPVIEWER_9083", "OM.server.ServerJDBCTheme.initialize")
		},
		addInfoColumn: function (a) {
			this.infoColumns.push(a)
		},
		setQuery: function (a) {
			this.sql = a
		},
		setExecuteAsis: function (a) {
			this.executeAsis = !0 === a || "true" === a
		},
		setXColumnName: function (a) {
			this.xColumn = a
		},
		setYColumnName: function (a) {
			this.yColumn = a
		},
		setRenderingStyleName: function (a) {
			this.renderingStyleName = a
		},
		setLabelColumnName: function (a) {
			this.label_column = a
		},
		setLabelStyleName: function (a) {
			this.label_style = a
		},
		setRenderingStyleValueColumns: function (a) {
			this.renderingStyleValueColumns = a
		},
		setSRID: function (a) {
			this.jdbc_srid = a
		},
		setGeometryColumnName: function (a) {
			this.geomColumn = a
		},
		toXMLString_JDBC_Query: function () {
			var b;
			b = "\x3cjdbc_query" + (a.notNull(this.dataSource) ? ' datasource\x3d"' + this.dataSource + '"' : "");
			b += a.notNull(this.geomColumn) ? ' spatial_column\x3d"' + this.geomColumn + '"' : "";
			b += a.notNull(this.xColumn) ? ' x_column\x3d"' + this.xColumn + '"' : "";
			b += a.notNull(this.yColumn) ? ' y_column\x3d"' + this.yColumn + '"' : "";
			b += a.notNull(this.jdbc_srid) ? ' jdbc_srid\x3d"' + this.jdbc_srid + '"' : "";
			b += a.notNull(this.label_column) ? ' label_column\x3d"' + this.label_column + '"' : "";
			b += a.notNull(this.label_style) ? ' label_style\x3d"' + this.label_style +
			'"' : "";
			b += !0 === this.executeAsis ? ' asis\x3d"true"' : "";
			b = b + "\x3e" + (a.notNull(this.sql) ? this.sql : "");
			var c = "";
			if (0 < this.infoColumns.length) {
				for (var Q = this.infoColumns, A = 0, B = Q.length; A < B; A++)
					var G = Q[A], c = c + ('\x3cfield column\x3d"' + G.column + '" name\x3d"' + G.name + '"/\x3e');
				c = "\x3chidden_info\x3e" + c + "\x3c/hidden_info\x3e"
			}
			b += c;
			return b += "\x3c/jdbc_query\x3e"
		},
		toXMLString_Rendering: function () {
			if (a.isNull(this.renderingStyleName))
				return "";
			var b;
			b = "\x3crendering\x3e\x3cstyle " + ('name\x3d"' + this.renderingStyleName +
					'"');
			a.notNull(this.renderingStyleValueColumns) && (b += ' value_columns\x3d"' + this.renderingStyleValueColumns + '"');
			return b + "/\x3e\x3c/rendering\x3e"
		},
		toXMLString: function () {
			if (a.isNull(this.name))
				return a.util.Logger.warning("MAPVIEWER_9095", "OM.server.ServerJDBCTheme"), "";
			var b = this.name,
			c = this.toXMLString_JDBC_Query(),
			Q = this.toXMLString_Rendering(),
			b = '\x3ctheme name\x3d"' + b.toUpperCase() + '"\x3e';
			return b + (c + Q + "\x3c/theme\x3e")
		}
	});
	a.server.ServerJDBCGeorasterTheme = a.server.ServerTheme.extend({
		initialize: function l(b) {
			l.base.call(this,
				b, a.server.ServerTheme.TYPE_GEORASTER);
			this.polygonMaskSRID = this.polygonMask = this.rasterBands = this.rasterPyramid = this.rasterTable = this.rasterId = this.jdbc_srid = this.georColumn = this.baseTable = null;
			this.transparentNoData = !1;
			this.pmaskJoinGeorColumn = this.pmaskJoinColumn = this.pmaskQCondition = this.pmaskGeomColumn = this.pmaskTable = this.alphaBand = null;
			this.reprojMode = "BILINEAR";
			this.filterReprojResult = !1;
			this.renderInterpolationHint = "NEAREST_NEIGHBOR";
			this.sql = null;
			this.executeAsis = !1;
			this.imgOperationParameters =
				this.imgOperationNames = this.bindingParameters = null;
			this.imgOperationGlobalStats = !1;
			this.bitmapMasks = null;
			this.isVirtualMosaic = !1;
			this.vmParams = {
				tables: null,
				sql: null,
				colorBalance: "NONE",
				fillGap: !0,
				noData: !0,
				resampling: "BILINEAR",
				resamplingTolerance: .5,
				resolutionFilter: !0,
				minStretchValue: 0,
				maxStretchValue: 255,
				mean: 1,
				standardDeviation: 1,
				commonPointRule: "START",
				srid: 8307
			}
		},
		setQuery: function (a) {
			this.sql = a
		},
		setExecuteAsis: function (a) {
			this.executeAsis = !0 === a || "true" === a
		},
		setSRID: function (a) {
			this.jdbc_srid =
				a
		},
		setBaseTable: function (a) {
			this.baseTable = a
		},
		setGeorasterColumn: function (a) {
			this.georColumn = a
		},
		setRasterId: function (a) {
			this.rasterId = a
		},
		setRasterDataTable: function (a) {
			this.rasterTable = a
		},
		setRasterPyramid: function (a) {
			this.rasterPyramid = a
		},
		setRasterBands: function (a) {
			this.rasterBands = a
		},
		setAlphaBand: function (a) {
			this.alphaBand = a
		},
		setPolygonMaskCoordinates: function (a) {
			this.polygonMask = a
		},
		setPolygonMaskSRID: function (a) {
			this.polygonMaskSRID = a
		},
		clearPolygonMaskTableParameters: function () {
			this.pmaskJoinGeorColumn =
				this.pmaskJoinColumn = this.pmaskQCondition = this.pmaskGeomColumn = this.pmaskTable = null
		},
		setPolygonMaskTableParameters: function (a, b, c, B, G) {
			this.pmaskTable = a;
			this.pmaskGeomColumn = b;
			this.pmaskQCondition = c;
			this.pmaskJoinColumn = B;
			this.pmaskJoinGeorColumn = G
		},
		setImageOperations: function (a, b) {
			this.imgOperationNames = a;
			this.imgOperationParameters = b
		},
		setImageOperationsUseGlobalStats: function (a) {
			this.imgOperationGlobalStats = a
		},
		setBindingParameters: function (b) {
			a.isNull(b) || 0 === b.length ? a.util.Logger.warning("MAPVIEWER_9094",
				"OM.server.ServerJDBCGeorasterTheme", b.stringify()) : this.bindingParameters = b
		},
		setAsVirtualMosaic: function (a) {
			this.isVirtualMosaic = a
		},
		setVMapplyResolutionFilter: function (a) {
			this.vmParams.resolutionFilter = a
		},
		setVMcolorBalance: function (a) {
			this.vmParams.colorBalance = a
		},
		setVMcommonPointRule: function (a) {
			this.vmParams.commonPointRule = a
		},
		setVMfillGap: function (a) {
			this.vmParams.fillGap = a
		},
		setVMincludeNODATA: function (a) {
			this.vmParams.noData = a
		},
		setVMmaxStretchValue: function (a) {
			this.vmParams.maxStretchValue = a
		},
		setVMmean: function (a) {
			this.vmParams.mean = a
		},
		setVMminStretchValue: function (a) {
			this.vmParams.minStretchValue = a
		},
		setVMresamplingMode: function (a) {
			this.vmParams.resampling = a
		},
		setVMresamplingTolerance: function (a) {
			this.vmParams.resamplingTolerance = a
		},
		setVMsql: function (a) {
			this.vmParams.sql = a
		},
		setVMsrid: function (a) {
			this.vmParams.srid = a
		},
		setVMstandardDeviation: function (a) {
			this.vmParams.standardDeviation = a
		},
		setVMtables: function (a) {
			this.vmParams.tables = a
		},
		toXMLString_JDBC_Query: function () {
			var b;
			b = "\x3cjdbc_georaster_query" +
				(a.notNull(this.dataSource) ? ' datasource\x3d"' + this.dataSource + '"' : "");
			b += a.notNull(this.baseTable) ? ' georaster_table\x3d"' + this.baseTable + '"' : "";
			b += a.notNull(this.georColumn) ? ' georaster_column\x3d"' + this.georColumn + '"' : "";
			b += a.notNull(this.jdbc_srid) ? ' jdbc_srid\x3d"' + this.jdbc_srid + '"' : "";
			b += a.notNull(this.rasterId) ? ' raster_id\x3d"' + this.rasterId + '"' : "";
			b += a.notNull(this.rasterTable) ? ' raster_table\x3d"' + this.rasterTable + '"' : "";
			b += a.notNull(this.rasterPyramid) ? ' raster_pyramid\x3d"' + this.rasterPyramid +
			'"' : "";
			b += a.notNull(this.rasterBands) ? ' raster_bands\x3d"' + this.rasterBands + '"' : "";
			b += a.notNull(this.polygonMask) ? ' polygon_mask\x3d"' + this.polygonMask + '"' : "";
			b += a.notNull(this.polygonMaskSRID) ? ' polygon_mask_srid\x3d"' + this.polygonMaskSRID + '"' : "";
			b += a.notNull(this.pmaskTable) ? ' polygon_mask_table\x3d"' + this.pmaskTable + '"' : "";
			b += a.notNull(this.pmaskGeomColumn) ? ' polygon_mask_geomcolumn\x3d"' + this.pmaskGeomColumn + '"' : "";
			b += a.notNull(this.pmaskQCondition) ? ' polygon_mask_condition\x3d"' + this.pmaskQCondition +
			'"' : "";
			b += a.notNull(this.pmaskJoinColumn) ? ' polygon_mask_joingeomcolumn\x3d"' + this.pmaskJoinColumn + '"' : "";
			b += a.notNull(this.pmaskJoinGeorColumn) ? ' polygon_mask_joingeorcolumn\x3d"' + this.pmaskJoinGeorColumn + '"' : "";
			b += !0 === this.transparentNoData ? ' transparent_nodata\x3d"true"' : "";
			b += a.notNull(this.alphaBand) ? ' alpha_band\x3d"' + this.alphaBand + '"' : "";
			b += a.notNull(this.reprojMode) && "BILINEAR" !== this.reprojMode ? ' reproj_mode\x3d"' + this.reprojMode + '"' : "";
			b += !0 === this.filterReprojResult ? ' filter_reproj\x3d"true"' :
			"";
			b += a.notNull(this.renderInterpolationHint) && "NEAREST_NEIGHBOR" !== this.renderInterpolationHint ? ' render_interpolation_hint\x3d"' + this.renderInterpolationHint + '"' : "";
			b += !0 === this.executeAsis ? ' asis\x3d"true"' : "";
			b = b + "\x3e" + (a.notNull(this.sql) ? this.sql : "");
			return b += "\x3c/jdbc_georaster_query\x3e"
		},
		toXMLString_Binding_Parameters: function (b) {
			var c = "",
			A = this.bindingParameters;
			if (a.notNull(A)) {
				for (var B = 0, G = A.length; B < G; B++) {
					var Y = A[B],
					W = Y.value,
					Y = Y.type;
					a.notNull(W) && a.notNull(Y) ? "tile_mbr" !== Y.toLowerCase() ?
					c += '\x3cparameter value\x3d"' + W + '" type\x3d"' + Y + '"/\x3e' : a.isNull(b) ? c += '\x3cparameter value\x3d"' + W + '" type\x3d"' + Y + '"/\x3e' : (W = "srid\x3d" + b.getSRID() + ":coords\x3d" + b.getMinX() + "," + b.getMinY() + "," + b.getMaxX() + "," + b.getMaxY(), c += '\x3cparameter value\x3d"' + W + '" type\x3d"Rectangle"/\x3e') : a.util.Logger.warning("MAPVIEWER_9093", "OM.server.ServerJDCGeorasterTheme")
				}
				a.notNull(c) && 0 < c.length && (c = "\x3cbinding_parameters\x3e" + c + "\x3c/binding_parameters\x3e")
			}
			return c
		},
		toXMLString_Image_Operations: function () {
			var b =
				"";
			if (a.notNull(this.imgOperationNames) && 0 < this.imgOperationNames.length) {
				for (var b = this.imgOperationGlobalStats ? b + '\x3coperations use_global_stats\x3d"true"\x3e' : b + "\x3coperations\x3e", c = 0; c < this.imgOperationNames.length; c++) {
					var A = this.imgOperationNames[c],
					b = b + ('\x3coperation name\x3d"' + A + '"\x3e');
					if (a.notNull(this.imgOperationParameters) && (A = this.imgOperationParameters[A], a.notNull(A)))
						for (var B = 0; B < A.length; B++)
							b += '\x3cparameter name\x3d"' + A[B].name + '" value\x3d"' + A[B].value + '"/\x3e';
					b += "\x3c/operation\x3e"
				}
				b +=
				"\x3c/operations\x3e"
			}
			return b
		},
		toXMLString_Virtual_Mosaic_Parameters: function () {
			var a = "";
			if (this.isVirtualMosaic) {
				a = a + "\x3cvirtual_mosaic" + (' srid\x3d"' + this.vmParams.srid + '"');
				this.vmParams.colorBalance && "NONE" !== this.vmParams.colorBalance.toUpperCase() && (a += ' color_balance\x3d"' + this.vmParams.colorBalance + '"', "LINEARSTRETCHING" === this.vmParams.colorBalance.toUpperCase() ? (a += ' min_stretch_value\x3d"' + this.vmParams.minStretchValue + '"', a += ' max_stretch_value\x3d"' + this.vmParams.maxStretchValue + '"') :
					"NORMALIZATION" === this.vmParams.colorBalance.toUpperCase() && (a += ' mean\x3d"' + this.vmParams.mean + '"', a += ' standard_deviation\x3d"' + this.vmParams.standardDeviation + '"'));
				this.vmParams.commonPointRule && "START" !== this.vmParams.commonPointRule.toUpperCase() && (a += ' common_point_rule\x3d"' + this.vmParams.commonPointRule + '"');
				this.vmParams.fillGap || (a += ' fill_gap\x3d"false"');
				this.vmParams.noData && (a += ' nodata_cell\x3d"true"');
				this.vmParams.resolutionFilter || (a += ' resolution_filter\x3d"false"');
				this.vmParams.resampling &&
				"BILINEAR" !== this.vmParams.resampling.toUpperCase() && (a += ' resampling_mode\x3d"' + this.vmParams.resampling + '"');
				.5 !== this.vmParams.resamplingTolerance && (a += ' resampling_tolerance\x3d"' + this.vmParams.resamplingTolerance + '"');
				a += "\x3e";
				if (null !== this.vmParams.sql)
					a += "\x3csql\x3e" + this.vmParams.sql + "\x3c/sql\x3e";
				else {
					for (var a = a + "\x3ctables\x3e", b = 0; b < this.vmParams.tables.length; b++)
						a += '\x3ctable name\x3d"' + this.vmParams.tables[b].name + '" georaster_column\x3d"' + this.vmParams.tables[b].georaster_column +
						'"', null !== this.vmParams.tables[b].query_condition && "undefined" !== typeof this.vmParams.tables[b].query_condition && (a += ' query_condition\x3d"' + this.vmParams.tables[b].query_condition + '"'), a += " /\x3e";
					a += "\x3c/tables\x3e\n"
				}
				a += "\x3c/virtual_mosaic\x3e"
			}
			return a
		},
		toXMLString: function (b) {
			if (a.isNull(this.name))
				return a.util.Logger.warning("MAPVIEWER_9095", "OM.server.ServerJDBCGeorasterTheme"), "";
			var c = this.name,
			A = this.toXMLString_JDBC_Query(),
			B = this.toXMLString_Image_Operations();
			b = this.toXMLString_Binding_Parameters(b);
			var G = this.toXMLString_Virtual_Mosaic_Parameters(),
			c = '\x3ctheme name\x3d"' + c.toUpperCase() + '"\x3e\n';
			return c + (A + B + b + G + "\x3c/theme\x3e")
		}
	});
	a.wmts.WMTSUtil = a.wmts.WMTSUtil || {};
	a.wmts.WMTSUtil.deriveSRID = function (b) {
		if (a.isNull(b))
			console.log("warning");
		else {
			var c = b.replace(/urn:(.-)?ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$2:$4"),
			A = c.indexOf(":");
			if (0 > A)
				return -1;
			b = c.substring(0, A).toUpperCase();
			c = c.substring(A + 1).toUpperCase();
			if ("OGC" === b || "CRS" === b) {
				if ("84" === c || "CRS84" === c)
					return 8307
			} else if ("EPSG" ===
				b)
				return "3857" === c ? 3857 : "4326" === c ? 8307 : parseInt(c)
		}
	};
	a.wmts.WMTSUtil.findIndex = function (a, b) {
		var c;
		return a.every(function (B, G) {
			c = G;
			return !b(B, G, a)
		}) ? -1 : c
	};
	a.wmts.WMTSUtil.find = function (b, c) {
		if (a.isNull(b))
			return null;
		for (var A = b.length >>> 0, B, G = 0; G < A; G++)
			if (B = b[G], c(B, G, b))
				return B;
		return null
	};
	a.wmts.WMTSUtil.includes = function (a, b) {
		return 0 <= a.indexOf(b)
	};
	a.wmts.WMTSUtil.linearFindNearest = function (a, b, c) {
		var B = a.length;
		if (a[0] <= b)
			return 0;
		if (!(b <= a[B - 1]))
			if (0 < c)
				for (c = 1; c < B; ++c) {
					if (a[c] < b)
						return c -
						1
				}
			else if (0 > c)
				for (c = 1; c < B; ++c) {
					if (a[c] <= b)
						return c
				}
			else
				for (c = 1; c < B; ++c) {
					if (a[c] == b)
						return c;
					if (a[c] < b)
						return a[c - 1] - b < b - a[c] ? c - 1 : c
				}
		return B - 1
	};
	a.wmts.WMTSUtil.isSorted = function (a, b, c) {
		var B = b || ol.array.numberSafeCompareFunction;
		return a.every(function (b, Q) {
			if (0 === Q)
				return !0;
			var W = B(a[Q - 1], b);
			return !(0 < W || c && 0 === W)
		})
	};
	a.wmts.WMTSUtil.RequestEncoding = {
		KVP: "KVP",
		REST: "REST"
	};
	a.wmts.WMTSUtil.readHref = function (a) {
		return a.getAttributeNS("http://www.w3.org/1999/xlink", "href")
	};
	a.wmts.WMTSUtil.boundingExtent =
	function (b) {
		for (var c = [Infinity, Infinity, -Infinity, -Infinity], A = 0, B = b.length; A < B; ++A)
			a.wmts.WMTSUtil.extendCoordinate(c, b[A]);
		return c
	};
	a.wmts.WMTSUtil.extendCoordinate = function (a, b) {
		b[0] < a[0] && (a[0] = b[0]);
		b[0] > a[2] && (a[2] = b[0]);
		b[1] < a[1] && (a[1] = b[1]);
		b[1] > a[3] && (a[3] = b[1])
	};
	a.wmts.WMTSUtil.TileGrid = function (b) {
		this.resolutions_ = b.resolutions;
		console.assert(a.wmts.WMTSUtil.isSorted(this.resolutions_, function (a, b) {
				return b - a
			}, !0), 17);
		this.origin_ = b.origin !== c ? b.origin : null;
		this.origins_ = null;
		b.origins !==
		c && (this.origins_ = b.origins, console.assert(this.origins_.length == this.resolutions_.length, 20));
		var Q = b.extent;
		Q === c || this.origin_ || this.origins_ || (this.origin_ = a.wmts.Extent.getTopLeft(Q));
		console.assert(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18);
		this.tileSizes_ = null;
		b.tileSizes !== c && (this.tileSizes_ = b.tileSizes, console.assert(this.tileSizes_.length == this.resolutions_.length, 19));
		this.tileSize_ = b.tileSize !== c ? b.tileSize : this.tileSizes_ ? null : 256;
		console.assert(!this.tileSize_ &&
			this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22);
		this.extent_ = Q !== c ? Q : null
	};
	a.wmts.WMTSUtil.optionsFromCapabilities = function (b, Q) {
		console.assert(Q.layer, 'config "layer" must not be null');
		var A = a.wmts.WMTSUtil.find(b.Contents.Layer, function (a, b, c) {
			return a.Identifier == Q.layer
		});
		console.assert(A, "found a matching layer in Contents/Layer");
		console.assert(0 < A.TileMatrixSetLink.length, "layer has TileMatrixSetLink");
		var B = b.Contents.TileMatrixSet,
		G,
		Y;
		G = 1 < A.TileMatrixSetLink.length ? "projection" in Q ?
			a.wmts.WMTSUtil.findIndex(A.TileMatrixSetLink, function (b, c, K) {
				return a.wmts.WMTSUtil.find(B, function (a) {
					return a.Identifier == b.TileMatrixSet
				}).SupportedCRS.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3") == Q.projection
			}) : a.wmts.WMTSUtil.findIndex(A.TileMatrixSetLink, function (a, b, c) {
				return a.TileMatrixSet == Q.matrixSet
			}) : 0;
		0 > G && (G = 0);
		Y = A.TileMatrixSetLink[G].TileMatrixSet;
		console.assert(Y, "TileMatrixSet must not be null");
		var W = A.Format[0];
		"format" in Q && (W = Q.format);
		G = a.wmts.WMTSUtil.findIndex(A.Style,
				function (a, b, c) {
				return "style" in Q ? a.Title == Q.style : a.isDefault
			});
		0 > G && (G = 0);
		G = A.Style[G].Identifier;
		var K = {};
		"Dimension" in A && A.Dimension.forEach(function (b, l, W) {
			l = b.Identifier;
			W = b.Default;
			W !== c ? console.assert(a.wmts.WMTSUtil.includes(b.Value, W), "default value contained in values") : W = b.Value[0];
			console.assert(W !== c, "value could be found");
			K[l] = W
		});
		var q = a.wmts.WMTSUtil.find(b.Contents.TileMatrixSet, function (a, b, c) {
			return a.Identifier == Y
		});
		console.assert(q, "found matrixSet in Contents/TileMatrixSet");
		var t = a.wmts.WMTSUtil.deriveSRID(q.SupportedCRS),
		I = a.universe.Universe.getSpecs(t),
		aa = A.WGS84BoundingBox,
		ba = A.BoundingBox;
		a.isNull(aa) && a.isNull(ba) && (ba = a.notNull(I.bounds) ? I.bounds.coordinates : null, ba = a.notNull(ba) ? [ba[0], ba[1], ba[2], ba[3]] : null);
		console.assert(a.notNull(aa) || a.notNull(ba), "Data bounding box cannot be retrieved");
		var t = a.notNull(aa) ? new a.geometry.Rectangle(aa[0], aa[1], aa[2], aa[3], 8307) : new a.geometry.Rectangle(ba[0], ba[1], ba[2], ba[3], t),
		q = a.wmts.WMTSUtil.createFromCapabilitiesMatrixSet(q,
				t.getMBR()),
		R = [],
		t = Q.requestEncoding,
		t = t !== c ? t : "";
		console.assert(a.wmts.WMTSUtil.includes(["REST", "RESTful", "KVP", ""], t), 'requestEncoding (%s) is one of "REST", "RESTful", "KVP" or ""', t);
		if ("OperationsMetadata" in b && "GetTile" in b.OperationsMetadata) {
			aa = b.OperationsMetadata.GetTile.DCP.HTTP.Get;
			console.assert(1 <= aa.length);
			for (var ba = 0, qa = aa.length; ba < qa; ++ba) {
				var ua = a.wmts.WMTSUtil.find(aa[ba].Constraint, function (a) {
					return "GetEncoding" == a.name
				}).AllowedValues.Value;
				console.assert(1 <= ua.length);
				"" ===
				t && (t = ua[0]);
				if (t === a.wmts.WMTSUtil.RequestEncoding.KVP)
					a.wmts.WMTSUtil.includes(ua, a.wmts.WMTSUtil.RequestEncoding.KVP) && R.push(aa[ba].href);
				else
					break
			}
		}
		0 === R.length && (t = a.wmts.WMTSUtil.RequestEncoding.REST, A.ResourceURL.forEach(function (a) {
				"tile" === a.resourceType && (W = a.format, R.push(a.template))
			}));
		console.assert(0 < R.length, "At least one URL found");
		return {
			urls: R,
			layer: Q.layer,
			matrixSet: Y,
			format: W,
			projection: I,
			requestEncoding: t,
			tileGrid: q,
			style: G,
			dimensions: K
		}
	};
	a.wmts.WMTSUtil.readDecimal = function (b) {
		b =
			a.util.XMLUtil.getAllTextContent(b, !1);
		return parseFloat(b)
	};
	a.wmts.WMTSUtil.readNonNegativeInteger = function (b) {
		b = a.util.XMLUtil.getAllTextContent(b, !1);
		return parseInt(b)
	};
	a.wmts.WMTSUtil.readString = function (b) {
		return a.util.XMLUtil.getAllTextContent(b, !1).trim()
	};
	a.wmts.WMTSUtil.createFromCapabilitiesMatrixSet = function (b, c) {
		var A = [],
		B = [],
		G = [],
		Y = [],
		W = [],
		K = a.wmts.WMTSUtil.deriveSRID(b.SupportedCRS),
		q = a.universe.Universe.getMPU(K);
		b.TileMatrix.sort(function (a, b) {
			return b.ScaleDenominator - a.ScaleDenominator
		});
		b.TileMatrix.forEach(function (a, b, c) {
			B.push(a.Identifier);
			b = 2.8E-4 * a.ScaleDenominator / q;
			c = a.TileWidth;
			var K = a.TileHeight;
			G.push(a.TopLeftCorner);
			A.push(b);
			Y.push(c === K ? c : [c, K]);
			W.push([a.MatrixWidth, -a.MatrixHeight])
		});
		return {
			extent: c,
			origins: G,
			resolutions: A,
			matrixIds: B,
			tileSizes: Y,
			sizes: W
		}
	};
	a.wmts.WMTSOws = a.wmts.OWSFormat || {};
	a.wmts.WMTSOws.NAMESPACE = "http://www.opengis.net/ows/1.1";
	a.wmts.WMTSOws.readFromDocument = function (a) {
		console.assert(a.nodeType == Node.DOCUMENT_NODE, "doc.nodeType should be DOCUMENT");
		for (a = a.firstChild; a; a = a.nextSibling)
			if (a.nodeType == Node.ELEMENT_NODE)
				return this.readFromNode(a);
		return null
	};
	a.wmts.WMTSOws.readFromNode = function (b) {
		console.assert(b.nodeType == Node.ELEMENT_NODE, "node.nodeType should be ELEMENT");
		return (b = a.util.XMLUtil.pushParseAndPop({}, a.wmts.WMTSOws.PARSERS_, b, [])) ? b : null
	};
	a.wmts.WMTSOws.readAddress_ = function (b, c) {
		console.assert(b.nodeType == Node.ELEMENT_NODE, "node.nodeType should be ELEMENT");
		console.assert("Address" == b.localName, "localName should be Address");
		return a.util.XMLUtil.pushParseAndPop({}, a.wmts.WMTSOws.ADDRESS_PARSERS_, b, c)
	};
	a.wmts.WMTSOws.readAllowedValues_ = function (b, c) {
		console.assert(b.nodeType == Node.ELEMENT_NODE, "node.nodeType should be ELEMENT");
		console.assert("AllowedValues" == b.localName, "localName should be AllowedValues");
		return a.util.XMLUtil.pushParseAndPop({}, a.wmts.WMTSOws.ALLOWED_VALUES_PARSERS_, b, c)
	};
	a.wmts.WMTSOws.readConstraint_ = function (b, Q) {
		console.assert(b.nodeType == Node.ELEMENT_NODE, "node.nodeType should be ELEMENT");
		console.assert("Constraint" ==
			b.localName, "localName should be Constraint");
		var A = b.getAttribute("name");
		return A ? a.util.XMLUtil.pushParseAndPop({
			name: A
		}, a.wmts.WMTSOws.CONSTRAINT_PARSERS_, b, Q) : c
	};
	a.wmts.WMTSOws.readContactInfo_ = function (b, c) {
		console.assert(b.nodeType == Node.ELEMENT_NODE, "node.nodeType should be ELEMENT");
		console.assert("ContactInfo" == b.localName, "localName should be ContactInfo");
		return a.util.XMLUtil.pushParseAndPop({}, a.wmts.WMTSOws.CONTACT_INFO_PARSERS_, b, c)
	};
	a.wmts.WMTSOws.readDcp_ = function (b, c) {
		console.assert(b.nodeType ==
			Node.ELEMENT_NODE, "node.nodeType should be ELEMENT");
		console.assert("DCP" == b.localName, "localName should be DCP");
		return a.util.XMLUtil.pushParseAndPop({}, a.wmts.WMTSOws.DCP_PARSERS_, b, c)
	};
	a.wmts.WMTSOws.readGet_ = function (b, Q) {
		console.assert(b.nodeType == Node.ELEMENT_NODE, "node.nodeType should be ELEMENT");
		console.assert("Get" == b.localName, "localName should be Get");
		var A = a.wmts.WMTSUtil.readHref(b);
		return A ? a.util.XMLUtil.pushParseAndPop({
			href: A
		}, a.wmts.WMTSOws.REQUEST_METHOD_PARSERS_, b, Q) : c
	};
	a.wmts.WMTSOws.readHttp_ =
	function (b, c) {
		console.assert(b.nodeType == Node.ELEMENT_NODE, "node.nodeType should be ELEMENT");
		console.assert("HTTP" == b.localName, "localName should be HTTP");
		return a.util.XMLUtil.pushParseAndPop({}, a.wmts.WMTSOws.HTTP_PARSERS_, b, c)
	};
	a.wmts.WMTSOws.readOperation_ = function (b, Q) {
		console.assert(b.nodeType == Node.ELEMENT_NODE, "node.nodeType should be ELEMENT");
		console.assert("Operation" == b.localName, "localName should be Operation");
		var A = b.getAttribute("name"),
		B = a.util.XMLUtil.pushParseAndPop({}, a.wmts.WMTSOws.OPERATION_PARSERS_,
				b, Q);
		if (!B)
			return c;
		Q[Q.length - 1][A] = B
	};
	a.wmts.WMTSOws.readOperationsMetadata_ = function (b, c) {
		console.assert(b.nodeType == Node.ELEMENT_NODE, "node.nodeType should be ELEMENT");
		console.assert("OperationsMetadata" == b.localName, "localName should be OperationsMetadata");
		return a.util.XMLUtil.pushParseAndPop({}, a.wmts.WMTSOws.OPERATIONS_METADATA_PARSERS_, b, c)
	};
	a.wmts.WMTSOws.readPhone_ = function (b, c) {
		console.assert(b.nodeType == Node.ELEMENT_NODE, "node.nodeType should be ELEMENT");
		console.assert("Phone" == b.localName,
			"localName should be Phone");
		return a.util.XMLUtil.pushParseAndPop({}, a.wmts.WMTSOws.PHONE_PARSERS_, b, c)
	};
	a.wmts.WMTSOws.readServiceIdentification_ = function (b, c) {
		console.assert(b.nodeType == Node.ELEMENT_NODE, "node.nodeType should be ELEMENT");
		console.assert("ServiceIdentification" == b.localName, "localName should be ServiceIdentification");
		return a.util.XMLUtil.pushParseAndPop({}, a.wmts.WMTSOws.SERVICE_IDENTIFICATION_PARSERS_, b, c)
	};
	a.wmts.WMTSOws.readServiceContact_ = function (b, c) {
		console.assert(b.nodeType ==
			Node.ELEMENT_NODE, "node.nodeType should be ELEMENT");
		console.assert("ServiceContact" == b.localName, "localName should be ServiceContact");
		return a.util.XMLUtil.pushParseAndPop({}, a.wmts.WMTSOws.SERVICE_CONTACT_PARSERS_, b, c)
	};
	a.wmts.WMTSOws.readServiceProvider_ = function (b, c) {
		console.assert(b.nodeType == Node.ELEMENT_NODE, "node.nodeType should be ELEMENT");
		console.assert("ServiceProvider" == b.localName, "localName should be ServiceProvider");
		return a.util.XMLUtil.pushParseAndPop({}, a.wmts.WMTSOws.SERVICE_PROVIDER_PARSERS_,
			b, c)
	};
	a.wmts.WMTSOws.readValue_ = function (b, c) {
		console.assert(b.nodeType == Node.ELEMENT_NODE, "node.nodeType should be ELEMENT");
		console.assert("Value" == b.localName, "localName should be Value");
		return a.wmts.WMTSUtil.readString(b)
	};
	a.wmts.WMTSOws.PARSERS_ = a.util.XMLUtil.makeStructureNS(a.wmts.WMTSOws.NAMESPACE, {
		ServiceIdentification: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSOws.readServiceIdentification_),
		ServiceProvider: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSOws.readServiceProvider_),
		OperationsMetadata: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSOws.readOperationsMetadata_)
	});
	a.wmts.WMTSOws.ADDRESS_PARSERS_ = a.util.XMLUtil.makeStructureNS(a.wmts.WMTSOws.NAMESPACE, {
		DeliveryPoint: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString),
		City: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString),
		AdministrativeArea: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString),
		PostalCode: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString),
		Country: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString),
		ElectronicMailAddress: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString)
	});
	a.wmts.WMTSOws.ALLOWED_VALUES_PARSERS_ = a.util.XMLUtil.makeStructureNS(a.wmts.WMTSOws.NAMESPACE, {
		Value: a.util.XMLUtil.makeObjectPropertyPusher(a.wmts.WMTSOws.readValue_)
	});
	a.wmts.WMTSOws.CONSTRAINT_PARSERS_ = a.util.XMLUtil.makeStructureNS(a.wmts.WMTSOws.NAMESPACE, {
		AllowedValues: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSOws.readAllowedValues_)
	});
	a.wmts.WMTSOws.CONTACT_INFO_PARSERS_ = a.util.XMLUtil.makeStructureNS(a.wmts.WMTSOws.NAMESPACE, {
		Phone: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSOws.readPhone_),
		Address: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSOws.readAddress_)
	});
	a.wmts.WMTSOws.DCP_PARSERS_ = a.util.XMLUtil.makeStructureNS(a.wmts.WMTSOws.NAMESPACE, {
		HTTP: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSOws.readHttp_)
	});
	a.wmts.WMTSOws.HTTP_PARSERS_ = a.util.XMLUtil.makeStructureNS(a.wmts.WMTSOws.NAMESPACE, {
		Get: a.util.XMLUtil.makeObjectPropertyPusher(a.wmts.WMTSOws.readGet_),
		Post: c
	});
	a.wmts.WMTSOws.OPERATION_PARSERS_ = a.util.XMLUtil.makeStructureNS(a.wmts.WMTSOws.NAMESPACE, {
		DCP: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSOws.readDcp_)
	});
	a.wmts.WMTSOws.OPERATIONS_METADATA_PARSERS_ = a.util.XMLUtil.makeStructureNS(a.wmts.WMTSOws.NAMESPACE, {
		Operation: a.wmts.WMTSOws.readOperation_
	});
	a.wmts.WMTSOws.PHONE_PARSERS_ = a.util.XMLUtil.makeStructureNS(a.wmts.WMTSOws.NAMESPACE, {
		Voice: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString),
		Facsimile: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString)
	});
	a.wmts.WMTSOws.REQUEST_METHOD_PARSERS_ = a.util.XMLUtil.makeStructureNS(a.wmts.WMTSOws.NAMESPACE, {
		Constraint: a.util.XMLUtil.makeObjectPropertyPusher(a.wmts.WMTSOws.readConstraint_)
	});
	a.wmts.WMTSOws.SERVICE_CONTACT_PARSERS_ = a.util.XMLUtil.makeStructureNS(a.wmts.WMTSOws.NAMESPACE, {
		IndividualName: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString),
		PositionName: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString),
		ContactInfo: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSOws.readContactInfo_)
	});
	a.wmts.WMTSOws.SERVICE_IDENTIFICATION_PARSERS_ = a.util.XMLUtil.makeStructureNS(a.wmts.WMTSOws.NAMESPACE, {
		Title: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString),
		ServiceTypeVersion: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString),
		ServiceType: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString)
	});
	a.wmts.WMTSOws.SERVICE_PROVIDER_PARSERS_ = a.util.XMLUtil.makeStructureNS(a.wmts.WMTSOws.NAMESPACE, {
		ProviderName: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString),
		ProviderSite: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readHref),
		ServiceContact: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSOws.readServiceContact_)
	});
	a.wmts.WMTSContents = a.wmts.WMTSContents || {};
	a.wmts.WMTSContents.NAMESPACE = "http://www.opengis.net/wmts/1.0";
	a.wmts.WMTSContents.readFromDocument = function (a) {
		console.assert(a.nodeType == Node.DOCUMENT_NODE, "doc.nodeType should be DOCUMENT");
		for (a = a.firstChild; a; a = a.nextSibling)
			if (a.nodeType == Node.ELEMENT_NODE)
				return this.readFromNode(a);
		return null
	};
	a.wmts.WMTSContents.readFromNode = function (b) {
		console.assert(b.nodeType == Node.ELEMENT_NODE, "node.nodeType should be ELEMENT");
		console.assert("Capabilities" == b.localName, "localName should be Capabilities");
		var c = b.getAttribute("version").trim(),
		A = a.wmts.WMTSOws.readFromNode(b);
		if (!A)
			return null;
		A.version = c;
		return (A = a.util.XMLUtil.pushParseAndPop(A, a.wmts.WMTSContents.PARSERS_, b, [])) ? A : null
	};
	a.wmts.WMTSContents.readContents_ = function (b, c) {
		console.assert(b.nodeType == Node.ELEMENT_NODE, "node.nodeType should be ELEMENT");
		console.assert("Contents" == b.localName, "localName should be Contents");
		return a.util.XMLUtil.pushParseAndPop({}, a.wmts.WMTSContents.CONTENTS_PARSERS_, b, c)
	};
	a.wmts.WMTSContents.readLayer_ = function (b, c) {
		console.assert(b.nodeType == Node.ELEMENT_NODE, "node.nodeType should be ELEMENT");
		console.assert("Layer" == b.localName, "localName should be Layer");
		return a.util.XMLUtil.pushParseAndPop({}, a.wmts.WMTSContents.LAYER_PARSERS_, b, c)
	};
	a.wmts.WMTSContents.readTileMatrixSet_ = function (b, c) {
		return a.util.XMLUtil.pushParseAndPop({},
			a.wmts.WMTSContents.TMS_PARSERS_, b, c)
	};
	a.wmts.WMTSContents.readStyle_ = function (b, Q) {
		var A = a.util.XMLUtil.pushParseAndPop({}, a.wmts.WMTSContents.STYLE_PARSERS_, b, Q);
		if (!A)
			return c;
		var B = "true" === b.getAttribute("isDefault");
		A.isDefault = B;
		return A
	};
	a.wmts.WMTSContents.readTileMatrixSetLink_ = function (b, c) {
		return a.util.XMLUtil.pushParseAndPop({}, a.wmts.WMTSContents.TMS_LINKS_PARSERS_, b, c)
	};
	a.wmts.WMTSContents.readDimensions_ = function (b, c) {
		return a.util.XMLUtil.pushParseAndPop({}, a.wmts.WMTSContents.DIMENSION_PARSERS_,
			b, c)
	};
	a.wmts.WMTSContents.readResourceUrl_ = function (a, b) {
		var c = a.getAttribute("format"),
		B = a.getAttribute("template"),
		G = a.getAttribute("resourceType"),
		Y = {};
		c && (Y.format = c);
		B && (Y.template = B);
		G && (Y.resourceType = G);
		return Y
	};
	a.wmts.WMTSContents.readWgs84BoundingBox_ = function (b, Q) {
		var A = a.util.XMLUtil.pushParseAndPop([], a.wmts.WMTSContents.WGS84_BBOX_READERS_, b, Q);
		return 2 != A.length ? c : a.wmts.WMTSUtil.boundingExtent(A)
	};
	a.wmts.WMTSContents.readBoundingBox_ = function (b, Q) {
		var A = a.util.XMLUtil.pushParseAndPop([],
				a.wmts.WMTSContents.BBOX_READERS_, b, Q);
		return 2 != A.length ? c : a.wmts.WMTSUtil.boundingExtent(A)
	};
	a.wmts.WMTSContents.readLegendUrl_ = function (b, c) {
		var A = {};
		A.format = b.getAttribute("format");
		A.href = a.notNull(a.wmts.WMTSContents.XLink) ? a.wmts.WMTSContents.XLink.readHref(b) : null;
		return A
	};
	a.wmts.WMTSContents.readCoordinates_ = function (b, Q) {
		var A = a.wmts.WMTSUtil.readString(b).split(" ");
		if (!A || 2 != A.length)
			return c;
		var B = +A[0],
		A = +A[1];
		return isNaN(B) || isNaN(A) ? c : [B, A]
	};
	a.wmts.WMTSContents.readTileMatrix_ =
	function (b, c) {
		return a.util.XMLUtil.pushParseAndPop({}, a.wmts.WMTSContents.TM_PARSERS_, b, c)
	};
	a.wmts.WMTSContents.PARSERS_ = a.util.XMLUtil.makeStructureNS(a.wmts.WMTSContents.NAMESPACE, {
		Contents: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSContents.readContents_)
	});
	a.wmts.WMTSContents.CONTENTS_PARSERS_ = a.util.XMLUtil.makeStructureNS(a.wmts.WMTSContents.NAMESPACE, {
		Layer: a.util.XMLUtil.makeObjectPropertyPusher(a.wmts.WMTSContents.readLayer_),
		TileMatrixSet: a.util.XMLUtil.makeObjectPropertyPusher(a.wmts.WMTSContents.readTileMatrixSet_)
	});
	a.wmts.WMTSContents.LAYER_PARSERS_ = a.util.XMLUtil.makeStructureNS(a.wmts.WMTSContents.NAMESPACE, {
		Style: a.util.XMLUtil.makeObjectPropertyPusher(a.wmts.WMTSContents.readStyle_),
		Format: a.util.XMLUtil.makeObjectPropertyPusher(a.wmts.WMTSUtil.readString),
		TileMatrixSetLink: a.util.XMLUtil.makeObjectPropertyPusher(a.wmts.WMTSContents.readTileMatrixSetLink_),
		Dimension: a.util.XMLUtil.makeObjectPropertyPusher(a.wmts.WMTSContents.readDimensions_),
		ResourceURL: a.util.XMLUtil.makeObjectPropertyPusher(a.wmts.WMTSContents.readResourceUrl_)
	},
			a.util.XMLUtil.makeStructureNS(a.wmts.WMTSOws.NAMESPACE, {
				Title: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString),
				Abstract: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString),
				WGS84BoundingBox: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSContents.readWgs84BoundingBox_),
				BoundingBox: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSContents.readBoundingBox_),
				Identifier: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString)
			}));
	a.wmts.WMTSContents.STYLE_PARSERS_ =
		a.util.XMLUtil.makeStructureNS(a.wmts.WMTSContents.NAMESPACE, {
			LegendURL: a.util.XMLUtil.makeObjectPropertyPusher(a.wmts.WMTSContents.readLegendUrl_)
		}, a.util.XMLUtil.makeStructureNS(a.wmts.WMTSOws.NAMESPACE, {
				Title: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString),
				Identifier: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString)
			}));
	a.wmts.WMTSContents.TMS_LINKS_PARSERS_ = a.util.XMLUtil.makeStructureNS(a.wmts.WMTSContents.NAMESPACE, {
		TileMatrixSet: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString)
	});
	a.wmts.WMTSContents.DIMENSION_PARSERS_ = a.util.XMLUtil.makeStructureNS(a.wmts.WMTSContents.NAMESPACE, {
		Default: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString),
		Value: a.util.XMLUtil.makeObjectPropertyPusher(a.wmts.WMTSUtil.readString)
	}, a.util.XMLUtil.makeStructureNS(a.wmts.WMTSOws.NAMESPACE, {
				Identifier: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString)
			}));
	a.wmts.WMTSContents.WGS84_BBOX_READERS_ = a.util.XMLUtil.makeStructureNS(a.wmts.WMTSOws.NAMESPACE, {
		LowerCorner: a.util.XMLUtil.makeArrayPusher(a.wmts.WMTSContents.readCoordinates_),
		UpperCorner: a.util.XMLUtil.makeArrayPusher(a.wmts.WMTSContents.readCoordinates_)
	});
	a.wmts.WMTSContents.BBOX_READERS_ = a.util.XMLUtil.makeStructureNS(a.wmts.WMTSOws.NAMESPACE, {
		LowerCorner: a.util.XMLUtil.makeArrayPusher(a.wmts.WMTSContents.readCoordinates_),
		UpperCorner: a.util.XMLUtil.makeArrayPusher(a.wmts.WMTSContents.readCoordinates_)
	});
	a.wmts.WMTSContents.TMS_PARSERS_ = a.util.XMLUtil.makeStructureNS(a.wmts.WMTSContents.NAMESPACE, {
		WellKnownScaleSet: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString),
		TileMatrix: a.util.XMLUtil.makeObjectPropertyPusher(a.wmts.WMTSContents.readTileMatrix_)
	}, a.util.XMLUtil.makeStructureNS(a.wmts.WMTSOws.NAMESPACE, {
				SupportedCRS: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString),
				Identifier: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString)
			}));
	a.wmts.WMTSContents.TM_PARSERS_ = a.util.XMLUtil.makeStructureNS(a.wmts.WMTSContents.NAMESPACE, {
		TopLeftCorner: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSContents.readCoordinates_),
		ScaleDenominator: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readDecimal),
		TileWidth: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readNonNegativeInteger),
		TileHeight: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readNonNegativeInteger),
		MatrixWidth: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readNonNegativeInteger),
		MatrixHeight: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readNonNegativeInteger)
	}, a.util.XMLUtil.makeStructureNS(a.wmts.WMTSOws.NAMESPACE, {
				Identifier: a.util.XMLUtil.makeObjectPropertySetter(a.wmts.WMTSUtil.readString)
			}));
	a.layer.Layer = a.Class.extend({
		mixin: a.event.EventSource,
		initialize: function (a) {
			this.name = a;
			this.group = null;
			this.visible = !0;
			this.minVisibleLevel = 0;
			this.maxVisibleLevel = 100;
			this.minVisibleScale = 0;
			this.maxVisibleScale = 1E9;
			this.zIndex = this.parentMap = this.visibleBound = null;
			this.opacity = 1;
			this.layerType = null;
			this.customType = "";
			this.loaded = !1;
			this.serverURL = null;
			this.infoWindow = !0;
			this.enableReloadParam = !1
		},
		init: function () {},
		initLayer: function (b) {
			this.initCalled = !0;
			this.init(b);
			b = a.event.LayerEvent;
			var c =
				new b(b.LAYER_INITIALIZED, this);
			this.parentMap && (c.mapContext = this.parentMap.getMapContext(), this.fire(b.LAYER_INITIALIZED, c))
		},
		panEvent: function (a) {
			this.pan(a.xOffset, a.yOffset, a)
		},
		refreshEvent: function (a) {
			this.refresh(a, !0)
		},
		setCenterAndZoomlevel: function () {},
		recenter: function () {},
		pan: function () {},
		enableInfoWindow: function (a) {
			this.infoWindow = a
		},
		getEnableInfoWindow: function () {
			return this.infoWindow
		},
		destroy: function () {
			this.parentMap = null;
			this.deleteAllListeners()
		},
		isVisible: function (b) {
			if (this.real)
				return this.real.isVisible();
			if (a.isNull(b) || isNaN(b))
				if (a.notNull(this.parentMap))
					b = this.parentMap.getMapContext().getZoomLevel();
				else
					return this.visible;
			return this.isInZoomLevelRange(b) ? this.visible : !1
		},
		setVisible: function (b) {
			if (!b || this.isInZoomLevelRange()) {
				if (this.real)
					return this.real.setVisible(b);
				var c = a.event.LayerEvent,
				A = new c(c.LAYER_VISIBILITY_CHANGED, this),
				B = this.visible;
				this.visible !== b && (this.visible = b, this.setVisibleImpl ? this.setVisibleImpl() : this.visible ? (this.group && this.parentMap && this.parentMap.graphics &&
						this.parentMap.graphics.applyStyle(this.group, {
							display: !0
						}), this.parentMap && this.parentMap.displayed && this.refresh(null, !1)) : this.group && this.parentMap && this.parentMap.graphics && this.parentMap.graphics.applyStyle(this.group, {
						display: !1
					}), A.newVisibility = b, A.oldVisibility = B, this.parentMap && (A.mapContext = this.parentMap.getMapContext()), this.fire(c.LAYER_VISIBILITY_CHANGED, A))
			}
		},
		refresh: function () {
			if (this.real)
				return this.real.refresh();
			var b = 0 < arguments.length ? arguments[0] : null;
			if (1 < arguments.length &&
				arguments[1]) {
				var c = a.event.LayerEvent,
				b = new c(c.BEFORE_REFRESH, this);
				this.parentMap && (b.mapContext = this.parentMap.getMapContext());
				this.fire(c.BEFORE_REFRESH, b)
			}
		},
		redraw: function () {
			if (this.real)
				return this.real.redraw(arguments);
			0 < arguments.length && this.refresh(arguments[0], !1)
		},
		setZoomLevelRange: function (a, b) {
			if (this.real)
				return this.real.setZoomLevelRange(a, b);
			this.minVisibleLevel = a;
			this.maxVisibleLevel = b;
			this.displayed && this.refresh(null, !1)
		},
		isInZoomLevelRange: function (b) {
			if (a.isNull(this.parentMap) ||
				a.isNull(this.parentMap.getMapContext()))
				return !1;
			if (a.isNull(b) || isNaN(b))
				b = this.parentMap.getMapContext().getZoomLevel();
			return a.isNull(b) ? !0 : b >= this.minVisibleLevel && b <= this.maxVisibleLevel
		},
		setVisibleBound: function (b) {
			if (this.real)
				return this.real.setVisibleBound(b);
			!b instanceof a.geometry.Rectangle || (this.visibleBound = b, this.displayed && (this.changeVisibleBound ? this.changeVisibleBound() : this.refresh()))
		},
		bringForward: function () {
			if (this.real)
				return this.real.bringForward();
			if (this.parentMap)
				return this.parentMap.bringForward(this)
		},
		sendBackward: function () {
			if (this.real)
				return this.real.sendBackward();
			if (this.parentMap)
				return this.parentMap.sendBackward(this)
		},
		bringToTop: function () {
			if (this.real)
				return this.real.bringToTop();
			var a = !1;
			0 < arguments.length && (a = arguments[0]);
			if (this.parentMap)
				return this.parentMap.bringToTop(this, a)
		},
		sendToBottom: function () {
			if (this.real)
				return this.real.sendToBottom();
			if (this.parentMap)
				return this.parentMap.sendToBottom(this)
		},
		setZIndex: function (b) {
			if (this.real)
				return this.real.setZIndex(b);
			if (this.parentMap) {
				var c =
					this.parentMap.setLayerIndex(this, b);
				if (this.parentMap && this.parentMap) {
					var A = this.parentMap,
					B;
					if (A.svgLayers && 0 < A.svgLayers.length)
						for (b = A.svgLayers.length - 1; 0 <= b; --b)
							B = A.svgLayers[b], A.graphics && a.notNull(B.group) && A.graphics.sendToBottom(B.group)
				}
				return c
			}
		},
		getZIndex: function () {
			if (this.real)
				return this.real.getZIndex();
			if (this.parentMap)
				return this.parentMap.getLayerCurrentIndex(this)
		},
		getName: function () {
			return this.name
		},
		setName: function (a) {
			this.name = a
		},
		setOpacity: function (b) {
			if (a.util.ValidationUtil.isNumber(b)) {
				if (this.real)
					return this.real.setOpacity(b);
				1 < b || 0 > b || (this.opacity = b, this.displayed && this.changeOpacity && this.changeOpacity())
			}
		},
		getOpacity: function () {
			return this.real ? this.real.getOpacity() : this.opacity
		},
		getLayerConfig: function () {},
		getDataSouce: function () {
			return this.dataSource
		},
		getReloadParamStatus: function () {
			return this.enableReloadParam
		},
		setReloadParamStatus: function (b) {
			a.isNull(b) || (this.enableReloadParam = b)
		},
		clone: function (b) {
			var c = {};
			a.$.extend(c, this);
			c.name = b ? b : c.name + "_clone" + Math.round(1E3 * Math.random());
			c.deleteAllListeners();
			this.layerType === a.LayerTypes.VECTOR && this.renderingStyle && this.renderingStyle.styleType && "Area" === this.renderingStyle.styleType && (this.renderingStyle.fill = null);
			return c
		},
		startNewTask: function () {
			if (!0 === a.gv.progressBarDisabled)
				return null;
			var b = new a.util.Task(this.parentMap.progressService);
			b.start();
			return b
		}
	});
	a.layer.TileLayer = a.layer.Layer.extend({
		initialize: function Q(b, c) {
			Q.base.call(this, b, c);
			if (c) {
				this.dataSource = c.dataSource;
				this.tileLayer = c.tileLayer;
				if (a.notNull(c.tileServerURL) && (this.serverURL =
							c.tileServerURL, a.notNull(c.subdomains))) {
					var G = [],
					Y = this.serverURL;
					c.subdomains.forEach(function (a) {
						G.push(Y.replace("://", "://" + a + "."))
					});
					this.serverArray = G;
					this.serverCounter = 0
				}
				this.tileImagesURL = c.tileImagesURL;
				this.tileLayerConfig = c.tileLayerConfig;
				this.getTileURL = c.getTileURL;
				this.mapSource = this.dataSource + "." + this.tileLayer;
				(this.isLocalTileLayer = c.isLocalTileLayer) && c.isInZXYOrder && (this.isInZXYOrder = c.isInZXYOrder);
				!0 === c.enableUTFGrid || "true" === c.enableUTFGrid ? (this.enableUTFGrid = !0, this.mouseETypeUTFGrid =
						c.infoWindowTrigger === a.event.MouseEvent.MOUSE_OVER || c.infoWindowTrigger === a.event.MouseEvent.MOUSE_MOVE ? a.event.MouseEvent.MOUSE_MOVE : a.event.MouseEvent.MOUSE_CLICK, this.utfgridResolution = this.getUTFGridResolution(c.utfGridResolution), this.enableInfoWindow(!0)) : (this.enableUTFGrid = !1, this.enableInfoWindow(!1));
				!1 !== c.enableUTFGridInfoWindow && "false" !== c.enableUTFGridInfoWindow || this.enableInfoWindow(!1)
			}
			this.layerType = a.notNull(this.layerType) ? this.layerType : a.LayerTypes.TILE;
			this.zIndex = 0;
			this.initError =
				!1;
			this.TILING_FACTOR = 20;
			this.UTFGRID_RESOLUTION = 4;
			this.maxMeshY = this.meshLength = 0;
			this.xFactors = [];
			this.yFactors = [];
			this.addListener(a.event.LayerEvent.TILE_IMG_LOADED, this.tileImgLoadedHandler);
			this.addListener(a.event.LayerEvent.TILE_IMG_LOAD_ERROR, this.tileImgLoadedHandler);
			this.initRequiredBinds = this.requiredBinds = this.tilesPercent = this.tilesImgLoaded = 0;
			a.notNull(this.initTask) && (this.initTask = null)
		},
		setCenterAndZoomlevel: function (b) {
			var c = this.parentMap.getMapContext().getCenterPoint(),
			B = b.preMapCenter;
			a.notNull(b.beforeZoomLevel) && this.zoom(b.beforeZoomLevel, b.afterZoomLevel, B, c)
		},
		getLayerConfig: function (a, b) {
			this.getTileLayerConfig(a, b)
		},
		getTileLayerConfig: function (b, c) {
			!1 === a.gv.progressBarDisabled && a.isNull(this.initTask) && (this.initTask = new a.util.Task(this.parentMap.progressService), this.initTask.start());
			var B,
			G,
			Y;
			!this.tileLayerConfig && (B = this.dataSource + "." + this.tileLayer, G = a.gv.CacheConfig[B]) && (this.tileLayerConfig = G);
			G = a.notNull(this.dataSource) ? this.dataSource.toUpperCase() : "";
			Y = a.notNull(this.tileLayer) ?
				this.tileLayer.toUpperCase() : "";
			var W = a.notNull(this.getTileServerURL()) ? this.getTileServerURL().toLowerCase() : "";
			if (this.tileLayerConfig)
				if (Y = new a.event.LayerEvent(a.event.LayerEvent.FINISH_GOT_CONFIG, this), Y.config = this.getEnabledConfig(this.tileLayerConfig), Y.mapContext = this.parentMap.getMapContext(), a.notNull(this.initTask) && this.initTask.update(.25), this.fire(a.event.LayerEvent.FINISH_GOT_CONFIG, Y), c)
					c(this.tileLayerConfig);
				else
					return this.tileLayerConfig;
			else if ("ELOCATION_MERCATOR" !== G ||
				!(0 < W.indexOf("elocation.oracle.com/") || 0 < W.indexOf("maps.oracle.com/")) || "WORLD_MAP" !== Y && "BI_WORLD_MAP" !== Y && "BI_WORLD_MAP_LIGHT" !== Y && "WORLD_MAP_MB" !== Y && "OSM_DARKMATTER" !== Y && "OSM_POSITRON" !== Y && "OSM_BRIGHT" !== Y) {
				var K = this;
				G = this.parentMap;
				var q;
				if (K.layerType === a.LayerTypes.WMTS_TILE)
					K.getTileLayerConfigFromWMTS(b, c);
				else if (this.isLocalTileLayer) {
					var t = this.tileImagesURL + "/instance.json",
					K = this;
					q = function () {
						if (K.parentMap && K.parentMap.graphics) {
							K.initError = !0;
							a.util.Logger.warning("MAPVIEWER_9044",
								"OM.layer.Tilelayer.getTileLayerConfig", "[" + t + "]");
							var b = a.event,
							c = new b.LayerEvent(b.LayerEvent.INIT_ERROR, K);
							K.parentMap && (c.mapContext = K.parentMap.getMapContext(), a.notNull(K.initTask) && K.initTask.abort(), K.fire(b.LayerEvent.INIT_ERROR, c))
						}
					};
					a.util.HttpRequest.send(t, {}, function (b) {
						if (K.parentMap && K.parentMap.graphics) {
							try {
								b = JSON.parse(b)
							} catch (W) {
								a.util.Logger.warning("MAPVIEWER_9044", "OM.layer.Tilelayer.getTileLayerConfig", "")
							}
							var q = b[0].coordSys,
							t = new a.layer.TileLayerConfig;
							t.bounds = new a.geometry.Rectangle(q.minX,
									q.minY, q.maxX, q.maxY, q.srid);
							t.srid = q.srid;
							t.tileImageFormat = b[0].format;
							t.isTransparentImage = b[0].transparent;
							t.copyright = b[0].copyright;
							var q = b[0].zoomLevels,
							R = q.length;
							if (q && 0 < R) {
								t.tileImageWidth = q[0].tileImageWidth;
								t.tileImageHeight = q[0].tileImageHeight;
								t.zoomLevels = Array(R);
								for (var Q = 0; Q < R; Q++) {
									var B = q[Q].tileWidth / t.tileImageWidth;
									t.zoomLevels[Q] = {
										resolution: B,
										stretchRatio: q[Q].tileHeight / t.tileImageHeight / B,
										infotip: ""
									}
								}
							}
							b[0].customTags && (t.customTags = b[0].customTags);
							t.isXYZStorageScheme = "true" ===
								b[0].xyzStorageScheme || !0 === b[0].xyzStorageScheme;
							t.isInZXYOrder = "true" === b[0].inZXYOrder || !0 === b[0].inZXYOrder;
							K.tileLayerConfig = t;
							b = new a.event.LayerEvent(a.event.LayerEvent.FINISH_GOT_CONFIG, K);
							b.config = K.getEnabledConfig(t);
							b.mapContext = K.parentMap.getMapContext();
							a.notNull(K.initTask) && K.initTask.update(.25);
							K.fire(a.event.LayerEvent.FINISH_GOT_CONFIG, b);
							c && c(t)
						}
					}, "text", q)
				} else {
					Y = '\x3c?xml version\x3d"1.0" standalone\x3d"yes"?\x3e\x3cmap_cache_admin_request\x3e\x3cget_client_config map_cache_names\x3d"' +
						B + '" format\x3d"JSON"' + (a.notNull(G.applicationID) ? ' applicationID\x3d"' + G.applicationID + '"' : "") + "/\x3e\x3c/map_cache_admin_request\x3e";
					G = this.serverURL = this.getTileServerURL();
					q = function () {
						if (K.parentMap && K.parentMap.graphics) {
							K.initError = !0;
							a.util.Logger.warning("MAPVIEWER_9001", "OM.layer.Tilelayer.getTileLayerConfig", "[" + B + "]");
							var b = a.event,
							c = new b.LayerEvent(b.LayerEvent.INIT_ERROR, K);
							K.parentMap && (c.mapContext = K.parentMap.getMapContext(), a.notNull(K.initTask) && (K.initTask.abort(), K.initTask =
										null), K.fire(b.LayerEvent.INIT_ERROR, c))
						}
					};
					Y = {
						xml_request: Y
					};
					if (0 <= G.indexOf("elocation.oracle.com") || 0 <= G.indexOf("maps.oracle.com"))
						Y.$enableXHR = !0;
					a.util.HttpRequest.send(G, Y, function (b) {
						if (K.parentMap && K.parentMap.graphics)
							if (b && b[0]) {
								a.gv && a.isNull(a.gv.defaultDataSource) && (a.gv.defaultDataSource = K.dataSource);
								var W = b[0].coordSys,
								t = new a.layer.TileLayerConfig;
								t.bounds = new a.geometry.Rectangle(W.minX, W.minY, W.maxX, W.maxY, W.srid);
								t.srid = W.srid;
								t.tileImageFormat = b[0].format;
								t.isTransparentImage =
									b[0].transparent;
								t.copyright = b[0].copyright;
								var W = b[0].zoomLevels,
								R = W.length;
								if (W && 0 < R) {
									t.tileImageWidth = W[0].tileImageWidth;
									t.tileImageHeight = W[0].tileImageHeight;
									t.zoomLevels = Array(R);
									!K.enableUTFGrid || !0 !== b[0].utfgrid && "true" !== b[0].utfgrid ? K.enableUTFGrid = !1 : K.getUTFGridResolution(b[0].utfGridResolution);
									for (var Q = 0; Q < R; Q++) {
										var Y = W[Q].tileWidth / t.tileImageWidth;
										t.zoomLevels[Q] = {
											resolution: Y,
											stretchRatio: W[Q].tileHeight / t.tileImageHeight / Y,
											infotip: ""
										}
									}
								}
								b[0].customTags && (t.customTags = b[0].customTags);
								K.setTileLayerConfig(t);
								if (b[0].clientTileAccess) {
									var G;
									b = b[0].clientTileAccess;
									a.isNull(b.mapTypeList) && a.notNull(b.map_type_values) && (b.mapTypeList = b.map_type_values);
									b.lib_url && b.key && (b.lib_url = b.lib_url.replace("\x3d$$key$$", "\x3d" + b.key));
									b.mapTypeVisible = "false" == b.mapTypeVisible || "false" == b.map_type_visible ? !1 : !0;
									var pa;
									if ("google" == b.type)
										pa = {
											libURL: b.lib_url,
											mapTypeList: b.mapTypeList.replace(/MVGoogleTileLayer/g, "OM.layer.GoogleTileLayer"),
											mapTypeVisible: b.mapTypeVisible
										},
									b.appID && (pa.appID =
											b.appID),
									b.key && (pa.key = b.key),
									b.client && (pa.clientID = b.client),
									G = new a.layer.GoogleTileLayer(K.name, pa);
									else if ("tomtom" == b.type)
										a.util.Logger.warning("MAPVIEWER_9201", "OM.layer.Tilelayer.getTileLayerConfig", "[" + B + "]");
									else if ("bing" == b.type || "bingV7" == b.type)
										pa = {
											key: b.key,
											libURL: b.lib_url,
											mapTypeList: b.mapTypeList.replace(/MVBingTileLayer/g, "OM.layer.BingTileLayer"),
											mapTypeVisible: b.mapTypeVisible
										},
									b.appID && (pa.appID = b.appID),
									G = new a.layer.BingTileLayer(K.name, pa);
									else if ("mapviewer" == b.type) {
										b.appID &&
										(pa.appID = b.appID);
										G = b.dataSource || "";
										pa = b.tile_layer_name;
										W = b.tileServerURL;
										R = -1;
										a.notNull(pa) && (R = pa.indexOf("."), 0 < R && (G = pa.substring(0, R), pa = pa.substring(R + 1)));
										R = W.length;
										R -= 9;
										Q = W.indexOf("/mcserver", R);
										if (-1 === Q || Q !== R)
											R = W.indexOf("/mcserver"), W = W.substring(0, R + 9);
										R = {};
										a.notNull(G) && (R.dataSource = G);
										R.tileLayer = pa;
										R.tileServerURL = W;
										G = new a.layer.TileLayer(K.name, R)
									} else
										"here" === b.type ? (pa = {
												libURL: b.libURL,
												mapTypeList: b.mapTypeList.replace(/MVHereTileLayer/g, "OM.layer.HereTileLayer"),
												mapTypeVisible: b.mapTypeVisible
											},
											a.notNull(b.appID) && a.notNull(b.appCode) && (pa.appID = b.appID, pa.appCode = b.appCode), a.notNull(b.apikey) && (pa.apikey = b.apikey), G = new a.layer.HereTileLayer(K.name, pa)) : "openstreetmap" == b.type ? G = new a.layer.OSMTileLayer(K.name, pa) : "locationbox" == b.type && a.util.Logger.warning("MAPVIEWER_9201", "OM.layer.Tilelayer.getTileLayerConfig", "[" + B + "]");
									b.default_map_type && ("OM.layer.GoogleTileLayer.TYPE_ROAD" == b.default_map_type && G.setMapType(a.layer.GoogleTileLayer.TYPE_ROAD), "OM.layer.GoogleTileLayer.TYPE_SATELLITE" ==
										b.default_map_type && G.setMapType(a.layer.GoogleTileLayer.TYPE_SATELLITE), "OM.layer.GoogleTileLayer.TYPE_SHADED" == b.default_map_type && G.setMapType(a.layer.GoogleTileLayer.TYPE_SHADED), "OM.layer.BingTileLayer.TYPE_ROAD" == b.default_map_type && G.setMapType(a.layer.BingTileLayer.TYPE_ROAD), "OM.layer.BingTileLayer.TYPE_SATELLITE" == b.default_map_type && G.setMapType(a.layer.BingTileLayer.TYPE_SATELLITE), "OM.layer.BingTileLayer.TYPE_HYBRID" == b.default_map_type && G.setMapType(a.layer.BingTileLayer.TYPE_HYBRID),
										"OM.layer.BingTileLayer.TYPE_SHADED" == b.default_map_type && G.setMapType(a.layer.BingTileLayer.TYPE_SHADED), "OM.layer.NokiaTileLayer.TYPE_ROAD" == b.default_map_type && G.setMapType(a.layer.NokiaTileLayer.TYPE_ROAD), "OM.layer.NokiaTileLayer.TYPE_HYBRID" == b.default_map_type && G.setMapType(a.layer.NokiaTileLayer.TYPE_HYBRID), "OM.layer.NokiaTileLayer.TYPE_TERRAIN" == b.default_map_type && G.setMapType(a.layer.NokiaTileLayer.TYPE_TERRAIN));
									G.tileLayerConfig = t;
									pa = K.parentMap;
									pa.replaceLayer(K, G);
									K.real = G;
									b = new a.event.LayerEvent(a.event.LayerEvent.FINISH_GOT_CONFIG,
											G);
									b.config = G.getEnabledConfig(t);
									b.mapContext = pa.getMapContext();
									a.notNull(K.initTask) && (K.initTask.complete(), K.initTask = null);
									G.fire(a.event.LayerEvent.FINISH_GOT_CONFIG, b)
								} else
									b = new a.event.LayerEvent(a.event.LayerEvent.FINISH_GOT_CONFIG, K), b.config = K.getEnabledConfig(t), b.mapContext = K.parentMap.getMapContext(), a.notNull(K.initTask) && K.initTask.update(.25), K.fire(a.event.LayerEvent.FINISH_GOT_CONFIG, b);
								c && c(t)
							} else
								return q(), null
					}, "json", function (b) {
						if (K.parentMap && K.parentMap.graphics) {
							K.initError =
								!0;
							if (b && b.responseText)
								try {
									var c = a.$(a.$.parseXML(b.responseText)).find("oms_error");
									0 < c.length && a.util.Logger.warning("MAPVIEWER_9009", "OM.layer.Tilelayer.getTileLayerConfig", c.text())
								} catch (W) {
									a.util.Logger.warning("MAPVIEWER_9009", "OM.layer.Tilelayer.getTileLayerConfig", b.responseText)
								}
							else
								a.util.Logger.warning("MAPVIEWER_9009", "OM.layer.Tilelayer.getTileLayerConfig", "[" + B + "]");
							b = a.event;
							c = new b.LayerEvent(b.LayerEvent.INIT_ERROR, K);
							K.parentMap && (c.mapContext = K.parentMap.getMapContext(), a.notNull(K.initTask) &&
								K.initTask.abort(), K.fire(b.LayerEvent.INIT_ERROR, c))
						}
					})
				}
			} else if (G = "WORLD_MAP_MB" === Y || "OSM_DARKMATTER" === Y || "OSM_POSITRON" === Y || "OSM_BRIGHT" === Y ? a.layer.TileLayerConfig.CONFIG_OSM : a.layer.TileLayerConfig.CONFIG_ELOCATION, Y = new a.event.LayerEvent(a.event.LayerEvent.FINISH_GOT_CONFIG, this), Y.config = this.getEnabledConfig(G), Y.mapContext = this.parentMap.getMapContext(), this.tileLayerConfig = G, this.fire(a.event.LayerEvent.FINISH_GOT_CONFIG, Y), c)
				c(G);
			else
				return G
		},
		init: function () {
			!1 === a.gv.progressBarDisabled &&
			a.isNull(this.initTask) && (this.initTask = this.startNewTask());
			var b = 0,
			c = this.parentMap.getMapContext();
			this.winWidth = c.getDeviceWidth();
			this.winHeight = c.getDeviceHeight();
			var B = c.getCenterPoint(),
			G = B.getX(),
			Y = B.getY(),
			W = this.getRealZoomLevel(c.getZoomLevel());
			if (this.checkVisible(W)) {
				this.tileImageWidth = this.tileLayerConfig.tileImageWidth;
				this.tileImageHeight = this.tileLayerConfig.tileImageHeight;
				this.bufferX = Math.ceil(this.tileImageWidth / 2);
				this.bufferY = Math.ceil(this.tileImageHeight / 2);
				this.tileNumX =
					Math.ceil((this.winWidth + 2 * this.bufferX) / this.tileImageWidth);
				this.centerMesh = null;
				this.centerMesh = new a.layer.Mesh(this.tileLayerConfig, G, Y, W);
				var K = this.tileLayerConfig.bounds;
				this.tileNumInCSBoun = Math.ceil((K.getMaxX() - K.getMinX()) / this.centerMesh.mw);
				var W = this.tileLayerConfig.zoomLevels[W],
				q = W.resolution,
				t = W.resolution * W.stretchRatio;
				this.pixPerX = this.tileImageWidth / this.centerMesh.mw;
				this.pixPerY = this.tileImageHeight / this.centerMesh.mh;
				this.coverPixel = (this.centerMesh.mw * this.tileNumInCSBoun -
					(this.tileLayerConfig.bounds.getMaxX() - this.tileLayerConfig.bounds.getMinX())) * this.pixPerX;
				this.parentMap.wraparound && (this.tileNumX = this.tileNumX + Math.ceil(this.tileNumX / this.tileNumInCSBoun * this.coverPixel / (this.tileImageWidth / 2)) + 1);
				this.tileNumY = Math.ceil((this.winHeight + 2 * this.bufferY) / this.tileImageHeight);
				this.tileMinY = this.tileMinX = 0;
				this.initTileArray();
				W = Math.floor(this.tileNumX / 2);
				K = Math.floor(this.tileNumY / 2);
				G = this.winWidth / 2 - (G - this.centerMesh.minX) / q;
				for (Y = this.winHeight / 2 + (Y - this.centerMesh.minY) /
						t - this.tileImageHeight; ; ) {
					var I = G - W * this.tileImageWidth;
					if (0 < I)
						W++;
					else if (q = Y - K * this.tileImageHeight, 0 < q)
						K++;
					else {
						var aa = G + (this.tileNumX - W) * this.tileImageWidth - this.winWidth;
						if (0 > aa)
							W--;
						else if (t = Y + (this.tileNumY - K) * this.tileImageHeight - this.winHeight, 0 > t)
							K--;
						else if (I = aa + I, q = t + q, I > this.tileImageWidth)
							W++;
						else if (I < -1 * this.tileImageWidth)
							W--;
						else if (q > this.tileImageHeight)
							K++;
						else if (q < -1 * this.tileImageHeight)
							K--;
						else
							break
					}
				}
				this.origLeft = G - W * this.tileImageWidth;
				this.origTop = Y - K * this.tileImageHeight;
				this.divLeft = this.origLeft;
				this.divTop = this.origTop;
				B = c.getTransform().toScreenPoint(B.getX(), B.getY());
				this.offsetX = B.x - c.getDeviceWidth() / 2;
				this.offsetY = B.y - c.getDeviceHeight() / 2;
				this.jqLayerDiv.css({
					left: this.divLeft,
					top: this.divTop
				});
				this.createImageNode(W, K, this.tileImageWidth, this.tileImageHeight, W * this.tileImageWidth, K * this.tileImageHeight);
				b++;
				this.centerMesh.moveMeshCode(-1, 1);
				c = Math.max(W, this.tileNumX - W);
				B = Math.max(K, this.tileNumY - K);
				for (q = 1; q <= Math.max(c, B); q++) {
					G = W - q;
					for (Y = K - q; G <= W + q; G++)
						0 >
						G || G >= this.tileNumX || 0 > Y || Y >= this.tileNumY || (this.createImageNode(G, Y, this.tileImageWidth, this.tileImageHeight, G * this.tileImageWidth, Y * this.tileImageHeight), b++), this.centerMesh.moveMeshCode(1, 0);
					this.centerMesh.moveMeshCode( - (2 * q + 1), -1);
					G = W - q;
					for (Y = K - q + 1; Y <= K + q - 1; Y++)
						0 > G || G >= this.tileNumX || 0 > Y || Y >= this.tileNumY || (this.createImageNode(G, Y, this.tileImageWidth, this.tileImageHeight, G * this.tileImageWidth, Y * this.tileImageHeight), b++), this.centerMesh.moveMeshCode(0, -1);
					G = W - q;
					for (Y = K + q; G <= W + q; G++)
						0 > G || G >=
						this.tileNumX || 0 > Y || Y >= this.tileNumY || (this.createImageNode(G, Y, this.tileImageWidth, this.tileImageHeight, G * this.tileImageWidth, Y * this.tileImageHeight), b++), this.centerMesh.moveMeshCode(1, 0);
					this.centerMesh.moveMeshCode(-1, 1);
					G = W + q;
					for (Y = K + q - 1; Y >= K - q + 1; Y--)
						0 > G || G >= this.tileNumX || 0 > Y || Y >= this.tileNumY || (this.createImageNode(G, Y, this.tileImageWidth, this.tileImageHeight, G * this.tileImageWidth, Y * this.tileImageHeight), b++), this.centerMesh.moveMeshCode(0, 1);
					this.centerMesh.moveMeshCode( - (2 * q + 1), 1)
				}
				this.centerMesh.moveMeshCode(q,
					-q);
				this.centerMesh.moveMeshCode(-W + Math.floor(this.tileNumX / 2), K - Math.floor(this.tileNumY / 2));
				this.zoomControl || (this.zoomControl = new a.layer.TileZoomAnimation(this));
				this.zoomControl.tileInitialized();
				this.displayed = !0;
				if (!this.hasListener(this.mouseETypeUTFGrid))
					this.on(this.mouseETypeUTFGrid, this.getAndStoreUTFGridAttr);
				this.initRequiredBinds = b
			} else
				this.jqLayerDiv && (this.visible = !1, this.jqLayerDiv.css("visibility", "hidden")), b = a.event, W = new b.LayerEvent(b.LayerEvent.FINISH_LOAD, this), W.mapContext =
					this.parentMap.getMapContext(), a.notNull(this.initTask) && (this.initTask.complete(), this.initTask = null), this.fire(b.LayerEvent.FINISH_LOAD, W)
		},
		getAndStoreUTFGridAttr: function () {
			if (!a.isNull(this.isVisible()) && !1 !== this.isVisible()) {
				var b = this.getFeatureInfo(),
				c = "";
				if (b && !a.$.isEmptyObject(b))
					for (var B in b)
						if ("string" === typeof B && 0 < B.trim().length) {
							var G = b[B];
							if (!a.isNull(G)) {
								var c = c + ("\x3ctr bgcolor\x3d'#bbbbbb'\x3e\x3ctd colspan\x3d'2' align\x3d'left'\x3e" + B + "\x3c/td\x3e\x3c/tr\x3e"),
								Y;
								for (Y in G)
									c +=
									"\x3ctr bgcolor\x3d'#dddddd'\x3e\x3ctd align\x3d'right'\x3e" + Y + "\x3c/td\x3e\x3ctd align\x3d'left'\x3e" + G[Y] + "\x3c/td\x3e\x3c/tr\x3e"
							}
						}
				this.parentMap.appendUTFGridLayerHTML(c)
			}
		},
		buildUTFGridReq: function (a) {
			var b = a.indexOf("/omserver");
			if (-1 == b)
				return null;
			var c = a.substring(0, b),
			b = a.indexOf(" grid_id\x3d") + 9,
			G = a.indexOf(" grid_res");
			a = a.substring(b + 1, G - 1);
			return c + "/images/utfgrid/utfgrid" + a + ".json"
		},
		getUpperLeftTileCode: function (a, b) {
			var c = this.centerMesh.mX,
			G = this.centerMesh.mY,
			Y = Math.max(Math.max(a,
						this.tileNumX - a), Math.max(b, this.tileNumY - b)),
			c = c - Math.min(a, Y),
			G = G + Math.min(b, Y),
			Y = [];
			Y.push(c);
			Y.push(G);
			return Y
		},
		initTileArray: function () {
			this.clearLayer();
			var b;
			try {
				b = this.parentMap.mapInstanceId
			} catch (c) {
				b = Math.round(1E4 * Math.random())
			}
			this.jqLayerDiv = a.$("\x3cdiv id \x3d'tilelayer_" + this.name + "_" + b + "'\x3e\x3c/div\x3e");
			this.jqLayerDiv.css({
				position: "absolute",
				"z-index": this.getZIndex() - 1
			});
			this.parentMap.$tileLayersDiv.append(this.jqLayerDiv);
			this.transImgURL = a.util.MiscUtil.transparentImgURL;
			var A,
			B;
			for (b = 0; b < this.tileNumX; b++) {
				B = [];
				for (A = 0; A < this.tileNumY; A++)
					B.push(this.initTileNode());
				this.tileArray.push(B)
			}
		},
		initTileNode: function (b) {
			var c = function (a) {
				a.preventDefault();
				return !1
			},
			B = function (a) {
				a.preventDefault()
			},
			G = null,
			G = a.isNull(b) ? a.$(a.util.DomUtil.createImageNode(this.transImgURL, this.tileLayerConfig.isTransparentImage)) : b.node;
			a.browser.touchSupported ? (G.bind("click", c), G.bind("focus", c)) : (G.bind("mouseout", c), G.bind("mousedown", B));
			a.notNull(b) && (a.$(G).css("top", a.$(b.node).css("top")),
				a.$(G).css("left", a.$(b.node).css("left")), a.$(G).css("position", a.$(b.node).css("position")), a.$(G).css("z-index", a.$(b.node).css("z-index")), a.$(G).css("opacity", a.$(b.node).css("opacity")));
			a.isNull(b) && this.jqLayerDiv.append(G);
			b = {};
			b.node = G;
			b.grid = null;
			b.gridsrc = null;
			return b
		},
		createImageNode: function (b, c, B, G, Y, W) {
			0 === b && 0 === c && this.transImgURL && (this.leftNum = this.centerMesh.mX, this.topNum = this.centerMesh.mY);
			var K = this.meshImgPath(this.centerMesh.mX, this.centerMesh.mY),
			q = this.tileArray[b][c].node;
			a.isNull(q) && (q = a.util.DomUtil.createImageNode(null, this.isTransparent), q = a.$(q), this.jqLayerDiv.append(q), this.tileArray[b][c].node = q);
			q.css({
				position: "absolute",
				left: Y,
				top: W,
				"pointer-events": "none"
			});
			a.browser.msie && q.css({
				width: B,
				height: G
			});
			this.zoomControl && this.zoomControl.zooming && q.css("display", "none");
			a.browser.mobileWebkit && !a.browser.android && q.css("-webkit-transform", "translate3d(0,0,0)");
			this.enableUTFGrid && (B = this.isDynamicTileLayer ? this.buildUTFGridReq(K) : this.meshUTFGridPath(this.centerMesh.mX,
						this.centerMesh.mY), this.tileArray[b][c].gridsrc = B);
			this.bindAndLoadTile(this.tileArray[b][c]);
			a.util.DomUtil.setImageSrc(q, K, this.opacity);
			q[0].mx = this.centerMesh.mX;
			q[0].my = this.centerMesh.mY
		},
		fetchUTFGrid: function (b) {
			a.isNull(b.gridsrc) ? b.grid = {}
			 : a.$.ajax({
				dataType: "text",
				url: b.gridsrc,
				data: "",
				cache: !0,
				success: function (c) {
					a.isNull(c) ? a.util.Logger.warning("MAPVIEWER_9065", "OM.layer.TileLayer.fetchUTFGrid", b.gridsrc) : b.grid = c
				}
			})
		},
		cloneGrid: function (b) {
			var c;
			if (a.isNull(b) || "object" != typeof b)
				return b;
			if (b instanceof Object) {
				c = {};
				for (var B in b)
					b.hasOwnProperty(B) && (c[B] = this.cloneGrid(b[B]));
				return c
			}
			throw Error("Unable to copy utfgrid Object{grid:'', src:''}! Its type isn't supported.");
		},
		decodeCharVal: function (b) {
			if (a.notNull(b))
				return b = b.charCodeAt(0), 93 <= b && b--, 35 <= b && b--, b - 32
		},
		featureInfoToJSON: function (b, c, B) {
			if (b.length !== c.length && b.length !== B.length)
				return a.util.Logger.warning("MAPVIEWER_9080", "OM.layer.Tilelayer.featureInfoToJSON"), null;
			c = {};
			for (var G = 0; G < B.length; G++)
				B[G] && (c[b[G]] =
						B[G]);
			return c
		},
		getFeatureInfo: function () {
			var b,
			c,
			B,
			G,
			Y,
			W,
			K,
			q = [],
			t = [],
			I = [];
			b = this.parentMap.mLocX - this.divLeft;
			c = this.parentMap.mLocY - this.divTop;
			W = parseInt(b / this.tileImageWidth);
			Y = parseInt(c / this.tileImageHeight);
			b -= W * this.tileImageWidth;
			c -= Y * this.tileImageHeight;
			try {
				K = JSON.parse(this.tileArray[W][Y].grid);
				if (a.isNull(K))
					return;
				var aa = parseInt(K.resolution);
				B = parseInt(b / aa);
				G = parseInt(c / aa)
			} catch (ua) {
				return
			}
			for (var ba in K)
				if ("rows" !== ba && "columns" !== ba && "resolution" !== ba) {
					q.push(ba);
					try {
						var R =
							this.decodeCharVal(K[ba].grid[G][B]);
						if (a.notNull(R)) {
							t.push(R);
							var qa = K[ba].data[R];
							a.isNull(qa) ? I.push("") : I.push(qa)
						}
					} catch (ua) {}
				}
			return this.featureInfoToJSON(q, t, I)
		},
		meshImgPath: function (b, c) {
			if (this.parentMap.wraparound) {
				if (0 > c || c >= (this.tileLayerConfig.bounds.getMaxY() - this.tileLayerConfig.bounds.getMinY()) / this.centerMesh.mh)
					return this.transImgURL;
				if (0 > b)
					for (; !(b = parseInt(Math.ceil((this.tileLayerConfig.bounds.getMaxX() - this.tileLayerConfig.bounds.getMinX()) / this.centerMesh.mw)) + b, 0 <= b); );
				else if (b >= (this.tileLayerConfig.bounds.getMaxX() - this.tileLayerConfig.bounds.getMinX()) / this.centerMesh.mw)
					for (; !(b -= parseInt(Math.ceil((this.tileLayerConfig.bounds.getMaxX() - this.tileLayerConfig.bounds.getMinX()) / this.centerMesh.mw)), b < (this.tileLayerConfig.bounds.getMaxX() - this.tileLayerConfig.bounds.getMinX()) / this.centerMesh.mw); );
			} else if (0 > b || b >= (this.tileLayerConfig.bounds.getMaxX() - this.tileLayerConfig.bounds.getMinX()) / this.centerMesh.mw || 0 > c || c >= (this.tileLayerConfig.bounds.getMaxY() - this.tileLayerConfig.bounds.getMinY()) /
				this.centerMesh.mh)
				return this.transImgURL;
			if (this.visibleBound) {
				var B = Math.floor((this.visibleBound.getMinX() - this.tileLayerConfig.bounds.getMinX()) / this.centerMesh.mw),
				G = Math.ceil((this.visibleBound.getMaxX() - this.tileLayerConfig.bounds.getMinX()) / this.centerMesh.mw),
				Y = Math.floor((this.visibleBound.getMinY() - this.tileLayerConfig.bounds.getMinY()) / this.centerMesh.mh),
				W = Math.ceil((this.visibleBound.getMaxY() - this.tileLayerConfig.bounds.getMinY()) / this.centerMesh.mh);
				if (b < B || b >= G || c < Y || c >= W)
					return this.transImgURL
			}
			B =
				this.centerMesh.zoom;
			if (this.getTileURL) {
				var G = this.tileLayerConfig.zoomLevels[B],
				W = this.tileLayerConfig.tileImageWidth * G.resolution,
				G = this.tileLayerConfig.tileImageHeight * G.resolution * G.stretchRatio,
				Y = this.tileLayerConfig.bounds.getMinX() + b * W,
				W = Y + W,
				K = this.tileLayerConfig.bounds.getMinY() + c * G,
				G = new a.geometry.Rectangle(Y, K, W, K + G, this.tileLayerConfig.srid);
				return (B = this.getTileURL(B, b, c, G)) ? B : this.transImgURL
			}
			Y = G = null;
			if (this.isLocalTileLayer)
				return G = Math.ceil((this.tileLayerConfig.bounds.getMaxX() -
							this.tileLayerConfig.bounds.getMinX()) / this.centerMesh.mw) - 1, this.maxMeshY = Y = Math.ceil((this.tileLayerConfig.bounds.getMaxY() - this.tileLayerConfig.bounds.getMinY()) / this.centerMesh.mh) - 1, this.tileLayerConfig.isXYZStorageScheme ? (Y = this.tileImagesURL + "/" + B + "/", Y = this.tileLayerConfig.isInZXYOrder ? Y + (b + "/" + (this.maxMeshY - c) + "." + this.tileLayerConfig.tileImageFormat) : Y + (this.maxMeshY - c + "/" + b + "." + this.tileLayerConfig.tileImageFormat)) : (this.calcMeshCode(b, c, Math.max(G, Y)), Y = this.tileImagesURL + "/" + this.getMeshStr(B) +
						"." + this.tileLayerConfig.tileImageFormat), Y;
			if (this.isDynamicTileLayer)
				return this.getDynamicTL_URL(b, c, B);
			if (this.isWMSTileLayer)
				return this.getWMSTL_URL(b, c, B);
			if (this.layerType === a.LayerTypes.WMTS_TILE)
				return this.getWMTS_URL(b, c, B);
			G = this.mapSource ? this.mapSource.toUpperCase() : this.dataSource.toUpperCase() + "." + this.tileLayer.toUpperCase();
			Y = this.serverURL;
			a.notNull(this.serverArray) && (Y = this.serverArray[this.serverCounter], this.serverCounter += 1, this.serverCounter %= this.serverArray.length);
			Y = Y +
				"?request\x3dgettile\x26format\x3d" + this.tileLayerConfig.tileImageFormat;
			Y += "\x26zoomlevel\x3d" + B + "\x26mapcache\x3d" + G + "\x26mx\x3d" + b + "\x26my\x3d" + c;
			this.reloadNumber && this.getReloadParamStatus() && (Y += "\x26reload\x3d" + this.reloadNumber);
			return Y
		},
		meshUTFGridPath: function (b, c) {
			var B = this.tileLayerConfig.bounds,
			G = B.getMinX(),
			Y = B.getMaxX(),
			W = B.getMinY(),
			K = B.getMaxY();
			if (this.parentMap.wraparound) {
				if (0 > c || c >= (K - W) / this.centerMesh.mh)
					return this.transUTFGridURL;
				if (0 > b)
					for (; !(b = parseInt(Math.ceil((Y - G) /
										this.centerMesh.mw)) + b, 0 <= b); );
				else if (b >= (Y - G) / this.centerMesh.mw)
					for (; !(b -= parseInt(Math.ceil((Y - G) / this.centerMesh.mw)), b < (Y - G) / this.centerMesh.mw); );
			} else if (0 > b || b >= (Y - G) / this.centerMesh.mw || 0 > c || c >= (K - W) / this.centerMesh.mh)
				return this.transUTFGridURL;
			if (this.visibleBound) {
				var B = Math.floor((this.visibleBound.getMinX() - G) / this.centerMesh.mw),
				q = Math.ceil((this.visibleBound.getMaxX() - G) / this.centerMesh.mw),
				t = Math.floor((this.visibleBound.getMinY() - W) / this.centerMesh.mh),
				I = Math.ceil((this.visibleBound.getMaxY() -
							W) / this.centerMesh.mh);
				if (b < B || b >= q || c < t || c >= I)
					return this.transUTFGridURL
			}
			B = this.centerMesh.zoom;
			if (this.getTileURL)
				return K = this.tileLayerConfig.zoomLevels[B], Y = this.tileLayerConfig.tileImageWidth * K.resolution, G += b * Y, W += c * this.tileLayerConfig.tileImageHeight * K.resolution * K.stretchRatio, W = new a.geometry.Rectangle(G, W, G + Y, W + Y, this.tileLayerConfig.srid), (W = this.getTileURL(B, b, c, W)) ? W : this.transUTFGridURL;
			q = q = null;
			this.isLocalTileLayer ? (G = Math.ceil((Y - G) / this.centerMesh.mw) - 1, this.maxMeshY = W = Math.ceil((K -
							W) / this.centerMesh.mh) - 1, this.tileLayerConfig.isXYZStorageScheme ? (q = this.tileImagesURL + "/" + B + "/", q = this.tileLayerConfig.isInZXYOrder ? q + (b + "/" + (this.maxMeshY - c) + ".json") : q + (this.maxMeshY - c + "/" + b + ".json")) : (this.calcMeshCode(b, c, Math.max(G, W)), q = this.tileImagesURL + "/" + this.getMeshStr(B) + ".json")) : (q = this.mapSource ? this.mapSource.toUpperCase() : this.dataSource.toUpperCase() + "." + this.tileLayer.toUpperCase(), W = this.serverURL, a.notNull(this.serverArray) && (W = this.serverArray[this.serverCounter], this.serverCounter +=
					1, this.serverCounter %= this.serverArray.length), q = W + "?request\x3dgetutfgrid\x26format\x3djson" + ("\x26zoomlevel\x3d" + B + "\x26mapcache\x3d" + q + "\x26mx\x3d" + b + "\x26my\x3d" + c), this.reloadNumber && this.getReloadParamStatus() && (q += "\x26reload\x3d" + this.reloadNumber));
			return q
		},
		bindAndLoadTile: function (b) {
			!1 === a.gv.progressBarDisabled && a.isNull(this.initTask) && (this.initTask = this.startNewTask());
			var c = this,
			B = a.$(b.node);
			B.imgLoadFinished = !1;
			B.bind("load", function () {
				B.imgLoadFinished = !0;
				B.unbind("load");
				B.css("display",
					"");
				c.enableUTFGrid && c.fetchUTFGrid(b);
				var G = new a.event.LayerEvent(a.event.LayerEvent.TILE_IMG_LOADED, c);
				c.fire(a.event.LayerEvent.TILE_IMG_LOADED, G)
			});
			B.bind("error", function () {
				B.unbind("error");
				B.imgLoadFinished = !0;
				var b = new a.event.LayerEvent(a.event.LayerEvent.TILE_IMG_LOAD_ERROR, c);
				c.fire(a.event.LayerEvent.TILE_IMG_LOAD_ERROR, b)
			})
		},
		getTileXOffset: function (a) {
			a += this.tileMinX;
			for (var b = 0; ; ) {
				var c = a - b * this.tileImageWidth;
				if (0 < c)
					b++;
				else {
					var G = a + (this.tileNumX - b) * this.tileImageWidth - this.winWidth;
					if (0 > G)
						b--;
					else if (c = G + c, c > this.tileImageWidth)
						b++;
					else if (c < -1 * this.tileImageWidth)
						b--;
					else
						return b
				}
			}
		},
		getTileYOffset: function (a) {
			a += this.tileMinY;
			for (var b = 0; ; ) {
				var c = a - b * this.tileImageHeight;
				if (0 < c)
					b++;
				else {
					var G = a + (this.tileNumY - b) * this.tileImageHeight - this.winHeight;
					if (0 > G)
						b--;
					else if (c = G + c, c > this.tileImageHeight)
						b++;
					else if (c < -1 * this.tileImageHeight)
						b--;
					else
						return b
				}
			}
		},
		pan: function (b, c, B) {
			if (!a.isNull(this.jqLayerDiv) && (B.callback && B.callback(), !1 === a.gv.progressBarDisabled && a.isNull(this.initTask) &&
					(this.initTask = this.startNewTask()), !a.isNull(this.parentMap)))
				if (b = this.getRealZoomLevel(this.parentMap.getMapContext().getZoomLevel()), this.checkVisible(b)) {
					b = this.parentMap.getMapContext();
					c = b.getCenterPoint();
					b = b.getTransform().toScreenPoint(c.getX(), c.getY());
					B = this.origLeft - b.x + this.winWidth / 2 + this.offsetX;
					var G = this.origTop - b.y + this.winHeight / 2 + this.offsetY;
					b = this.getTileXOffset(B);
					c = this.getTileYOffset(G);
					var Y = this.tileMinY - c * this.tileImageHeight;
					this.divLeft = B + (this.tileMinX - b * this.tileImageWidth);
					this.divTop = G + Y;
					this.jqLayerDiv.css({
						left: B,
						top: G
					});
					if (0 !== b || 0 !== c) {
						B = this.centerMesh.mX - Math.floor(this.tileNumX / 2);
						var G = this.centerMesh.mY + Math.floor(this.tileNumY / 2),
						Y = 0,
						W,
						K,
						q,
						t,
						I,
						aa,
						ba,
						R,
						qa = this.tileArray[0].length;
						if (0 !== b)
							for (W = 0; 0 < b ? W < b : W > b; 0 < b ? W++ : W--)
								if (I = 0 < b ? this.tileMinX - (W + 1) * this.tileImageWidth : this.tileMinX + (this.tileNumX - W) * this.tileImageWidth, 0 < b ? this.leftNum-- : this.leftNum++, 0 < b) {
									q = this.tileArray.pop();
									t = [];
									for (K = 0; K < qa; K++)
										aa = q[K], t.push(this.initTileNode(aa));
									for (K = 0; K < qa; K++) {
										ba =
											t[K];
										a.util.DomUtil.setImageSrc(ba.node, null);
										if (0 === c || 0 < c && K < t.length - c || 0 > c && K >= -c)
											R = B - W - 1, q = G - K, aa = this.meshImgPath(R, q), a.util.DomUtil.setImageSrc(ba.node, aa), ba.node[0].mx = R, ba.node[0].my = q, this.enableUTFGrid && (q = this.isDynamicTileLayer ? this.buildUTFGridReq(aa) : this.meshUTFGridPath(R, q), ba.gridsrc = q), this.bindAndLoadTile(ba), Y++;
										this.parentMap.wraparound ? (aa = this.tileArray[0][K], q = R, ba.node[0].style.left = 0 === q % this.tileNumInCSBoun ? parseInt(aa.node[0].style.left) - this.tileImageWidth + this.coverPixel +
												"px" : parseInt(aa.node[0].style.left) - this.tileImageWidth + "px") : a.$(ba.node).css("left", I)
									}
									this.tileArray.unshift(t)
								} else {
									q = this.tileArray.shift();
									t = [];
									for (K = 0; K < qa; K++)
										aa = q[K], t.push(this.initTileNode(aa));
									for (K = 0; K < qa; K++) {
										ba = t[K];
										a.util.DomUtil.setImageSrc(ba.node, null);
										if (0 === c || 0 < c && K < t.length - c || 0 > c && K >= -c)
											R = B + this.tileNumX - W, q = G - K, aa = this.meshImgPath(R, q), a.util.DomUtil.setImageSrc(ba.node, aa), ba.node[0].mx = R, ba.node[0].my = q, this.enableUTFGrid && (q = this.isDynamicTileLayer ? this.buildUTFGridReq(aa) :
													this.meshUTFGridPath(R, q), ba.gridsrc = q), this.bindAndLoadTile(ba), Y++;
										this.parentMap.wraparound ? (aa = this.tileArray[this.tileArray.length - 1][K], q = R, ba.node[0].style.left = q % this.tileNumInCSBoun == this.tileNumInCSBoun - 1 || -1 == q % this.tileNumInCSBoun ? parseInt(aa.node[0].style.left) + this.tileImageWidth - this.coverPixel + "px" : parseInt(aa.node[0].style.left) + this.tileImageWidth + "px") : a.$(ba.node).css("left", I)
									}
									this.tileArray.push(t)
								}
						if (0 !== c)
							for (K = 0; 0 < c ? K < c : K > c; 0 < c ? K++ : K--)
								for (0 < c ? (qa = this.tileMinY - (K + 1) * this.tileImageHeight,
										this.topNum++) : (qa = this.tileMinY + (this.tileNumY - K) * this.tileImageHeight, this.topNum--), W = 0; W < this.tileArray.length; W++)
									t = this.tileArray[W], 0 < c ? (R = B - b + W, q = G + K + 1, aa = t.pop(), aa = this.initTileNode(aa), I = aa.node, a.util.DomUtil.setImageSrc(I, null), t.unshift(aa), a.$(I).css("top", qa), aa = this.meshImgPath(R, q), a.util.DomUtil.setImageSrc(I, aa), I[0].mx = R, I[0].my = q, this.enableUTFGrid && (q = this.isDynamicTileLayer ? this.buildUTFGridReq(aa) : this.meshUTFGridPath(R, q), t[0].gridsrc = q), this.bindAndLoadTile(t[0])) : (R = B -
											b + W, q = G - this.tileNumY + K, aa = t.shift(), aa = this.initTileNode(aa), I = aa.node, a.util.DomUtil.setImageSrc(I, null), t.push(aa), a.$(I).css("top", qa), aa = this.meshImgPath(R, q), a.util.DomUtil.setImageSrc(I, aa), I[0].mx = R, I[0].my = q, this.enableUTFGrid && (q = this.isDynamicTileLayer ? this.buildUTFGridReq(aa) : this.meshUTFGridPath(R, q), t[t.length - 1].gridsrc = q), this.bindAndLoadTile(t[t.length - 1])), Y++;
						this.requiredBinds += Y;
						this.tileMinX = this.parentMap.wraparound ? parseInt(this.tileArray[0][0].node[0].style.left) : this.tileMinX -
							b * this.tileImageWidth;
						this.tileMinY -= c * this.tileImageHeight;
						this.centerMesh.moveMeshCode(-b, c)
					}
				} else
					R = a.event, b = new R.MapEvent(R.LayerEvent.FINISH_LOAD, this), b.mapContext = this.parentMap.getMapContext(), this.fire(R.LayerEvent.FINISH_LOAD, b)
		},
		refresh: function A(b, c) {
			if (!a.isNull(this.parentMap) && (a.isNull(c) && (c = !0), A.base.call(this, b, c), this.reloadNumber = Math.round(1E10 * Math.random()), this.parentMap && (this.parentMap.getMapContext().getTransform(), this.clearLayer(), this.init()), c)) {
				var Y = new a.event.LayerEvent(a.event.LayerEvent.AFTER_REFRESH,
						this);
				this.parentMap && (Y.mapContext = this.parentMap.getMapContext());
				this.fire(a.event.LayerEvent.AFTER_REFRESH, Y)
			}
		},
		checkVisible: function (a) {
			if (this.initError || !this.isVisible(a) || a >= this.tileLayerConfig.zoomLevels.length)
				return !1;
			if (this.parentMap.enableZoomLevels) {
				for (var b = 0; b < this.parentMap.enableZoomLevels.length; b++)
					if (this.parentMap.enableZoomLevels[b] == a)
						return !0;
				return !1
			}
			return !0
		},
		clearLayer: function () {
			this.jqLayerDiv && this.zoomControl && !this.zoomControl.zooming && (this.jqLayerDiv.remove(),
				this.jqLayerDiv = null);
			this.tileArray = []
		},
		changeOpacity: function () {
			for (var b = this.tileArray.length, c = a.util.DomUtil.changeOpacity, G = 0; G < b; G++)
				for (var Y = this.tileArray[G].length, W = 0; W < Y; W++)
					c(this.tileArray[G][W].node, this.opacity)
		},
		zoom: function (b, c, G, Y) {
			b = this.getRealZoomLevel(b);
			c = this.getRealZoomLevel(c);
			this.checkVisible(b) ? (this.zoomControl || (this.zoomControl = new a.layer.TileZoomAnimation(this)), this.checkVisible(c) ? this.parentMap.tileLayerZoomAnimation ? this.zoomControl.scaling ? (this.init(), this.zoomControl.endScaling()) :
				this.zoomControl.showTiles(b, c, G, Y) : (this.init(), this.zoomControl.tileInitialized()) : (this.clearLayer(), this.zoomControl.tileInitialized())) : this.init()
		},
		getTileServerURL: function () {
			this.serverURL == this.parentMap.mapviewerURL && (this.serverURL += "/mcserver");
			return this.serverURL
		},
		setVisibleImpl: function () {
			this.jqLayerDiv && this.jqLayerDiv.css("visibility", this.visible ? "visible" : "hidden");
			this.visible && this.init()
		},
		getCustomTags: function () {
			return this.tileLayerConfig && this.tileLayerConfig.customTags ?
			this.tileLayerConfig.customTags : {}
		},
		destroy: function B() {
			this.clearLayer();
			this.zoomContorl && this.zoomControl.destroy();
			this.zoomControl = this.initError = null;
			B.base.call(this)
		},
		getEnabledConfig: function (b) {
			if (this.parentMap.enableZoomLevels) {
				var c = new a.layer.TileLayerConfig;
				c.bounds = b.bounds;
				c.srid = b.srid;
				c.tileImageFormat = b.tileImageFormat;
				c.isTransparentImage = b.isTransparentImage;
				c.tileImageWidth = b.tileImageWidth;
				c.tileImageHeight = b.tileImageHeight;
				c.customTags = b.customTags;
				c.zoomLevels = [];
				for (var Y =
						[], W = 0; W < this.parentMap.enableZoomLevels.length; W++)
					if (!(b.zoomLevels.length <= this.parentMap.enableZoomLevels[W] || 0 > this.parentMap.enableZoomLevels[W])) {
						var K = b.zoomLevels[this.parentMap.enableZoomLevels[W]];
						K ? (Y.push(this.parentMap.enableZoomLevels[W]), c.zoomLevels.push(K)) : a.util.Logger.warning("MAPVIEWER_9039", "OM.layer.Tilelayer.setEnabledZoomLevels", "[" + this.parentMap.enableZoomLevels[W] + "]")
					}
				this.parentMap.enableZoomLevels = Y;
				return c
			}
			return b
		},
		getRealZoomLevel: function (a) {
			return this.parentMap.enableZoomLevels ?
			(a >= this.parentMap.enableZoomLevels.length && (a = this.parentMap.enableZoomLevels.length), this.parentMap.enableZoomLevels[a]) : a
		},
		exportToSVG: function (b) {
			var c = parseInt(this.jqLayerDiv.css("left")),
			Y = parseInt(this.jqLayerDiv.css("top")),
			W = this.parentMap.graphics;
			W.setLeftTop(b, c, Y);
			var K = this;
			K.loadImg = 0;
			this.jqLayerDiv.find("img").each(function () {
				var q = this.src,
				t = a.$(this);
				c = parseInt(t.css("left"));
				Y = parseInt(t.css("top"));
				K.loadImg++;
				W.drawImage({
					x: c,
					y: Y
				}, {
					src: q,
					width: 256,
					height: 256
				}, {
					group: b
				}).handleEvent =
				function (a) {
					this.resourceUpdate(a);
					K.loadImg--
				}
			});
			return b
		},
		drawTilesImages: function (a, b) {
			var c = this.parentMap.getMapCenter(),
			c = this.serverURL + "?request\x3dgetmap\x26mapcache\x3d" + this.dataSource + "." + this.tileLayer + "\x26zoomlevel\x3d" + this.parentMap.getMapZoomLevel() + "\x26cx\x3d" + c.getX() + "\x26cy\x3d" + c.getY() + "\x26width\x3d" + a + "\x26height\x3d" + b;
			this.loadingImg = !0;
			var W = this,
			K = new Image;
			K.onload = function () {
				W.loadingImg = !1;
				W.canvas.getContext("2d").drawImage(K, 0, 0, a, b)
			};
			K.onerror = function () {
				W.loadingImg =
					!1;
				W.canvas = null
			};
			K.src = c
		},
		clone: function G(a) {
			a = G.base.call(this, a);
			a.displayed && (a.jqLayerDiv = null, a.displayed = !1, a.zoomControl = null);
			return a
		},
		prepareDrag: function () {
			var a = this.jqLayerDiv[0];
			this.downLoc = {
				l: a.offsetLeft,
				t: a.offsetTop
			}
		},
		calcMeshCode: function (a, b, c) {
			this.meshLength = Math.max(1, Math.ceil(Math.log(c) / Math.log(this.TILING_FACTOR)));
			this.xFactors.length = this.meshLength;
			this.yFactors.length = this.meshLength;
			this.factors(a, this.xFactors);
			this.factors(b, this.yFactors)
		},
		factors: function (a,
			b) {
			for (var c = 0; c < this.meshLength; c++) {
				var K = a / this.TILING_FACTOR;
				b[this.meshLength - 1 - c] = Math.floor(a % this.TILING_FACTOR);
				a = K
			}
		},
		getMeshStr: function (a) {
			a = "/" + a;
			for (var b = 0; b < this.meshLength; b++)
				b < this.meshLength && (a += "/"), a += this.xFactors[b] + "_" + this.yFactors[b];
			return a
		},
		tileImgLoadedHandler: function (b) {
			if (b instanceof a.event.LayerEvent && (b.type === a.event.LayerEvent.TILE_IMG_LOADED || b.type === a.event.LayerEvent.TILE_IMG_LOAD_ERROR)) {
				var c = this.requiredBinds + this.initRequiredBinds;
				0 === c && (c = 1);
				this.tilesImgLoaded++;
				this.tilesPercent = this.tilesImgLoaded / c * 100;
				this.tilesImgLoaded >= c ? (b = new a.event.LayerEvent(a.event.LayerEvent.ALL_TILES_LOADED, this), b.totalTiles = c, this.initRequiredBinds = this.requiredBinds = this.tilesImgLoaded = 0, this.fire(a.event.LayerEvent.ALL_TILES_LOADED, b), a.notNull(this.initTask) && (this.initTask.complete(), this.initTask = null)) : (b = new a.event.LayerEvent(a.event.LayerEvent.TILE_IMG_LOADING, this), a.notNull(this.initTask) && (c = this.getTilesPercentStatus(), 0 < c ? this.initTask.update(c / 100) : this.initTask.update(.25)));
				this.lastEvent = b.type
			}
		},
		getTilesPercentStatus: function () {
			return this.tilesPercent
		},
		setEnableUTFGridInfoWindow: function (a) {
			this.enableUTFGridInfoWindow(a)
		},
		enableUTFGridInfoWindow: function (b) {
			this.enableInfoWindow(b);
			this.parentMap && a.notNull(this.isVisible()) && !0 === this.isVisible() && this.parentMap.updateUTFGridLayerCount()
		},
		setInfoWindowTrigger: function (b) {
			this.mouseETypeUTFGrid = b === a.event.MouseEvent.MOUSE_OVER || b === a.event.MouseEvent.MOUSE_MOVE ? a.event.MouseEvent.MOUSE_MOVE : a.event.MouseEvent.MOUSE_CLICK;
			this.parentMap.validateUTFGridLayerTriggers();
			this.parentMap.updateUTFGridLayerListener()
		},
		setVisible: function Y(a) {
			Y.base.call(this, a);
			this.parentMap && (this.parentMap.changeOverView(), this.parentMap.updateUTFGridLayerCount())
		},
		getUTFGridResolution: function (b) {
			var c;
			if (a.isNull(b))
				return this.UTFGRID_RESOLUTION;
			try {
				return c = parseInt(b),
				a.isNull(c) || 1 > c ? this.UTFGRID_RESOLUTION : c
			} catch (K) {
				return this.UTFGRID_RESOLUTION
			}
		},
		setTileLayerConfig: function (a) {
			this.tileLayerConfig = a
		},
		getTileLayerConfigFromWMTS: function (b,
			c) {
			var K = this;
			a.util.HttpRequest.send(this.getCapabilitiesURL, "REQUEST\x3dGetCapabilities\x26SERVICE\x3dWMTS", function (b) {
				if (K.parentMap && K.parentMap.graphics)
					if (b) {
						b = a.wmts.WMTSContents.readFromDocument(b);
						b = a.wmts.WMTSUtil.optionsFromCapabilities(b, {
							layer: K.layerID,
							matrixSet: K.matrixSetID
						});
						b = K.buildConfig(b);
						K.setTileLayerConfig(b);
						var t = new a.event.LayerEvent(a.event.LayerEvent.FINISH_GOT_CONFIG, K);
						t.config = b;
						t.mapContext = K.parentMap.getMapContext();
						a.notNull(K.initTask) && K.initTask.update(.25);
						K.fire(a.event.LayerEvent.FINISH_GOT_CONFIG, t);
						c && c(b)
					} else
						return K.parentMap && K.parentMap.graphics && (K.initError = !0, a.util.Logger.warning("MAPVIEWER_9001", "OM.layer.Tilelayer.getTileLayerConfigFromWMTS", "[" + K.name + "]"), b = a.event, t = new b.LayerEvent(b.LayerEvent.INIT_ERROR, K), K.parentMap && (t.mapContext = K.parentMap.getMapContext(), a.notNull(K.initTask) && (K.initTask.abort(), K.initTask = null), K.fire(b.LayerEvent.INIT_ERROR, t))), null
			}, "XML", function (b) {
				if (K.parentMap && K.parentMap.graphics) {
					K.initError =
						!0;
					if (b && b.responseText)
						try {
							var c = a.$(a.$.parseXML(b.responseText)).find("oms_error");
							0 < c.length && a.util.Logger.warning("MAPVIEWER_9009", "OM.layer.Tilelayer.getTileLayerConfig", c.text())
						} catch (W) {
							a.util.Logger.warning("MAPVIEWER_9009", "OM.layer.Tilelayer.getTileLayerConfig", b.responseText)
						}
					else
						a.util.Logger.warning("MAPVIEWER_9009", "OM.layer.Tilelayer.getTileLayerConfig", "[" + K.name + "]");
					b = a.event;
					c = new b.LayerEvent(b.LayerEvent.INIT_ERROR, K);
					K.parentMap && (c.mapContext = K.parentMap.getMapContext(),
						a.notNull(K.initTask) && K.initTask.abort(), K.fire(b.LayerEvent.INIT_ERROR, c))
				}
			})
		}
	});
	a.layer.TileLayerConfig = function (a) {
		this.tileImageHeight = this.tileImageWidth = 256;
		this.tileImageFormat = "PNG";
		this.enableUTFGrid = this.isInZXYOrder = this.isXYZStorageScheme = this.isTransparentImage = !1;
		this.utfgridResolution = 4;
		a && (this.srid = a.srid, this.zoomLevels = a.zoomLevels, this.bounds = a.bounds, a.tileImageWidth && (this.tileImageWidth = a.tileImageWidth), a.tileImageHeight && (this.tileImageHeight = a.tileImageHeight), a.tileImageFormat &&
			(this.tileImageFormat = a.tileImageFormat), a.isTransparentImage && (this.isTransparentImage = a.isTransparentImage), a.customTags && (this.customTags = a.customTags), a.isXYZStorageScheme && (this.isXYZStorageScheme = a.isXYZStorageScheme, a.isInZXYOrder && (this.isInZXYOrder = a.isInZXYOrder)), a.enableUTFGrid && (this.enableUTFGrid = !0, this.utfgridResolution = a.utfgridResolution))
	};
	a.layer.TileLayerConfig.prototype.equals = function (a) {
		if (this.srid != a.srid || this.zoomLevels && a.zoomLevels && this.zoomLevels.length != a.zoomLevels.length)
			return !1;
		for (var b = this.zoomLevels.length, c = 0; c < b; c++)
			if (this.zoomLevels[c].resolution != a.zoomLevels[c].resolution || this.zoomLevels[c].stretchRatio != a.zoomLevels[c].stretchRatio)
				return !1;
		return !0
	};
	a.layer.TileLayerConfig.CONFIG_ELOCATION = new a.layer.TileLayerConfig;
	a.layer.TileLayerConfig.CONFIG_S_ELOCATION = new a.layer.TileLayerConfig;
	a.layer.TileLayerConfig.CONFIG_GOOGLE = new a.layer.TileLayerConfig;
	a.layer.TileLayerConfig.CONFIG_TOMTOM = new a.layer.TileLayerConfig;
	a.layer.TileLayerConfig.CONFIG_LOCATIONBOX =
		new a.layer.TileLayerConfig;
	a.layer.TileLayerConfig.CONFIG_WGS84_WORLD = new a.layer.TileLayerConfig;
	a.layer.TileLayerConfig.CONFIG_OSM = new a.layer.TileLayerConfig;
	a.layer.TileLayerConfig.CONFIG_BAIDU = new a.layer.TileLayerConfig;
	a.layer.TileLayerConfig.setConstants = function () {
		var b = a.layer.TileLayerConfig,
		c = new a.universe.WorldMercatorUniverse;
		b.CONFIG_ELOCATION.zoomLevels = c.getZoomLevels();
		b.CONFIG_ELOCATION.srid = c.getSRID();
		b.CONFIG_ELOCATION.bounds = c.getMapBounds();
		b.CONFIG_ELOCATION.tileImageFormat =
			"PNG";
		b.CONFIG_ELOCATION.isTransparentImage = !1;
		c = new a.universe.WorldMercatorUniverse;
		b.CONFIG_S_ELOCATION.zoomLevels = c.getZoomLevels();
		b.CONFIG_S_ELOCATION.srid = c.getSRID();
		b.CONFIG_S_ELOCATION.bounds = c.getMapBounds();
		b.CONFIG_S_ELOCATION.tileImageFormat = "PNG";
		b.CONFIG_S_ELOCATION.isTransparentImage = !1;
		c = new a.universe.WorldMercatorUniverse;
		b.CONFIG_GOOGLE.zoomLevels = c.getZoomLevels();
		b.CONFIG_GOOGLE.srid = c.getSRID();
		b.CONFIG_GOOGLE.bounds = c.getMapBounds();
		c = new a.universe.BaiduUniverse;
		b.CONFIG_BAIDU.zoomLevels =
			c.getZoomLevels();
		b.CONFIG_BAIDU.srid = c.getSRID();
		b.CONFIG_BAIDU.bounds = c.getMapBounds();
		a.notNull(a.universe.TomTomUniverse) && (c = new a.universe.TomTomUniverse, b.CONFIG_TOMTOM.zoomLevels = c.getZoomLevels(), b.CONFIG_TOMTOM.srid = c.getSRID(), b.CONFIG_TOMTOM.bounds = c.getMapBounds());
		a.notNull(a.universe.LocationBoxUniverse) && (c = new a.universe.LocationBoxUniverse, b.CONFIG_LOCATIONBOX.zoomLevels = c.getZoomLevels(), b.CONFIG_LOCATIONBOX.srid = c.getSRID(), b.CONFIG_LOCATIONBOX.bounds = c.getMapBounds());
		c = new a.universe.LatLonUniverse;
		b.CONFIG_WGS84_WORLD.zoomLevels = c.getZoomLevels();
		b.CONFIG_WGS84_WORLD.srid = c.getSRID();
		b.CONFIG_WGS84_WORLD.bounds = c.getMapBounds();
		c = new a.universe.OSMUniverse;
		b.CONFIG_OSM.zoomLevels = c.getZoomLevels();
		b.CONFIG_OSM.srid = c.getSRID();
		b.CONFIG_OSM.bounds = c.getMapBounds()
	};
	a.layer.TileLayerConfig.setConstants();
	a.layer.TileZoomAnimation = a.Class.extend({
		initialize: function (b) {
			this.tdiff = this.ldiff = 0;
			this.tileLayer = b;
			this.aniDiv = this.tileArray = null;
			this.zooming = !1;
			this.timeouts = [];
			this.imageWidth = b.tileLayerConfig.tileImageWidth;
			this.imageHeight = b.tileLayerConfig.tileImageHeight;
			this.animate = !a.browser.msie || "transition" in document.documentElement.style ? !0 : !1
		},
		computeTilesOffset: function () {
			var b = this.tileLayer.jqLayerDiv;
			b && (b = a.util.DomUtil.getElementPos(b), this.ldiff = -b.left, this.tdiff = -b.top)
		},
		getScreenXY: function (a, b, c) {
			var q = this.tileLayer.tileLayerConfig.zoomLevels[c];
			c = 1 / q.resolution;
			var q = c / q.stretchRatio,
			t = this.newCenter;
			return {
				x: (a - t.getX()) * c,
				y: (t.getY() - b) * q
			}
		},
		copyTiles: function (a) {
			if (this.aniDiv && this.aniDiv.parent())
				return !1;
			this.oldLevel = a;
			this.aniDiv = this.tileLayer.jqLayerDiv;
			this.tileArray = this.tileLayer.tileArray;
			this.aniDiv.css("zIndex", this.tileLayer.zIndex + 1);
			return !0
		},
		transformTiles: function (b, c) {
			var K = this.getScreenXY(this.oldCenter.getX(), this.oldCenter.getY(), b),
			q = this.getScreenXY(this.newCenter.getX(), this.newCenter.getY(), b),
			t = this.tileLayer.tileLayerConfig,
			I = t.zoomLevels[b],
			aa = t.zoomLevels[c],
			ba = t.bounds,
			t = this.getLeftTopTile(),
			R = t.x * this.imageWidth * I.resolution + ba.getMinX(),
			qa = (t.y + 1) * this.imageHeight *
			I.resolution * I.stretchRatio + ba.getMinY(),
			ba = this.getScreenXY(R, qa, b),
			R = this.getScreenXY(R, qa, c),
			I = I.resolution / aa.resolution,
			K = "translate3d(" + (-1 * (q.x - K.x + ba.x - R.x) - t.l * (I - 1)) + "px," + (-1 * (q.y - K.y + ba.y - R.y) - t.t * (I - 1)) + "px, 0px) scale(" + I + ")",
			ua = this;
			a.browser.webkit3d ? (this.aniDiv.css("-webkit-transition", "-webkit-transform 0.25s cubic-bezier(0,0,0.5,1)"), this.aniDiv.bind("webkitTransitionEnd", function () {
					ua.zooming = !1
				}), this.aniDiv.css("-webkit-transform", K)) : (this.aniDiv.css("transition", "transform 0.25s cubic-bezier(0,0,0.5,1)"),
				this.aniDiv.bind("transitionend", function () {
					ua.zooming = !1
				}), this.aniDiv.css("transform", K));
			this.zooming = !0
		},
		getLeftTopTile: function () {
			var a = this.tileArray,
			a = a[0][0].node[0].src !== this.tileLayer.transImgURL ? a[0][0].node : a[1][0].node[0].src !== this.tileLayer.transImgURL ? a[1][0].node : a[0][1].node[0].src !== this.tileLayer.transImgURL ? a[0][1].node : a[1][1].node,
			b = a.position();
			return {
				x: a[0].mx,
				y: a[0].my,
				l: b.left,
				t: b.top
			}
		},
		showTiles: function (b, c, K, q) {
			if (!this.tileLayer.isVisible() || a.isNull(this.tileLayer.tileArray) ||
				this.tileLayer.tileLayerConfig.isTransparentImage)
				this.reset();
			else {
				var t = null;
				!1 === a.gv.progressBarDisabled && (t = new a.util.Task(this.tileLayer.parentMap.progressService), t.start());
				this.newCenter = q;
				this.oldCenter = K;
				this.animate ? (this.computeTilesOffset(), this.copyTiles(b), this.transformTiles(this.oldLevel, c), this.tileLayer.init(), this.tileLayer.jqLayerDiv.css("visibility", "hidden")) : (this.tileLayer.jqLayerDiv.css("visibility", "hidden"), this.tileLayer.init());
				a.notNull(t) && t.update(.7);
				a.notNull(t) &&
				t.complete()
			}
		},
		reset: function () {
			this.tdiff = this.ldiff = 0;
			this.aniDiv && this.aniDiv.parent() && this.aniDiv.remove();
			this.aniDiv = this.tileArray = null;
			this.zooming = !1;
			for (var a = 0; a < this.timeouts.length; a++)
				clearTimeout(this.timeouts[a]);
			this.timeouts = [];
			this.tileLayer.isVisible() && this.tileLayer.init()
		},
		tileInitialized: function () {
			if (this.tileLayer && this.tileLayer.parentMap)
				if (!this.hasTilesLoadFinished() && !this.tileLayer.isLocalTileLayer || this.zooming) {
					var b = this,
					c = setTimeout(function () {
						b.tileInitialized()
					},
							70);
					this.timeouts.push(c)
				} else {
					this.aniDiv && this.startClear();
					this.tileLayer.jqLayerDiv && this.tileLayer.jqLayerDiv.css("visibility", this.tileLayer.visible ? "visible" : "hidden");
					var c = a.event,
					K = new c.LayerEvent(c.LayerEvent.FINISH_LOAD, this.tileLayer);
					K.mapContext = this.tileLayer.parentMap.getMapContext();
					this.tileLayer.fire(c.LayerEvent.FINISH_LOAD, K)
				}
		},
		hasTilesLoadFinished: function () {
			if (!this.tileArray && !this.tileLayer.tileArray)
				return !0;
			if (!this.tileLayer.isLocalTileLayer) {
				var a,
				b;
				for (a = 0; a < this.tileLayer.tileArray.length; a++)
					for (b =
							0; b < this.tileLayer.tileArray[a].length; b++)
						if (!this.hasTileLoaded(this.tileLayer.tileArray[a][b].node))
							return !1
			}
			return !0
		},
		hasTileLoaded: function (b) {
			return b[0].src === a.util.MiscUtil.transparentImgURL ? !0 : a.browser.msie ? b.imgLoadFinished : 1 >= Math.abs(Math.max(b[0].offsetWidth, b[0].width) - this.imageWidth)
		},
		startClear: function () {
			if (a.browser.msie)
				for (var b = 0; b < this.tileLayer.tileArray.length; b++)
					for (var c = 0; c < this.tileLayer.tileArray[b].length; c++)
						this.tileLayer.tileArray[b][c].node.css("display", "");
			this.aniDiv && this.aniDiv.css("zIndex", this.tileLayer.zIndex);
			this.clearCloneTiles()
		},
		clearCloneTiles: function () {
			if (this.tileLayer && this.tileLayer.parentMap)
				if (this.hasTilesLoadFinished()) {
					var a;
					for (a = 0; a < this.tileLayer.tileArray.length; a++)
						for (var b = 0; b < this.tileLayer.tileArray[a].length; b++)
							this.tileLayer.tileArray[a][b].node.css("display", "");
					this.removeCloneTiles();
					for (a = 0; a < this.timeouts.length; a++)
						clearTimeout(this.timeouts[a]);
					this.timeouts = []
				} else {
					var c = this;
					a = setTimeout(function () {
						c.clearCloneTiles()
					},
							70);
					this.timeouts.push(a)
				}
		},
		removeCloneTiles: function () {
			this.aniDiv && this.aniDiv.parent() && (this.aniDiv.remove(), this.aniDiv = null);
			this.zooming = !1
		},
		scaleTiles: function (b) {
			if (this.scaling || this.tileLayer.isVisible() && !a.isNull(this.tileLayer.tileArray)) {
				var c,
				K,
				q;
				if (!this.scaling)
					for (this.computeTilesOffset(), this.copyTiles(), this.scaling = !0, c = 0; c < this.tileArray.length; c++)
						for (K = 0; K < this.tileArray[c].length; K++) {
							q = this.tileArray[c][K].node;
							var t = a.util.DomUtil.getElementPos(a.$(q));
							q.origLeft = t.left;
							q.origTop = t.top
						}
				c = this.tileLayer.tileLayerConfig;
				var t = c.tileImageWidth * b,
				I = c.tileImageWidth * b;
				c = this.tileLayer.parentMap.getMapContext();
				var aa = c.getDeviceWidth() / 2 + this.ldiff,
				ba = c.getDeviceHeight() / 2 + this.tdiff;
				for (c = 0; c < this.tileArray.length; c++)
					for (K = 0; K < this.tileArray[c].length; K++)
						q = this.tileArray[c][K].node, this.scaleTile(q, b, t, I, aa, ba)
			} else
				this.reset()
		},
		scaleTile: function (b, c, K, q, t, I) {
			b.zoomFinished = !0;
			1 != c && (t -= (t - b.origLeft) * c, c = I - (I - b.origTop) * c, a.$(b).css({
					left: t,
					top: c,
					width: K + 1,
					height: q +
					1
				}))
		},
		endScaling: function () {
			this.scaling = !1;
			var b = this.tileLayer.jqLayerDiv;
			if (b) {
				var c = a.util.DomUtil.getElementPos(b),
				K = c.left,
				c = c.top,
				q = a.util.DomUtil.getElementPos(b.parent().parent());
				b.css({
					left: K + q.left,
					top: c + q.Top
				})
			}
			this.startClear()
		},
		destroy: function () {
			this.tileLayer = null
		}
	});
	a.layer.Mesh = function (a, b, c, q) {
		var t = a.zoomLevels[q];
		this.mw = a.tileImageWidth * t.resolution;
		this.mh = a.tileImageHeight * t.resolution * t.stretchRatio;
		a = a.bounds;
		this.mX = Math.floor((b - a.getMinX()) / this.mw);
		this.mY = Math.floor((c -
					a.getMinY()) / this.mh);
		this.zoom = q;
		this.minX = this.mX * this.mw + a.getMinX();
		this.minY = this.mY * this.mh + a.getMinY()
	};
	a.layer.Mesh.prototype.moveMeshCode = function (a, b) {
		this.mX += a;
		this.mY += b
	};
	a.layer.VectorLayer = a.layer.Layer.extend({
		initialize: function W(b, c) {
			if (a.isNull(c) || a.isNull(c.def) || a.isNull(c.def.type))
				throw Error("Invalid or null VectorLayer options found.");
			a.notNull(this.boundingDataTask) && (this.boundingDataTask = null);
			a.notNull(this.initTask) && (this.initTask = null);
			this.displayFeaturesTask = null;
			this.displayFeaturesTaskEnabled = !0;
			this.editingContextMenuEnabled = !1;
			this.hideEditCircleVertices = !0;
			var t = c.def;
			this.options = c;
			W.base.call(this, b);
			this.options && this.options.renderingStyle && (this.opacity = a.notNull(this.options.renderingStyle.opacity) ? this.options.renderingStyle.opacity : this.opacity);
			this.useRTree = a.notNull(c && c.useRTree) ? c.useRTree : a.gv.useRTree;
			this.layerType = a.LayerTypes.VECTOR;
			this.initError = this.dataLoaded = this.cachingEnabled = !1;
			this.name = b;
			var I = a.layer.VectorLayer;
			this.type =
				t.type;
			a.isNull(t.xRatio) || !a.util.ValidationUtil.isNumber(t.xRatio) || 1 > t.xRatio ? this.xRatio = 2 : this.xRatio = t.xRatio;
			a.isNull(t.yRatio) || !a.util.ValidationUtil.isNumber(t.yRatio) || 1 > t.yRatio ? this.yRatio = 2 : this.yRatio = t.yRatio;
			this.searchBuffer = a.browser.touchSupported ? 10 : 5;
			this.enableXHR = t && t.enableXHR ? !0 : !1;
			this.jsonp = !1;
			"undefined" !== typeof t.jsonp && (this.jsonp = t.jsonp);
			this.flag = !0;
			this.bfMbr = this.mbr = null;
			var aa = t.dataSource || t.datasource;
			if (this.type === I.TYPE_PREDEFINED)
				this.dataSource = aa, this.themeName =
					t.theme, t.url && (this.serverURL = t.url), a.isNull(t.loadOnDemand) ? this.loadOnDemand = !0 : this.loadOnDemand = t.loadOnDemand, this.workspace = t.workspace, this.featureArray = [];
			else if (this.type === I.TYPE_LOCAL) {
				this.featureArray = [];
				for (var I = {}, aa = t.features ? t.features.length : 0, ba = 0; ba < aa; ba++) {
					var R = t.features[ba];
					a.notNull(R) && !0 !== I[R.id] ? (this.featureArray.push(R), I[R.id] = !0) : a.util.Logger.warning("MAPVIEWER_9005", "OM.layer.VectorLayer")
				}
			} else
				this.type === I.TYPE_JDBC ? (this.dataSource = aa, this.sql = t.sql, this.serverURL =
						t.url, this.featureArray = [], this.geometryColumn = t.geometryColumn, this.labelColumn = t.labelColumn ? t.labelColumn.toUpperCase() : null, this.keyColumn = t.keyColumn ? t.keyColumn.toUpperCase() : null, this.baseTable = t.baseTable ? t.baseTable.toUpperCase() : null, a.isNull(t.loadOnDemand) ? this.loadOnDemand = !0 : this.loadOnDemand = t.loadOnDemand, this.workspace = t.workspace, this.jdbcSrid = a.notNull(t.jdbcSrid) ? t.jdbcSrid : 8307, this.asis = !0 === t.asis || "true" === t.asis) : this.type === I.TYPE_DATAPACK ? (this.serverURL = (I = t.dataPackUrl ||
							t.url) ? I : "invalid url", this.featureArray = [], this.geometryColumn = t.geometryColumn, this.labelColumn = t.labelColumn ? t.labelColumn.toUpperCase() : null) : this.type === I.TYPE_GEORSS && (this.serverURL = t.url);
			c.renderingStyle && c.renderingStyle.effects && 0 < c.renderingStyle.effects.length && (this.visualFilter = c.renderingStyle.effects[0]);
			if (this.renderingStyle = c.renderingStyle)
				this.renderingStyle = c.renderingStyle;
			this.styleAttributes = c.styleAttributes;
			this.boundingTheme = c.boundingTheme;
			this.enableInfoWindow(a.isNull(c.infoWindow) ?
				!0 : c.infoWindow);
			this.boundingZoomLevel = null;
			this.selectionEnable = !1;
			this.selectionMode = a.layer.VectorLayer.SINGLE_SELECTION;
			this.keepSelected = !1;
			this.bringToTopFlag = !0;
			this.selectedFeatures = [];
			this.featureEditable = !1;
			this.hoverStyle = this.hoverFeature = null;
			this.mapping = this.hoverEnable = !1;
			this.showToolTip = !0;
			this.mouseCursor = a.CursorTypes.POINTER;
			this.areaIdx = this.loadingStyle = 0;
			this.attributeTypes = this.undoManager = this.changeManager = null;
			this.notNullAttributes = [];
			this.rtree = null;
			this.segmentRtree = {};
			this.sharedBoundary = !1;
			this.selectionChecker = null;
			this.pointerSensitivity = !0;
			this.tileFeatureGroup = {}
		},
		setStyles: function (a) {
			var b = this;
			Object.entries(a).forEach(function (a) {
				var c = a[1];
				switch (a[0]) {
				case "render":
					b.setRenderingStyle(c);
					break;
				case "hover":
					b.setHoverStyle(c);
					break;
				case "select":
					b.setSelectStyle(c);
					break;
				case "edit_point":
					b.setRenderingStyle_PointEditing(c)
				}
			})
		},
		setRenderingStyle_PointEditing: function (b) {
			!a.isNull(b) && b instanceof a.style.Style && (this.renderingStyle_PointEditing = b)
		},
		getRenderingStyle_PointEditing: function () {
			return this.renderingStyle_PointEditing
		},
		setRenderingStyle: function (b, c) {
			if (b)
				if (this.parentMap && this.isServerSideStyle(b, "rendering"))
					c && (this.styleAttributes = c);
				else {
					var q = this.renderingStyle,
					t = this.styleAttributes;
					this.renderingStyle = b;
					this.heatMap = null;
					c && (this.styleAttributes = c, b instanceof a.style.BucketStyle && !b.isServerSide && (this.loadOnDemand ? b.generateBuckets(this.featureArray, this.styleAttributes, !0) : b.generateBuckets(this.featureArray, this.styleAttributes,
								!1)));
					b.effects && 0 < b.effects.length && this.setVisualFilter(b.effects[0]);
					b.opacity && (0 <= b.opacity || 1 >= b.opacity ? this.opacity = b.opacity : a.util.Logger.warning("The 'opacity' must be in range of [0,1.0]"));
					!this.visible && this.displayed && (this.parentMap.graphics.remove(this.realGroup), this.clearFeatureShapes(), this.displayed = !1);
					this.displayed && (this.parentMap.graphics.remove(this.realGroup), this.clearFeatureShapes(), this.displayFeatures(!1), "POINT" !== this.getFeatureGeometryType() && "PieChart" !== this.renderingStyle.styleType &&
						"BarChart" !== this.renderingStyle.styleType || this.parentMap.refreshVectorLayerLabels());
					q == b && a.util.MiscUtil.arraysAreEqual(t, this.styleAttributes) || (q = new a.event.LayerEvent(a.event.LayerEvent.RENDERING_STYLE_CHANGED, this), q.newStyle = b, q.attributes = c, this.parentMap && (q.mapContext = this.parentMap.getMapContext()), this.fire(a.event.LayerEvent.RENDERING_STYLE_CHANGED, q))
				}
		},
		getAllFeatures: function () {
			return this.featureArray
		},
		size: function () {
			return this.featureArray ? this.featureArray.length : 0
		},
		getRenderingStyle: function () {
			var b =
				this.renderingStyle;
			a.isNull(b) && this.featureArray && 0 < this.featureArray.length && (b = this.featureArray[0].renderingStyle);
			return b
		},
		setLabelingStyle: function (b) {
			if (b && (!this.parentMap || !this.isServerSideStyle(b, "label"))) {
				this.labelingStyle = b;
				this.setLabelsVisible(!0);
				if (this.displayed) {
					for (var c = this.featureArray ? this.featureArray.length : 0, q = 0; q < c; q++)
						this.featureArray[q].setLabelingStyle(this.labelingStyle);
					this.parentMap.refreshVectorLayerLabels()
				}
				c = a.event.LayerEvent;
				q = new c(c.LABELING_STYLE_CHANGED,
						this);
				q.style = b;
				this.parentMap && (q.mapContext = this.parentMap.getMapContext());
				this.fire(c.LABELING_STYLE_CHANGED, q)
			}
		},
		getLabelingStyle: function () {
			return this.labelingStyle
		},
		setLabelColumn: function (a) {
			this.labelColumn = a
		},
		getLabelColumn: function () {
			return this.labelColumn
		},
		getSelectedFeatures: function () {
			return this.selectedFeatures
		},
		setSelectStyle: function (b) {
			if (b && (!this.parentMap || !this.isServerSideStyle(b, "select"))) {
				this.enableFeatureSelection(!0, this.selectionMode);
				this.selectionStyle = b;
				b.effects &&
				0 < b.effects.length && this.setSelectVisualFilter(b.effects[0]);
				var c = a.event.LayerEvent,
				q = new c(c.SELECTION_STYLE_CHANGED, this);
				q.style = b;
				this.parentMap && (q.mapContext = this.parentMap.getMapContext());
				this.fire(c.SELECTION_STYLE_CHANGED, q)
			}
		},
		setPartialSelectStyleForCluster: function (b) {
			if (b && (!this.parentMap || !this.isServerSideStyle(b, "select"))) {
				this.enableFeatureSelection(!0, this.selectionMode);
				this.partialSelectionStyle = b;
				var c = a.event.LayerEvent,
				q = new c(c.SELECTION_STYLE_CHANGED, this);
				q.style = b;
				this.parentMap &&
				(q.mapContext = this.parentMap.getMapContext());
				this.fire(c.SELECTION_STYLE_CHANGED, q)
			}
		},
		isClusterSelectable: function () {
			return !0 === this.clustering && !1 === this.vClusterClickToZoomToMBR
		},
		getSelectStyle: function () {
			return this.selectionStyle
		},
		setHoverStyle: function (b) {
			if (b && (!this.parentMap || !this.isServerSideStyle(b, "hover"))) {
				this.enableFeatureHover(!0);
				b.effects && 0 < b.effects.length && this.setHoverVisualFilter(b.effects[0]);
				this.hoverStyle = b;
				var c = a.event.LayerEvent,
				q = new c(c.SELECTION_STYLE_CHANGED, this);
				q.style = b;
				this.parentMap && (q.mapContext = this.parentMap.getMapContext());
				this.fire(c.HOVER_STYLE_CHANGED, q)
			}
		},
		getHoverStyle: function () {
			return this.hoverStyle
		},
		setHoverVisualFilter: function (a) {
			this.hoverFilter = a
		},
		clearSelectedFeatures: function () {
			for (var a = this.selectedFeatures ? this.selectedFeatures.length : 0; 0 < a; a--) {
				var b = this.selectedFeatures.pop();
				b.enableFeatureEditing(!1);
				this.resetFeatureStates(b)
			}
		},
		resetFeatureStates: function (a) {
			a.selected = !1;
			a.hover = !1;
			a.selectShape && (a.graphics.remove(a.selectShape),
				a.selectShape = null);
			a.hoverShape && (a.graphics.remove(a.hoverShape), a.hoverShape = null);
			a.setRenderingStyle(a.getOldStyle());
			var b = this.parentMap.graphics;
			a.shape && (this.graphicFilter && !this.visualFilter.applyToLayer ? b.applyStyle(a.shape, {
					filter: this.graphicFilter
				}) : b.applyStyle(a.shape, {
					filter: b.oui.filters.NONE
				}))
		},
		setSelectionChecker: function (a) {
			"function" === typeof a && (this.selectionChecker = a)
		},
		getSelectionChecker: function () {
			return this.selectionChecker
		},
		setPointerSensitivity: function (a) {
			this.pointerSensitivity =
				a;
			this.realGroup && this.realGroup.applyStyle({
				pointerSensitivity: a
			})
		},
		getPointerSensitivity: function () {
			return this.pointerSensitivity
		},
		selectFeature: function (b, c) {
			if (b instanceof a.Feature) {
				if (!b || !b.draggable)
					if (!this.selectionEnable || !this.selectionStyle && !this.featureEditable)
						return;
				var q;
				q = "function" === typeof b.getOldStyle ? b.getOldStyle() : null;
				if (!a.notNull(this.selectionChecker) || this.selectionChecker.call(this, b)) {
					if (b.parentFeature)
						return q = b.parentFeature, q.parentLayer.selectFeature(q), q;
					if (b.selected)
						this.keepSelected ||
						(!0 === b.inCluster && b.clusterFeature ? this.selectActiveSelection() : (this.deselectFeature(b), this.isClusterSelectable() && this.vCluster && this.vCluster.removeFromBaseSelArray(b, c)));
					else {
						this.selectionMode === a.layer.VectorLayer.SINGLE_SELECTION && this.clearSelectedFeatures();
						b.hoverShape && (b.graphics.remove(b.hoverShape), b.hoverShape = null);
						if (this.isClusterSelectable() && !0 === b.inCluster) {
							this.vCluster.updateBaseSelArray(b);
							return
						}
						this.isClusterSelectable() && b.isCluster() && a.notNull(this.partialSelectionStyle) &&
						a.notNull(this.vCluster.getBaseSelArray()) && 0 < this.vCluster.getBaseSelArray().length && this.vCluster.isPartialSelection(b) ? (q || (b.renderingStyle ? b.setOldStyle(b.renderingStyle) : b.setOldStyle(this.getDefaultRenderingStyle(b.geo.type))), "PulseAnimation" === this.selectionStyle.styleType || "AnimationColor" === this.selectionStyle.styleType ? (q = b.shape, b.displayFeature([this.partialSelectionStyle]), b.selectShape = b.shape, b.shape = q) : (q = this.getHoverSelectStyle(this.partialSelectionStyle, b), b.setRenderingStyle(q))) :
						this.selectionStyle && (q || (b.renderingStyle ? b.setOldStyle(b.renderingStyle) : b.setOldStyle(this.getDefaultRenderingStyle(b.geo.type))), "PulseAnimation" === this.selectionStyle.styleType || "AnimationColor" === this.selectionStyle.styleType ? (q = b.shape, b.displayFeature([this.selectionStyle]), b.selectShape = b.shape, b.shape = q) : (q = this.getHoverSelectStyle(this.selectionStyle, b), b.setRenderingStyle(q)));
						if (b.displayed && b.shape) {
							q = this.parentMap.graphics;
							if (this.selectVisualFilter) {
								var t = q.getGraphicFilter(this.selectVisualFilter);
								q.applyStyle(b.shape, {
									filter: t
								})
							} else
								q.applyStyle(b.shape, {
									filter: q.oui.filters.NONE
								});
							b.startAnimation()
						}
						this.featureEditable && b.enableFeatureEditing(!0);
						b.draggable && b.enableFeatureDragging(!0);
						this.selectedFeatures.push(b);
						this.isClusterSelectable() && this.vCluster && this.vCluster.addToBaseSelArray(b, c);
						b.selected = !0;
						this.bringToTopFlag && (b.getShapeIndex(), b.bringToTop());
						c && c.origin && "selectActiveSelection" === c.origin || (q = a.event.LayerEvent, t = new q(q.FEATURE_SELECTED, this), t.selectedFeature = b,
							t.mapContext = this.parentMap.getMapContext(), this.fire(q.FEATURE_SELECTED, t))
					}
					return b
				}
			}
		},
		hover: function (b) {
			if (b instanceof a.Feature) {
				if (!this.hoverEnable || b.hover || b.selected)
					return null;
				this.deHover(this.hoverFeature);
				b.getOldStyle() || (b.renderingStyle ? b.setOldStyle(b.renderingStyle) : b.setOldStyle(this.getDefaultRenderingStyle(b.geo.type)));
				if (this.hoverStyle)
					if ("PulseAnimation" === this.hoverStyle.styleType || "AnimationColor" === this.hoverStyle.styleType) {
						var c = b.shape;
						b.displayFeature([this.hoverStyle]);
						b.hoverShape = b.shape;
						b.shape = c
					} else
						c = this.getHoverSelectStyle(this.hoverStyle, b), b.setRenderingStyle(c);
				b.displayed && b.shape && (this.hoverFilter ? (c = this.parentMap.graphics.getGraphicFilter(this.hoverFilter), this.parentMap.graphics.applyStyle(b.shape, {
							filter: c
						})) : this.parentMap.graphics.applyStyle(b.shape, {
						filter: this.parentMap.graphics.oui.filters.NONE
					}), b.startAnimation());
				this.hoverFeature = b;
				b.hover = !0;
				return b
			}
		},
		deHover: function (b) {
			if (b instanceof a.Feature && b.hover) {
				var c = b.selected;
				b.editable ||
				(b.hoverShape ? (b.graphics.remove(b.hoverShape), b.hoverShape = null) : c || (b.setRenderingStyle(b.getOldStyle()), this.bringSelectedFeaturesToTop(), b.displayed && b.shape && (c = this.parentMap.graphics, this.graphicFilter && !this.visualFilter.applyToLayer ? c.applyStyle(b.shape, {
								filter: this.graphicFilter
							}) : c.applyStyle(b.shape, {
								filter: c.oui.filters.NONE
							}))), this.hoverFeature && (this.hoverFeature.hover = !1, this.hoverFeature = null))
			}
		},
		bringSelectedFeaturesToTop: function () {
			var b = this.getSelectedFeatures();
			if (a.notNull(b) &&
				0 < b.length)
				for (var c = 0; c < b.length; c++) {
					var q = b[c];
					if (a.isNull(q.parentLayer)) {
						a.util.Logger.info(null, "VectorLayer.bringSelectedFeaturesToTop", "Feature has no parent layer, possibly because feature ID is no longer valid: " + q.id);
						break
					}
					this.bringFeatureToTop(q)
				}
		},
		deselectFeature: function (b, c) {
			if (b instanceof a.Feature) {
				var q;
				if (b.selected) {
					b.enableFeatureEditing(!1);
					b.selectShape && (b.graphics.remove(b.selectShape), b.selectShape = null);
					b.hover ? (this.hoverStyle && ("PulseAnimation" === this.hoverStyle.styleType ||
							"AnimationColor" === this.hoverStyle.styleType ? (q = b.shape, b.displayFeature([this.hoverStyle]), b.hoverShape = b.shape, b.shape = q) : (q = this.getHoverSelectStyle(this.hoverStyle, b), b.setRenderingStyle(q))), b.displayed && b.shape && (q = this.parentMap.graphics, this.hoverFilter ? q.applyStyle(b.shape, {
								filter: this.hoverGraphicFilter
							}) : q.applyStyle(b.shape, {
								filter: q.oui.filters.NONE
							}), b.startAnimation())) : (b.getOldStyle() && b.setRenderingStyle(b.getOldStyle()), b.displayed && b.shape && (q = this.parentMap.graphics, this.graphicFilter &&
							!this.visualFilter.applyToLayer ? q.applyStyle(b.shape, {
								filter: this.graphicFilter
							}) : q.applyStyle(b.shape, {
								filter: q.oui.filters.NONE
							})));
					b.selected = !1;
					this.bringSelectedFeaturesToTop();
					q = this.selectedFeatures ? this.selectedFeatures.length : 0;
					for (var t = 0; t < q; t++)
						if (this.selectedFeatures[t] === b) {
							this.selectedFeatures.splice(t, 1);
							break
						}
					c && c.origin && "removeAllFeatureInCluster" === c.origin || (q = a.event.LayerEvent, t = new q(q.FEATURE_DESELECTED, this), t.deselectedFeature = b, t.mapContext = this.parentMap.getMapContext(),
						this.fire(q.FEATURE_DESELECTED, t))
				}
				return b
			}
		},
		enableFeatureSelection: function (b, c) {
			if (this.selectionEnable = b)
				a.notNull(c) && c === a.layer.VectorLayer.MULTIPLE_SELECTION ? this.selectionMode = c : this.selectionMode = a.layer.VectorLayer.SINGLE_SELECTION
		},
		getSelectionMode: function () {
			return this.selectionMode
		},
		setKeepSelected: function (a) {
			this.keepSelected = a
		},
		enableFeatureHover: function (a) {
			this.hoverEnable = a
		},
		setHideEditCircleVertices: function (a) {
			this.hideEditCircleVertices = !!a
		},
		getHideEditCircleVertices: function () {
			return this.hideEditCircleVertices
		},
		enableFeatureEditing: function (b) {
			if (this.featureEditable === b)
				return b && (this.selectionEnable = !0), !0;
			var c = a.layer.VectorLayer;
			if (b) {
				if (this.parentMap && this.parentMap.wraparound)
					return a.util.Logger.warning("MAPVIEWER_9105", "OM.layer.VectorLayer.enableFeatureEditing"), !1;
				if (this.type === c.TYPE_JDBC || this.type === c.TYPE_PREDEFINED) {
					if (a.isNull(this.keyColumn) || a.isNull(this.baseTable) || a.isNull(this.geometryColumn))
						return a.util.Logger.alert("MAPVIEWER_9052", "OM.layer.VectorLayer.enableFeatureEditing",
							""), !1;
					if ("ROWID" === this.keyColumn.toUpperCase())
						return a.util.Logger.alert("MAPVIEWER_9053", "OM.layer.VectorLayer.enableFeatureEditing", ""), !1
				}
			}
			if (this.featureEditable = b)
				return this.selectionEnable = !0, this.changeManager = new a.edit.EditChangeManager({
					layer: this
				}), this.undoManager = new a.UndoManager, this.createRtree(), this.enableInfoWindow(!1), !0;
			if (this.selectedFeatures)
				for (b = this.selectedFeatures.length, c = 0; c < b; c++)
					this.selectedFeatures[c].enableFeatureEditing(!1);
			this.undoManager = this.changeManager =
				null;
			!1 === this.useRTree && (this.rtree = null);
			this.segmentRtree = {};
			this.enableInfoWindow(!0);
			return !0
		},
		getUndoManager: function () {
			return this.undoManager
		},
		isFeatureEditable: function () {
			return this.featureEditable
		},
		getReqXML_saveModified: function (b) {
			var c = "";
			if (a.isNull(b))
				return c;
			for (var q = a.notNull(this.spatialType) ? this.spatialType : "geometry", c = c + "\x3cupdate_features\x3e\n", t = 0; t < b.length; t++) {
				var I = b[t];
				if (!a.isNull(I)) {
					var c = c + ('\x3cfeature key\x3d"' + I.id + '"\x3e\n'),
					aa = "string";
					a.notNull(this.attributeTypes[this.keyColumn]) &&
					(aa = this.attributeTypes[this.keyColumn]);
					var c = c + ('\x3cattribute name\x3d"' + this.keyColumn + '" type\x3d"' + aa + '"\x3e\n'),
					c = c + ("\x3cvalue\x3e" + I.id + "\x3c/value\x3e\n"),
					c = c + "\x3c/attribute\x3e\n",
					ba = this.changeManager.getChangedAttributesOfModifiedFeature(I.id);
					if (a.notNull(ba))
						for (var R = 0; R < ba.length; R++)
							if (ba[R] !== this.keyColumn) {
								var qa = I.getAttributeValue(ba[R]);
								if (a.notNull(qa)) {
									aa = "string";
									a.notNull(this.attributeTypes[ba[R]]) && (aa = this.attributeTypes[ba[R]]);
									var ua = ba[R],
									Ca = I.getRealColumnName(ua);
									a.notNull(Ca) && (ua = Ca);
									c += '\x3cattribute name\x3d"' + ua + '" type\x3d"' + aa + '"\x3e\n';
									c += "\x3cvalue\x3e" + qa + "\x3c/value\x3e\n";
									c += "\x3c/attribute\x3e\n"
								}
							}
					this.changeManager.hasSpatialAttributeChanged(I.id) && (c += '\x3cattribute name\x3d"' + this.geometryColumn + '" type\x3d"' + q + '"\x3e\n', c += "\x3cvalue\x3e" + I.geo.toGML() + "\x3c/value\x3e\n", c += "\x3c/attribute\x3e\n");
					c += "\x3c/feature\x3e\n"
				}
			}
			return c + "\x3c/update_features\x3e\n"
		},
		getReqXML_removeDeleted: function (b) {
			var c = "";
			if (a.isNull(b))
				return c;
			for (var c =
					c + "\x3cdelete_features\x3e\n", q = 0; q < b.length; q++) {
				var t = b[q];
				a.isNull(t) || (c += '\x3cfeature key\x3d"' + t.id + '"/\x3e\n')
			}
			return c + "\x3c/delete_features\x3e\n"
		},
		getReqXML_addNew: function (b) {
			var c = "";
			if (a.isNull(b))
				return c;
			for (var q = a.notNull(this.spatialType) ? this.spatialType : "geometry", c = c + "\x3cinsert_features\x3e\n", t = 0; t < b.length; t++) {
				var I = b[t];
				if (!a.isNull(I)) {
					var aa = I.geo,
					aa = a.notNull(aa) ? aa.toGML() : "",
					c = c + ('\x3cfeature key\x3d"' + I.id + '"\x3e\n'),
					ba = "string";
					a.notNull(this.attributeTypes[this.keyColumn]) &&
					(ba = this.attributeTypes[this.keyColumn]);
					c += '\x3cattribute name\x3d"' + this.keyColumn + '" type\x3d"' + ba + '"\x3e\n';
					c += "\x3cvalue\x3e" + I.id + "\x3c/value\x3e\n";
					c += "\x3c/attribute\x3e\n";
					if (a.notNull(this.attrNames))
						for (var R = 0; R < this.attrNames.length; R++) {
							var qa = this.attrNames[R];
							a.notNull(qa) && (qa = qa.toUpperCase());
							if (qa !== this.keyColumn.toUpperCase()) {
								var ua = I.getAttributeValue(qa);
								if ("_LABEL_" !== qa && a.notNull(ua)) {
									ba = "string";
									a.notNull(this.attributeTypes[qa]) && (ba = this.attributeTypes[qa]);
									var Ca = I.getRealColumnName(qa);
									a.notNull(Ca) && (qa = Ca);
									c += '\x3cattribute name\x3d"' + qa + '" type\x3d"' + ba + '"\x3e\n';
									c += "\x3cvalue\x3e" + ua + "\x3c/value\x3e\n";
									c += "\x3c/attribute\x3e\n"
								}
							}
						}
					c += '\x3cattribute name\x3d"' + this.geometryColumn + '" type\x3d"' + q + '"\x3e\n';
					c += "\x3cvalue\x3e" + aa + "\x3c/value\x3e\n";
					c += "\x3c/attribute\x3e\n";
					c += "\x3c/feature\x3e\n"
				}
			}
			return c + "\x3c/insert_features\x3e\n"
		},
		saveEditing: function (b) {
			if (a.notNull(this.changeManager) && this.changeManager.hasChanges) {
				var c = a.layer.VectorLayer;
				if (this.type === c.TYPE_PREDEFINED ||
					this.type === c.TYPE_JDBC) {
					var c = this.serverURL + "/dataserver/" + this.dataSource,
					q = {},
					t = a.util.HttpRequest.getDomain(this.serverURL);
					t || (t = a.util.HttpRequest.localDomain);
					if (t = a.gv.mvKeyMap[t])
						q.key = t;
					this.sessionId && (q.ssid = this.sessionId);
					t = '\x3c?xml version\x3d"1.0" standalone\x3d"yes"?\x3e\n\x3cedit_request\x3e\n\x3csave_session_layer';
					t += ' data_source\x3d"' + this.dataSource + '"';
					t += ' editor\x3d"dummy"\x3e\n';
					t += "\x3clayer ";
					t += 'base_table\x3d"' + this.baseTable + '" ';
					t += 'key_column\x3d"' + this.keyColumn +
					'" ';
					t += 'spatial_column\x3d"' + this.geometryColumn + '" ';
					t += 'spatial_type\x3d"' + this.spatialType + '" ';
					this.workspace && "LIVE" !== this.workspace.toUpperCase() && (t += 'workspace\x3d"' + this.workspace + '"');
					var t = t + "\x3e\n",
					I = this.changeManager.getNewFeatures();
					a.notNull(I) && 0 < I.length && (t += this.getReqXML_addNew(I));
					I = this.changeManager.getModifiedFeatures();
					a.notNull(I) && 0 < I.length && (t += this.getReqXML_saveModified(I));
					I = this.changeManager.getRemovedFeatures();
					a.notNull(I) && 0 < I.length && (t += this.getReqXML_removeDeleted(I));
					t += "\x3c/layer\x3e\n";
					t += "\x3c/save_session_layer\x3e\n";
					t += "\x3c/edit_request\x3e\n";
					q.xml_request = t;
					var aa = this;
					q.refresh = Math.round(1E5 * Math.random());
					a.notNull(this.saveDataRequest) && this.saveDataRequest.abort();
					this.saveDataRequest = this.sendHttpRequest(c, q, function (c) {
						c = c.documentElement.getElementsByTagName("save_session_layer");
						var q = !1;
						if (a.notNull(c)) {
							var K = c[0].attributes.getNamedItem("data_source").value,
							t = c[0].attributes.getNamedItem("layer").value,
							q = c[0].attributes.getNamedItem("success").value;
							"true" === q ? (aa.changeManager.clearChanges(), aa.undoManager = new a.UndoManager, a.util.Logger.info("MAPVIEWER_9058", "OM.layer.VectorLayer.saveEditing", "[" + K + "," + t + "," + q + "]")) : a.util.Logger.warning("MAPVIEWER_9057", "OM.layer.VectorLayer.saveEditing", "[" + K + "," + t + "," + q + "," + c[0].childNodes[1].childNodes[1].textContent + "]")
						} else
							a.util.Logger.warning("MAPVIEWER_9057", "OM.layer.VectorLayer.saveEditing", "Unexpected response.");
						aa.saveDataRequest = null;
						a.notNull(b) && b(q)
					}, "xml", function (b) {
						aa.saveDataRequest =
							null;
						b && a.util.Logger.alert("MAPVIEWER_9057", "OM.layer.VectorLayer.saveEditing", b.responseText)
					}, !1)
				} else
					a.util.Logger.warning("MAPVIEWER_9056", "OM.layer.VectorLayer.saveEditing", ""), a.notNull(b) && b(!1)
			} else
				a.notNull(b) && b(!1)
		},
		setBoundingTheme: function (a) {
			this.boundingTheme = a
		},
		zoomToTheme: function () {
			var a = this;
			this.parentMap && this.parentMap.initialized ? (this.bfMbr = this.mbr = null, this.loadBoundingTheme(function (b, c, t, I) {
					(b = a.calculateCenterAndZoomLevel(b, c, t, I)) && 1 < b.length && a.parentMap.setMapCenterAndZoomLevel(b[1],
						b[0])
				})) : setTimeout(function () {
				a.zoomToTheme()
			}, 300)
		},
		centerToTheme: function () {
			var a = this;
			this.parentMap && this.parentMap.initialized ? this.loadBoundingTheme(function (b, c, t, I) {
				(b = a.calculateCenterAndZoomLevel(b, c, t, I)) && 1 < b.length && a.parentMap.setMapCenter(b[1])
			}) : setTimeout(function () {
				a.centerToTheme()
			}, 300)
		},
		setBringToTopOnMouseOver: function (a) {
			this.bringToTopFlag = a
		},
		getFeatureGeometryType: function () {
			if (this.type != a.layer.VectorLayer.TYPE_LOCAL && this.featureArray && 0 < this.featureArray.length) {
				var b =
					this.featureArray[0].geo;
				if ("Point" == b.type || "OrientedPoint" == b.type || "MultiPoint" == b.type || "OrientedMultiPoint" == b.type)
					return "POINT";
				if ("LineString" == b.type || "MultiLineString" == b.type)
					return "LINESTRING";
				if ("Polygon" == b.type || "MultiPolygon" == b.type)
					return "POLYGON"
			}
			return ""
		},
		setSelectVisualFilter: function (a) {
			this.selectVisualFilter = a
		},
		setVisualFilter: function (b) {
			this.visualFilter = b;
			if (this.displayed && this.visualFilter)
				if (this.graphicFilter = this.parentMap.graphics.getGraphicFilter(this.visualFilter),
					this.visualFilter.applyToLayer)
					this.parentMap.graphics.applyStyle(this.realGroup, {
						filter: this.graphicFilter
					});
				else {
					b = this.featureArray ? this.featureArray.length : 0;
					for (var c = 0; c < b; c++) {
						var q = this.featureArray[c];
						q.shape && this.parentMap.graphics.applyStyle(q.shape, {
							filter: this.graphicFilter
						})
					}
				}
			else
				this.displayed && a.isNull(this.visualFilter) && (this.graphicFilter = null, this.parentMap.graphics.applyStyle(this.realGroup, {
						filter: this.parentMap.graphics.oui.filters.NONE
					}))
		},
		getSelectVisualFilter: function () {
			return this.selectVisualFilter
		},
		getVisualFilter: function () {
			return this.visualFilter
		},
		setLabelsVisible: function (a) {
			this.showLabels = a
		},
		labelsVisible: function () {
			return this.showLabels
		},
		getExtent: function () {
			if (!this.mbr) {
				var b = this.featureArray ? this.featureArray.length : 0,
				c = {
					minX: null,
					minY: null,
					maxX: null,
					maxY: null
				},
				q = {
					minX: null,
					minY: null,
					maxX: null,
					maxY: null
				},
				t = a.geometry.Geometry.calculateMBR,
				I = this.renderingStyle,
				aa = a.notNull(I) && a.notNull(I.hasBinding) && I.hasBinding(),
				ba = a.notNull(this.nsdpData) && a.notNull(this.nsdpKey),
				R = function (a,
					b) {
					var c,
					q,
					K,
					v;
					a.getMBR ? (v = a.getMBR(), c = v.getMinX(), K = v.getMinY(), q = v.getMaxX(), v = v.getMaxY()) : (v = t(a.coordinates, a.type, a.dimension), c = v.minX, K = v.minY, q = v.maxX, v = v.maxY);
					if (null === b.minX || c < b.minX)
						b.minX = c;
					if (null === b.minY || K < b.minY)
						b.minY = K;
					if (null === b.maxX || q > b.maxX)
						b.maxX = q;
					if (null === b.maxY || v > b.maxY)
						b.maxY = v
				},
				qa = this.parentMap.getMapContext().getUniverse().getSRID(),
				ua = !1,
				Ca = !1,
				pa = function (a) {
					R(a, c);
					(ua || Ca) && R(a, q)
				},
				ga,
				da,
				v = a.util.BaiduUtil.SRID;
				for (ga = 0; ga < b; ga++)
					da = this.featureArray[ga], ua =
						aa && I.isFeatureBound(da), Ca = ba ? a.notNull(this.getNsdpDataForFeature(da)) : !1, da = da.getGeometry(), qa !== da.srid ? qa !== v ? da.transform(qa, pa) : da.transform(qa, pa, null, null, {
						map: this.parentMap,
						inputIsBD09LonLat: !0
					}) : (R(da, c), (ua || Ca) && R(da, q));
				a.notNull(c.minX) && a.notNull(c.minY) && a.notNull(c.maxX) && a.notNull(c.maxY) ? this.mbr = new a.geometry.Rectangle(c.minX, c.minY, c.maxX, c.maxY, qa) : this.mbr = null;
				aa || ba ? a.notNull(q.minX) && a.notNull(q.minY) && a.notNull(q.maxX) && a.notNull(q.maxY) ? this.bfMbr = new a.geometry.Rectangle(q.minX,
						q.minY, q.maxX, q.maxY, qa) : this.bfMbr = null : this.bfMbr = this.mbr
			}
			return this.mbr
		},
		getAttributeNames: function () {
			return this.attrNames
		},
		setNSDP: function (b) {
			if (b && b.keyColumn) {
				this.clearNSDP();
				this.nsdpKey = b.keyColumn;
				this.nsdpKey = this.nsdpKey.toUpperCase();
				this.nsdp = b;
				"undefined" === typeof this.nsdp.ignoreCase && (this.nsdp.ignoreCase = !0);
				a.isNull(this.nsdp.fullDisplay) && (this.nsdp.fullDisplay = !1);
				var c = this,
				q = function (b) {
					a.util.Logger.finest("", "OM.VectorLayer.setNSDP", "parsing NSDP XML data...");
					var q = null;
					"string" === typeof b && (b = a.$.trim(b), b = a.$.parseXML(b));
					var q = a.$(b),
					t = 0;
					c.nsdpTitleArray = [];
					q.find("th").each(function () {
						var b = a.$(this).text();
						c.nsdpTitleArray.push(b);
						a.util.Logger.finest("title[" + t + "]:" + b);
						t += 1
					});
					a.util.Logger.finest("Total " + t + " column(s) found");
					t = 0;
					c.nsdpData = {};
					q.find("tr").each(function () {
						var b = 0,
						q = null,
						I = {};
						a.$(this).find("td").each(function () {
							if (0 === b)
								q = a.$(this).text();
							else {
								var t = c.nsdpTitleArray[b].toUpperCase();
								I[t] = a.$(this).text()
							}
							b++
						});
						q && (q = c.nsdp.ignoreCase ? q.toUpperCase() :
								q, c.nsdpData[q] = I, a.util.Logger.finest("Values for key '" + q + "' added into layer '" + c.name + "'"), t += 1)
					});
					a.util.Logger.finest("Total " + t + " key/value pair(s) added into layer '" + c.name + "'");
					c.parentMap && c.name === c.parentMap.boundingLayerName && c.loadBoundingTheme();
					c.displayed && (c.renderingStyle instanceof a.style.BucketStyle && c.renderingStyle.clearBuckets(), c.redraw(!1))
				},
				t = function (q) {
					a.util.Logger.finest("JSON data to be parsed: " + JSON.stringify(q));
					a.util.Logger.finest("parsing NSDP JSON data...");
					"string" === typeof q && (q = a.$.parseJSON(q));
					if (q.items && 0 !== q.items.length) {
						q = q.items;
						var t = q.length,
						ba = 0;
						c.nsdpData = {};
						c.nsdpTitleArray = [];
						var R = b.keyAttr,
						qa = !1;
						a.isNull(R) && (R = b.keyColumn);
						a.notNull(q[0][R]) && (qa = !0);
						for (var ua in q[0])
							c.nsdpTitleArray.push(ua), a.util.Logger.finest("attribute[" + ba + "]:" + ua), ba += 1, qa || ua.toUpperCase() != R.toUpperCase() || (qa = !0, R = ua);
						a.util.Logger.finest("Total " + ba + " attribute(s) found");
						for (qa = ba = 0; qa < t; qa++) {
							var Ca = q[qa][R];
							if (!a.isNull(Ca)) {
								var pa = {};
								for (ua in q[qa])
									ua !=
									R && (pa[ua.toUpperCase()] = q[qa][ua]);
								Ca = c.nsdp.ignoreCase && Ca.toUpperCase ? Ca.toUpperCase() : Ca;
								c.nsdpData[Ca] = pa;
								a.util.Logger.finest("Values for key '" + Ca + "' added into layer '" + c.name + "'");
								ba += 1
							}
						}
						a.util.Logger.finest("Total " + ba + " key/value pair(s) added into layer '" + c.name + "'");
						c.displayed && (c.renderingStyle instanceof a.style.BucketStyle && c.renderingStyle.clearBuckets(), c.redraw(!1))
					}
				};
				if (b && b.url) {
					a.$.ajaxSetup({
						async: !1
					});
					try {
						a.$.get(b.url, null, function (a) {
							try {
								q(a)
							} catch (b) {
								t(a)
							}
						}, "text").fail(function () {
							a.util.Logger.warning("MAPVIEWER_9042",
								"OM.layer.VectorLayer.setNSDP", b.url)
						})
					} catch (I) {
						a.util.Logger.warning(null, "OM.layer.VectorLayer.setNSDP", "Exception when loading nsdp url data.")
					} finally {
						a.$.ajaxSetup({
							async: !0
						})
					}
				} else
					b && b.xml ? (a.util.Logger.finest("XML string to be parsed: " + b.xml), q(a.util.XMLUtil.parse(b.xml))) : b && b.json && t(b.json)
			}
		},
		getNSDPString: function () {
			if (!this.nsdp)
				return "";
			var b;
			b = '{"nsdp_id":"defaultNSDP",' + ('"nsdp_theme":"' + this.name + '",');
			b += '"nsdp_keycol":"' + this.nsdpKey + '"';
			a.notNull(this.fullDisplay) && !1 === this.fullDisplay &&
			(b += ',"nsdp_smfo":"true"');
			b += ',"nsdp_params":[';
			var c,
			q;
			a.notNull(this.nsdp.xml) ? (c = "xml", q = this.nsdp.xml, q = q.replaceAll('"', '\\"')) : a.notNull(this.nsdp.json) ? (c = "json", q = this.nsdp.json, "object" === typeof q && (q = JSON.stringify(q)), q = q.replaceAll('"', '\\"')) : a.notNull(this.nsdp.url) && (c = "url", q = this.nsdp.url, q = q.replaceAll('"', '\\"'));
			b += '{"' + c + '":"' + q + '"}';
			return b += "]}"
		},
		applyFilter: function (b, c) {
			if ("undefined" === typeof c || c) {
				if (b.filterMode === a.filter.Filter.CLIENT_SIDE)
					return this.filterArray ||
					(this.filterArray = []), this.filterArray.push(b), this.replace = !1, this.doFilter(), this.loadOnDemand = !1, this
			} else if (b.filterMode == a.filter.Filter.CLIENT_SIDE) {
				var q = this.clone();
				q.loadOnDemand = !1;
				q.filterArray = this.filterArray ? a.$.extend([], this.filterArray) : [];
				q.filterArray.push(b);
				this.replace = !1;
				q.doFilter();
				return q
			}
		},
		removeFilter: function (a) {
			if (this.filterArray)
				for (var b = this.filterArray.length; -1 < b; b--)
					if (a == this.filterArray[b]) {
						this.filterArray.splice(b, 1);
						break
					}
		},
		removeFilterAll: function () {
			this.filterArray =
				[]
		},
		doFilter: function (a, b, c) {
			if (this.filterArray && 0 !== this.filterArray.length || b) {
				var t = this.filterArray;
				this.replace && (t = [b]);
				for (b = 0; b < t.length; b++) {
					var I = t[b];
					if (a) {
						if (!I.evaluate(a))
							return !0
					} else {
						if (!this.featureArray || 0 === this.featureArray.length)
							break;
						var aa = this.featureArray;
						if (this.clustering && this.vCluster) {
							var ba = this.vCluster.clusterFeatureArray;
							if (ba && 0 < ba.length)
								for (var aa = this.featureArray.slice(0), R = 0; R < ba.length; R++)
									aa.push(ba[R])
						}
						c && !0 === c.selectFeatureByFilter && aa.reverse();
						for (ba =
								aa.length - 1; -1 < ba; ba--)
							R = aa[ba], this.replace && R.selected || (I.evaluate(R) ? this.replace && this.selectFeature(R) : this.replace || this.removeFeature(R));
						c && !0 === c.selectFeatureByFilter && aa.reverse()
					}
				}
			}
		},
		selectFeatureByFilter: function (b) {
			if (b && (this.enableFeatureSelection(!0, a.layer.VectorLayer.MULTIPLE_SELECTION), b.filterMode == a.filter.Filter.CLIENT_SIDE))
				return this.replace = !0, this.doFilter(null, b, {
					selectFeatureByFilter: !0
				}), this.loadOnDemand = this.replace = !1, this
		},
		addToRtree: function (b, c) {
			if (!(!1 === this.featureEditable &&
					!1 === this.useRTree || a.isNull(b))) {
				var q = a.isNull(c) ? b.getGeometry() : c;
				a.isNull(q) || (q = a.notNull(q.mbr) ? q.mbr : a.notNull(q.getMBR) ? q.getMBR() : null, q = {
						x: q.getMinX(),
						y: q.getMinY(),
						w: q.getWidth(),
						h: q.getHeight()
					}, this.containsKey(b, q) || (a.isNull(this.rtree) && (this.rtree = new a.RTree(10)), this.rtree.insert(q, b), b.rtreeKeys.push(q)))
			}
		},
		containsKey: function (b, c) {
			a.isNull(b.rtreeKeys) && (b.rtreeKeys = []);
			a.isNull(c) && (c = {});
			for (var q = b.rtreeKeys, t = 0; t < q.length; t++)
				if (q[t].x === c.x && q[t].y === c.y && q[t].w === c.w &&
					q[t].h === c.h)
					return !0;
			return !1
		},
		removeFromRtree: function (b) {
			if (!(!1 === this.useRTree || a.isNull(b) || a.isNull(this.rtree) || a.isNull(b.rtreeKeys))) {
				for (var c = b.rtreeKeys, q = 0; q < c.length; q++)
					this.rtree.remove(c[q], b);
				b.rtreeKeys = []
			}
		},
		beforeZoom: function () {
			this.pixMaxYDistance = this.pixMaxXDistance = null
		},
		updatedSearchWindow: function (b, c) {
			if (a.notNull(b.shape) && (c === a.GeomTypes.POINT || c === a.GeomTypes.ORIENTEDPOINT || c === a.GeomTypes.MULTIPOINT || c === a.GeomTypes.ORIENTEDMULTIPOINT)) {
				var q = b.getGeometry(),
				t = b.shape.getLayoutBounds();
				if (c === a.GeomTypes.MULTIPOINT || c === a.GeomTypes.ORIENTEDMULTIPOINT)
					q = q.coordinates, q = new a.geometry.Point(q[0][0], q[0][1]), 1 < b.shape.childrenCount && (t = b.shape.getChildAt(0).getLayoutBounds());
				if (a.notNull(t) && a.notNull(this.parentMap)) {
					var I = this.parentMap,
					q = I.getScreenLocation(q),
					I = I.graphics.getLeftTop(I.draggableGroup);
					t.x = I.x + t.x;
					t.y = I.y + t.y;
					I = Math.abs(t.x - q.x) + t.width / 2;
					t = Math.abs(t.y - q.y) + t.height / 2;
					if (a.isNull(this.pixMaxXDistance) || this.pixMaxXDistance < I)
						this.pixMaxXDistance = I;
					if (a.isNull(this.pixMaxYDistance) ||
						this.pixMaxYDistance < t)
						this.pixMaxYDistance = t
				}
			}
		},
		getSearchWindow: function (b) {
			var c,
			q;
			c = a.notNull(this.pixMaxXDistance) ? 2 * this.pixMaxXDistance : this.searchBuffer;
			q = a.notNull(this.pixMaxYDistance) ? 2 * this.pixMaxYDistance : this.searchBuffer;
			var t = a.gv.searchTolerance;
			this.parentMap && (t = this.parentMap.getSearchTolerance());
			t && "px" === t.unit && (c = Math.max(c, 2 * t.value), q = Math.max(q, 2 * t.value));
			q = this.pixToCoord(c, q);
			return a.notNull(q) ? (c = q.width, q = q.height, {
				x: b.getX() - c / 2,
				y: b.getY() - q / 2,
				w: c,
				h: q,
				srid: this.parentMap.getMapContext().getUniverse().srid
			}) :
			null
		},
		pixToCoord: function (a, b) {
			var c = this.parentMap,
			t = c.getMapContext(),
			I = t.getUniverse(),
			t = t.getZoomLevel();
			if (I && I.zoomLevels)
				return t = c.checkZoomLevel(t), c = I.zoomLevels[t].resolution, {
					width: Math.abs(a * c),
					height: Math.abs(b * c * I.zoomLevels[t].stretchRatio)
				}
		},
		findFeature: function (b, c) {
			if (a.isNull(this.rtree))
				return null;
			try {
				var q = null,
				t = a.util.DomUtil.getTouchesClientPosition(b);
				a.notNull(t.x) && (b.clientX = t.x, b.clientY = t.y);
				if (a.isNull(b.clientX) || a.isNull(b.clientY))
					return null;
				var I = this.parentMap.getScreenPointLocation(b.clientX,
						b.clientY),
				aa = this.getSearchWindow(I),
				ba = this.rtree.search(aa),
				t = [],
				R;
				for (R = 0; R < ba.length; R++) {
					q = ba[R];
					if (a.notNull(q.selectivity)) {
						if (0 > q.selectivity)
							continue
					} else
						q.selectivity = 0;
					t.push(q)
				}
				if (0 === t.length)
					return null;
				if (2 === t.length && a.notNull(t[0].parentFeature) && t[0].parentFeature === t[1].parentFeature && a.notNull(t[0].parentFeature.geo) && t[0].parentFeature.geo.type === a.GeomTypes.POLYGON && a.notNull(t[0].parentFeature.geo.coordinates) && 10 === t[0].parentFeature.geo.coordinates[0].length && this.isSameAsMBR(t[0].parentFeature.geo.coordinates[0]))
					for (R =
							0; R < t.length; R++)
						if (q = t[R], a.notNull(q.id) && 0 < q.id.indexOf("resizePoints") && this.pointInFeature(b.clientX, b.clientY, q))
							return q;
				if (1 < t.length)
					for (R = 0; R < t.length; R++)
						if (q = t[R], a.notNull(q) && !0 === q.selected && this.pointInFeature(b.clientX, b.clientY, q))
							return q;
				t.sort(function (a, b) {
					return a.selectivity < b.selectivity ? 1 : -1
				});
				for (R = 0; R < t.length; R++)
					if (q = t[R], this.pointInFeature(b.clientX, b.clientY, q))
						return q;
				if (!1 === c)
					return null;
				for (ba = 0; ba < t.length; ba++)
					if (q = t[ba], this.pointNearFeature(I, q))
						return q.fkNode =
							q.shape, q
			} catch (qa) {}
			return null
		},
		isSameAsMBR: function (b) {
			if (a.isNull(b) || 10 !== b.length)
				return !1;
			var c = 1E-7 > Math.abs(b[2] - b[4]),
			q = 1E-7 > Math.abs(b[5] - b[7]),
			t = 1E-7 > Math.abs(b[0] - b[2]),
			I = 1E-7 > Math.abs(b[3] - b[5]),
			aa = 1E-7 > Math.abs(b[4] - b[6]);
			return 1E-7 > Math.abs(b[1] - b[3]) && c && q || t && I && aa
		},
		findFeatures: function (b, c) {
			if (this.isVisible()) {
				!0 !== c && (c = !1);
				if (a.isNull(this.rtree))
					return null;
				var q = [],
				t = null;
				try {
					var I = a.util.DomUtil.getTouchesClientPosition(b);
					a.notNull(I.x) && (b.clientX = I.x, b.clientY = I.y);
					for (var aa =
							this.parentMap.getScreenPointLocation(b.clientX, b.clientY), ba = this.getSearchWindow(aa), R = this.rtree.search(ba), I = 0; I < R.length; I++)
						t = R[I], this.pointInFeature(b.clientX, b.clientY, t) && q.push(t);
					if (0 < q.length)
						return q;
					if (!1 === c)
						return null;
					for (I = 0; I < R.length; I++)
						t = R[I], this.pointNearFeature(aa, t) && (t.fkNode = t.shape, q.push(t))
				} catch (qa) {}
				return 0 < q.length ? q : null
			}
		},
		pointInFeature: function (b, c, q) {
			if (a.notNull(q) && a.notNull(q.shape)) {
				if (this.pointInShape(b, c, q.shape, q) || this.pointInShape(b, c, q.ghostShape,
						q))
					return !0;
				if (a.notNull(q.shapeArray))
					for (var t = 0; t < q.shapeArray.length; t++)
						if (this.pointInShape(b, c, q.shapeArray[t], q))
							return !0
			}
			return !1
		},
		pointInShape: function (b, c, q, t) {
			if (a.isNull(q))
				return !1;
			if (t && t.geo) {
				var I = t.geo.getType();
				if (I === a.GeomTypes.POINT || I === a.GeomTypes.ORIENTEDPOINT || I === a.GeomTypes.ORIENTEDMULTIPOINT || I === a.GeomTypes.LINESTRING || I === a.GeomTypes.MULTILINESTRING)
					if (I = a.gv.searchTolerance.value, I = t.parentLayer.parentMap.getSearchTolerance(), "px" === I.unit)
						return I = I.value, (b = q.hitTest(b,
									c, {
									tolerance: I
								})) ? (t.fkNode = b, b.feature = t, !0) : !1
			}
			return (b = q.hitTest(b, c)) ? (t.fkNode = b, b.feature = t, !0) : !1
		},
		pointNearFeature: function (b, c) {
			var q = c.getGeometry(),
			t = q.coordinates,
			I = q.getType(),
			aa = null,
			ba = Number.MAX_VALUE,
			R = [];
			switch (I) {
			case a.GeomTypes.POINT:
			case a.GeomTypes.ORIENTEDPOINT:
				aa = this.minDistance({
					x: b.getX(),
					y: b.getY()
				}, [{
								x: q.getX(),
								y: q.getY()
							}
						]);
				break;
			case a.GeomTypes.MULTIPOINT:
			case a.GeomTypes.ORIENTEDMULTIPOINT:
				R = [];
				for (q = 0; q < t.length; q++)
					for (I = t[q], aa = 0; aa < I.length; aa += 2)
						R.push({
							x: I[aa],
							y: I[aa + 1]
						});
				aa = this.minDistance({
					x: b.getX(),
					y: b.getY()
				}, R);
				break;
			case a.GeomTypes.LINESTRING:
				for (q = 0; q < t.length - 2; q += 2)
					R.push([{
								x: t[q],
								y: t[q + 1]
							}, {
								x: t[q + 2],
								y: t[q + 3]
							}
						]);
				aa = this.minPointSegmentDistance({
					x: b.getX(),
					y: b.getY()
				}, R);
				break;
			case a.GeomTypes.MULTILINESTRING:
				for (q = 0; q < t.length; q++)
					for (I = t[q], aa = 0; aa < I.length - 2; aa += 2)
						R.push([{
									x: I[aa],
									y: I[aa + 1]
								}, {
									x: I[aa + 2],
									y: I[aa + 3]
								}
							]);
				aa = this.minPointSegmentDistance({
					x: b.getX(),
					y: b.getY()
				}, R)
			}
			a.notNull(aa) && a.notNull(c.parentLayer) && a.notNull(c.parentLayer.parentMap) &&
			(ba = c.parentLayer.parentMap.getMapContext().getTransform().toScreenXLength(aa));
			return ba <= this.searchBuffer
		},
		minDistance: function (b, c) {
			for (var q = Number.MAX_VALUE, t = 0; t < c.length; t++)
				q = Math.min(q, a.util.GeomUtil.distance(b.x, b.y, c[t].x, c[t].y));
			return q
		},
		minPointSegmentDistance: function (b, c) {
			for (var q = Number.MAX_VALUE, t = 0; t < c.length; t++)
				q = Math.min(q, a.util.GeomUtil.pointSegmentDistance(b.x, b.y, c[t][0].x, c[t][0].y, c[t][1].x, c[t][1].y));
			return q
		},
		addFeature: function (b) {
			if (!this.doFilter(b))
				if (this.featureArray ||
					(this.featureArray = []), this.isValidId(b.id)) {
					if (this.featureArray.push(b), b.parentLayer = this, this.addToRtree(b), this.displayed) {
						var c = b.geo;
						if (!a.isNull(c)) {
							var q = this,
							t = function (c) {
								var t = a.notNull(c.mbr) ? c.mbr : a.notNull(c.getMBR) ? c.getMBR() : null;
								b.geo = c;
								c = q.parentMap.getMapZoomLevel();
								q.clustering && c <= q.maxClusteringLevel && q.vCluster.addFeature(b);
								if (!b.displayed) {
									c = q.parentMap.getMapContext();
									var K = c.getWholeMapNum(),
									I = c.getBaseWholeMapIndex();
									a.notNull(q.featureGroupArr) && 0 < q.featureGroupArr.length &&
									(a.notNull(b.activeIdx) ? q.realGroup = q.featureGroupArr[b.activeIdx] : q.realGroup = q.featureGroupArr[0]);
									a.isNull(q.realGroup) && (q.realGroup = q.parentMap.graphics.createGroup(), q.realGroup.applyStyle({
											cursor: q.mouseCursor
										}), q.pointerSensitivity || q.realGroup.applyStyle({
											pointerSensitivity: !1
										}), q.group.appendChild(q.realGroup));
									b.group = q.realGroup;
									b.screenTransformObj = q.parentMap.getMapContext().getTransform();
									b.graphics = q.parentMap.graphics;
									b.parentLayer = q;
									q.display(b, t);
									var ua,
									Ca,
									pa;
									if (1 < K && (a.isNull(q.featureGroupArr) &&
											(q.featureGroupArr = []), a.notNull(b.activeIdx) && (K = b.activeIdx + 1), a.isNull(q.featureGroupArr[K - 1]) && (q.featureGroupArr[K - 1] = q.realGroup, ua = c.getUniverse().getZoomLevels()[c.getZoomLevel()].resolution, Ca = c.getUniverse().getMapBounds().getWidth(), pa = (c.getCenterPoint().getX() - c.getRoundMapCenterPoint().getX()) / ua, q.realGroup.translate((K - 1 - I) * Ca / ua - pa, 0)), !a.notNull(b.activeIdx)))
										for (var ga = 1; ga < K; ga++)
											b.shapeArray || (b.shapeArray = []), b.shapeArray.push(b.shape), a.notNull(q.featureGroupArr[ga]) ? q.realGroup =
												q.featureGroupArr[ga] : (q.realGroup = q.parentMap.graphics.createGroup(), q.realGroup.applyStyle({
														cursor: q.mouseCursor
													}), q.pointerSensitivity || q.realGroup.applyStyle({
														pointerSensitivity: !1
													}), q.group.appendChild(q.realGroup), q.featureGroupArr[ga] = q.realGroup, ua = c.getUniverse().getZoomLevels()[c.getZoomLevel()].resolution, Ca = c.getUniverse().getMapBounds().getWidth(), pa = (c.getCenterPoint().getX() - c.getRoundMapCenterPoint().getX()) / ua, q.realGroup.translate((ga - I) * Ca / ua - pa, 0)), q.display(b, t)
								}
							},
							I = this.parentMap.getMapContext().getUniverse().getSRID();
							I !== c.srid ? I !== a.util.BaiduUtil.SRID ? c.transform(I, t) : c.transform(I, t, null, null, {
								map: this.parentMap
							}) : t(c);
							this.labelsVisible() && b.label && this.parentMap.refreshVectorLayerLabels()
						}
					}
				} else
					a.util.Logger.warning("MAPVIEWER_9005", "OM.layer.VectorLayer.addFeature")
		},
		addFeatures: function (b) {
			this.featureArray || (this.featureArray = []);
			for (var c = b ? b.length : 0, q = 0; q < c; q++)
				this.isValidId(b[q].id) && !this.doFilter(b[q]) ? this.featureArray.push(b[q]) : a.util.Logger.warning("MAPVIEWER_9005", "OM.layer.VectorLayer.addFeatures")
		},
		clearFeature: function (b, c) {
			if (!a.isNull(b)) {
				this.parentMap && this.parentMap.deleteFeatureInfoWindow(this.name + "_" + b.id);
				b.clearAnimation();
				b.animations = null;
				b.moveAnimation && b.pauseMoveAnimation();
				b.selected && this.deselectFeature(b, c);
				b.shape && (b.shape.feature = null, this.parentMap.graphics.remove(b.shape), b.shape = null);
				if (b.shapeArray) {
					for (var q = b.shapeArray.length, t = 0; t < q; t++)
						b.shapeArray[t] && (b.shapeArray[t].feature = null, this.parentMap.graphics.remove(b.shapeArray[t]));
					b.shapeArray = null
				}
				if (b.shapeGroup) {
					q =
						b.shapeGroup.length;
					for (t = 1; t < q; t++)
						b.shapeGroup[t].feature = null, this.parentMap.graphics.remove(b.shapeGroup[t]);
					b.shapeGroup = null
				}
				b.labelShape && (b.labelShape.feature = null, this.parentMap.graphics.remove(b.labelShape));
				if (b.labelShapeArr) {
					for (q = 0; q < b.labelShapeArr.length; q++)
						this.parentMap.graphics.remove(b.labelShapeArr[q]);
					b.labelShapeArr = null
				}
				b.group = null;
				b.screenTransformObj = null;
				b.graphics = null;
				b.parentLayer = null;
				b.displayed = !1;
				b.inCluster = !1;
				this.removeFromRtree(b);
				a.notNull(b.$customDiv) && (b.$customDiv.remove(),
					b.$customDiv = null)
			}
		},
		removeFeature: function (b) {
			var c,
			q;
			b && b.editable && b.featureEditingProperties && b.deleteEditingProperties();
			c = this.featureArray ? this.featureArray.length : 0;
			for (q = 0; q < c; q++)
				if (this.featureArray[q] === b)
					return this.featureArray.splice(q, 1), a.notNull(this.rtree) && a.notNull(b.geo) && (c = a.notNull(b.geo.mbr) ? b.geo.mbr : a.notNull(b.geo.getMBR) ? b.geo.getMBR() : null, a.notNull(c) && (c = {
								x: c.getMinX(),
								y: c.getMinY(),
								w: c.getWidth(),
								h: c.getHeight()
							}, this.rtree.remove(c, b), a.notNull(this.segmentRtree) &&
							a.notNull(this.segmentRtree[b.id]) && delete this.segmentRtree[b.id])), this.clearFeature(b), b;
			return null
		},
		removeAllFeatures: function () {
			this.vCluster && this.vCluster.clearAllClusterFeatures();
			if (this.heatMap) {
				var b = a.$(this.getHeatmapDivId());
				0 < b.length && b.empty()
			}
			b = this.featureArray ? this.featureArray.length : 0;
			a.isNotNull(this.parentMap) && this.parentMap.graphics.clearGroup(this.group);
			for (var c = b - 1; 0 <= c; c--) {
				var q = this.featureArray.pop();
				this.clearFeature(q)
			}
			a.notNull(this.rtree) && (this.rtree = null);
			this.segmentRtree = {};
			this.realGroup = null;
			this.featureArray = [];
			this.dataBufferWindow = null;
			return b
		},
		initGroup: function () {
			this.parentMap && this.parentMap.graphics && (this.group = this.parentMap.graphics.createGroup({
					opacity: this.opacity,
					visibility: !0
				}), this.parentMap.draggableGroup.appendChild(this.group))
		},
		init: function () {
			if (!a.isNull(this.parentMap)) {
				var b = this.parentMap.getMapContext(),
				c = b.getDeviceWidth(),
				b = b.getDeviceHeight();
				this.serverURL || this.type != a.layer.VectorLayer.TYPE_JDBC && this.type != a.layer.VectorLayer.TYPE_PREDEFINED ||
				(this.serverURL = this.parentMap.mapviewerURL);
				this.renderingStyle && this.isServerSideStyle(this.renderingStyle, "rendering");
				this.labelStyle && this.isServerSideStyle(this.labelStyle, "label");
				this.hoverStyle && this.isServerSideStyle(this.hoverStyle, "hover");
				this.selectionStyle && this.isServerSideStyle(this.selectionStyle, "select");
				if (this.otherStyles && 0 < this.otherStyles.length)
					for (var q = 0; q < this.otherStyles.length; q++)
						this.isServerSideStyle(this.otherStyles[q], "secondary") && (this.otherStyles.splice(q, 1),
							q--);
				q = this.parentMap.graphics;
				this.group && (this.clearFeatureShapes(), 0 === this.group.childrenCount && this.parentMap.draggableGroup.appendChild(this.group));
				var t = a.event.MouseEvent,
				I = this;
				I.timeStamp = 0;
				I.mouseEventListener = function (b) {
					var c = b.type;
					a.event.EventSource.setProcessedEventStatus(I, c, !0);
					var q = I.getTargetFeature(b.target),
					t = I.parentMap.getMapContext();
					if (!a.isNull(q)) {
						var K = a.event.MouseEvent;
						(c === K.MOUSE_CLICK || c === K.MOUSE_DOWN) && 2 === b.button || c === K.TOUCH_LONG_PRESS ? c = K.MOUSE_RIGHT_CLICK :
							c === K.TOUCH_TAP && (c = K.MOUSE_CLICK);
						if (I.parentMap.enableMapAction.mouse) {
							var pa = new K(c, q),
							ga = a.$.extend(!0, {}, b);
							ga.clientX += I.parentMap.$oracleMapDiv.offset().left;
							ga.clientY += I.parentMap.$oracleMapDiv.offset().top;
							pa.evt = ga;
							pa.mapContext = t;
							q.fire(c, pa);
							pa = new K(c, I);
							pa.evt = b;
							pa.feature = q;
							if ((c === K.MOUSE_OVER || c === K.MOUSE_OUT) && null !== b.relatedTarget && (ga = I.getTargetFeature(b.relatedTarget), q === ga))
								return;
							c === K.MOUSE_OVER ? (I.hoverEnable && I.hover(q), I.bringToTopFlag && (q.getShapeIndex(), q.bringToTop()),
								(I.showToolTip && a.isNull(q.tooltipNode) || q.shape && a.isNull(q.shape.feature)) && q.applyToolTip()) : c === K.MOUSE_OUT ? (I.bringToTopFlag && q.setShapeIndex(), I.hoverEnable && I.deHover(q)) : c !== K.MOUSE_CLICK || q.multi ? c === K.TOUCH_END && I.parentMap.enableMapAction.mouse ? (I.endFeatureDragging(b), b.stopPropagation()) : c === K.MOUSE_UP && "overview_rectangle" === pa.feature.id && !0 === pa.feature.dragging && (I.endFeatureDragging(b), b.stopPropagation()) : I.handleVectorMouseClick(aa, I, q);
							b.type === K.TOUCH_TAP && I.handleVectorTouchTap(aa,
								I, q, "touch tapped");
							pa.mapContext = t;
							b = a.$.extend(!0, {}, b);
							b.clientX += I.parentMap.$oracleMapDiv.offset().left;
							b.clientY += I.parentMap.$oracleMapDiv.offset().top;
							pa.evt = b;
							I.fire(c, pa)
						}
					}
				};
				I.touchStart = function (b) {
					b.preventDefault();
					var c = a.util.DomUtil;
					1 == c.getTouchCount(b) && (b.button = 0, c = c.getTouchesClientPosition(b), b.clientX = c.x, b.clientY = c.y, I.graphicsDown(b))
				};
				q.attachEventListener(t.MOUSE_OVER, I.mouseEventListener, this.group);
				q.attachEventListener(t.MOUSE_OUT, I.mouseEventListener, this.group);
				I.graphicsDown =
				function (b) {
					if (2 !== b.button) {
						I.lastMouseDown = I.parentMap.getCursorLocation();
						var c = I.getTargetFeature(b.target);
						c && (c && c.editable ? (I.focusFeature = c, c.startDrag(b, !0)) : c && c.draggable ? (I.selectFeature(c), I.focusFeature = c, c.startDrag && (c.startDrag(b, !0), c.dragStartListener && (b.markerX = c.getMarkerX(), b.markerY = c.getMarkerY(), b.markerSRID = c.getMarkerSRID(), c.dragStartListener.call(this, b)))) : c && a.notNull(c.parentFeature) && (I.focusFeature = c.parentFeature, c.parentFeature.startDrag(b, !1)), I.curTopFeature =
								c)
					}
				};
				a.browser.touchSupported && (q.attachEventListener(t.TOUCH_TAP, I.mouseEventListener, this.group), q.attachEventListener(t.TOUCH_LONG_PRESS, I.mouseEventListener, this.group), q.attachEventListener(t.TOUCH_END, I.mouseEventListener, this.group), q.attachEventListener(t.TOUCH_START, I.touchStart, this.group));
				q.attachEventListener(t.MOUSE_CLICK, I.mouseEventListener, this.group);
				q.attachEventListener(t.MOUSE_RIGHT_CLICK, I.mouseEventListener, this.group);
				q.attachEventListener(t.MOUSE_UP, I.mouseEventListener, this.group);
				q.attachEventListener(t.MOUSE_DOWN, I.mouseEventListener, this.group);
				q.attachEventListener(a.event.MouseEvent.MOUSE_DOWN, I.graphicsDown, this.group);
				q.attachEventListener(t.MOUSE_MOVE, I.mouseEventListener, this.group);
				I.draggingFeature = function (b) {
					if (a.notNull(I.focusFeature) && (I.focusFeature.featureDragging(b), I.focusFeature.draggingListener)) {
						var c = I.focusFeature.parentLayer.parentMap.getMapContext(),
						q = c.getUniverse().getZoomLevels(0)[c.getZoomLevel()],
						c = (I.focusFeature.mouseLocX - I.focusFeature.startX) *
						q.resolution,
						q =  - (I.focusFeature.mouseLocY - I.focusFeature.startY) * q.resolution;
						b.markerX = I.focusFeature.getMarkerX() + c;
						b.markerY = I.focusFeature.getMarkerY() + q;
						b.markerSRID = I.focusFeature.getMarkerSRID();
						I.focusFeature.draggingListener.call(this, b)
					}
				};
				I.draggingFeature_touch = function (b) {
					var c = a.util.DomUtil.getTouchesPosition(b);
					b.pageX = c.x;
					b.pageY = c.y;
					I.draggingFeature(b)
				};
				I.draggingFeature_win8Touch = function (a) {
					a.pageX = a.gesture.touches[0].pageX;
					a.pageY = a.gesture.touches[0].pageY;
					I.draggingFeature(a)
				};
				this.parentMap.$oracleMapDiv.on("mousemove", I.draggingFeature);
				if (a.gv.isWin8Touch)
					a.Hammer(this.parentMap.$oracleMapDiv[0]).on("drag", I.draggingFeature_win8Touch);
				this.parentMap.$oracleMapDiv.on("touchmove", I.draggingFeature_touch);
				I.endFeatureDragging = function (b) {
					if (a.notNull(I.focusFeature)) {
						var c = I.focusFeature;
						c.endDragOrietation ? (b.focusFeature = c, c.endDragOrietation(b)) : (c.endDrag(b), c.dragEndListener && (b.markerX = c.getMarkerX(), b.markerY = c.getMarkerY(), b.markerSRID = c.getMarkerSRID(), c.draggingListener ?
								setTimeout(function () {
									c.dragEndListener.call(this, b)
								}, 100) : c.dragEndListener.call(this, b)));
						a.notNull(I.curTopFeature) && (c.focusProperties(I.curTopFeature), I.curTopFeature = null);
						I.focusFeature = null
					}
				};
				I.endFeatureDragging_touch = function (b) {
					var c = a.util.DomUtil.getTouchesPosition(b);
					b.pageX = c.x;
					b.pageY = c.y;
					I.endFeatureDragging(b)
				};
				a.$(document).on("mouseup", I.endFeatureDragging);
				a.$(document).on("mouseout", I.endFeatureDragging);
				this.parentMap.$oracleMapDiv.on("touchend", I.endFeatureDragging_touch);
				this.orgWidth = c;
				this.orgHeight = b;
				if (this.type !== a.layer.VectorLayer.TYPE_PREDEFINED && this.type !== a.layer.VectorLayer.TYPE_JDBC && this.type !== a.layer.VectorLayer.TYPE_DATAPACK && this.type !== a.layer.VectorLayer.TYPE_GEORSS && this.type !== a.layer.VectorLayer.TYPE_MAPBOX || this.boundingTheme && this.loadedBoundingTheme)
					if (this.setWindow(), this.checkVisible())
						this.displayFeatures();
					else {
						var aa = new a.event.LayerEvent(a.event.LayerEvent.FINISH_LOAD, this);
						aa.mapContext = this.parentMap.getMapContext();
						a.notNull(this.initTask) &&
						(this.initTask.complete(), this.initTask = null);
						this.fire(a.event.LayerEvent.FINISH_LOAD, aa)
					}
				else
					this.setWindow(), this.refreshImpl()
			}
		},
		redrawFeature: function (a) {
			this.removeFeature(a);
			this.addFeature(a)
		},
		setWindow: function () {
			var a = this.parentMap.getMapContext(),
			b = a.getUniverse(),
			c = b.getZoomLevels();
			c && (c = c[a.getZoomLevel()], b = b.bound, this.minX = b.getMinX(), this.minY = b.getMinY(), this.windowW = b.getWidth(), this.windowH = b.getHeight(), this.orgDraggbleGroupPos = this.parentMap.graphics.getLeftTop(this.parentMap.draggableGroup),
				a = a.getCenterPoint(), this.parentMap.graphics.setLeftTop(this.group, 0, 0), b = this.orgWidth * this.xRatio * c.resolution, c = this.orgHeight * this.yRatio * c.resolution * c.stretchRatio, this.dataBufferWindow = {
					x: a.getX() - b / 2,
					y: a.getY() - c / 2,
					w: b,
					h: c
				})
		},
		refresh: function K(b, c) {
			a.isNull(c) && (c = !0);
			K.base.call(this, b, c);
			this.reloadNumber = Math.round(1E10 * Math.random());
			this.refreshImpl(b, c)
		},
		emptyCustomLayer: function () {
			var b = this.getCustomLayerDiv();
			0 < b.length && (b.children().each(function (b, c) {
					a.$(c).data("f").displayed =
						!1;
					a.$(c).remove()
				}), b.off("mouseout"), b.remove())
		},
		refreshImpl: function (b, c, t) {
			if (!a.isNull(this.group)) {
				var I = b && b.type === a.event.MapEvent.MAP_BEFORE_REFRESH ? b.bigPan : !1;
				c ? (I || (this.loaded = !1), this.clearFeatureShapes(), this.clearAllLabels(), I || (this.dataLoaded = !1)) : b && null !== b.beforeZoomLevel && null !== b.afterZoomLevel && b.beforeZoomLevel !== b.afterZoomLevel ? this.setWindow() : this.loadOnDemand ? (this.loaded = !1, this.clearFeatureShapes(), this.clearAllLabels(), this.dataLoaded = !1) : this.clearAllLabels();
				if (this.checkVisible()) {
					b =
						this.parentMap.getMapContext();
					var aa = b.getUniverse(),
					I = aa.getZoomLevels()[b.getZoomLevel()],
					ba = b.getCenterPoint();
					b = this.orgWidth * this.xRatio * I.resolution;
					I = this.orgHeight * this.yRatio * I.resolution * I.stretchRatio;
					this.dataBufferWindow = {
						x: ba.getX() - b / 2,
						y: ba.getY() - I / 2,
						w: b,
						h: I
					};
					this.emptyCustomLayer();
					var R = this,
					aa = aa.getSRID(),
					ba = null;
					if (this.loadOnDemand) {
						var ba = this.visibleBound ? Math.max(this.dataBufferWindow.x, this.visibleBound.getMinX()) : this.dataBufferWindow.x,
						qa = this.visibleBound ? Math.max(this.dataBufferWindow.y,
								this.visibleBound.getMinY()) : this.dataBufferWindow.y;
						b = this.visibleBound ? Math.min(this.dataBufferWindow.x + b, this.visibleBound.getMaxX()) : this.dataBufferWindow.x + b;
						I = this.visibleBound ? Math.min(this.dataBufferWindow.y + I, this.visibleBound.getMaxY()) : this.dataBufferWindow.y + I;
						ba = new a.geometry.Rectangle(ba, qa, b, I, aa)
					}
					(this.loadOnDemand || !this.dataLoaded && this.type !== a.layer.VectorLayer.TYPE_LOCAL) && !1 !== t ? (this.parentMap && this.name === this.parentMap.boundingLayerName && !1 === a.gv.progressBarDisabled && (this.boundingDataTask =
								this.startNewTask()), a.isNull(R.getDataRequest) && this.getThemeData(ba, function () {
							a.notNull(R.boundingDataTask) && (R.boundingDataTask.complete(), R.boundingDataTask = null);
							R.mapping = !1;
							R.renderingStyle instanceof a.style.BucketStyle && !R.renderingStyle.isServerSide && R.renderingStyle.generateBuckets(R.featureArray, R.styleAttributes, !0);
							R.displayFeatures(c)
						})) : this.displayFeatures(c)
				} else
					t = a.event, b = new t.MapEvent(t.LayerEvent.FINISH_LOAD, this), b.mapContext = this.parentMap.getMapContext(), a.notNull(this.initTask) &&
					(this.initTask.complete(), this.initTask = null), this.fire(t.LayerEvent.FINISH_LOAD, b)
			}
		},
		delayDisplayFeatures: function (a) {
			var b = this,
			c = function (a) {
				0 < b.loadingStyle ? setTimeout(c, 100, a) : b.displayFeatures(a)
			};
			c(a)
		},
		setDisplayFeaturesTaskEnabled: function (a) {
			this.displayFeaturesTaskEnabled = a
		},
		isDisplayFeaturesTaskEnabled: function () {
			return this.displayFeaturesTaskEnabled
		},
		displayFeatures: function (b) {
			a.util.Logger.finest(null, "VectorLayer", "[" + this.name + "] displayFeatures called.");
			if (0 < this.loadingStyle)
				this.delayDisplayFeatures(b);
			else {
				this.displayFeaturesTaskEnabled && a.isNull(this.displayFeaturesTask) && (this.displayFeaturesTask = this.startNewTask());
				this.loading = !0;
				this.loaded = !1;
				this.displayCount = 0;
				a.util.Logger.fine("", "OM.VectorLayers.displayFeatures", "[" + this.name + "] displaying Features");
				this.visualFilter && (this.graphicFilter = this.parentMap.graphics.getGraphicFilter(this.visualFilter));
				var c = this.parentMap.graphics,
				t = !1;
				a.isNull(this.realGroup) && (t = !0, this.realGroup = c.createGroup(), this.realGroup.applyStyle({
						cursor: this.mouseCursor
					}),
					this.pointerSensitivity || this.realGroup.applyStyle({
						pointerSensitivity: !1
					}));
				this.graphicFilter && this.visualFilter.applyToLayer && this.parentMap.graphics.applyStyle(this.realGroup, {
					filter: this.graphicFilter
				});
				this.renderingStyle && "HeatMap" == this.renderingStyle.styleType ? (this.displayHeatMap(), a.notNull(this.displayFeaturesTask) && (this.displayFeaturesTask.complete(), this.displayFeaturesTask = null)) : (c = this.parentMap.getMapContext().getZoomLevel(), this.clustering && c <= this.maxClusteringLevel && (this.vCluster.displayAsCluster(this.dataBufferWindow),
						this.vCluster && this.selectedFeatures && 0 < this.selectedFeatures.length && this.vCluster.removeClustersFromSelectedFeatures()), this.mappingNSDP(), this.mfMarker && (this.vmf || (this.vmf = new a.layer.VectorLayerMultiFeature(this), this.vmf.checkLocation()), this.vmf.display()), a.notNull(this.displayFeaturesTask) && this.displayFeaturesTask.update(.65), this.displayBatch(0, t, this, b))
			}
		},
		displayBatch: function (b, c, t, I) {
			a.util.Logger.finest(null, "VectorLayer", "[" + t.name + "] displayBatch called with start\x3d" + b + ".");
			if (t.group) {
				t.renderingStyle &&
				t.renderingStyle instanceof a.style.BucketStyle && (!t.styleAttributes || 0 === t.styleAttributes.length) && (!t.nsdpTitleArray || 1 > t.nsdpTitleArray.length) && a.util.Logger.warning("MAPVIEWER_9042", "OM.layer.VectorLayer.displayBatch", "");
				var aa,
				ba = t.featureArray ? t.featureArray.length : 0;
				a.util.Logger.finest(null, "VectorLayer", "[" + t.name + "] feature count: " + ba + ".");
				var R = t.parentMap.getMapContext().getUniverse().getSRID(),
				qa,
				ua,
				Ca = a.util.BaiduUtil.SRID,
				pa = function (b) {
					return function () {
						var c = b.getGeometry(),
						q =
						function (q) {
							var N = a.notNull(q.mbr) ? q.mbr : a.notNull(q.getMBR) ? q.getMBR() : null;
							b.srid = R;
							b.geo = q;
							if (b.labelBox) {
								q = b.labelBox;
								q = new a.geometry.LineString([q[0], q[1], q[2], q[3]], c.srid);
								var v = function (a) {
									a = a.coordinates;
									b.labelBox = [a[0], a[1], a[2], a[3]];
									t.display(b, N)
								};
								q.srid !== Ca && R !== Ca ? q.transform(R, v) : q.transform(R, v, null, null, {
									map: t.parentMap
								})
							} else
								t.display(b, N)
						};
						c.srid !== Ca && R !== Ca ? c.transform(R, q) : c.transform(R, q, null, null, {
							map: t.parentMap
						})
					}
					()
				},
				ga = function () {
					da(qa, !1, t, I)
				};
				a.notNull(t.featureArray) &&
				0 < t.featureArray.length && a.util.Logger.finest("", "OM.VectorLayer.displayBatch", "Number of features in layer: " + t.featureArray.length);
				console && console.time && "finest" === a.gv.getLogLevel() && a.util.Logger.finest("", "OM.VectorLayer.displayBatch", console.time("[" + this.name + "] displayFeatures"));
				for (qa = b; qa < ba; qa += 1)
					if (ua = t.featureArray[qa], (ua.displayed || ua.multi) && 1 == t.parentMap.getMapContext().getWholeMapNum() || a.notNull(ua.activeIdx) && ua.activeIdx !== this.areaIdx || ua.inCluster)
						ua.removeGhostShape();
					else {
						if (t.enableBatch && (t.displayCount++, t.displayCount > t.numberInBatch)) {
							if (c)
								t.group.appendChild(t.realGroup);
							else
								for (; b <= qa; b++)
									ua = t.featureArray[b], ua.displayed && ua.startAnimation();
							t.displayCount = 0;
							var da = t.displayBatch;
							h.setTimeout(ga, 1E3);
							return
						}
						var v = ua.geo;
						ua.displayed && (ua.shapeArray ? ua.shapeArray.push(ua.shape) : ua.shapeArray = [ua.shape]);
						R !== v.srid ? pa(ua) : this.type !== a.layer.VectorLayer.TYPE_LOCAL ? ("Circle" === v.type && (v = ua.getGeometry()), aa = null, t.loadOnDemand || v.mbr || (aa = v.coordinates ?
									a.geometry.Geometry.calculateMBR(v.coordinates, v.type) : a.geometry.Geometry.calculateGeomCollectionMBR(v.geometries, v.type), v.mbr = new a.geometry.Rectangle(aa.minX, aa.minY, aa.maxX, aa.maxY, v.srid)), t.display(ua, v.mbr)) : (aa = a.notNull(v.mbr) ? v.mbr : a.notNull(v.getMBR) ? v.getMBR() : null, t.display(ua, aa))
					}
				t.displayed = !0;
				console && console.timeEnd && "finest" === a.gv.getLogLevel() && a.util.Logger.finest("", "OM.VectorLayer.displayBatch", console.timeEnd("[" + this.name + "] displayFeatures"));
				c && t.group.appendChild(t.realGroup);
				for (qa = b; qa < ba; qa++)
					ua = t.featureArray[qa], ua.displayed && ua.startAnimation();
				t.displayEnd(I)
			}
		},
		displayEnd: function (b) {
			a.util.Logger.finest(null, "VectorLayer", "[" + this.name + "] displayEnd called.");
			this.bringSelectedFeaturesToTop();
			this.getShadowArea();
			var c = this.parentMap.getMapContext(),
			t = c.getWholeMapNum(),
			I;
			if (1 < t) {
				I = c.getBaseWholeMapIndex();
				a.isNull(this.areaIdx) && (this.areaIdx = 0);
				this.featureGroupArr || (this.featureGroupArr = []);
				this.featureGroupArr.push(this.realGroup);
				var aa = c.getUniverse().getZoomLevels()[c.getZoomLevel()].resolution,
				ba = c.getUniverse().getMapBounds().getWidth(),
				R = (c.getCenterPoint().getX() - c.getRoundMapCenterPoint().getX()) / aa,
				qa = c.getDeviceWidth();
				this.realGroup.translate((this.areaIdx - I) * ba / aa - R, 0);
				this.areaIdx++;
				if (this.areaIdx < t) {
					this.realGroup = this.parentMap.graphics.createGroup();
					this.lineGroup = null;
					this.realGroup.applyStyle({
						cursor: this.mouseCursor
					});
					this.pointerSensitivity || this.realGroup.applyStyle({
						pointerSensitivity: !1
					});
					this.displayBatch(0, !0, this, !1);
					return
				}
				this.parentMap.wraparound && (t = c.getUniverse(),
					aa = t.getZoomLevels()[c.getZoomLevel()].resolution, I = c.getRoundMapCenterPoint().getX() - qa / 2 * aa, c = c.getRoundMapCenterPoint().getX() + qa / 2 * aa, this.wraparound_lEdgeIdx = Math.round(I / t.getMapBounds().getWidth()), this.wraparound_rEdgeIdx = Math.round(c / t.getMapBounds().getWidth()))
			}
			!0 === this.clustering && this.vCluster && this.vCluster.getBaseSelArray() && 0 < this.vCluster.getBaseSelArray().length && this.vCluster.selectActiveSelection();
			c = this.parentMap.getMapContext().getZoomLevel();
			this.clustering && c <= this.maxClusteringLevel &&
			this.vCluster.showClusterInWrapAround();
			a.util.Logger.finest("", "OM.VectorLayer.displayEnd", "[" + this.name + "] display features completed");
			this.loading = !1;
			c = a.event.LayerEvent;
			qa = this.parentMap.getMapContext();
			a.notNull(this.initTask) && (this.initTask.complete(), this.initTask = null);
			a.notNull(this.displayFeaturesTask) && (this.displayFeaturesTask.complete(), this.displayFeaturesTask = null);
			t = new c(c.FINISH_LOAD, this);
			t.mapContext = qa;
			this.fire(c.FINISH_LOAD, t);
			t = new c(c.FEATURES_DISPLAYED, this);
			t.mapContext =
				qa;
			this.fire(c.FEATURES_DISPLAYED, t);
			b && (t = new c(c.FEATURES_DISPLAYED, this), t.mapContext = this.parentMap.getMapContext(), this.fire(c.AFTER_REFRESH, t))
		},
		display: function (b, c, t) {
			var I = this.dataBufferWindow;
			if (I && a.notNull(c) && (c.getMaxX() < I.x || c.getMaxY() < I.y || c.getMinX() > I.x + I.w || c.getMinY() > I.y + I.h))
				if (this.parentMap.wraparound) {
					var aa = this.parentMap.getMapContext().getUniverse().getMapBounds().getWidth();
					if (!(a.notNull(c) && c.getMaxX() < I.x && c.getMaxX() + aa > I.x || a.notNull(c) && c.getMinX() > I.x + I.w && c.getMinX() -
							aa < I.x + I.w))
						return
				} else
					return;
			if (!(a.notNull(c) && this.visibleBound && (c.getMinX() > this.visibleBound.getMaxX() || c.getMinY() > this.visibleBound.getMaxY() || c.getMaxX() < this.visibleBound.getMinX() || c.getMaxY() < this.visibleBound.getMinY()) || this.mapping && !b.mapping && !this.nsdp.fullDisplay)) {
				b.group = this.realGroup;
				b.screenTransformObj = this.parentMap.getMapContext().getTransform();
				b.screenPoints = null;
				b.graphics = this.graphics ? this.graphics : this.parentMap.graphics;
				b.parentLayer = this;
				var ba = this.getFeatureStyles(b);
				b.setOldStyle(null);
				b.hover = !1;
				b.selected && b.selected && this.selectionStyle && (b.setOldStyle(this.renderingStyle), c = {}, "PulseAnimation" === this.selectionStyle.styleType || "AnimationColor" === this.selectionStyle.styleType ? (c = b.shape, b.displayFeature([this.selectionStyle], null, t), b.selectShape = b.shape, b.shape = c, c = b.getOldStyle()) : c = this.getHoverSelectStyle(this.selectionStyle, b), ba = c, this.parentMap.wraparound && (b.renderingStyle = ba));
				a.notNull(ba) ? (b.setRenderingStyle(ba), ba = [ba]) : ba = [];
				this.otherStyles &&
				(ba = ba.concat(this.otherStyles));
				if (0 === ba.length)
					if (c = this.getDefaultRenderingStyle(b.geo.type))
						ba.push(c), b.setRenderingStyle(c), a.isNull(this.renderingStyle) && (this.renderingStyle = c);
					else
						return;
				ba = b.getAllStyles(ba);
				a.notNull(this.labelingStyle) ? a.isNull(b.getLabelingStyle()) && b.setLabelingStyle(this.labelingStyle) : !b.labelStyle && b.labelStyleName && (c = a.style.StyleStore.getServerSideStyle(this.dataSource, b.labelStyleName), b.setLabelingStyle(c));
				var R = this,
				qa = function () {
					if ("Marker" !== ba[0].styleType ||
						!ba[0].src || null !== ba[0].width && null !== ba[0].height)
						if (b.displayFeature(ba, null, t), b.startAnimation(), R.selectVisualFilter && b.selected) {
							var a = R.parentMap.graphics.getGraphicFilter(R.selectVisualFilter);
							R.parentMap.graphics.applyStyle(b.shape, {
								filter: a
							})
						} else
							R.graphicFilter && !R.visualFilter.applyToLayer && b.shape && R.parentMap.graphics.applyStyle(b.shape, {
								filter: this.graphicFilter
							});
					else
						setTimeout(qa, 300)
				};
				qa()
			}
		},
		mappingNSDP: function () {
			if (!this.mapping && (this.nsdpTitleArray && (this.attrNames ? (this.nsdpTitleArray[0].toUpperCase() ==
							this.nsdpKey && this.nsdpTitleArray.shift(), this.attrNames = this.attrNames.concat(this.nsdpTitleArray)) : this.nsdpTitleArray[0].toUpperCase() == this.nsdpKey && (this.attrNames = this.nsdpTitleArray.slice(1))), this.nsdpData && this.nsdpKey)) {
				for (var b = this.featureArray ? this.featureArray.length : 0, c = 0; c < b; c++) {
					var t = this.featureArray[c],
					I = this.getNsdpDataForFeature(t);
					if (a.notNull(I)) {
						a.$.extend(t.attributes, I);
						t.columns = [];
						for (var aa in I)
							t.columns.push(aa);
						t.mapping = !0
					} else
						t.mapping = !1
				}
				this.mapping = !0;
				b = a.event.LayerEvent;
				c = new b(b.NSDP_MAPPED, this);
				this.fire(b.NSDP_MAPPED, c)
			}
		},
		getNsdpDataForFeature: function (b) {
			var c = null;
			a.notNull(b.attributes) && (c = b.getAttributeValue(this.nsdpKey));
			a.isNull(c) && (c = b.id);
			var c = this.nsdp.ignoreCase ? c.toUpperCase() : c,
			t = this.nsdpData[c];
			a.isNull(t) && (c = b.attributes._LABEL_, a.notNull(c) && (c = this.nsdp.ignoreCase ? c.toUpperCase() : c, t = this.nsdpData[c]));
			return t
		},
		clearNSDP: function () {
			if (this.nsdpTitleArray) {
				var a = this.nsdpTitleArray.length;
				this.attrNames.splice(this.attrNames.length - a, a);
				if (this.nsdpData && this.mapping) {
					for (var b = this.featureArray ? this.featureArray.length : 0, c = 0; c < b; c++) {
						var I = this.featureArray[c];
						if (I.mapping)
							for (var aa = 0; aa < a; aa++)
								I.attributes[this.nsdpTitleArray[aa].toUpperCase()] = null;
						I.mapping = !1
					}
					this.mapping = !1
				}
			}
		},
		isValidId: function (a) {
			for (var b = this.featureArray ? this.featureArray.length : 0, c = 0; c < b; c++)
				if (this.featureArray[c].id == a)
					return !1;
			return !0
		},
		getFeature: function (a) {
			for (var b = this.featureArray ? this.featureArray.length : 0, c = 0; c < b; c++)
				if (this.featureArray[c].id ==
					a)
					return this.featureArray[c];
			return null
		},
		getFeaturesByAttribute: function (a, b) {
			var c,
			I,
			aa,
			ba = !1,
			R,
			qa,
			ua,
			Ca = this.featureArray ? this.featureArray.length : 0;
			if (0 === Ca)
				return null;
			a = a.toUpperCase();
			this.getAttributeNames().forEach(function (b) {
				a === b.toUpperCase() && (ba = !0)
			});
			if (!ba)
				return null;
			var pa = b instanceof Array;
			pa && (ua = b.length);
			c = [];
			for (aa = 0; aa < Ca; aa++)
				if (I = this.featureArray[aa], (qa = I.getAttributeValue(a)) && pa)
					for (R = 0; R < ua; R++)
						b[R] === qa && c.push(I);
			return c
		},
		getAllThemeData: function (a, b) {
			this.getThemeData(null,
				a, b)
		},
		sendHttpRequest: function (b, c, t, I, aa, ba, R) {
			return a.util.HttpRequest.send(b, c, t, I, aa, ba, R)
		},
		getThemeData: function (b, c, t) {
			if (!this.usedInOverview)
				if (this.initError)
					c();
				else if (this.type === a.layer.VectorLayer.TYPE_GEORSS)
					this.getGeoRss(b, c, t);
				else if (this.type !== a.layer.VectorLayer.TYPE_LOCAL && this.loadOnDemand && a.isNull(this.sessionId))
					this.getSessionId(b, c);
				else {
					a.notNull(this.getDataRequest) && this.getDataRequest.abort();
					this.loading = !0;
					var I = this,
					aa = this.serverURL;
					this.type !== a.layer.VectorLayer.TYPE_DATAPACK &&
					(aa += "/dataserver/" + this.dataSource);
					var ba = {};
					I.lastEvent = a.event.LayerEvent.VECTOR_LAYER_LOADING_THEME;
					(I.type === a.layer.VectorLayer.TYPE_PREDEFINED || I.type === a.layer.VectorLayer.TYPE_JDBC) && I.parentMap && a.notNull(I.boundingDataTask) && I.boundingDataTask.update(.5);
					var R = this.parentMap;
					R && R.applicationID && (ba.applicationID = R.applicationID);
					this.options && (this.options.simplify && (ba.simplify = this.options.simplify, this.options.threshold && (ba.threshold = this.options.threshold), this.options.simplifyAlgorithm &&
							(ba.simplifyAlgorithm = this.options.simplifyAlgorithm)), this.options.dadp && (ba.dadp = this.options.dadp));
					this.type === a.layer.VectorLayer.TYPE_PREDEFINED ? (ba.t = this.themeName, a.notNull(this.workspace) && "LIVE" !== this.workspace.toUpperCase() && (ba.workspace = this.workspace)) : this.type === a.layer.VectorLayer.TYPE_JDBC && (a.notNull(this.workspace) && "LIVE" !== this.workspace.toUpperCase() && (ba.workspace = this.workspace), ba.t = this.name, ba.sql = this.sql, this.keyColumn && (ba.id_col = this.keyColumn), this.baseTable && (ba.base_table =
								this.baseTable), this.geometryColumn && (ba.geom_col = this.geometryColumn), this.jdbcSrid && (ba.jdbc_srid = this.jdbcSrid), this.asis && (ba.asis = !0));
					a.$.extend(ba, this.queryParameter);
					if (b)
						if (b.srid === a.util.BaiduUtil.SRID) {
							var qa = new BMap.Pixel(b.getMinX(), b.getMinY());
							b = new BMap.Pixel(b.getMaxX(), b.getMaxY());
							qa = R.bdutil.project.pointToLngLat(qa);
							R = R.bdutil.project.pointToLngLat(b);
							ba.bbox = qa.lng + "," + qa.lat + "," + R.lng + "," + R.lat
						} else
							ba.bbox = b.getMinX() + "," + b.getMinY() + "," + b.getMaxX() + "," + b.getMaxY();
					R = a.util.HttpRequest.getDomain(this.serverURL);
					R || (R = a.util.HttpRequest.localDomain);
					if (R = a.gv.mvKeyMap[R])
						ba.key = R;
					this.type !== a.layer.VectorLayer.TYPE_DATAPACK && (ba.include_label_box = "true", R = null, this.parentMap && (R = this.parentMap.getMapContext().getUniverse().getSRID()), R && (R === a.util.BaiduUtil.SRID ? (ba.to_srid = 8307, ba.bbox_srid = 8307) : (ba.to_srid = R, ba.bbox_srid = R)), this.sessionId && (ba.ssid = this.sessionId), this.nsdp && (ba.nsdp = this.getNSDPString()));
					this.type !== a.layer.VectorLayer.TYPE_DATAPACK && (ba.refresh = Math.round(1E5 * Math.random()));
					var R =
						I.type === a.layer.VectorLayer.TYPE_DATAPACK ? !0 : !1,
					ua = function (b) {
						I.initError = !0;
						I.getDataRequest = null;
						b && a.util.Logger.alert("MAPVIEWER_9006", "OM.layer.VectorLayer.getThemeData", b.responseText);
						t && t();
						b = a.event;
						var c = new b.LayerEvent(b.LayerEvent.INIT_ERROR, I);
						a.notNull(I.parentMap) && (c.mapContext = I.parentMap.getMapContext());
						a.notNull(I.initTask) && (I.initTask.abort(), I.initTask = null);
						I.fire(b.LayerEvent.INIT_ERROR, c)
					};
					this.enableXHR && (ba.$enableXHR = !0);
					this.getDataRequest = this.sendHttpRequest(aa,
							ba, function (b) {
							if (I.parentMap && I.parentMap.graphics) {
								I.dataLoaded = !0;
								var t,
								ga = !1;
								"string" === typeof b && (I.lastEvent = a.event.LayerEvent.VECTOR_LAYER_PARSING_THEME, a.notNull(I.boundingDataTask) ? I.boundingDataTask.update(.75) : !1 === a.gv.progressBarDisabled && (I.boundingDataTask = I.startNewTask(), I.boundingDataTask.update(.75)), b = b.trim(), ga = 0 === b.indexOf("{") || 0 === b.indexOf("["));
								try {
									"object" !== typeof b && (b = a.$.parseJSON(b))
								} catch (K) {
									a.notNull(I.boundingDataTask) && I.boundingDataTask.abort();
									ga && a.util.Logger.warning(null,
										"OM.layer.VectorLayer.getThemeData", K);
									try {
										b = a.$(a.$.parseXML(b));
										var da = b.find("oms_error");
										if (0 < da.length) {
											a.util.Logger.alert("MAPVIEWER_9007", "OM.layer.VectorLayer.getThemeData", da.text());
											ua();
											return
										}
										t = new a.layer.KMLParser(I);
										var v = t.parse(b, c);
										v || (t = new a.layer.GeoRSSParser(I), v = t.parse(b, c), v || (a.util.Logger.alert("MAPVIEWER_9008", "OM.layer.VectorLayer.getThemeData"), ua()));
										return
									} catch (N) {
										ua();
										return
									}
								}
								I.getDataRequest = null;
								try {
									t = new a.layer.GeoJSONParser(I);
									t.parse(b, c, ua);
									a.notNull(I.boundingDataTask) &&
									(I.boundingDataTask.complete(), I.boundingDataTask = null);
									var E = new a.event.LayerEvent(a.event.LayerEvent.FEATURES_LOADED, I);
									I.fire(a.event.LayerEvent.FEATURES_LOADED, E)
								} catch (K) {
									a.util.Logger.warning("MAPVIEWER_9101", "OM.layer.VectorLayer.getThemeData", K.message),
									ua()
								}
							}
						}, this.jsonp ? "jsonp" : "text", ua, R)
				}
		},
		getGeoRss: function (b, c, t) {
			if (this.initError)
				c();
			else {
				this.loading = !0;
				var I = this;
				b = this.serverURL;
				var aa = function (b) {
					I.initError = !0;
					I.getDataRequest = null;
					b && a.util.Logger.alert("MAPVIEWER_9008", "OM.layer.VectorLayer.getThemeData",
						b.responseText);
					t && t();
					b = a.event;
					var c = new b.LayerEvent(b.LayerEvent.INIT_ERROR, I);
					c.mapContext = I.parentMap.getMapContext();
					I.fire(b.LayerEvent.INIT_ERROR, c)
				};
				this.attrNames = ["link", "updated", "content", "summary"];
				this.getDataRequest = this.sendHttpRequest(b, {}, function (b) {
					var K = a.$(b).find("oms_error");
					0 < K.length ? (a.util.Logger.alert("MAPVIEWER_9008", "OM.layer.VectorLayer.getThemeData", K.text()), aa()) : (new a.layer.GeoRSSParser(I)).parse(b, c, t) || aa()
				}, "xml", aa, !0, !0)
			}
		},
		isBoundingTheme: function () {
			return this.boundingTheme
		},
		loadBoundingTheme: function (b) {
			var c = this,
			t = this.parentMap.getMapContext();
			this.orgWidth = this.orgWidth ? this.orgWidth : t.getDeviceWidth();
			this.orgHeight = this.orgHeight ? this.orgHeight : t.getDeviceHeight();
			var I = new a.event.LayerEvent(a.event.LayerEvent.FINISH_GOT_CONFIG, this);
			!1 === a.gv.progressBarDisabled && (this.boundingDataTask = this.startNewTask());
			var aa = c.renderingStyle && c.renderingStyle.hasBinding(),
			ba = a.notNull(c.nsdpData) && a.notNull(c.nsdpKey),
			t = function (t) {
				t || (t = (t = c.getExtent()) ? t.coordinates :
					null, (aa || ba) && a.notNull(c.bfMbr) && (t = c.bfMbr.coordinates));
				t ? (c.dataLoaded = !0, b ? b(t[0], t[1], t[2], t[3]) : (I.bbox = [t[0], t[1], t[2], t[3]], I.mapContext = c.parentMap.getMapContext(), c.fire(a.event.LayerEvent.FINISH_GOT_CONFIG, I), a.notNull(c.boundingDataTask) && (c.boundingDataTask.complete(), c.boundingDataTask = null))) : (c.dataLoaded = !1, R())
			},
			R = function () {
				c.loadedBoundingTheme = !0;
				a.util.Logger.warning("MAPVIEWER_9049", "OM.layer.VectorLayer.loadBoundingTheme", c.name);
				var t = c.parentMap.getMapContext(),
				R = t.getUniverse().getMapBounds();
				b ? b(R.getMinX(), R.getMinY(), R.getMaxX(), R.getMaxY()) : (I.bbox = [R.getMinX(), R.getMinY(), R.getMaxX(), R.getMaxY()], I.mapContext = t, a.notNull(c.boundingDataTask) && (c.boundingDataTask.abort(), c.boundingDataTask = null), c.fire(a.event.LayerEvent.FINISH_GOT_CONFIG, I))
			},
			qa;
			this.mbr ? (qa = this.mbr, t([qa.getMinX(), qa.getMinY(), qa.getMaxX(), qa.getMaxY()])) : !this.loadOnDemand && this.dataLoaded || this.type === a.layer.VectorLayer.TYPE_LOCAL ? (qa = this.getExtent(), (aa || ba) && a.notNull(this.bfMbr) && (qa = this.bfMbr), a.isNull(qa) &&
				(qa = this.parentMap.getMapContext().getUniverse().getMapBounds()), t([qa.getMinX(), qa.getMinY(), qa.getMaxX(), qa.getMaxY()])) : this.getAllThemeData(t, R)
		},
		calculateCenterAndZoomLevel: function (b, c, t, I) {
			var aa = this.parentMap.getMapContext(),
			ba = aa.getUniverse();
			if (0 === b && 0 === c && 0 === t && 0 === I)
				return [aa.getZoomLevel(), aa.getCenterPoint()];
			if (this.type === a.layer.VectorLayer.TYPE_LOCAL)
				I = this.getExtent(), this.renderingStyle && this.renderingStyle.hasBinding() && a.notNull(this.bfMbr) && (I = this.bfMbr), a.isNull(I) &&
				(I = this.parentMap.getMapContext().getUniverse().getMapBounds()), b = I.getMinX(), c = I.getMinY(), t = I.getMaxX(), I = I.getMaxY();
			else if (a.isNull(this.mbr)) {
				var R = ba.getSRID();
				this.mbr = new a.geometry.Rectangle(b, c, t, I, R)
			}
			for (var R = (t - b) / aa.getDeviceWidth(), aa = (I - c) / aa.getDeviceHeight(), qa = ba.getZoomLevels(), ua = ba.getZoomLevelNumber(), Ca = null, pa = 0; pa < ua; pa++)
				if (R > qa[pa].resolution || aa > qa[pa].resolution * qa[pa].stretchRatio) {
					Ca = 0 === pa ? 0 : pa - 1;
					break
				}
			a.isNull(Ca) && (Ca = 1E-7 > Math.abs(b - t) && 1E-7 > Math.abs(c - I) && a.gv.pointZoomLevel ===
					a.gv.MID_ZOOM ? Math.floor(ua / 2) : ua - 1);
			this.loadedBoundingTheme = !0;
			this.boundingZoomLevel = Ca;
			return [Ca, new a.geometry.Point((b + t) / 2, (c + I) / 2, ba.getSRID())]
		},
		getLayerConfig: function () {
			var b = new a.event.LayerEvent(a.event.LayerEvent.FINISH_GOT_CONFIG, this);
			b.mapContext = this.parentMap.getMapContext();
			!1 === a.gv.progressBarDisabled && (this.initTask = this.startNewTask());
			a.notNull(this.initTask) && this.initTask.update(.25);
			this.fire(a.event.LayerEvent.FINISH_GOT_CONFIG, b)
		},
		setCenterAndZoomlevel: function (a) {
			this.refreshImpl(a,
				!1)
		},
		recenter: function (a) {
			if (this.displayed) {
				var b = this.dataBufferWindow,
				c = b.x + b.w / 2,
				I = b.y + b.h / 2,
				b = this.parentMap.getMapContext(),
				aa = b.getUniverse(),
				ba = b.getRoundMapCenterPoint(),
				R = b.getCenterPoint(),
				qa = aa.getZoomLevels()[b.getZoomLevel()];
				this.refreshCenterX || (this.refreshCenterX = c);
				var c = this.parentMap.wraparound ? Math.abs(ba.getX() - this.refreshCenterX) / qa.resolution : Math.abs(R.getX() - c) / qa.resolution,
				I = Math.abs(R.getY() - I) / qa.resolution * qa.stretchRatio,
				R = (this.orgWidth * this.xRatio - this.orgWidth) /
				2,
				ua = (this.orgHeight * this.yRatio - this.orgHeight) / 2,
				Ca = b.getDeviceWidth(),
				pa = qa.resolution,
				qa = !1;
				if (this.parentMap.wraparound) {
					var ga = ba.getX() - Ca / 2 * pa,
					ba = ba.getX() + Ca / 2 * pa,
					Ca = Math.round(ga / aa.getMapBounds().getWidth()),
					aa = Math.round(ba / aa.getMapBounds().getWidth());
					if (Ca !== this.wraparound_lEdgeIdx || aa !== this.wraparound_rEdgeIdx)
						qa = !0
				}
				R < c || ua < I || qa ? (this.clearFeatureShapes(), this.featureGroupArr ? this.featureGroupArr.length = 0 : this.featureGroupArr = [], this.parentMap.wraparound && (this.refreshCenterX = b.getRoundMapCenterPoint().getX()),
					this.loaded = !1, this.areaIdx = 0, this.refreshImpl(a, !1)) : this.refreshShadowGeom()
			} else
				this.parentMap && this.parentMap.initialized && (this.loaded = !1, this.refreshImpl(a, !1))
		},
		checkVisible: function () {
			return this.isInZoomLevelRange() && this.isVisible() ? !0 : !1
		},
		clearFeatureShapes: function () {
			for (var b = (this.featureArray ? this.featureArray.length : 0) - 1; 0 <= b; b--) {
				var c = this.featureArray[b];
				c.clearAnimation();
				c.animations = null;
				c.moveAnimation && (this.parentMap.wraparound ? c.stopMoveAnimation() : c.pauseMoveAnimation());
				c.screenTransformObj = null;
				c.graphics = null;
				c.displayed = !1;
				c.inCluster = !1;
				c.markerSize = null;
				if (c.shapeGroup) {
					for (var t = c.shapeGroup.length, I = 0; I < t; I++)
						c.shapeGroup[I].feature = null;
					c.shapeGroup = null
				} else
					c.shape && (this.parentMap.graphics.remove(c.shape), c.shape.feature = null, c.shape = null);
				c.labelShape && (c.labelShape.feature = null);
				c.labelShape = null;
				c.ghostShape && (c.ghostShape.feature = null);
				c.ghostShape = null;
				c.ghostGeom = null;
				a.notNull(c.shapeArray) && (c.shapeArray = null);
				a.notNull(c.chartGroup) && (c.chartGroup =
						null);
				this.parentMap.graphics.remove(c.group);
				c.group = null;
				this.removeFromRtree(c)
			}
			a.notNull(this.parentMap) && a.notNull(this.parentMap.graphics) && this.parentMap.graphics.clearGroup(this.group);
			this.featureGroupArr = this.labelGroup = this.realGroup = this.lineGroup = null;
			this.vCluster && this.vCluster.clearAllClusterFeatures();
			this.heatMap && (b = a.$(this.getHeatmapDivId()), 0 < b.length && b.empty());
			this.areaIdx = 0;
			this.emptyCustomLayer();
			this.displayed = !1;
			this.tileFeatureGroup = {}
		},
		getCustomLayerDiv: function () {
			var b =
				this.getCustomLayerDivId(),
			c = a.$("#" + b);
			0 >= c.length && a.notNull(this.parentMap) && (b = a.$("\x3cdiv id\x3d'" + b + "' style\x3d'position:absolute;'\x3e"), b.css({
					display: "block",
					left: "0px",
					top: "0px",
					width: "0px",
					height: "0px",
					"z-index": 5
				}), this.parentMap.$topLayerDIV.append(b), b.on("mouseout", function (a) {
					a.stopPropagation()
				}), c = b);
			return c
		},
		getHeatmapDivId: function () {
			return "#" + this.getDivId("heatmap_")
		},
		getCustomLayerDivId: function () {
			return this.getDivId("customDiv")
		},
		getDivId: function (a) {
			return (a + this.parentMap.mapInstanceId +
				"_" + this.name).replace(/([ #;?%&,.+*~\':"!^$[\]()=>|\/@])/g, "\\$1")
		},
		showInfoWindow: function (b, c) {
			var t = "",
			I = b.attributes;
			if (I || this.type === a.layer.VectorLayer.TYPE_LOCAL) {
				var aa = 0,
				ba,
				R;
				if (b.InfoHtml)
					t = b.InfoHtml;
				else if (this.attrNames && 0 < this.attrNames.length) {
					for (var qa = this.attrNames.length, ua = [], Ca = 0; Ca < qa; Ca++) {
						ba = this.attrNames[Ca];
						var pa = ba.toUpperCase();
						R = "#bbbbbb";
						0 === aa % 2 && (R = "#dddddd");
						"_LABEL_" != pa && b.attributes[pa] && -1 === ua.indexOf(pa) && (aa++, (ga = b.attributes[pa]) ? "string" !== typeof ga ||
							a.util.DomUtil.isHtml(ga) || (ga = ga.replace(/\s/g, "\x26nbsp;")) : ga = "", t += "\x3ctr bgcolor\x3d'" + R + "'\x3e\x3ctd align\x3d'right'\x3e" + ba + "\x3c/td\x3e\x3ctd align\x3d'left'\x3e" + ga + "\x3c/td\x3e\x3c/tr\x3e", ua.push(pa))
					}
					t = "\x3ctable cellspacing\x3d'2' style\x3d'margin: auto;border-spacing: 2px;border-collapse: separate;'\x3e" + t + "\x3c/table\x3e"
				} else if (this.type === a.layer.VectorLayer.TYPE_DATAPACK || this.type === a.layer.VectorLayer.TYPE_LOCAL) {
					for (ba in b.attributes) {
						var ga = b.attributes[ba];
						ga && ("string" ===
							typeof ga && (ga = ga.replace(/\s/g, "\x26nbsp;")), R = "#bbbbbb", 0 === aa % 2 && (R = "#dddddd"), aa++, "_LABEL_" !== ba && (t += "\x3ctr bgcolor\x3d'" + R + "'\x3e\x3ctd align\x3d'right'\x3e" + ba + "\x3c/td\x3e\x3ctd align\x3d'left'\x3e" + ga + "\x3c/td\x3e\x3c/tr\x3e"))
					}
					if (0 === aa)
						return;
					t = "\x3ctable cellspacing\x3d'2' style\x3d'margin: auto;border-spacing: 2px;border-collapse: separate;'\x3e" + t + "\x3c/table\x3e"
				} else
					return;
				aa = {};
				b.label ? (I = (b.label + "").replace(/ /g, "\x26nbsp;"), aa.title = I) : I && a.notNull(I._LABEL_) && (I = (b.attributes._LABEL_ +
						"").replace(/ /g, "\x26nbsp;"), aa.title = I);
				I = this.parentMap;
				c || (c = I.getCursorLocation());
				aa.id = this.name + "_" + b.id;
				a.notNull(c) ? I.displayInfoWindow(c, t, aa) : I.displayInfoWindow(b.getGeometry(), t, aa)
			}
		},
		getSessionId: function (a, b) {
			var c = this;
			this.sendHttpRequest(this.serverURL + "/dataserver/" + this.dataSource, {
				get_session_id: "yes"
			}, function (I) {
				c.sessionId = I;
				c.getThemeData(a, b)
			}, "text")
		},
		removeGraphics: function () {
			this.clearSelectedFeatures();
			if (this.group) {
				var a = this.parentMap.graphics;
				this.clearFeatureShapes();
				a.remove(this.group);
				a.destroy(this.group);
				this.group = null
			}
		},
		changeVisibleBound: function () {
			this.type != a.layer.VectorLayer.TYPE_PREDEFINED || this.loadOnDemand || this.clearFeatureShapes();
			this.refreshImpl()
		},
		changeOpacity: function () {
			this.parentMap && this.parentMap.graphics && this.parentMap.graphics.applyStyle(this.group, {
				opacity: this.opacity
			});
			if (this.parentMap && this.heatMap && a.notNull(this.heatmapStore)) {
				var b = this.heatmapStore,
				c = b.srcHeatmapCanvas,
				t = b.dstHeatmapCanvas;
				if (!a.isNull(c) && !a.isNull(t)) {
					var I =
						t.getContext("2d"),
					aa = I.globalAlpha;
					I.globalAlpha = this.opacity;
					I.clearRect(0, 0, t.width, t.height);
					I.drawImage(c, b.srcx, b.srcy, b.srcw, b.srch, b.dstx, b.dsty, b.dstw, b.dsth);
					I.globalAlpha = aa
				}
			}
		},
		getNSDPXML: function () {
			if (!this.nsdp)
				return "";
			var a;
			a = '\x3cns_data_provider provider_id\x3d"defaultNSDP"\x3e' + ('\x3cfor_theme name\x3d"' + this.name + '"/\x3e');
			a += '\x3cjoin spatial_key_column\x3d"' + this.nsdpKey + '"/\x3e';
			a += "\x3cparameters\x3e";
			this.nsdp.xml ? a += '\x3cparameter name\x3d"xml" value\x3d"' + this.nsdp.xml.replace(/</g,
				"\x26lt;") + '"/\x3e' : this.nsdp.url && (a += '\x3cparameter name\x3d"xml_url" value\x3d"' + this.nsdp.url + '"/\x3e');
			return a += "\x3c/parameters\x3e\x3c/ns_data_provider\x3e"
		},
		selectAllFeatures: function () {
			for (var a = this.featureArray ? this.featureArray.length : 0, b = 0; b < a; b++) {
				var c = this.featureArray[b];
				this.selectionEnable && !c.selected && (c.getOldStyle() || c.setOldStyle(c.renderingStyle), c.setRenderingStyle(this.selectionStyle), this.selectedFeatures ? this.selectedFeatures.push(c) : this.selectedFeatures = Array(c), c.selected =
						!0)
			}
			return null
		},
		addMarkerBoundToGrid: function () {
			var b = this.getFeatureGeometryType();
			if ("" !== b && "LINESTRING" !== b && "POLYGON" !== b) {
				for (var b = this.featureArray ? this.featureArray.length : 0, c = 0; c < b; c++) {
					var t = this.featureArray[c];
					if (t.displayed && t.screenPoints) {
						var I = t.screenPoints.x,
						aa = t.screenPoints.y,
						ba,
						R;
						t.markerSize ? (ba = t.markerSize.w, R = t.markerSize.h) : (R = t.renderingStyle ? t.renderingStyle : this.otherStyles && 0 < this.otherStyles.length ? this.otherStyles[0] : this.getDefaultRenderingStyle(t.geo.type), a.notNull(R.lengthUnit) ?
							(ba = R.realWidthInPx ? R.realWidthInPx : R.width, R = R.realHeightInPx ? R.realHeightInPx : R.height) : (ba = R.realWidth ? R.realWidth : R.width, R = R.realHeight ? R.realHeight : R.height), t.markerSize = {
								w: ba,
								h: R
							});
						this.parentMap.grid.insert([I - ba / 2, aa - R / 2, I + ba / 2, aa + R / 2])
					}
				}
				this.vCluster && this.vCluster.addClusterFeatureToLabelGrid()
			}
		},
		addLabels: function () {
			if (this.group) {
				var a = this.featureArray ? this.featureArray.length : 0,
				b = this.parentMap.getMapContext(),
				c = b.getWholeMapNum(),
				I = b.getBaseWholeMapIndex();
				this.labelGroupArray ? this.labelGroupArray.length =
					0 : this.labelGroupArray = [];
				for (var aa = 0; aa < c; aa++)
					if (this.labelGroup || (this.labelGroup = this.parentMap.graphics.createGroup({
								opacity: this.opacity,
								visibility: !0
							}), this.group.appendChild(this.labelGroup)), 1 < c) {
						var ba = b.getUniverse().getZoomLevels()[b.getZoomLevel()].resolution,
						R = b.getUniverse().getMapBounds().getWidth(),
						qa = (b.getCenterPoint().getX() - b.getRoundMapCenterPoint().getX()) / ba;
						this.labelGroup.translate((aa - I) * R / ba - qa, 0);
						this.labelGroupArray || (this.labelGroupArray = []);
						this.labelGroupArray.push(this.labelGroup);
						this.labelGroup = null
					}
				this.shadow && this.getShadowArea();
				1 < c && (this.labelGroup = this.labelGroupArray[0]);
				for (b = 0; b < a; b++)
					if (I = this.featureArray[b], !I.labelShape && !1 !== I.visible && (I.addLabel(this.parentMap.grid), I.labelShape))
						for (I.labelShapeArr = [], aa = 1; aa < c; aa++)
							if (ba = this.parentMap.graphics.cloneText(I.labelShape))
								ba.applyStyle({
									cursor: this.mouseCursor
								}), ba.feature = I, this.labelGroupArray[aa].appendChild(ba), I.labelShapeArr.push(ba)
			}
		},
		clearAllLabels: function () {
			this.mask = null;
			this.labelGroup && a.notNull(this.parentMap) &&
			a.notNull(this.parentMap.graphics) && this.parentMap.graphics.clearGroup(this.labelGroup);
			if (this.labelGroupArray) {
				for (var b = 0; b < this.labelGroupArray.length; b++)
					a.notNull(this.parentMap) && a.notNull(this.parentMap.graphics) && this.parentMap.graphics.clearGroup(this.labelGroupArray[b]);
				this.labelGroupArray.length = 0
			}
			for (var b = this.featureArray ? this.featureArray.length : 0, c = 0; c < b; c++) {
				var t = this.featureArray[c];
				t.labelShape && (t.labelShape.feature = null, t.labelShape = null)
			}
		},
		enableDisplayInBatch: function (a,
			b) {
			if (this.enableBatch = a)
				this.batchInterval = b && b.interval ? b.interval : 200, this.numberInBatch = b && b.numberInBatch ? b.numberInBatch : 100
		},
		enableClustering: function (b, c) {
			var t;
			this.clustering = b;
			if (!1 === b || "false" === b)
				this.parentMap && (t = this.parentMap, t.displayed && t.refreshMap());
			else {
				var I = !0;
				this.vCluster = new a.layer.VectorLayerCluster(this, c);
				if (a.notNull(c)) {
					if (a.notNull(c.clickBehavior) && "select" === c.clickBehavior ? (this.vClusterClickToZoomToMBR = !1, this.vCluster.initClusterSelection()) : this.vClusterClickToZoomToMBR =
							!0, a.notNull(c.options) && (t = c.options, !1 === t.refreshMap || "false" === t.refreshMap))
						I = !1
				} else
					this.vClusterClickToZoomToMBR = !0;
				this.maxClusteringLevel = c && c.maxClusteringLevel ? c.maxClusteringLevel : 100;
				this.clickZoomInLevels = -1;
				c && !1 === c.enableZoomIn ? this.clickZoomInLevels = 0 : c && c.zoomInLevels && (this.clickZoomInLevels = parseInt(c.zoomInLevels));
				this.parentMap && (t = this.parentMap, t.displayed && I && t.refreshMap())
			}
		},
		getFeatureIndex: function (a) {
			var b = this.featureArray.length;
			if (0 === b)
				return -1;
			for (var c = 0; c < b; c++)
				if (this.featureArray[c] ==
					a)
					return c + 1;
			return -1
		},
		bringFeatureForward: function (a) {
			var b = a.parentLayer.parentMap.getMapContext().getGraphics();
			if (a.displayed && a.shape) {
				if (a.shapeGroup && 1 < a.shapeGroup.length)
					for (var c = 0; c < a.shapeGroup.length; c++)
						b.bringForward(a.shapeGroup[c]);
				else
					b.bringForward(a.shape);
				a.labelShape && b.bringForward(a.labelShape)
			}
		},
		sendFeatureBackward: function (a) {
			var b = a.parentLayer.parentMap.getMapContext().getGraphics();
			if (a.displayed && a.shape)
				if (a.labelShape && b.sendBackward(a.labelShape), a.shapeGroup && 1 <
					a.shapeGroup.length)
					for (var c = 0; c < a.shapeGroup.length; c++)
						b.sendBackward(a.shapeGroup[c]);
				else
					b.sendBackward(a.shape)
		},
		bringFeatureToTop: function (a) {
			var b = a.parentLayer.parentMap.getMapContext().getGraphics();
			if (a.displayed && a.shape) {
				if (a.shapeGroup && 1 < a.shapeGroup.length)
					for (var c = 0; c < a.shapeGroup.length; c++)
						b.bringToTop(a.shapeGroup[c]);
				else
					b.bringToTop(a.shape);
				a.labelShape && b.bringToTop(a.labelShape)
			}
		},
		sendFeatureToBottom: function (a) {
			var b = a.parentLayer.parentMap.getMapContext().getGraphics();
			if (a.displayed && a.shape)
				if (a.labelShape && b.sendToBottom(a.labelShape), a.shapeGroup && 1 < a.shapeGroup.length)
					for (var c = 0; c < a.shapeGroup.length; c++)
						b.sendToBottom(a.shapeGroup[c]);
				else
					b.sendToBottom(a.shape)
		},
		getTargetFeature: function (b) {
			if (a.isNull(b))
				return null;
			for (var c = b.feature, t = b; a.isNull(c) && b.parentNode; )
				b = b.parentNode, c = b.feature;
			if (a.isNull(c) && 0 < t.childrenCount)
				for (b = t.firstChild; a.isNull(c) && b; )
					c = b.feature, b = b.nextSibling;
			return c
		},
		getLineGroup: function () {
			if (!this.lineGroup) {
				this.lineGroup =
					[];
				for (var a = this.parentMap.graphics, b = 0; 4 > b; b++)
					this.lineGroup[b] = a.createGroup(), this.realGroup.appendChild(this.lineGroup[b])
			}
			return this.lineGroup
		},
		redraw: function (a) {
			var b = this.parentMap.getMapContext();
			this.orgWidth = b.getDeviceWidth();
			this.orgHeight = b.getDeviceHeight();
			this.setWindow();
			this.clearFeatureShapes();
			this.refreshImpl(null, null, a)
		},
		calculateLayerGradientBound: function () {
			var a = this.parentMap.getMapContext(),
			b = a.getUniverse(),
			c = a.getMapCenter(),
			b = b.getZoomLevels()[a.getZoomLevel()],
			a = (c.getX() - this.minX) / b.resolution,
			c = (c.getY() - this.minY) / b.resolution / b.stretchRatio;
			return {
				x1: a - this.orgWidth / 2,
				y1: c - this.orgHeight / 2,
				x2: a + this.orgWidth / 2,
				y2: c + this.orgHeight / 2,
				useObjectBoundingBox: !1
			}
		},
		clearLayer: function () {
			try {
				this.removeAllFeatures(),
				this.transform = null,
				this.dataLoaded = !1,
				this.bfMbr = this.mbr = this.vCluster = null,
				this.vmf && (this.vmf.destroy(), this.vmf = null),
				this.draggingFeature && (this.parentMap.$oracleMapDiv.off("mousemove", this.draggingFeature), this.parentMap.$oracleMapDiv.off("touchmove",
						this.draggingFeature_touch), a.gv.isWin8Touch && a.Hammer(this.parentMap.$oracleMapDiv[0]).off("drag", this.draggingFeature_win8Touch)),
				this.draggingFeature = null,
				this.endFeatureDragging && (a.$(document).off("mouseup", this.endFeatureDragging), a.$(document).off("mouseout", this.endFeatureDragging), this.parentMap.$oracleMapDiv.off("touchend", this.endFeatureDragging_touch)),
				this.toolTipCustomizer = this.endFeatureDragging = null
			} catch (b) {}
			this.removeGraphics()
		},
		destroy: function q() {
			this.clearLayer();
			q.base.call(this)
		},
		addSecondaryStyle: function (a) {
			this.parentMap && this.isServerSideStyle(a, "secondary") || (this.otherStyles ? this.otherStyles.push(a) : this.otherStyles = [a])
		},
		removeSecondaryStyle: function (a) {
			if (null === this.otherStyles)
				return null;
			for (var b = this.otherStyles.length, c = 0; c < b; c++)
				if (this.otherStyles[c] === a)
					return this.otherStyles.splice(c, 1), a;
			return null
		},
		setVisibleImpl: function () {
			a.isNull(this.parentMap) || (this.heatMap && a.$(this.getHeatmapDivId()).toggle(this.visible), this.getCustomLayerDiv().toggle(this.visible),
				this.group && this.parentMap && this.parentMap.graphics && this.parentMap.graphics.applyStyle(this.group, {
					display: this.visible
				}), this.visible && this.parentMap && this.parentMap.displayed && !this.displayed && (this.type === a.layer.VectorLayer.TYPE_LOCAL || this.dataLoaded || this.initError ? this.displayFeatures() : this.refresh(null, !1)), this.parentMap && this.parentMap.displayed && this.parentMap.refreshVectorLayerLabels())
		},
		clone: function t(b, c, ba) {
			var R = t.base.call(this, b);
			R.getDataRequest = null;
			R.boundingTheme = !1;
			R.sessionId =
				null;
			this.renderingStyle && "HeatMap" == this.renderingStyle.styleType && this.renderingStyle.containerVectorLayer && (R.renderingStyle = this.renderingStyle.clone(), R.renderingStyle.containerVectorLayer = R.renderingStyle.containerVectorLayer.clone("over_" + R.renderingStyle.containerVectorLayer.name, !0, !0), R.heatMap = null);
			if (R.displayed || R.dataLoaded)
				for (R.featureArray = [], b = this.featureArray.length, c = 0; c < b; c++)
					ba = this.featureArray[c].clone(), ba.parentLayer = R, R.featureArray.push(ba);
			else
				c && (R.usedInOverview =
						!0, R.containerLayer = ba, b = a.event, R.copyFeatures = function (a) {
					a = a.target;
					R.featureArray = [];
					for (var b = a.featureArray.length, c = 0; c < b; c++) {
						var t = a.featureArray[c].clone();
						R.featureArray.push(t)
					}
					R.dataLoaded = !0;
					R.containerLayer || R.displayFeatures()
				}, this.on(b.LayerEvent.FEATURES_LOADED, R.copyFeatures));
			R.displayed = !1;
			R.group = null;
			R.realGroup = null;
			R.labelGroup = null;
			R.lineGroup = null;
			R.graphics = null;
			return R
		},
		displayHeatMap: function () {
			this.loaded = !1;
			var b = this.featureArray ? this.featureArray.length : 0,
			c = this.parentMap.getMapContext(),
			aa = c.getUniverse().getSRID(),
			ba = c.getTransform();
			this.yRatio = this.xRatio = 1.2;
			this.setWindow();
			var R = this.orgWidth * this.xRatio,
			qa = this.orgHeight * this.yRatio,
			ua = ba.toScreenPoint(this.dataBufferWindow.x, this.dataBufferWindow.y + this.dataBufferWindow.h);
			this.heatMap || (this.heatMap = this.createVectorLayerHeatMap());
			this.styleAttributes && 0 < this.styleAttributes.length && (this.heatMap.isValued = !0);
			a.style.Style.calculateStyleSize(this.renderingStyle, c);
			this.heatMap.init(R, qa, ua.x, ua.y, this.renderingStyle.spotlightRadius);
			for (var Ca = this, pa = 0, c = function (b) {
				return function () {
					var c = a.util.BaiduUtil.SRID,
					N = function (a) {
						pa--;
						b.srid = aa;
						b.geo = a;
						Ca.addFeatureToHeatMap(b, ua)
					};
					ga.srid === c || aa === c ? ga.transform(aa, N, null, null, {
						map: Ca.parentMap,
						inputIsBD09LonLat: !0
					}) : ga.transform(aa, N)
				}
				()
			}, ba = 0; ba < b; ba++) {
				var R = this.featureArray[ba],
				ga = R.getGeometry();
				if (this.type === a.layer.VectorLayer.TYPE_MAPBOX) {
					if ("POINT" !== this.getFeatureGeometryType())
						continue
				} else if ("Point" != ga.type && "OrientedPoint" != ga.type && "MultiPoint" != ga.type && "OrientedMultiPoint" !=
					ga.type)
					continue;
				aa !== ga.srid ? (pa++, c(R)) : Ca.addFeatureToHeatMap(R, ua)
			}
			var da = function (b, c, N, v, t, da, m, ga, S, I) {
				var w = "heatmap_" + Ca.parentMap.mapInstanceId + "_" + Ca.name,
				pa = a.$("#" + w);
				0 === pa.length ? (pa = a.$("\x3cdiv id\x3d'" + w + "' style\x3d'position:absolute;'\x3e"), Ca.parentMap.$heatMapDiv.append(pa)) : pa.empty();
				pa.css({
					display: "block",
					left: "0px",
					top: "0px",
					width: Ca.orgWidth + "px",
					height: Ca.orgHeight + "px"
				});
				var w = Ca.parentMap.getMapContext(),
				R = w.getUniverse(),
				na = w.getZoomLevel(),
				na = R.getZoomLevels()[na],
				aa = w.getCenterPoint(),
				R = (Ca.dataBufferWindow.x - aa.getX()) / na.resolution + w.getDeviceWidth() / 2,
				w = (aa.getY() - Ca.dataBufferWindow.y - Ca.dataBufferWindow.h) / na.resolution / na.stretchRatio + w.getDeviceHeight() / 2;
				b.style.cssText = "position:absolute;left:" + R + "px;top:" + w + "px;";
				w = b.getContext("2d");
				R = w.globalAlpha;
				w.globalAlpha = Ca.opacity;
				w.clearRect(0, 0, b.width, b.height);
				w.drawImage(c, N, v, t, da, m, ga, S, I);
				pa[0].appendChild(b);
				w.globalAlpha = R;
				Ca.heatmapStore = {
					srcHeatmapCanvas: c,
					dstHeatmapCanvas: b,
					srcx: N,
					srcy: v,
					srcw: t,
					srch: da,
					dstx: m,
					dsty: ga,
					dstw: S,
					dsth: I
				};
				Ca.displayed = !0;
				a.util.Logger.finest("", "OM.VectorLayer.displayHeatMap", "[" + Ca.name + "] display heat map completed");
				Ca.displayEnd()
			},
			v = function () {
				0 !== pa || Ca.heatMap.loadingBoundaray ? setTimeout(v, 100) : Ca.heatMap.drawHeatMap(da)
			};
			v()
		},
		createVectorLayerHeatMap: function () {
			return new a.layer.VectorLayerHeatMap(this.renderingStyle, this)
		},
		addFeatureToHeatMap: function (b) {
			b.parentLayer = this;
			var c = 1,
			c = b.geo;
			if (!a.isNull(c)) {
				var aa = [c];
				"GeometryCollection" === c.type && (aa =
						a.notNull(c.geometries) && 0 < c.geometries.length ? c.geometries : null);
				if (!a.isNull(aa)) {
					var ba = this.parentMap.getMapContext().getTransform(),
					c = a.notNull(this.styleAttributes) && 0 < this.styleAttributes.length ? Number(b.getAttributeValue(this.styleAttributes[0])) : this.renderingStyle.getDataValueFromBinding(b);
					if (isNaN(c) || a.isNull(c))
						c = 1;
					for (var R = this.dataBufferWindow, qa, ua, Ca = this.parentMap.getMapContext().getZoomLevel(), pa = 0; pa < aa.length; pa++) {
						var ga = aa[pa];
						if ("Point" === ga.type || "OrientedPoint" === ga.type) {
							if (qa =
									ga.coordinates[0], ua = ga.coordinates[1], !(qa < R.x || ua < R.y || qa > R.x + R.w || ua > R.y + R.h)) {
								if (b.tiledFeature && (ga = b.zoomLevelsGeomClipArea["zoomlevel_" + Ca][pa], qa < ga.getMinX() || qa > ga.getMaxX() || ua < ga.getMinY() || ua > ga.getMaxY()))
									continue;
								qa = ba.toHeatMapPoint(qa, ua, 0, 0, this.heatMap.scale);
								this.heatMap.addData(qa.x, qa.y, c)
							}
						} else if ("MultiPoint" == ga.type || "OrientedMultiPoint" == ga.type)
							for (var da = ga.coordinates.length, v = 0; v < da; v++)
								if (qa = ga.coordinates[v][0], ua = ga.coordinates[v][1], !(qa < R.x || ua < R.y || qa > R.x + R.w ||
										ua > R.y + R.h)) {
									if (b.tiledFeature) {
										var E = b.zoomLevelsGeomClipArea["zoomlevel_" + Ca][pa];
										if (qa < E.getMinX() || qa > E.getMaxX() || ua < E.getMinY() || ua > E.getMaxY())
											continue
									}
									qa = this.screenTransformObj.toHeatMapPoint(qa, ua, 0, 0, this.heatMap.scale);
									this.heatMap.addData(qa.x, qa.y, c)
								}
					}
				}
			}
		},
		pan: function () {
			if (!a.isNull(this.parentMap) && this.displayed) {
				var b = this.parentMap.getMapContext(),
				c = b.getCenterPoint();
				if (!a.isNull(this.dataBufferWindow)) {
					var aa = this.dataBufferWindow.x + this.dataBufferWindow.w / 2 - c.getX(),
					c = this.dataBufferWindow.y +
						this.dataBufferWindow.h / 2 - c.getY(),
					b = b.getTransform(),
					aa = b.toScreenXLength(aa),
					c = b.toScreenYLength(-c);
					this.heatMap && (b = a.$(this.getHeatmapDivId()), 0 < b.length && b.css({
							left: aa,
							top: c
						}));
					b = this.getCustomLayerDiv();
					0 < b.length && b.css({
						left: aa,
						top: c
					})
				}
			}
		},
		getHoverSelectStyle: function (b, c) {
			if (!a.isNull(b)) {
				if ("Color" !== b.styleType)
					return b;
				var aa = c.getOldStyle(),
				ba = c.geo.type,
				R = {};
				if (a.notNull(aa)) {
					if (aa.resolve) {
						var qa = aa.resolve(c);
						qa && (aa = qa)
					}
					"Marker" !== aa.styleType || "Point" !== ba && "MultiPoint" !== ba && "OrientedPoint" !==
					ba && "OrientedMultiPoint" !== ba ? "Line" !== aa.styleType || "LineString" !== ba && "MultiLineString" !== ba ? "LinearGradient" === aa.styleType || "RadialGradient" === aa.styleType ? (a.$.extend(R, aa, b.origConfig), R.stops1 && (R.stops = R.stops1)) : (a.$.extend(R, aa, b.origConfig), R.bindings = b.bindings) : (ba = {}, a.$.extend(ba, aa, b.origConfig), R = new a.style.Line(ba)) : aa.vectorDef && 0 < aa.vectorDef.length && aa.vectorDef[0].style ? (a.$.extend(!0, R, aa), a.$.extend(R.vectorDef[0].style, b.origConfig), R.bindings = []) : R = b
				} else
					a.$.extend(R, b.origConfig),
					R.bindings = b.bindings;
				return R
			}
		},
		setToolTipCustomizer: function (a) {
			a && "function" === typeof a && (this.toolTipCustomizer = a)
		},
		enableToolTip: function (a) {
			this.showToolTip = a;
			this.displayed && this.redraw()
		},
		enableIndicatorFeatures: function (a, b) {
			if (this.shadow = a)
				this.setLabelsVisible(!0), this.leadLine = b && b.leadLine ? b.leadLine : !1, this.maxIndicators = b && b.maxIndicators ? b.maxIndicators : 8, 0 === b.maxIndicators && (this.maxIndicators = 0), this.shadowLev = {},
			this.shadowLev.min = b && b.enabledZoomLevels && b.enabledZoomLevels.min ?
				b.enabledZoomLevels.min : 0,
			this.shadowLev.max = b && b.enabledZoomLevels && b.enabledZoomLevels.max ? b.enabledZoomLevels.max : 9,
			this.indicatorSize = {},
			this.indicatorSize.w = b && b.indicatorSize && b.indicatorSize.width / 10 ? b.indicatorSize.width / 10 : 4,
			this.indicatorSize.h = b && b.indicatorSize && b.indicatorSize.height / 10 ? b.indicatorSize.height / 10 : 3,
			this.indicatorPos = b && b.position ? b && b.position : 3,
			"object" != typeof this.indicatorPos && (this.shadowAnchor = this.indicatorPos)
		},
		getShadowArea: function () {
			if (this.shadow) {
				this.ghostNum =
					-1;
				var b = this.parentMap.getMapContext(),
				c = b.getUniverse(),
				aa,
				ba;
				if (b.getZoomLevel() <= this.shadowLev.max && b.getZoomLevel() >= this.shadowLev.min) {
					if (1 === this.shadowAnchor || 3 === this.shadowAnchor)
						aa = b.getDeviceWidth() / 2 - 5, ba = b.getDeviceHeight() / 2;
					if (4 === this.shadowAnchor || 6 === this.shadowAnchor)
						aa = b.getDeviceWidth() / 2 - 5, ba = b.getDeviceHeight() / 2 - 10;
					var R = b.getZoomLevel();
					aa *= c.getZoomLevels()[R].resolution;
					ba = ba * c.getZoomLevels()[R].resolution * c.getZoomLevels()[R].stretchRatio;
					this.transformLon = 10 * c.getZoomLevels()[R].resolution;
					this.transformLat = 10 * c.getZoomLevels()[R].resolution * c.getZoomLevels()[R].stretchRatio;
					b = b.getCenterPoint();
					R = Math.round(this.maxIndicators / 2);
					1 === this.shadowAnchor ? this.shadowArea = new a.geometry.Rectangle(b.getX() - aa, b.getY() + ba, b.getX() - aa + this.indicatorSize.w * this.transformLon, b.getY() + ba + this.indicatorSize.h * this.transformLat, c.srid) : 3 === this.shadowAnchor ? this.shadowArea = new a.geometry.Rectangle(b.getX() + aa - this.indicatorSize.w * this.transformLon, b.getY() + ba, b.getX() + aa, b.getY() + ba + this.indicatorSize.h *
							this.transformLat, c.srid) : 4 === this.shadowAnchor ? this.shadowArea = new a.geometry.Rectangle(b.getX() + aa - this.indicatorSize.w * this.transformLon, b.getY() - ba + R * this.indicatorSize.h * this.transformLat + R * this.transformLat, b.getX() + aa, b.getY() - ba + R * this.indicatorSize.h * this.transformLat + R * this.transformLat + this.indicatorSize.h * this.transformLat, c.srid) : 6 === this.shadowAnchor ? this.shadowArea = new a.geometry.Rectangle(b.getX() - aa, b.getY() - ba + R * this.indicatorSize.h * this.transformLat + R * this.transformLat, b.getX() -
							aa + this.indicatorSize.w * this.transformLon, b.getY() - ba + R * this.indicatorSize.h * this.transformLat + R * this.transformLat + this.indicatorSize.h * this.transformLat, c.srid) : this.indicatorPos && this.indicatorPos instanceof a.geometry.Point && (this.shadowArea = new a.geometry.Rectangle(this.indicatorPos.getX(), this.indicatorPos.getY(), this.indicatorPos.getX() + this.indicatorSize.w * this.transformLon, this.indicatorPos.getY() + this.indicatorSize.h * this.transformLat))
				} else
					this.shadowArea = null
			}
		},
		createShadowGeometry: function (b) {
			if (!this.shadowArea)
				return null;
			var c = this.maxIndicators,
			aa = b.getGeometry(),
			ba = aa.getMBR();
			if (aa.getType() === a.GeomTypes.POLYGON || aa.getType() === a.GeomTypes.MULTIPOLYGON || aa.mbr) {
				var R = this.parentMap.getMapContext().getQueryWindow();
				if (!(ba.getMaxX() > R.getMaxX() || ba.getMinX() < R.getMinX() || ba.getMinY() < R.getMinY() || ba.getMaxY() > R.getMaxY())) {
					this.ghostNum++;
					var qa;
					if (0 !== c) {
						if (this.ghostNum < Math.round(c / 2) || this.leadLine && this.ghostNum < c)
							qa = new a.geometry.Rectangle(this.shadowArea.getMinX(), this.shadowArea.getMinY() - (this.indicatorSize.h +
										1) * this.transformLat, this.shadowArea.getMaxX(), this.shadowArea.getMaxY() - (this.indicatorSize.h + 1) * this.transformLat, aa.srid);
						else if (this.ghostNum == Math.round(c / 2) && 1 !== c) {
							if (3 == this.shadowAnchor || 4 == this.shadowAnchor)
								qa = new a.geometry.Rectangle(this.shadowArea.getMinX() - (this.indicatorSize.w + 1) * this.transformLon, this.shadowArea.getMinY(), this.shadowArea.getMaxX() - (this.indicatorSize.w + 1) * this.transformLon, this.shadowArea.getMaxY(), aa.srid);
							1 != this.shadowAnchor && 6 != this.shadowAnchor && this.shadowAnchor ||
							(qa = new a.geometry.Rectangle(this.shadowArea.getMinX() + (this.indicatorSize.w + 1) * this.transformLon, this.shadowArea.getMinY(), this.shadowArea.getMaxX() + (this.indicatorSize.w + 1) * this.transformLon, this.shadowArea.getMaxY(), aa.srid))
						} else
							Math.round(c / 2) < this.ghostNum && this.ghostNum < c && (qa = new a.geometry.Rectangle(this.shadowArea.getMinX(), this.shadowArea.getMinY() + (this.indicatorSize.h + 1) * this.transformLat, this.shadowArea.getMaxX(), this.shadowArea.getMaxY() + (this.indicatorSize.h + 1) * this.transformLat,
										aa.srid));
						this.shadowArea = qa;
						this.addToRtree(b, qa);
						return qa
					}
				}
			}
		},
		refreshShadowGeom: function () {
			if (this.shadow && this.showLabels) {
				var a = this.featureArray,
				b = a.length;
				this.getShadowArea();
				for (var c = 0; c < b; c++) {
					var ba = a[c];
					if (ba.displayed && ba.label && (ba.removeGhostShape(), !ba.labelShape)) {
						var R = this.createShadowGeometry(ba);
						R && (ba.drawGhostGeom(R, [ba.renderingStyle]), ba.drawGhostLabel(R))
					}
				}
			}
		},
		createRtree: function () {
			if (!a.notNull(this.rtree)) {
				console && console.time && "finest" === a.gv.getLogLevel() && a.util.Logger.finest("",
					"OM.VectorLayer.createRtree", console.time("createRtree"));
				this.rtree = new a.RTree(10);
				for (var b = this.featureArray.length, c = 0; c < b; c++)
					this.addToRtree(this.featureArray[c]);
				console && console.timeEnd && "finest" === a.gv.getLogLevel() && a.util.Logger.finest("", "OM.VectorLayer.createRtree", console.timeEnd("createRtree"))
			}
		},
		searchFeatures: function (b) {
			return a.isNull(this.rtree) || a.isNull(b) ? null : this.rtree.search(b)
		},
		setQueryParameters: function () {
			if (!(0 >= arguments.length)) {
				this.queryParameter = {
					paramnum: arguments.length
				};
				for (var b = 0; b < arguments.length; b++)
					if (a.isNull(arguments[b]))
						this.queryParameter["param" + (b + 1)] = null;
					else {
						var c = arguments[b];
						if ("object" !== typeof c)
							this.queryParameter["param" + (b + 1)] = c;
						else if (c instanceof a.geometry.Geometry)
							this.queryParameter["param" + (b + 1)] = c.toString(), this.queryParameter["paramtype" + (b + 1)] = "geometry";
						else {
							if (a.isNull(c.type)) {
								var aa = a.util.ValidationUtil;
								"object" === typeof c.value ? aa.isNumberArray(c.value) ? c.type = "narray" : c.type = "sarray" : aa.isNumber2(c.value) ? c.type = "number" :
									c.type = "string"
							}
							a.isNull(c.sqlType) && ("sarray" === c.type ? c.sqlType = "MV_STRINGLIST" : "narray" === c.type && (c.sqlType = "MV_NUMBERLIST"));
							"sarray" === c.type ? this.queryParameter["param" + (b + 1)] = '"' + c.value.join('","') + '"' : "narray" === c.type && (this.queryParameter["param" + (b + 1)] = c.value.join(","));
							this.queryParameter["sqltype" + (b + 1)] = c.sqlType;
							this.queryParameter["paramtype" + (b + 1)] = c.type
						}
					}
			}
		},
		setMultiFeatureMarker: function (a) {
			this.mfMarker = a
		},
		getFeatureStyles: function (b) {
			var c = null,
			c = b.selected && a.notNull(this.selectionStyle) ?
				this.selectionStyle : this.renderingStyle ? this.renderingStyle : b.styleName ? a.style.StyleStore.getServerSideStyle(this.dataSource, b.styleName) : b.getOldStyle() ? b.getOldStyle() : b.renderingStyle;
			if (this.loadOnDemand)
				for (var aa = this.selectedFeatures.length, ba = 0; ba < aa; ba++)
					this.selectedFeatures[ba].id == b.id && (b.selected = !0, this.selectedFeatures[ba] = b);
			c && c.stylelist && 1 < c.stylelist.length && (b.lineGroup = this.getLineGroup());
			return c
		},
		getDefaultRenderingStyle: function (b) {
			switch (b) {
			case "Point":
			case "MultiPoint":
			case "OrientedPoint":
			case "OrientedMultiPoint":
				return a.style.StyleStore.defaultMarkerStyle;
			case "LineString":
			case "MultiLineString":
				return a.style.StyleStore.defaultLineStyle;
			case "Polygon":
			case "MultiPolygon":
			case "Rectangle":
			case "GeometryCollection":
				return a.style.StyleStore.defaultPolygonStyle
			}
			return null
		},
		setMouseCursorStyle: function (a) {
			this.mouseCursor = "object" === typeof a ? {
				definition: [{
						type: "image",
						src: a.src
					}
				],
				hotspotX: a.hotspotX,
				hotspotY: a.hotspotY
			}
			 : a;
			this.realGroup && this.realGroup.applyStyle({
				cursor: this.mouseCursor
			})
		},
		isServerSideStyle: function (b, c) {
			if (!(b instanceof a.style.Style) &&
				b.dataSource && b.name) {
				var aa = this,
				ba = b.url;
				a.isNull(ba) && (ba = this.type === a.layer.VectorLayer.TYPE_JDBC || this.type === a.layer.VectorLayer.TYPE_PREDEFINED || this.type === a.layer.VectorLayer.TYPE_MAPBOX ? this.serverURL : this.parentMap.mapviewerURL);
				aa.loadingStyle++;
				a.style.StyleStore.getServerSideStyle(b.dataSource, b.name, {
					url: ba,
					callback: function (b) {
						aa.loadingStyle--;
						"rendering" === c ? a.isNull(b) ? aa.renderingStyle = b : aa.setRenderingStyle(b, aa.styleAttributes) : "hover" === c ? aa.setHoverStyle(b) : "select" === c ? aa.setSelectStyle(b) :
							"secondary" === c ? aa.otherStyles.push(b) : "label" === c && aa.setLabelingStyle(b)
					}
				});
				return !0
			}
			return !1
		},
		getAttributeType: function (b) {
			if ("string" !== typeof b)
				return null;
			var c = this.attributeTypes;
			b = b.toUpperCase();
			return c && a.notNull(c[b]) ? c[b] : null
		},
		hasSharedBoundary: function () {
			return this.sharedBoundary
		},
		setSharedBoundary: function (a) {
			this.sharedBoundary = a
		},
		getFeatureAttributesInHTML: function (b) {
			var c = "",
			aa = "";
			if (b.attributes || this.type === a.layer.VectorLayer.TYPE_LOCAL) {
				var ba = 0,
				R,
				qa = null;
				a.notNull(this.customInfoWindowAttributes) &&
				(qa = this.customInfoWindowAttributes.map(function (a) {
						return a.toUpperCase()
					}));
				if (b.InfoHtml)
					aa = b.InfoHtml;
				else if (this.attrNames && 0 < this.attrNames.length)
					for (var ua = this.attrNames.length, Ca = [], pa = 0; pa < ua; pa++) {
						if (R = this.attrNames[pa], !qa || qa.includes(R.toUpperCase())) {
							var ga = R.toUpperCase(),
							c = "\x3ctr bgcolor\x3d'#bbbbbb'\x3e\x3ctd colspan\x3d'2' align\x3d'left'\x3eLAYER NAME: " + this.name + "\x3c/td\x3e\x3c/tr\x3e";
							b.attributes[ga] && -1 === Ca.indexOf(ga) && ((ga = b.attributes[ga]) ? "string" !== typeof ga || a.util.DomUtil.isHtml(ga) ||
								(ga = ga.replace(/\s/g, "\x26nbsp;")) : ga = "", aa += "\x3ctr bgcolor\x3d'#dddddd'\x3e\x3ctd align\x3d'right'\x3e" + R.toUpperCase() + "\x3c/td\x3e\x3ctd align\x3d'left'\x3e" + ga + "\x3c/td\x3e\x3c/tr\x3e", ba += 1)
						}
					}
				else if (this.type === a.layer.VectorLayer.TYPE_DATAPACK || this.type === a.layer.VectorLayer.TYPE_LOCAL) {
					c = "\x3ctr bgcolor\x3d'#bbbbbb'\x3e\x3ctd colspan\x3d'2' align\x3d'left'\x3eLAYER NAME: " + this.name + "\x3c/td\x3e\x3c/tr\x3e";
					for (R in b.attributes)
						if (!qa || qa.includes(R.toUpperCase()))
							if (ga = b.attributes[R])
								"string" ===
								typeof ga && (ga = ga.replace(/\s/g, "\x26nbsp;")), aa += "\x3ctr bgcolor\x3d'#dddddd'\x3e\x3ctd align\x3d'right'\x3e" + R.toUpperCase() + "\x3c/td\x3e\x3ctd align\x3d'left'\x3e" + ga + "\x3c/td\x3e\x3c/tr\x3e", ba += 1;
					if (0 === ba)
						return
				}
				return 0 < aa.trim().length ? c + aa.trim() : null
			}
		},
		isInternalUtilLayer: function () {
			if ("ii_oracle_maps_internal_editing" === this.name || "ii_oracle_maps_internal_others" === this.name)
				return !0
		},
		insertFeatureInfo: function (b) {
			if (!a.isNull(b) && !a.isNull(b.id)) {
				var c = this.parentMap;
				if (!0 === this.getEnableInfoWindow() &&
					!a.isNull(b) && !a.isNull(c) && !a.notNull(c.vctinfoFeatures[b.id])) {
					var aa = this.getFeatureAttributesInHTML(b);
					a.isNull(aa) || 0 >= aa.trim().length || (c.vctinfoHTMLArray.push(aa), c.vctinfoFeatures[b.id] = b.id)
				}
			}
		},
		deselectFeatures: function () {
			var b = this.selectedFeatures ? this.selectedFeatures.length : 0;
			for (1 < b && this.selectedFeatures.reverse(); 0 < b; b--) {
				var c = this.selectedFeatures.pop();
				this.deselectFeature(c);
				c.enableFeatureEditing(!1);
				this.resetFeatureStates(c)
			}
			this.isClusterSelectable() && a.notNull(this.vCluster) &&
			this.vCluster.clearBaseSelArray()
		},
		handleVectorTouchTap: function (b, c, aa) {
			c.selectionEnable && !aa.cluster && c.selectFeature(aa);
			c.featureEditable && (a.event.EventSource.stopEvents[b.type] = !0);
			aa.parentFeature && "OrientedPoint" === aa.parentFeature.getGeometry().type && (b = aa.parentFeature, b.parentLayer.deselectFeature(b))
		},
		handleVectorMouseClick: function (b, c, aa) {
			c.selectionEnable && (aa.cluster ? (a.isNull(c.vClusterClickToZoomToMBR) || !0 !== c.vClusterClickToZoomToMBR) && c.selectFeature(aa) : c.selectFeature(aa));
			c.featureEditable && a.notNull(b) && a.notNull(b.type) && (a.event.EventSource.stopEvents[b.type] = !0);
			aa.parentFeature && "OrientedPoint" === aa.parentFeature.getGeometry().type && (b = aa.parentFeature, b.parentLayer.deselectFeature(b))
		},
		setEditingRightClickVertexHandler: function (b) {
			if (a.isNull(b))
				return a.util.Logger.warning("", "OM.layer.VectorLayer.setEditingRightClickVertexHandler", "No handler provided."), !1;
			this.editingRightClickVertexHandler = b;
			return !0
		},
		getEditingRightClickVertexHandler: function () {
			return this.editingRightClickVertexHandler
		},
		removeEditingRightClickVertexHandler: function () {
			this.editingRightClickVertexHandler = null
		},
		enableEditingContextMenu: function (a) {
			this.editingContextMenuEnabled = a
		},
		isEditingContextMenuEnabled: function () {
			return this.editingContextMenuEnabled
		}
	});
	a.layer.VectorLayer.SINGLE_SELECTION = 0;
	a.layer.VectorLayer.MULTIPLE_SELECTION = 1;
	a.layer.VectorLayer.TYPE_PREDEFINED = 0;
	a.layer.VectorLayer.TYPE_JDBC = 1;
	a.layer.VectorLayer.TYPE_DATAPACK = 2;
	a.layer.VectorLayer.TYPE_LOCAL = 3;
	a.layer.VectorLayer.TYPE_GEORSS = 4;
	a.layer.VectorLayer.TYPE_WFS =
		5;
	a.layer.VectorLayer.TYPE_MAPBOX = 6;
	a.layer.VectorLayer.ERROR_COUNT = 5;
	a.layer.MarkerLayer = a.layer.VectorLayer.extend({
		initialize: function I(b, c) {
			var R = c || {};
			R.def = {
				type: a.layer.VectorLayer.TYPE_LOCAL
			};
			I.base.call(this, b, R);
			this.markerStyle = new a.style.Marker({
				width: 50,
				height: 50,
				src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAG3klEQVRoQ+2XaWwUZRzG37n26LWUAi0toi1IImhiggqioiEhqYkJH5SEIyECMSAYTCiKHAot5xflC2CQ+EFEjgBRULlrLeEoJKACBakNaaDHUloshXZLa3d8nndmyrZAod3tasgOeTvnzjy///P83xkU8ZgsymPCIWIg/zcnY47EHOmhCsSi1UOF7fZtY450u3Q99MOYI/6bzSMVoWWHW2BTtO5P87mKwr1PtxwpqWjcXXOrafSvl81eQphtGhTczZS7vK0prH0Fa1Med86HHn89U63rk+g5MiQjblw4MF0GKa9t/vzQ6bIZeQUivqG00NLcyRIMEqTjRdi3D7XUVYg18yY0jB3+5IYBKa6c7sJ0GaSkMlD88ffXhx4vPNBWZefhJsoO2VKkaartNYXAKArOWdZJyGfTVPHl/PEXhqR7h0UN5PK1pqq pm6rSLp46bD3TSlFbhSWAs++Ix76qqnYIuQNcRM5E5FRFFxneRrFj5RR/Vqqnf1RBpn3rT7tw6pD1TOiSuulCEBC2x9Yxxsp2BiCOA5Zr1oUm1unegNi1fHL0QaZvrkorPglH7D5HXe9xQfaFqt0VDyAnbmh96ZBc4E4GQHbkTYg+CKNFR6RYRsSxoYMDKsUzUkEahX8QLbd0AuJ3ckaDIx5EK/cdgLijGy2nR6QTVl5k88oYaYrMPY9JoXRFJo5rjdw4bzllOWaKAeiR7YvH+TOjDSKjVZR/1wlqoig6IsVqQtGgnk7ogCIEz2nctvuI7xU7XhlxAbF9wZv/Dcj5ol+cXhcaBEoAiKQ4RcU+QUzbAd2Q0FbjwzHu0xruIW7p7gax7ZOx/sx+RvSjdeEkQDiN2pU2IZKRsqJkOaKohnSDYPKY3SPsG4XXYvpV4F66+5bYkjM6+iCM1vmTBTIqrLEJwW1iIUw1AMA+oXgZM+zLbSt6ElZOEtbsxWbfPOdFgOjRdUT2yCl8njAamtvKOsSzoRXdJYXLinNtO8N9XAiD6AbiJd2y3iMZntti08znogtSWhW48v626if+IAgqyxlINVzSAUUHFPJP0TxmCkO6QwdUuBcEKB1QNDiCbzD2FN/uWQmNYsPUQVcH9dUHWtNZ15cuf2uV+gNb1hXenLh1D16IsicIABBUXzM8gHPJZlawVhgxVJ4QcsZizOx+ke8TvlDRN28NaRWzRidvHZyqT+o6gvWLLoNU1jUPr6hpyJ+xrc5XVXoa1adoCDbcEIxtwKgciJyAK4rtitXsgJIuBuWrR8Of3nFCZD+tiKkjvLmpPm1p1ED4IMJU1gTyZ+6s91WW/AZHLPEOhIZ9xkwwaoBT4ZhB4UiUm5Oa/EA2RYpXFa8NNsS7L+i5ZqBxfVpaYnVUQdpgapsAc9tXVXYJIF6hQbjq9iJdcRCPmAFCh3oPetztUoROGGzrIEnG6VcGGWLi8+FDdCtao RWTztTeyZ/9wx2fv7xMaG7kBECMFd1xGbqIhxX8EIlDGxFExydML1w26ilDZGcFVu/e/t3Xc+fOvt6JE+ykVox/7DW37/631P5hl3uk4wMlzI2W/A/2mL5qf4VQ3PFwxit0lyHi3Ypwo6O9hircaCOCJCNxI7J0MVQr2bgqd+HOfft++rsTCHzkiBaMAMYtjNsYTTZQO5iwQSji0tWal+pb4g/N39eadLW2QTridasiAeI9cIQghmoiTooYmamLlBtHdy7/bNHBM2eKbj4AgiIJ0YzRiMHrajEI3WC7E1EQFoJfgolr1m18Y1T25G9WFAQTSmuDMlLxBtzQAaGbom+cKiHiyg/uXbls4ZHic+dY4dDFEUYAB4KiCVGDwfjdsB3h+XZLOI44EAm4Y1+M1PdmzRkxPWd13hdHgt6yOlMkoi84S/VLUMXLgPBc+fngquVLjv1Z3A6CAM5g/jnu2E7U2wDXbAhG7B4IEoUDws8sJF4kY/SzYXpPmjJt2Jwla+etPx70XqkLiv5Jmng1SxMJ5XtDIZzoOI3sNDP7gRAUTAg6QDfqHuSEY0skQJJwsxSM3jZUAmCe+XDp2nlfnTC9w9I10af6wP5Vyz49evH8WcbEqTpFcybimr1AADYyIdjUBOFgvHj+npnKgQjXERaBriBAgvHy2YNgibt+PDzlL++otzPrC/esWLqg4OzZ31lVinaqTnEUTfEOABvbOUYwgnYK4MCE40joPRwgvCEEQZLGjHlz4EeLl4zPW5Sz/8SJY5xtKCpUNAWHgjgOPZLwUDfCdaTjvbjvAHmxTSiu+T50ZiEHxKn2fV9u97vxw45FwpEHARGKUzMXpy/uO+M8TOSjnO8pkEd5dkSviYFEtJwRuFnMkQgUMaK3iDkS0XJG4GaPjSP/Al31T1GL6r+HAAAAAElFTkSuQmCC",
				yOffset: -12,
				xOffset: 2,
				textStyle: {
					fontSize: 15,
					fill: "#ffffff"
				},
				textOffset: {
					x: 0,
					y: -15
				}
			});
			this.labelStyle = new a.style.Text({
				styleName: "defaultMMLabelStyle",
				fill: "#000000",
				fontStyle: a.Text.FONTSTYLE_ITALIC,
				fontSize: 12,
				sticky: !1
			})
		},
		addMapMarker: function (b) {
			a.isNull(b) || (a.isNull(b.renderingStyle) && (b.renderingStyle = this.markerStyle.clone()), a.notNull(b.label) && a.isNull(b.labelStyle) && (b.labelStyle = this.labelStyle), a.notNull(b.markerTextStyle) && (b.renderingStyle.textStyle = b.markerTextStyle), this.addFeature(b))
		},
		removeMapMarker: function (a) {
			this.removeFeature(a)
		},
		addMapMarkers: function (b) {
			if (!a.isNull(b))
				for (var c = 0; c < b.length; c++)
					this.addMapMarker(b[c])
		}
	});
	a.layer.BuiltinExternalTileLayer = a.layer.TileLayer.extend({
		initialize: function aa(b, c, qa) {
			aa.base.call(this, b);
			this.layerType = a.LayerTypes.EXTERNAL;
			b = a.layer.BuiltinExternalTileLayer;
			c && b.tileLayerConfigs && b.tileLayerConfigs[c] && (this.tileLayerConfig = b.tileLayerConfigs[c]);
			qa && (this.customParameters = qa)
		},
		init: function (a) {},
		pan: function (a, b) {},
		setCenterAndZoomlevel: function () {
			var b =
				a.event,
			c = new b.MapEvent(b.LayerEvent.FINISH_LOAD, this);
			c.mapContext = this.parentMap.getMapContext();
			this.fire(b.LayerEvent.FINISH_LOAD, c);
			this.setMapCenterAndZoomlevel()
		},
		setMapCenterAndZoomlevel: function () {},
		setMapType: function (a) {},
		resize: function () {},
		setVisibleImpl: function () {
			if (this.container) {
				var b = a.$(this.container);
				b.css("visibility", this.visible ? "visible" : "hidden");
				b.css("display", this.visible ? "" : "none")
			}
			this.visible && this.parentMap.displayed && this.init(this.container)
		},
		checkVisible: function () {
			if (!this.isVisible())
				return !1;
			if (this.parentMap) {
				var a = this.parentMap.getMapZoomLevel();
				if (a >= this.tileLayerConfig.zoomLevels.length || a < this.minVisibleLevel || a > this.maxVisibleLevel)
					return !1
			}
			return !0
		},
		setContainer: function () {
			var b = a.$("\x3cdiv id \x3d'tilelayer_" + this.name + "'\x3e\x3c/div\x3e");
			b.css({
				position: "absolute",
				left: "0px",
				"z-index": this.getZIndex() - 1,
				top: "0px",
				width: "100%",
				height: "100%",
				overflow: "hidden"
			});
			this.parentMap.$tileLayersDiv.append(b);
			var c = a.$("\x3cdiv id \x3d'transparent_tilelayer_" + this.name + "'\x3e\x3c/div\x3e");
			c.css({
				position: "absolute",
				left: "0px",
				"z-index": this.getZIndex(),
				top: "0px",
				width: "100%",
				height: "100%",
				background: "white",
				opacity: "0",
				overflow: "hidden"
			});
			b.append(c);
			this.container = b[0]
		},
		getLayerConfig: function () {
			var b = new a.event.LayerEvent(a.event.LayerEvent.FINISH_GOT_CONFIG, this);
			b.config = this.getEnabledConfig(this.tileLayerConfig);
			this.parentMap && (b.mapContext = this.parentMap.getMapContext());
			var c = this,
			R = function () {
				c.fire(a.event.LayerEvent.FINISH_GOT_CONFIG, b);
				var R = a.event,
				pa = new R.MapEvent(R.LayerEvent.FINISH_LOAD,
						c);
				pa.mapContext = c.parentMap.getMapContext();
				c.fire(R.LayerEvent.FINISH_LOAD, pa)
			};
			if (a.isNull(c.isBaiduMap) || !1 === c.isBaiduMap)
				R();
			else
				var qa = 1, ua = h.setInterval(function () {
					a.notNull(c.bdutil) ? (a.notNull(c.parentMap) && (c.parentMap.bdutil = c.bdutil), R(), clearInterval(ua), a.util.Logger.finest("waited " + qa + " cycles")) : (a.util.Logger.finest("waiting for baidu to load converter functions."), qa += 1, 60 < qa && (clearInterval(ua), a.util.Logger.warning("", "OM.layer.BuiltinExternalTileLayer.getLayerConfig", "Failed to get Baidu Map transform utilities")))
				},
						1E3)
		},
		destroy: function () {
			this.mapTypeControl && this.mapTypeControl.destroy();
			this.container && a.$(this.container).empty().remove()
		},
		refresh: function ba(b, c) {
			a.isNull(c) && (c = !0);
			ba.base.call(this, b, c);
			this.reloadNumber = Math.round(1E10 * Math.random());
			this.parentMap && this.map && this.setCenterAndZoomlevel();
			if (c) {
				var ua = new a.event.LayerEvent(a.event.LayerEvent.AFTER_REFRESH, this);
				this.parentMap && (ua.mapContext = this.parentMap.getMapContext());
				this.fire(a.event.LayerEvent.AFTER_REFRESH, ua)
			}
		},
		exportToSVG: function (a,
			b, c) {
			var ua = 0,
			Ca = 0;
			this.maxWidth && b > this.maxWidth ? (ua = (b - this.maxWidth) / 2, b = this.maxWidth) : this.minWidth && b < this.minWidth && (ua = (this.minWidth - b) / 2, b = this.minWidth);
			this.maxHeight && c > this.maxHeight ? (Ca = (c - this.maxHeight) / 2, c = this.maxHeight) : this.minHeight && c < this.minHeight && (Ca = (this.minHeight - c) / 2, c = this.minHeight);
			var pa = this;
			pa.loadImg = 0;
			var ga = this.getStaticMapURL(b, c),
			da = this.parentMap.graphics;
			pa.loadImg++;
			da.drawImage({
				x: ua,
				y: Ca
			}, {
				src: ga,
				width: b,
				height: c
			}, {
				group: a
			}).handleEvent = function (a) {
				this.resourceUpdate(a);
				pa.loadImg--
			};
			return a
		},
		drawTilesImages: function (a, b) {
			var c = 0,
			ua = 0;
			this.maxWidth && a > this.maxWidth ? (c = (a - this.maxWidth) / 2, a = this.maxWidth) : this.minWidth && a < this.minWidth && (c = (this.minWidth - a) / 2, a = this.minWidth);
			this.maxHeight && b > this.maxHeight ? (ua = (b - this.maxHeight) / 2, b = this.maxHeight) : this.minHeight && b < this.minHeight && (ua = (this.minHeight - b) / 2, b = this.minHeight);
			var Ca = this;
			Ca.loadImg = 0;
			var pa = this.getStaticMapURL(a, b);
			Ca.loadingImg = !0;
			var ga = new Image;
			ga.onload = function () {
				Ca.loadingImg = !1;
				Ca.canvas.getContext("2d").drawImage(ga,
					c, ua)
			};
			ga.onerror = function () {
				Ca.loadingImg = !1;
				Ca.canvas = null
			};
			ga.src = pa
		},
		clone: function (b) {
			var c = {};
			a.$.extend(c, this);
			c.name = b ? b : c.name + "_clone";
			c.deleteAllListeners();
			c.map = null;
			return c
		}
	});
	a.layer.BuiltinExternalTileLayer.register = function (b, c) {
		var qa = a.layer.BuiltinExternalTileLayer;
		"undefined" === typeof qa.tileLayerConfigs && (qa.tileLayerConfigs = []);
		qa.tileLayerConfigs[b] = c
	};
	a.layer.BingTileLayer = a.layer.BuiltinExternalTileLayer.extend({
		initialize: function R(b, c) {
			R.base.call(this, b);
			this.key = c &&
				c.key ? c.key : "your_bing_api_key";
			this.libURL = null;
			this.over = 2 < arguments.length ? arguments[2] : !1;
			var Ca = a.layer.BingTileLayer;
			this.over || "undefined" === typeof Microsoft || h.OM_finishLoadBingJsV7();
			this.over || Ca.LOADEDJS || Ca.LOADING || (Ca.LOADING = !0, c && c.libURL ? (this.libURL = c.libURL, a.$.getScript(this.libURL + "\x26onscriptload\x3dOM_finishLoadBingJsV7")) : a.$.getScript(a.gv.secureHttp() + "//ecn.dev.virtualearth.net/mapcontrol/mapcontrol.ashx?v\x3d7.0\x26onscriptload\x3dOM_finishLoadBingJsV7"));
			this.mapType =
				c && c.mapType ? c.mapType : Ca.TYPE_ROAD;
			this.mapTypeList = c && c.mapTypeList ? c.mapTypeList : null;
			a.isNull(this.mapTypeList) && (this.mapTypeList = c && c.map_type_values ? c.map_type_values : null);
			this.tileLayerConfig = a.layer.TileLayerConfig.CONFIG_GOOGLE;
			this.mapTypeVisible = c && a.notNull(c.mapTypeVisible) ? c.mapTypeVisible : !0;
			this.maxWidth = 900;
			this.maxHeight = 834;
			this.minHeight = this.minWidth = 80
		},
		init: function () {
			if (this.container) {
				var b = this,
				c,
				ua = function (pa) {
					if (b.parentMap) {
						var ga = b.parentMap.getMapContext(),
						da = function (v) {
							v =
								a.notNull(v) ? new Microsoft.Maps.Location(v.getY(), v.getX()) : new Microsoft.Maps.Location(ga.getCenterPoint().getY(), ga.getCenterPoint().getX());
							b.checkMapType();
							try {
								if (b.map = new Microsoft.Maps.Map(pa, {
										credentials: b.key,
										center: v,
										mapTypeId: a.layer.BingTileLayer.TYPES[b.mapType],
										zoom: b.getRealZoomLevel(ga.getZoomLevel()) + 1,
										animate: !1,
										labelOverlay: Microsoft.Maps.LabelOverlay.hidden,
										showDashboard: !1,
										showCopyright: !1,
										showScalebar: !1,
										disableKeyboardInput: !0
									}), b.mapTypeList && !b.over) {
									var da = [];
									"string" ===
									typeof b.mapTypeList ? da = b.mapTypeList.split(";") : Array.isArray(b.mapTypeList) && (da = b.mapTypeList);
									v = {
										road: null,
										satellite: null,
										mercator: null
									};
									for (var M = 0; M < da.length; M++)
										if ("OM.layer.BingTileLayer.TYPE_ROAD" === da[M] || da[M] === a.layer.BingTileLayer.TYPE_ROAD)
											v.road = a.layer.BingTileLayer.TYPE_ROAD;
										else if ("OM.layer.BingTileLayer.TYPE_AERIAL" === da[M] || da[M] === a.layer.BingTileLayer.TYPE_AERIAL)
											v.satellite = a.layer.BingTileLayer.TYPE_AERIAL;
									var da = null,
									N;
									for (N in v)
										v[N] === b.mapType && (da = N);
									b.mapTypeControl =
										new a.control.MapTypeControl(b.parentMap, b, {
											enableTypes: v,
											type: da
										});
									b.mapTypeControl.infoDecoration && b.mapTypeControl.infoDecoration.setVisible(b.mapTypeVisible)
								}
							} catch (O) {}
							a.notNull(c) && c.update(.85);
							Microsoft.Maps.Events.addHandler(b.map, "viewchangeend", function () {
								var N = a.event,
								v = new N.MapEvent(N.LayerEvent.FINISH_LOAD, b);
								v.mapContext = ga;
								setTimeout(function () {
									null !== c && (c.complete(), c = null)
								}, 1E3);
								b.fire(N.LayerEvent.FINISH_LOAD, v)
							})
						};
						ga.getCenterPoint().transform(8307, function (b) {
							a.notNull(c) &&
							c.update(.5);
							da(b)
						})
					} else
						a.notNull(c) && (c.abort(), c = null)
				},
				Ca = function () {
					!1 === a.gv.progressBarDisabled && a.isNull(c) && (c = b.startNewTask());
					a.layer.BingTileLayer.LOADEDJS ? (a.notNull(c) && c.update(.25), ua(b.container)) : setTimeout(Ca, 500)
				};
				Ca()
			}
		},
		pan: function (a, b, c) {
			if (this.map) {
				var Ca = this.map.getOptions();
				Ca.center = this.map.getCenter();
				Ca.animate = !1;
				Ca.centerOffset = new Microsoft.Maps.Point(a, b);
				this.map.setView(Ca);
				c.callback && c.callback()
			} else
				c.callback && c.callback(!0)
		},
		setCenterAndZoomlevel: function () {
			var b =
				null;
			!1 === a.gv.progressBarDisabled && (b = this.startNewTask());
			if (this.map) {
				var c = this.parentMap.getMapContext(),
				ua = this.getRealZoomLevel(c.getZoomLevel()),
				Ca = this,
				pa = function (c) {
					var da = Ca.map.getOptions();
					da.zoom = ua + 1;
					da.center = new Microsoft.Maps.Location(c.getY(), c.getX());
					Ca.map.setView(da);
					setTimeout(function () {
						a.notNull(b) && (b.complete(), b = null)
					}, 1E3)
				};
				a.notNull(b) && b.update(.25);
				c.getCenterPoint().transform(8307, function (c) {
					a.notNull(b) && b.update(.5);
					pa(c)
				})
			}
		},
		setMapType: function (b) {
			this.mapType =
				b;
			b = null;
			this.map && (this.checkMapType(), b = a.layer.BingTileLayer.TYPES[this.mapType], this.map.setMapType(b), this.cloneLayer && this.cloneLayer.setMapType(this.mapType))
		},
		resize: function () {
			if (this.map) {
				var a = this.parentMap.getMapContext();
				this.map.setOptions({
					height: a.getDeviceWidth(),
					width: a.getDeviceHeight()
				})
			}
		},
		getMapType: function () {
			return this.mapType
		},
		checkMapType: function () {
			a.layer.BingTileLayer.TYPES[this.mapType] || (this.mapType = a.layer.BingTileLayer.TYPE_ROAD)
		},
		getStaticMapURL: function (b, c) {
			var ua =
				"http://dev.virtualearth.net/REST/V1/Imagery/Map/",
			Ca = this.map.getCenter(),
			Ca = Ca.latitude + "," + Ca.longitude,
			pa;
			pa = a.layer.BingTileLayer;
			switch (this.mapType) {
			case pa.TYPE_AERIAL:
				pa = "Aerial";
				break;
			case pa.TYPE_MERCATOR:
				pa = "AerialWithLabels";
				break;
			default:
				pa = "Road"
			}
			var ga = this.map.getZoom();
			return ua = ua + pa + "/" + Ca + "/" + ga + "?" + ("mapSize\x3d" + b + "," + c) + "\x26" + ("key\x3d" + this.key)
		},
		clone: function (b) {
			b || (b = this.name + "_clone");
			return this.cloneLayer = new a.layer.BingTileLayer(b, {
				key: this.key,
				libURL: this.libURL,
				mapType: this.mapType
			}, !0)
		}
	});
	a.layer.BingTileLayer.TYPE_ROAD = "road";
	a.layer.BingTileLayer.TYPE_AERIAL = "aerial";
	a.layer.BingTileLayer.TYPE_AUTO = "auto";
	a.layer.BingTileLayer.TYPE_MERCATOR = "mercator";
	a.layer.BingTileLayer.TYPES = [];
	a.layer.BingTileLayer.LOADEDJS = !1;
	a.layer.BingTileLayer.LOADING = !1;
	h.OM_finishLoadBingJsV7 = h.OM_finishLoadBingJsV7 || function () {
		a.layer.BingTileLayer.LOADEDJS = !0;
		a.layer.BingTileLayer.TYPES[a.layer.BingTileLayer.TYPE_ROAD] = Microsoft.Maps.MapTypeId.road;
		a.layer.BingTileLayer.TYPES[a.layer.BingTileLayer.TYPE_AERIAL] =
			Microsoft.Maps.MapTypeId.aerial;
		a.layer.BingTileLayer.TYPES[a.layer.BingTileLayer.TYPE_AUTO] = Microsoft.Maps.MapTypeId.auto;
		a.layer.BingTileLayer.TYPES[a.layer.BingTileLayer.TYPE_MERCATOR] = Microsoft.Maps.MapTypeId.mercator
	};
	a.layer.ElocationTileLayer = a.layer.TileLayer.extend({
		initialize: function qa(b, c) {
			var pa = {
				WORLD_MAP: "WORLD_MAP",
				BI_WORLD_MAP: "WORlD_MAP_BI_DARK",
				BI_WORLD_MAP_LIGHT: "WORLD_MAP_BI_LIGHT"
			},
			ga = c || {};
			ga.dataSource = "ELOCATION_MERCATOR";
			ga.tileLayerConfig = a.layer.TileLayerConfig.CONFIG_ELOCATION;
			this.basemap = "WORLD_MAP";
			var da = a.gv.secureHttp() + "//elocation.oracle.com/mapviewer/mcserver",
			v = "WORLD_MAP";
			a.isNull(c) ? ga.tileServerURL = da : (a.notNull(c.layerName) ? (v = c.layerName.trim().toUpperCase(), pa[v] || (a.util.Logger.warning("", "ElocationTileLayer.initialize", "Specified layerName [" + c.layerName + "] not supported, default 'WORLD_MAP' is used instead."), v = "WORLD_MAP")) : v = "WORLD_MAP", a.isNull(c.appID) ? ga.tileServerURL = da : (this.appID = c.appID.trim(), ga.tileServerURL = a.gv.secureHttp() + "//elocation.oracle.com/" +
								this.appID + "/mapviewer/mcserver"));
			ga.tileLayer = v;
			this.basemap = pa[v];
			qa.base.call(this, b, ga)
		},
		getStaticMapURL: function (b, c) {
			var Ca;
			Ca = a.isNull(this.appID) ? a.gv.secureHttp() + "//elocation.oracle.com/mapviewer/omserver?" : a.gv.secureHttp() + "//elocation.oracle.com/" + this.appID + "/mapviewer/omserver?";
			var pa = 'width\x3d"' + b + '" height\x3d"' + c + '" antialiase\x3d"false" datasource\x3d"ELOCATION_MERCATOR" basemap\x3d"' + this.basemap + '" format\x3d"PNG_STREAM"\x3e',
			ga = new a.geometry.Point(this.parentMap.getMapWindowBoundingBox().getMinX(),
					this.parentMap.getMapWindowBoundingBox().getMinY(), 3857),
			da = new a.geometry.Point(this.parentMap.getMapWindowBoundingBox().getMaxX(), this.parentMap.getMapWindowBoundingBox().getMaxY(), 3857),
			ga = '\x3cbox srsName\x3d"EPSG:3857"\x3e\x3ccoordinates\x3e' + ga.getX() + "," + ga.getY() + "," + da.getX() + "," + da.getY() + "\x3c/coordinates\x3e\x3c/box\x3e\x3c/map_request\x3e";
			return Ca + 'xml_request\x3d\x3c?xml version\x3d"1.0" standalone\x3d"yes"?\x3e\x3cmap_request ' + pa + ga
		}
	});
	a.layer.HereTileLayer = a.layer.BuiltinExternalTileLayer.extend({
		initialize: function ua(b,
			c) {
			ua.base.call(this, b);
			var ga = a.layer.HereTileLayer;
			this.over = 2 < arguments.length ? arguments[2] : !1;
			c && c.libURL ? (this.libURL = c.libURL, -1 === this.libURL.indexOf("/", this.libURL.length - 1) && (this.libURL += "/")) : this.libURL = a.gv.secureHttp() + "//js.api.here.com/v3/3.0/";
			var da = this;
			this.over || "undefined" !== typeof H || ga.LOADING ? ga.LOADING || (ga.LOADED = !0, a.util.Logger.finest("", "OM.layer.HereTileLayer.initialize", "HERE API already loaded.")) : (a.util.Logger.finest("", "OM.layer.HereTileLayer.initialize", "Loading HERE API ..."),
				a.layer.HereTileLayer.LOADING = !0, a.$.getScript(da.libURL + "mapsjs-core.js", function () {
					a.$.when(a.$.getScript(da.libURL + "mapsjs-service.js"), a.$.getScript(da.libURL + "mapsjs-mapevents.js"), a.$.Deferred(function (b) {
							a.$(b.resolve)
						})).done(function () {
						ga.LOADING = !1;
						ga.LOADED = !0;
						a.util.Logger.finest("", "OM.layer.HereTileLayer.initialize", "HERE API just loaded.")
					})
				}));
			this.appCode = c && c.appCode ? c.appCode : null;
			this.appID = c && c.appID ? c.appID : null;
			!this.appID && c && c.appId && (this.appID = c.appId);
			!this.appID && c && c.appid &&
			(this.appID = c.appid);
			!this.appID && c && c.app_id && (this.appID = c.app_id);
			this.useHTTPS = c && c.useHTTPS ? c.useHTTPS : !1;
			this.useCIT = c && c.useCIT ? c.useCIT : !1;
			a.notNull(c.apikey) && 0 < c.apikey.length && (this.apikey = c.apikey);
			this.mapType = c && c.mapType ? c.mapType : a.layer.HereTileLayer.TYPE_NORMAL_MAP;
			this.mapTypeList = c && c.mapTypeList ? c.mapTypeList : null;
			a.isNull(this.mapTypeList) && (this.mapTypeList = c && c.map_type_values ? c.map_type_values : null);
			this.mapTypeVisible = c && a.notNull(c.mapTypeVisible) ? c.mapTypeVisible : !0;
			this.tileLayerConfig =
				a.layer.TileLayerConfig.CONFIG_GOOGLE;
			this.maxHeight = this.maxWidth = 2048
		},
		init_legacy_3_0: function () {
			var b = null,
			c = this,
			pa = null;
			!1 === a.gv.progressBarDisabled && (pa = this.startNewTask());
			var ga = function () {
				if (c.parentMap) {
					a.notNull(pa) && pa.update(.25);
					var v = c.parentMap.getMapContext(),
					da = v.getCenterPoint(),
					ga = function (N) {
						var O = da.getX(),
						ga = da.getY();
						N && (O = N.getX(), ga = N.getY());
						b = c.getRealZoomLevel(v.getZoomLevel()) + 1;
						c.checkMapType();
						if (!c.map) {
							try {
								c.platform = new H.service.Platform({
									app_id: c.appID,
									app_code: c.appCode,
									useHTTPS: c.useHTTPS,
									useCIT: c.useCIT
								})
							} catch (r) {
								a.util.Logger.warning("MAPVIEWER_9077", "OM.layer.HereTileLayer.showHereMap", r.message);
								return
							}
							a.util.Logger.finest("", "OM.layer.HereTileLayer.showHereMap", "H.service.Platform instance created.");
							try {
								c.mapLayers = c.platform.createDefaultLayers(),
								c.map = new H.Map(c.container, c.mapLayers.normal.map, {
									zoom: b,
									center: {
										lng: O,
										lat: ga
									}
								}),
								c.setBaseLayer(c.map, c.mapLayers, c.mapType)
							} catch (r) {
								a.util.Logger.warning("MAPVIEWER_9078", "OM.layer.HereTileLayer.showHereMap",
									r.message);
								return
							}
							a.util.Logger.finest("", "OM.layer.HereTileLayer.showHereMap", "H.Map instance created.");
							try {
								c.events = new H.mapevents.MapEvents(c.map),
								c.behavior = new H.mapevents.Behavior(c.events)
							} catch (r) {
								a.util.Logger.warning("MAPVIEWER_9079", "OM.layer.HereTileLayer.showHereMap", r.message);
								return
							}
							a.util.Logger.finest("", "OM.layer.HereTileLayer.showHereMap", "H.mapevents.MapEvents and H.mapevents.Behavior instances created.");
							c.parentMap.addListener(a.event.MapEvent.MAP_RESIZED, function () {
								c.map.getViewPort().resize()
							});
							if (c.mapTypeList && !c.over) {
								O = [];
								"string" === typeof c.mapTypeList ? O = c.mapTypeList.split(";") : Array.isArray(c.mapTypeList) && (O = c.mapTypeList);
								N = {
									road: null,
									satellite: null,
									terrain: null
								};
								for (ga = 0; ga < O.length; ga++)
									if ("OM.layer.HereTileLayer.TYPE_NORMAL_MAP" === O[ga] || O[ga] === a.layer.HereTileLayer.TYPE_NORMAL_MAP)
										N.road = "road";
									else if ("OM.layer.HereTileLayer.TYPE_SATELLITE_MAP" === O[ga] || O[ga] === a.layer.HereTileLayer.TYPE_SATELLITE_MAP)
										N.satellite = "satellite";
									else if ("OM.layer.HereTileLayer.TYPE_TERRAIN_MAP" ===
										O[ga] || O[ga] === a.layer.HereTileLayer.TYPE_TERRAIN_MAP)
										N.terrain = "terrain";
								O = null;
								a.layer.HereTileLayer.TYPE_NORMAL_MAP === c.mapType ? O = "road" : a.layer.HereTileLayer.TYPE_SATELLITE_MAP === c.mapType ? O = "satellite" : a.layer.HereTileLayer.TYPE_TERRAIN_MAP === c.mapType && (O = "terrain");
								c.mapTypeControl = new a.control.MapTypeControl(c.parentMap, c, {
									enableTypes: N,
									type: O
								});
								c.mapTypeControl.infoDecoration && c.mapTypeControl.infoDecoration.setVisible(c.mapTypeVisible)
							}
							N = a.event;
							setTimeout(function () {
								a.notNull(pa) && (pa.complete(),
									pa = null)
							}, 1E3);
							O = new N.MapEvent(N.LayerEvent.FINISH_LOAD, c);
							O.mapContext = c.parentMap.getMapContext();
							c.fire(N.LayerEvent.FINISH_LOAD, O)
						}
					};
					da.transform(8307, function (b) {
						a.notNull(pa) && pa.update(.5);
						ga(b)
					})
				} else
					a.util.Logger.finest("", "OM.layer.HereTileLayer.init_Here", "A HereTileLayer instance already created.")
			},
			da = h.setInterval(function () {
				!a.layer.HereTileLayer.LOADING && a.layer.HereTileLayer.LOADED && (ga(), clearInterval(da))
			}, 500)
		},
		init_latest: function () {
			var b = null,
			c = this,
			pa = null;
			!1 === a.gv.progressBarDisabled &&
			(pa = this.startNewTask());
			var ga = function () {
				if (c.parentMap) {
					a.notNull(pa) && pa.update(.25);
					var v = c.parentMap.getMapContext(),
					da = v.getCenterPoint(),
					ga = function (N) {
						var O = da.getX(),
						ga = da.getY();
						N && (O = N.getX(), ga = N.getY());
						b = c.getRealZoomLevel(v.getZoomLevel()) + 1;
						c.checkMapType();
						if (!c.map) {
							try {
								c.platform = new H.service.Platform({
									apikey: c.apikey,
									useHTTPS: c.useHTTPS,
									useCIT: c.useCIT
								})
							} catch (r) {
								a.util.Logger.warning("MAPVIEWER_9077", "OM.layer.HereTileLayer.showHereMap", r.message);
								return
							}
							a.util.Logger.finest("",
								"OM.layer.HereTileLayer.showHereMap", "H.service.Platform instance created.");
							try {
								c.mapLayers = c.platform.createDefaultLayers(),
								c.map = new H.Map(c.container, c.mapLayers.raster.normal.map, {
									zoom: b,
									center: {
										lng: O,
										lat: ga
									}
								}),
								c.setBaseLayer(c.map, c.mapLayers.raster, c.mapType)
							} catch (r) {
								a.util.Logger.warning("MAPVIEWER_9078", "OM.layer.HereTileLayer.showHereMap", r.message);
								return
							}
							a.util.Logger.finest("", "OM.layer.HereTileLayer.showHereMap", "H.Map instance created.");
							try {
								c.events = new H.mapevents.MapEvents(c.map),
								c.behavior = new H.mapevents.Behavior(c.events)
							} catch (r) {
								a.util.Logger.warning("MAPVIEWER_9079", "OM.layer.HereTileLayer.showHereMap", r.message);
								return
							}
							a.util.Logger.finest("", "OM.layer.HereTileLayer.showHereMap", "H.mapevents.MapEvents and H.mapevents.Behavior instances created.");
							c.parentMap.addListener(a.event.MapEvent.MAP_RESIZED, function () {
								c.map.getViewPort().resize()
							});
							if (c.mapTypeList && !c.over) {
								O = [];
								"string" === typeof c.mapTypeList ? O = c.mapTypeList.split(";") : Array.isArray(c.mapTypeList) && (O = c.mapTypeList);
								N = {
									road: null,
									satellite: null,
									terrain: null
								};
								for (ga = 0; ga < O.length; ga++)
									if ("OM.layer.HereTileLayer.TYPE_NORMAL_MAP" === O[ga] || O[ga] === a.layer.HereTileLayer.TYPE_NORMAL_MAP)
										N.road = "road";
									else if ("OM.layer.HereTileLayer.TYPE_SATELLITE_MAP" === O[ga] || O[ga] === a.layer.HereTileLayer.TYPE_SATELLITE_MAP)
										N.satellite = "satellite";
									else if ("OM.layer.HereTileLayer.TYPE_TERRAIN_MAP" === O[ga] || O[ga] === a.layer.HereTileLayer.TYPE_TERRAIN_MAP)
										N.terrain = "terrain";
								O = null;
								a.layer.HereTileLayer.TYPE_NORMAL_MAP === c.mapType ? O = "road" :
									a.layer.HereTileLayer.TYPE_SATELLITE_MAP === c.mapType ? O = "satellite" : a.layer.HereTileLayer.TYPE_TERRAIN_MAP === c.mapType && (O = "terrain");
								c.mapTypeControl = new a.control.MapTypeControl(c.parentMap, c, {
									enableTypes: N,
									type: O
								});
								c.mapTypeControl.infoDecoration && c.mapTypeControl.infoDecoration.setVisible(c.mapTypeVisible)
							}
							N = a.event;
							setTimeout(function () {
								a.notNull(pa) && (pa.complete(), pa = null)
							}, 1E3);
							O = new N.MapEvent(N.LayerEvent.FINISH_LOAD, c);
							O.mapContext = c.parentMap.getMapContext();
							c.fire(N.LayerEvent.FINISH_LOAD,
								O)
						}
					};
					da.transform(8307, function (b) {
						a.notNull(pa) && pa.update(.5);
						ga(b)
					})
				} else
					a.util.Logger.finest("", "OM.layer.HereTileLayer.init_Here", "A HereTileLayer instance already created.")
			},
			da = h.setInterval(function () {
				!a.layer.HereTileLayer.LOADING && a.layer.HereTileLayer.LOADED && (ga(), clearInterval(da))
			}, 500)
		},
		init: function () {
			a.notNull(this.apikey) ? this.init_latest() : this.init_legacy_3_0()
		},
		setCenterAndZoomlevel: function () {
			var b = this.parentMap.getMapContext(),
			c = this.getRealZoomLevel(b.getZoomLevel()),
			pa =
				this,
			ga = null;
			!1 === a.gv.progressBarDisabled && (ga = this.startNewTask(), ga.update(.3));
			var da = function (b) {
				if (pa.map) {
					pa.map.setCenter({
						lng: b.getX(),
						lat: b.getY()
					});
					pa.map.setZoom(c + 1);
					setTimeout(function () {
						a.notNull(ga) && (ga.complete(), ga = null)
					}, 1E3);
					b = a.event;
					var da = new b.MapEvent(b.LayerEvent.FINISH_LOAD, pa);
					da.mapContext = pa.parentMap.getMapContext();
					pa.fire(b.LayerEvent.FINISH_LOAD, da)
				}
			};
			b.getCenterPoint().transform(8307, function (b) {
				a.notNull(ga) && ga.update(.5);
				da(b)
			})
		},
		setMapType: function (b) {
			"road" ===
			b ? b = "NORMAL_MAP" : "satellite" === b ? b = "SATELLITE_MAP" : "terrain" === b && (b = "TERRAIN_MAP");
			this.mapType = b;
			this.map && (this.checkMapType(), a.isNull(this.apikey) ? this.setBaseLayer(this.map, this.mapLayers, this.mapType) : this.setBaseLayer(this.map, this.mapLayers.raster, this.mapType), this.cloneLayer && this.cloneLayer.setMapType(this.mapType))
		},
		getMapType: function () {
			return this.mapType
		},
		checkMapType: function () {
			var b = a.layer.HereTileLayer;
			a.isNull(b.TYPES[this.mapType]) && (this.mapType = b.TYPE_NORMAL_MAP)
		},
		clone: function (b) {
			b ||
			(b = this.name + "_clone");
			return this.cloneLayer = new a.layer.HereTileLayer(b, {
				libURL: this.libURL,
				mapType: this.mapType,
				key: this.appCode,
				appID: this.appID
			}, !0)
		},
		getStaticMapURL: function (b, c) {
			var pa = a.gv.secureHttp() + "//image.maps.api.here.com/mia/1.6/mapview",
			ga = this.map.getCenter(),
			ga = ga.lat + "," + ga.lng,
			da = "\x26t\x3d0",
			v = a.layer.HereTileLayer;
			this.mapType == v.TYPE_TERRAIN_MAP ? da = "\x26t\x3d2" : this.mapType == v.TYPE_SATELLITE_MAP && (da = "\x26t\x3d1");
			v = this.map.getZoom();
			return pa = pa + "?app_id\x3d" + this.appID +
				"\x26app_code\x3d" + this.appCode + "\x26c\x3d" + ga + "\x26z\x3d" + v + da + ("\x26w\x3d" + b + "\x26h\x3d" + c) + "\x26nodot "
		},
		setBaseLayer: function (b, c, pa) {
			a.isNull(b) || a.isNull(c) ? a.util.Logger.warning("MAPVIEWER_9074", "OM.layer.HereTileLayer.setBaseLayer") : (a.isNull(pa) && (pa = "NORMAL_MAP"), "NORMAL_MAP" === pa.toUpperCase() ? b.setBaseLayer(c.normal.map) : "SATELLITE_MAP" === pa.toUpperCase() ? b.setBaseLayer(c.satellite.map) : "TERRAIN_MAP" === pa.toUpperCase() ? b.setBaseLayer(c.terrain.map) : "NORMAL_TRAFFIC" === pa.toUpperCase() ?
				b.setBaseLayer(c.normal.traffic) : "SATELLITE_TRAFFIC" === pa.toUpperCase() ? b.setBaseLayer(c.satellite.traffic) : "TERRAIN_TRAFFIC" === pa.toUpperCase() ? b.setBaseLayer(c.terrain.traffic) : "NORMAL_PANORAMA" === pa.toUpperCase() ? b.setBaseLayer(c.normal.panorama) : "SATELLITE_PANORAMA" === pa.toUpperCase() ? b.setBaseLayer(c.satellite.panorama) : "TERRAIN_PANORAMA" === pa.toUpperCase() ? b.setBaseLayer(c.terrain.panorama) : "NORMAL_TRANSIT" === pa.toUpperCase() ? b.setBaseLayer(c.normal.transit) : "NORMAL_XBASE" === pa.toUpperCase() ?
				b.setBaseLayer(c.normal.xbase) : "SATELLITE_XBASE" === pa.toUpperCase() ? b.setBaseLayer(c.satellite.xbase) : "TERRAIN_XBASE" === pa.toUpperCase() ? b.setBaseLayer(c.terrain.xbase) : "NORMAL_BASE" === pa.toUpperCase() ? b.setBaseLayer(c.normal.base) : "SATELLITE_BASE" === pa.toUpperCase() ? b.setBaseLayer(c.satellite.base) : "TERRAIN_BASE" === pa.toUpperCase() ? b.setBaseLayer(c.terrain.base) : "NORMAL_LABELS" === pa.toUpperCase() ? b.setBaseLayer(c.normal.labels) : "SATELLITE_LABELS" === pa.toUpperCase() ? b.setBaseLayer(c.satellite.labels) :
				"TERRAIN_LABELS" === pa.toUpperCase() ? b.setBaseLayer(c.terrain.labels) : b.setBaseLayer(c.normal.map))
		},
		pan: function (b, c, pa) {
			var ga = this;
			this.parentMap.getMapContext().getCenterPoint().transform(8307, function (b) {
				if (ga.map) {
					ga.map.setCenter({
						lng: b.getX(),
						lat: b.getY()
					});
					b = a.event;
					var c = new b.MapEvent(b.LayerEvent.FINISH_LOAD, ga);
					c.mapContext = ga.parentMap.getMapContext();
					ga.fire(b.LayerEvent.FINISH_LOAD, c);
					pa.callback && pa.callback()
				} else
					pa.callback && pa.callback(!0)
			})
		}
	});
	a.layer.HereTileLayer.TYPE_NORMAL_MAP =
		"NORMAL_MAP";
	a.layer.HereTileLayer.TYPE_SATELLITE_MAP = "SATELLITE_MAP";
	a.layer.HereTileLayer.TYPE_TERRAIN_MAP = "TERRAIN_MAP";
	a.layer.HereTileLayer.TYPE_NORMAL_TRAFFIC = "NORMAL_TRAFFIC";
	a.layer.HereTileLayer.TYPE_SATELLITE_TRAFFIC = "SATELLITE_TRAFFIC";
	a.layer.HereTileLayer.TYPE_TERRAIN_TRAFFIC = "TERRAIN_TRAFFIC";
	a.layer.HereTileLayer.TYPE_NORMAL_PANORAMA = "NORMAL_PANORAMA";
	a.layer.HereTileLayer.TYPE_SATELLITE_PANORAMA = "SATELLITE_PANORAMA";
	a.layer.HereTileLayer.TYPE_TERRAIN_PANORAMA = "TERRAIN_PANORAMA";
	a.layer.HereTileLayer.TYPE_NORMAL_TRANSIT =
		"NORMAL_TRANSIT";
	a.layer.HereTileLayer.TYPE_NORMAL_XBASE = "NORMAL_XBASE";
	a.layer.HereTileLayer.TYPE_SATELLITE_XBASE = "SATELLITE_XBASE";
	a.layer.HereTileLayer.TYPE_TERRAIN_XBASE = "TERRAIN_XBASE";
	a.layer.HereTileLayer.TYPE_NORMAL_BASE = "NORMAL_BASE";
	a.layer.HereTileLayer.TYPE_SATELLITE_BASE = "SATELLITE_BASE";
	a.layer.HereTileLayer.TYPE_TERRAIN_BASE = "TERRAIN_BASE";
	a.layer.HereTileLayer.TYPE_NORMAL_LABELS = "NORMAL_LABELS";
	a.layer.HereTileLayer.TYPE_SATELLITE_LABELS = "SATELLITE_LABELS";
	a.layer.HereTileLayer.TYPE_TERRAIN_LABELS =
		"TERRAIN_LABELS";
	a.layer.HereTileLayer.LOADING = !1;
	a.layer.HereTileLayer.LOADED = !1;
	a.layer.HereTileLayer.TYPES = [];
	a.layer.HereTileLayer.TYPES[a.layer.HereTileLayer.TYPE_NORMAL_MAP] = "NORMAL_MAP";
	a.layer.HereTileLayer.TYPES[a.layer.HereTileLayer.TYPE_TERRAIN_MAP] = "TERRAIN_MAP";
	a.layer.HereTileLayer.TYPES[a.layer.HereTileLayer.TYPE_SATELLITE_MAP] = "SATELLITE_MAP";
	a.layer.HereTileLayer.TYPES[a.layer.HereTileLayer.TYPE_NORMAL_TRAFFIC] = "NORMAL_TRAFFIC";
	a.layer.HereTileLayer.TYPES[a.layer.HereTileLayer.TYPE_TERRAIN_TRAFFIC] =
		"TERRAIN_TRAFFIC";
	a.layer.HereTileLayer.TYPES[a.layer.HereTileLayer.TYPE_SATELLITE_TRAFFIC] = "SATELLITE_TRAFFIC";
	a.layer.HereTileLayer.TYPES[a.layer.HereTileLayer.TYPE_NORMAL_PANORAMA] = "NORMAL_PANORAMA";
	a.layer.HereTileLayer.TYPES[a.layer.HereTileLayer.TYPE_TERRAIN_PANORAMA] = "TERRAIN_PANORAMA";
	a.layer.HereTileLayer.TYPES[a.layer.HereTileLayer.TYPE_SATELLITE_PANORAMA] = "SATELLITE_PANORAMA";
	a.layer.HereTileLayer.TYPES[a.layer.HereTileLayer.TYPE_NORMAL_TRANSIT] = "NORMAL_TRANSIT";
	a.layer.HereTileLayer.TYPES[a.layer.HereTileLayer.TYPE_NORMAL_XBASE] =
		"NORMAL_XBASE";
	a.layer.HereTileLayer.TYPES[a.layer.HereTileLayer.TYPE_TERRAIN_XBASE] = "TERRAIN_XBASE";
	a.layer.HereTileLayer.TYPES[a.layer.HereTileLayer.TYPE_SATELLITE_XBASE] = "SATELLITE_XBASE";
	a.layer.HereTileLayer.TYPES[a.layer.HereTileLayer.TYPE_NORMAL_BASE] = "NORMAL_BASE";
	a.layer.HereTileLayer.TYPES[a.layer.HereTileLayer.TYPE_TERRAIN_BASE] = "TERRAIN_BASE";
	a.layer.HereTileLayer.TYPES[a.layer.HereTileLayer.TYPE_SATELLITE_BASE] = "SATELLITE_BASE";
	a.layer.HereTileLayer.TYPES[a.layer.HereTileLayer.TYPE_NORMAL_LABELS] =
		"NORMAL_LABELS";
	a.layer.HereTileLayer.TYPES[a.layer.HereTileLayer.TYPE_TERRAIN_LABELS] = "TERRAIN_LABELS";
	a.layer.HereTileLayer.TYPES[a.layer.HereTileLayer.TYPE_SATELLITE_LABELS] = "SATELLITE_LABELS";
	a.layer.BaiduTileLayer = a.layer.BuiltinExternalTileLayer.extend({
		initialize: function Ca(b, c) {
			Ca.base.call(this, b);
			this.isBaiduMap = !0;
			var da = a.layer.BaiduTileLayer;
			c && (c.libURL ? (this.libURL = c.libURL, -1 !== this.libURL.indexOf("/", this.libURL.length - 1) && (this.libURL = this.libURL.substring(0, this.libURL.length -
								1))) : this.libURL = a.gv.secureHttp() + "//api.map.baidu.com/api", this.v = c.version || "2.0", a.isNull(c.APIKey) ? (a.util.Logger.warning("", "OM.layer.BaiduTileLayer.initialize", "Application is required for Baidu Application"), this.ak = "Baidu application key is required!") : this.ak = c.APIKey, a.notNull(c.enableBD09Encoding) && !0 === c.enableBD09Encoding ? this.enableBD09Encoding = !0 : this.enableBD09Encoding = !1);
			var v = this;
			da.LOADING ? da.LOADING || (da.LOADED = !0, a.util.Logger.finest("", "OM.layer.BaiduTileLayer.initialize",
					"Baidu API already loaded.")) : (h.setBaiduMapUtil = function () {
				"undefined" !== typeof BMap && (da.LOADING = !1, da.LOADED = !0, a.util.Logger.finest("", "OM.layer.BaiduTileLayer.initialize", "Baidu API just loaded, now setting bdutil."), v.bdutil = {
						ak: v.ak,
						WGS84ToBD09: new BMap.Convertor,
						project: new BMap.MercatorProjection,
						enableBD09Encoding: v.enableBD09Encoding,
						BD09_APIURL: a.gv.secureHttp() + "//api.map.baidu.com/geoconv/v1/"
					})
			}, a.$(document).ready(function () {
					var b = v.libURL + "?v\x3d" + v.v + "\x26ak\x3d" + v.ak + "\x26callback\x3dsetBaiduMapUtil";
					if (a.isNull(h.BMap)) {
						var c = document.createElement("script");
						c.type = "text/javascript";
						c.src = b;
						document.body.appendChild(c)
					} else
						v.bdutil = {
							ak: v.ak,
							WGS84ToBD09: new BMap.Convertor,
							project: new BMap.MercatorProjection,
							enableBD09Encoding: v.enableBD09Encoding,
							BD09_APIURL: a.gv.secureHttp() + "//api.map.baidu.com/geoconv/v1/"
						},
					a.util.Logger.finest("", "OM.layer.BaiduTileLayer.initialize", "Baidu API loaded already, only to set bdutil")
				}));
			this.tileLayerConfig = a.layer.TileLayerConfig.CONFIG_BAIDU;
			this.maxHeight =
				this.maxWidth = 2048
		},
		init: function () {
			var b = null,
			c = null,
			ga = this,
			da = this.container,
			v = null;
			!1 === a.gv.progressBarDisabled && (v = this.startNewTask());
			var E = function () {
				if (ga.parentMap) {
					a.notNull(v) && v.update(.25);
					var N = ga.parentMap.getMapContext(),
					O = N.getCenterPoint(),
					E = function (r) {
						var m = O.getX(),
						D = O.getY();
						r && (m = r.getX(), D = r.getY());
						r = ga.bdutil.project.pointToLngLat(new BMap.Pixel(m, D));
						c = new BMap.Point(r.lng, r.lat);
						b = N.getZoomLevel();
						b = ga.getRealZoomLevel(b);
						b = a.util.BaiduUtil.getValidZoomLevel(b);
						c = new BMap.Point(r.lng,
								r.lat);
						try {
							ga.map = new BMap.Map(da);
							ga.map.centerAndZoom(c, b);
							var E = ga.map.getZoom();
							E !== b && (a.util.Logger.warning("", "OM.layer.BaiduTileLayer.init_Baidu", "Failed to set zoom level to: " + b + ", actual zoom is: " + E), ga.parentMap.setMapZoomLevel(E))
						} catch (y) {
							a.util.Logger.warning("", "OM.layer.BaiduTileLayer.showBaiduMap", y.message);
							return
						}
						a.util.Logger.finest("", "OM.layer.BaiduTileLayer.showBaiduMap");
						ga.map.addEventListener("tilesloaded", function () {
							a.notNull(v) && (v.complete(), v = null);
							var b = a.event,
							c =
								new b.MapEvent(b.LayerEvent.ALL_TILES_LOADED, ga);
							c.mapContext = ga.parentMap.getMapContext();
							ga.fire(b.LayerEvent.ALL_TILES_LOADED, c)
						})
					};
					O.transform(a.util.BaiduUtil.SRID, function (b) {
						a.notNull(v) && v.update(.5);
						E(b)
					}, null, null, {
						map: ga.parentMap
					})
				} else
					a.util.Logger.finest("", "OM.layer.BaiduTileLayer.init_Baidu", "A BaiduTileLayer instance already created.")
			},
			M = h.setInterval(function () {
				!a.layer.BaiduTileLayer.LOADING && a.layer.BaiduTileLayer.LOADED && (E(), clearInterval(M))
			}, 500)
		},
		setCenterAndZoomlevel: function () {
			var b =
				this.parentMap.getMapContext(),
			c = this.getRealZoomLevel(b.getZoomLevel()),
			ga = this,
			da = null;
			!1 === a.gv.progressBarDisabled && (da = this.startNewTask(), da.update(.3));
			b.getCenterPoint().transform(a.util.BaiduUtil.SRID, function (b) {
				a.notNull(da) && da.update(.5);
				ga.map && (b = new BMap.Pixel(b.getX(), b.getY()), b = ga.bdutil.project.pointToLngLat(b), ga.map.setCenter(new BMap.Point(b.lng, b.lat)), ga.map.setZoom(c), b = ga.map.getZoom(), b !== c && (a.util.Logger.warning("", "OM.layer.BaiduTileLayer.init_Baidu", "Failed to set zoom level to: " +
							c + ", actual zoom is: " + b), ga.parentMap.setMapZoomLevel(b)))
			}, null, null, {
				map: this.parentMap
			});
			b = a.event;
			setTimeout(function () {
				a.notNull(da) && (da.complete(), da = null)
			}, 1E3);
			var v = new b.MapEvent(b.LayerEvent.FINISH_LOAD, ga);
			v.mapContext = ga.parentMap.getMapContext();
			ga.fire(b.LayerEvent.FINISH_LOAD, v)
		},
		pan: function (b, c, ga) {
			b = this.parentMap.getMapContext();
			if (a.isNull(this.map))
				ga.callback && ga.callback(!0);
			else {
				var da = this;
				b.getCenterPoint().transform(a.util.BaiduUtil.SRID, function (b) {
					b = new BMap.Pixel(b.getX(),
							b.getY());
					for (b = da.bdutil.project.pointToLngLat(b); -180 > b.lng; )
						b.lng += 360;
					for (; 180 < b.lng; )
						b.lng -= 360;
					da.parentMap.wraparound && a.util.Logger.currentLevel <= a.util.Logger.LEVELS.fine && a.util.Logger.fine("", "BaiduTileLayer.pan", "Baidu tile layer long " + b.lng + "; lat: " + b.lat);
					ga.callback && ga.callback();
					da.map.setCenter(new BMap.Point(b.lng, b.lat))
				})
			}
		}
	});
	a.layer.BaiduTileLayer.LOADING = !1;
	a.layer.BaiduTileLayer.LOADED = !1;
	a.layer.GoogleTileLayer = a.layer.BuiltinExternalTileLayer.extend({
		initialize: function pa(b,
			c) {
			pa.base.call(this, b);
			this.libURL = null;
			this.tileSource = "google";
			var v = a.layer.GoogleTileLayer;
			this.over = 2 < arguments.length ? arguments[2] : !1;
			this.mapTypeList = c && c.mapTypeList ? c.mapTypeList : null;
			a.isNull(this.mapTypeList) && (this.mapTypeList = c && c.map_type_values ? c.map_type_values : null);
			this.mapTypeVisible = c && a.notNull(c.mapTypeVisible) ? c.mapTypeVisible : !0;
			this.mapTypeAnchorPosition = c && a.notNull(c.mapTypeAnchorPosition) ? c.mapTypeAnchorPosition : null;
			this.tilt = c && c.tilt ? c.tilt : 0;
			c && c.key && (this.key = c.key);
			c && c.clientID && (this.clientID = c.clientID);
			var E = "";
			!this.clientID && this.key ? E += "\x26key\x3d" + this.key : this.clientID && (E += "\x26client\x3d" + this.clientID);
			if (!this.over && "undefined" !== typeof google)
				a.finishLoadGoogleV3();
			else if (!this.over && !v.LOADING) {
				if (c && c.libURL) {
					var M = c.libURL;
					0 <= M.indexOf("?") ? "?" === M.slice(-1) ? this.libURL = c.libURL + "callback\x3dOM.finishLoadGoogleV3" + E : this.libURL = c.libURL + "\x26callback\x3dOM.finishLoadGoogleV3" + E : this.libURL = c.libURL + "?callback\x3dOM.finishLoadGoogleV3" + E
				} else
					this.libURL =
						a.gv.secureHttp() + "//maps.google.com/maps/api/js?v\x3d3\x26sensor\x3dfalse\x26callback\x3dOM.finishLoadGoogleV3" + E;
				a.$.getScript(this.libURL);
				v.LOADING = !0
			}
			this.tileLayerConfig = a.layer.TileLayerConfig.CONFIG_GOOGLE;
			this.mapType = c && c.mapType ? c.mapType : a.layer.GoogleTileLayer.TYPE_ROAD;
			this.maxHeight = this.maxWidth = 640
		},
		init: function () {
			var b = null,
			c = null,
			da = this,
			v = a.layer.GoogleTileLayer,
			E = this.container,
			M = function () {
				var N = da.parentMap.getMapContext(),
				y = N.getCenterPoint(),
				r = function (m) {
					var D = y.getX(),
					r = y.getY();
					m && (D = m.getX(), r = m.getY());
					null !== D && null !== r && (b = new google.maps.LatLng(r, D));
					m = N.getZoomLevel();
					null !== m && (c = da.getRealZoomLevel(m) + 1);
					da.checkMapType();
					da.map = new google.maps.Map(E, {
						zoom: c,
						center: b,
						mapTypeId: v.TYPES[da.mapType],
						tilt: da.tilt,
						navigationControl: !1,
						panControl: !1,
						zoomControl: !1,
						mapTypeControl: !1,
						streetViewControl: !1,
						draggable: !1,
						keyboardShortcuts: !1,
						fullscreenControl: !1,
						scrollwheel: !1
					});
					if (da.mapTypeList && !da.over) {
						D = [];
						"string" === typeof da.mapTypeList ? D = da.mapTypeList.split(";") :
							Array.isArray(da.mapTypeList) && (D = da.mapTypeList);
						m = {
							road: null,
							satellite: null,
							shaded: null,
							hybrid: null
						};
						for (r = 0; r < D.length; r++)
							if (D[r] === a.layer.GoogleTileLayer.TYPE_ROAD || "OM.layer.GoogleTileLayer.TYPE_ROAD" === D[r])
								m.road = v.TYPE_ROAD;
							else if (D[r] === a.layer.GoogleTileLayer.TYPE_SATELLITE || "OM.layer.GoogleTileLayer.TYPE_SATELLITE" === D[r])
								m.satellite = v.TYPE_SATELLITE;
							else if (D[r] === a.layer.GoogleTileLayer.TYPE_SHADED || "OM.layer.GoogleTileLayer.TYPE_SHADED" === D[r])
								m.shaded = v.TYPE_SHADED;
							else if (D[r] ===
								a.layer.GoogleTileLayer.TYPE_HYBRID || "OM.layer.GoogleTileLayer.TYPE_HYBRID" === D[r])
								m.hybrid = v.TYPE_HYBRID;
						var D = null,
						U;
						for (U in m)
							if (m[U] === da.mapType) {
								D = U;
								break
							}
						a.isNull(D) && (D = v.TYPE_ROAD);
						da.mapTypeControl = new a.control.MapTypeControl(da.parentMap, da, {
							enableTypes: m,
							type: D
						});
						da.mapTypeControl.infoDecoration && da.mapTypeControl.infoDecoration.setVisible(da.mapTypeVisible);
						!0 === da.mapTypeVisible && da.mapTypeAnchorPosition && da.mapTypeControl.infoDecoration.setAnchorPosition(da.mapTypeAnchorPosition)
					}
					da.map.addListener("tilesloaded",
						function () {
						var b = a.event,
						c = new b.MapEvent(b.LayerEvent.ALL_TILES_LOADED, da);
						c.mapContext = N;
						da.fire(b.LayerEvent.ALL_TILES_LOADED, c)
					})
				};
				y.transform(8307, function (a) {
					r(a)
				})
			},
			N = h.setInterval(function () {
				!v.LOADING && a.layer.GoogleTileLayer.LOADED && (clearInterval(N), M())
			}, 500)
		},
		setCenterAndZoomlevel: function () {
			if (this.parentMap && this.map) {
				var b = null;
				!1 === a.gv.progressBarDisabled && (b = this.startNewTask());
				var c = this.parentMap.getMapContext(),
				da = this.getRealZoomLevel(c.getZoomLevel()),
				v = this,
				E = function (c) {
					v.map.setOptions({
						zoom: da +
						1,
						center: new google.maps.LatLng(c.getY(), c.getX())
					});
					c = new a.event.MapEvent(a.event.LayerEvent.FINISH_LOAD, v);
					c.mapContext = v.parentMap.getMapContext();
					setTimeout(function () {
						a.notNull(b) && (b.complete(), b = null)
					}, 1E3);
					v.fire(a.event.LayerEvent.FINISH_LOAD, c)
				};
				c.getCenterPoint().transform(8307, function (c) {
					a.notNull(b) && b.update(.5);
					E(c)
				})
			}
		},
		setMapType: function (b) {
			this.mapType = b;
			this.map && (this.checkMapType(), this.map.setMapTypeId(a.layer.GoogleTileLayer.TYPES[this.mapType]), this.cloneLayer && this.cloneLayer.setMapType(this.mapType),
				this.parentMap.setMapZoomLevel(this.map.getZoom() - 1))
		},
		resize: function () {
			this.map && google.maps.event.trigger(this.map, "resize")
		},
		getMapType: function () {
			return this.mapType
		},
		checkMapType: function () {
			var b = a.layer.GoogleTileLayer;
			b.TYPES[this.mapType] || (this.mapType = b.TYPE_ROAD)
		},
		pan: function (a, b, c) {
			if (this.map) {
				var v = this.map;
				this.parentMap.getMapCenter().transform(8307, function (a) {
					v.panTo(new google.maps.LatLng(a.getY(), a.getX()))
				});
				c.callback && c.callback()
			} else
				c.callback && c.callback(!0)
		},
		clone: function (b) {
			b ||
			(b = this.name + "_clone");
			return this.cloneLayer = new a.layer.GoogleTileLayer(b, {
				libURL: this.libURL,
				mapType: this.mapType
			}, !0)
		},
		getStaticMapURL: function (b, c) {
			var da = "https://maps.googleapis.com/maps/api/staticmap?",
			v = this.map.getCenter(),
			v = "center\x3d" + v.lat() + "," + v.lng(),
			E = "zoom\x3d" + this.map.getZoom(),
			M = "size\x3d" + b + "x" + c,
			N;
			switch (this.mapType) {
			case a.layer.GoogleTileLayer.TYPE_SATELLITE:
				N = "satellite";
				break;
			case a.layer.GoogleTileLayer.TYPE_HYBRID:
				N = "hybrid";
				break;
			case a.layer.GoogleTileLayer.TYPE_SHADED:
				N =
					"terrain";
				break;
			default:
				N = "roadmap"
			}
			N = "maptype\x3d" + N;
			var O = "";
			if (a.isNull(this.clientID) && this.key)
				O = "\x26key\x3d" + this.key;
			else if (this.clientID) {
				var O = "\x26client\x3d" + this.clientID,
				y = a.util.MiscUtil.signURL(this.key, "/maps/api/staticmap?" + v + "\x26" + E + "\x26" + M + "\x26" + N + "\x26sensor\x3dfalse" + O);
				a.notNull(y) && (O = O + "\x26signature\x3d" + y)
			}
			return da + v + "\x26" + E + "\x26" + M + "\x26" + N + "\x26sensor\x3dfalse" + O
		}
	});
	a.finishLoadGoogleV3 = a.finishLoadGoogleV3 || function () {
		var b = a.layer.GoogleTileLayer;
		a.layer.GoogleTileLayer.LOADED =
			!0;
		a.layer.GoogleTileLayer.LOADING = !1;
		null === b.TYPES && (b.TYPES = [], b.TYPES[b.TYPE_ROAD] = google.maps.MapTypeId.ROADMAP, b.TYPES[b.TYPE_SATELLITE] = google.maps.MapTypeId.SATELLITE, b.TYPES[b.TYPE_HYBRID] = google.maps.MapTypeId.HYBRID, b.TYPES[b.TYPE_SHADED] = google.maps.MapTypeId.TERRAIN)
	};
	a.layer.GoogleTileLayer.TYPE_ROAD = "road";
	a.layer.GoogleTileLayer.TYPE_SATELLITE = "satellite";
	a.layer.GoogleTileLayer.TYPE_HYBRID = "hybrid";
	a.layer.GoogleTileLayer.TYPE_SHADED = "shaded";
	a.layer.GoogleTileLayer.LOADING = !1;
	a.layer.GoogleTileLayer.LOADED =
		!1;
	a.layer.GoogleTileLayer.TYPES = null;
	a.layer.Cluster = a.Class.extend({
		initialize: function (a, b, c, v) {
			this.clusterX = a;
			this.clusterY = b;
			this.numberOfPoints = 1;
			this.featureArray = [c];
			this.updateFlag = !0;
			this.mbr = null;
			this.vectorClusterLayer = v
		},
		addFeature: function (a, b, c) {
			this.clusterX = (this.clusterX * this.numberOfPoints + a) / (this.numberOfPoints + 1);
			this.clusterY = (this.clusterY * this.numberOfPoints + b) / (this.numberOfPoints + 1);
			this.numberOfPoints++;
			this.featureArray.push(c);
			this.updateFlag = !0;
			this.mbr = null
		},
		addCluster: function (a) {
			this.clusterX =
				(this.clusterX * this.numberOfPoints + a.clusterX * a.numberOfPoints) / (this.numberOfPoints + a.numberOfPoints);
			this.clusterY = (this.clusterY * this.numberOfPoints + a.clusterY * a.numberOfPoints) / (this.numberOfPoints + a.numberOfPoints);
			this.numberOfPoints += a.numberOfPoints;
			this.featureArray = this.featureArray.concat(a.featureArray)
		},
		getMBR: function () {
			if (a.notNull(this.mbr))
				return this.mbr;
			for (var b, c, da = Number.MAX_VALUE, v = -Number.MAX_VALUE, E = Number.MAX_VALUE, M = -Number.MAX_VALUE, N = this.featureArray.length, O = 0; O < N; O++)
				b =
					this.featureArray[O].getGeometry().getMBR(), a.isNull(c) && (c = b.getSRID()), b.getMinX() < da && (da = b.getMinX()), b.getMaxX() > v && (v = b.getMaxX()), b.getMinY() < E && (E = b.getMinY()), b.getMaxY() > M && (M = b.getMaxY());
			return this.mbr = b = new a.geometry.Rectangle(da, E, v, M, c)
		},
		getMBP: function () {
			var a = null,
			b = null,
			c = [];
			this.iterateCoordinates(function (v) {
				c.push(v);
				if (null === a || v.x < a.x)
					a = v;
				if (null === b || v.x > b.x)
					b = v
			});
			return [].concat(this.buildConvexHull([a, b], c), this.buildConvexHull([b, a], c))
		},
		getDistant: function (a, b) {
			return (b[0].y -
				b[1].y) * (a.x - b[0].x) + (b[1].x - b[0].x) * (a.y - b[0].y)
		},
		findMostDistantPointFromBaseLine: function (a, b) {
			for (var c = 0, v = null, E = [], M = b.length - 1; 0 <= M; M--) {
				var N = b[M],
				O = this.getDistant(N, a);
				0 < O && (E.push(N), O > c && (c = O, v = N))
			}
			return {
				maxPoint: v,
				newPoints: E
			}
		},
		buildConvexHull: function (a, b) {
			var c = [],
			v = this.findMostDistantPointFromBaseLine(a, b);
			return v.maxPoint ? (c = c.concat(this.buildConvexHull([a[0], v.maxPoint], v.newPoints)), c = c.concat(this.buildConvexHull([v.maxPoint, a[1]], v.newPoints))) : [a[0]]
		},
		iterateCoordinates: function (a) {
			for (var b =
					this.featureArray.length, c = 0; c < b; c++) {
				var v = this.featureArray[c].getGeometry(),
				E = v.coordinates;
				"Polygon" === v.type && (E = E[0]);
				for (var v = v.dim, M = 0; M < E.length; M += v)
					a({
						x: E[M],
						y: E[M + 1]
					})
			}
		},
		removeFeature: function (a, b, c) {
			for (var v = 0; v < this.featureArray.length; v++)
				if (this.featureArray[v] == c)
					return 1 < this.numberOfPoints && (this.clusterX = (this.clusterX * this.numberOfPoints - a) / (this.numberOfPoints - 1), this.clusterY = (this.clusterY * this.numberOfPoints - b) / (this.numberOfPoints - 1)), this.numberOfPoints--, this.featureArray.splice(v,
						1), this.updateFlag = !0;
			return !1
		},
		getVectorLayer: function () {
			if (this.vectorClusterLayer && this.vectorClusterLayer.vectorLayer)
				return this.vectorClusterLayer.vectorLayer;
			a.util.Logger.warning("", "OM.layer.Cluster", "no vector layer was found for this cluster.");
			return null
		},
		createClusterFeature: function (b, c, da) {
			c = new a.geometry.Point(this.clusterX, this.clusterY, c);
			this.clusterFeatureId = b;
			b = new a.Feature(b, c, {
				renderingStyle: da
			});
			b.cluster = this;
			b.parentLayer = this.getVectorLayer();
			da = function (a) {
				var b = a.target;
				a = b.parentLayer;
				var c = a.parentMap,
				b = b.cluster.getMBR();
				-1 === a.clickZoomInLevels ? c.zoomToExtent(b) : 0 < a.clickZoomInLevels && c.setMapCenterAndZoomLevel(b.getCenter(), c.getMapZoomLevel() + a.clickZoomInLevels);
				setTimeout(function () {
					c.graphics && c.graphics.clearToolTips()
				}, 100)
			};
			c = this.getVectorLayer();
			a.notNull(c) && c.vClusterClickToZoomToMBR && b.addListener(a.event.MouseEvent.MOUSE_CLICK, da);
			this.updateFlag = !1;
			return b
		}
	});
	a.layer.VectorLayerCluster = a.Class.extend({
		initialize: function (b, c) {
			this.vectorLayer =
				b;
			this.threshold = c && c.threshold ? c.threshold : 30;
			this.clusterStyle = c && c.clusterStyle ? c.clusterStyle : null;
			this.clusterSelectStyle = a.notNull(c.clusterSelectStyle) ? c.clusterSelectStyle : null;
			this.clusterHoverStyle = a.notNull(c.clusterHoverStyle) ? c.clusterHoverStyle : null;
			this.minPointCount = c && c.minPointCount ? c.minPointCount : 2;
			this.showDefaultTooltip = !0;
			c && a.notNull(c.showDefaultTooltip) && (this.showDefaultTooltip = c.showDefaultTooltip)
		},
		initClusterSelection: function () {
			this.selectedBaseFeatures = null;
			this.vectorLayer.origSelectionMode =
				this.vectorLayer.selectionMode
		},
		getBaseSelArray: function () {
			return this.selectedBaseFeatures
		},
		setBaseSelArray: function (a) {
			this.selectedBaseFeatures = a
		},
		updateBaseSelArray: function (a) {
			var b = this.vectorLayer;
			a.isCluster() || (0 <= this.getIndexInBaseSelArray(a) ? (b.deselectFeature(a), this.removeFromBaseSelArray(a)) : (b.selectedFeatures.push(a), this.addToBaseSelArray(a)), this.selectActiveSelection())
		},
		hasBeenSelected: function (b) {
			for (var c = this.getBaseSelArray(), da = a.notNull(c) ? c.length : 0, v = 0; v < da; v += 1)
				if (b.id ===
					c[v].id)
					return !0;
			return !1
		},
		getAllSelectedFeatures: function () {
			for (var a = {}, b = this.vectorLayer.getAllFeatures(), c = 0; c < b.length; c += 1) {
				var v = b[c];
				v.inCluster && v.clusterId && v.clusterFeature ? this.hasBeenSelected(v) && (a[v.clusterId] = {
						f: v.clusterFeature,
						c: !0
					}) : this.hasBeenSelected(v) && (a[v.id] = {
						f: v,
						c: !1
					})
			}
			return a
		},
		selectActiveSelection: function () {
			var b = this.vectorLayer,
			c,
			da = this.getAllSelectedFeatures();
			try {
				b.clearSelectedFeatures();
				b.origSelectionMode = b.selectionMode;
				b.enableFeatureSelection(!0, a.layer.VectorLayer.MULTIPLE_SELECTION);
				for (var v in da)
					da.hasOwnProperty(v) && (c = da[v].f, b.selectFeature(c, {
							origin: "selectActiveSelection"
						}))
			} finally {
				b.enableFeatureSelection(!0, b.origSelectionMode)
			}
		},
		getIndexInBaseSelArray: function (a) {
			for (var b = this.selectedBaseFeatures || [], c = b.length, v = 0; v < c; v += 1)
				if (a === b[v])
					return v;
			return -1
		},
		addToBaseSelArray: function (b, c) {
			if (!c || !c.origin || "selectActiveSelection" !== c.origin) {
				if (b.isCluster()) {
					for (var da = b.getClusteredFeatures(), v = 0; v < da.length; v += 1)
						this.addToBaseSelArray(da[v]);
					return !0
				}
				if (0 > this.getIndexInBaseSelArray(b))
					return this.selectedBaseFeatures =
						this.selectedBaseFeatures || [], this.selectedBaseFeatures.push(b), !0;
				a.util.Logger.finest("", "OM.VectorLayerCluster.addToBaseSelArray", "Feature already added in the selectedBaseFeatures");
				return !1
			}
		},
		removeFromBaseSelArray: function (b, c) {
			if (!c || !c.origin || "selectActiveSelection" !== c.origin) {
				if (b.isCluster()) {
					for (var da = b.getClusteredFeatures(), v = 0; v < da.length; v += 1)
						this.removeFromBaseSelArray(da[v]);
					return !0
				}
				da = this.getIndexInBaseSelArray(b);
				if (0 <= da)
					return this.selectedBaseFeatures.splice(da, 1), !0;
				a.util.Logger.finest("",
					"OM.VectorLayerCluster.removeFromBaseSelArray", "Feature not found in the selectedBaseFeatures");
				return !1
			}
		},
		isPartialSelection: function (b) {
			if (a.isNull(this.getBaseSelArray()) || 0 === this.getBaseSelArray().length)
				return !1;
			b = b.getClusteredFeatures();
			for (var c = a.notNull(b) ? b.length : 0, da = 0, v = 0, E = 0; E < c; E += 1)
				if (this.hasBeenSelected(b[E]) ? da += 1 : v += 1, 0 < da && 0 < v)
					return !0;
			return 0 === da || da === c ? !1 : !0
		},
		clearBaseSelArray: function () {
			this.selectedBaseFeatures = null
		},
		initCluster: function (a, b) {
			this.gridSizeInX = this.threshold *
				a;
			this.gridSizeInY = this.threshold * b;
			this.clusters = {};
			var c = this.vectorLayer.parentMap.getMapContext().getUniverse().getMapBounds(),
			v = this.vectorLayer.visibleBound;
			this.minX = v ? Math.max(v.getMinX(), c.getMinX()) : c.getMinX();
			this.maxX = v ? Math.min(v.getMaxX(), c.getMaxX()) : c.getMaxX();
			this.minY = v ? Math.max(v.getMinY(), c.getMinY()) : c.getMinY();
			this.maxY = v ? Math.min(v.getMaxY(), c.getMaxY()) : c.getMaxY();
			this.numInX = Math.ceil((this.maxX - this.minX) / this.gridSizeInX);
			this.numInY = Math.ceil((this.maxY - this.minY) /
					this.gridSizeInY);
			this.clusterFeatureArray = [];
			this.initialized = !0
		},
		addFeatureToCluster: function (b) {
			var c = b.getGeometry().getMBR(),
			da = (c.getMinX() + c.getMaxX()) / 2,
			c = (c.getMinY() + c.getMaxY()) / 2,
			v = Math.floor((da - this.minX) / this.gridSizeInX),
			E = Math.floor((c - this.minY) / this.gridSizeInY);
			this.clusters[v] || (this.clusters[v] = {});
			this.clusters[v][E] ? this.clusters[v][E].addFeature(da, c, b) : this.clusters[v][E] = new a.layer.Cluster(da, c, b, this);
			return {
				x: v,
				y: E
			}
		},
		removeClustersFromSelectedFeatures: function () {
			for (var b =
					this.vectorLayer.selectedFeatures, c = b.length - 1; 0 <= c; ) {
				var da = b[c];
				a.notNull(da) && a.notNull(da.cluster) && 0 <= da.id.indexOf("-CL") && b.splice(c, 1);
				--c
			}
		},
		displayAsCluster: function (b) {
			a.util.Logger.finest(null, "VectorLayerCluster", "[" + this.vectorLayer.name + "] displayAsCluster called.");
			var c = this.vectorLayer.parentMap.getMapContext(),
			da = c.getUniverse(),
			v = c.getZoomLevel();
			if (!(this.vectorLayer.maxClusteringLevel < v)) {
				this.initialized || (v = da.getZoomLevels()[v], this.initCluster(v.resolution, v.resolution * v.stretchRatio));
				1 < c.getWholeMapNum() && (c = da.getMapBounds(), b = {
						x: c.getMinX(),
						y: c.getMinY(),
						w: c.getWidth(),
						h: c.getHeight()
					});
				this.startX = Math.floor((b.x - this.minX) / this.gridSizeInX);
				this.endX = Math.ceil((b.x + b.w - this.minX) / this.gridSizeInX);
				this.startY = Math.floor((b.y - this.minY) / this.gridSizeInY);
				this.endY = Math.ceil((b.y + b.h - this.minY) / this.gridSizeInY);
				var v = (c = this.vectorLayer.featureArray) ? c.length : 0,
				E = da.getSRID(),
				M = this,
				N = 0;
				this.totolPointNumber = 0;
				for (var da = function (a) {
					return function () {
						a.getGeometry().transform(E,
							function (b) {
							a.srid = E;
							a.geo = b;
							M.addFeatureToCluster(a);
							N--
						})
					}
					()
				}, O = 0; O < v; O++) {
					var y = c[O];
					y.inCluster = !1;
					"Point" !== y.geo.type && "Polygon" !== y.geo.type || y.displayed || (this.totolPointNumber++, y.geo.srid !== E ? (N++, da(y)) : this.addFeatureToCluster(y))
				}
				var r = function () {
					if (0 === N) {
						for (var a = M.mergeAllClusters(b); a; )
							a = M.mergeAllClusters(b);
						M.showAllClusters()
					} else
						h.setTimeout(r, 100)
				};
				r()
			}
		},
		showAllClusters: function () {
			for (var b = this.vectorLayer.parentMap.getMapContext().getUniverse().getSRID(), c = this.startX; c <
				this.endX; c++)
				for (var da = this.startY; da < this.endY; da++)
					if (a.notNull(this.clusters[c]) && a.notNull(this.clusters[c][da]) && this.clusters[c][da].numberOfPoints >= this.minPointCount) {
						var v = "-CL" + c + "-" + da,
						E = this.getClusterFeatureById(v);
						E ? this.updateMarkerText(E) : (E = this.clusters[c][da].createClusterFeature(v, b, this.clusterStyle), this.displayClusterFeature(E))
					}
		},
		displayClusterFeature: function (b) {
			this.clusterFeatureArray.push(b);
			b.group = this.vectorLayer.realGroup;
			b.screenTransformObj = this.vectorLayer.parentMap.getMapContext().getTransform();
			b.graphics = this.vectorLayer.parentMap.graphics;
			b.parentLayer || (b.parentLayer = this.vectorLayer);
			b.markerText = b.cluster.numberOfPoints;
			var c = b.renderingStyle;
			c instanceof a.style.BucketStyle && (c.generateBuckets([this.minPointCount, this.totolPointNumber], "_NUMBERINCLUSTER", !0), c = c.getRealStyle(b.cluster.numberOfPoints), b.renderingStyle = c);
			a.isNull(c) ? c = b.renderingStyle : b.renderingStyle = c;
			b.displayFeature([c]);
			b.shape && this.showDefaultTooltip && b.shape.applyStyle({
				tooltip: b.cluster.numberOfPoints + ""
			});
			for (var c = b.cluster.featureArray.length, da = 0; da < c; da++) {
				var v = b.cluster.featureArray[da];
				v.displayed = !0;
				v.inCluster = !0;
				v.clusterId = b.id;
				v.clusterFeature = b
			}
		},
		mergeAllClusters: function () {
			for (var b = !1, c = this.startX; c < this.endX; c++)
				for (var da = this.startY; da < this.endY; da++)
					if (a.notNull(this.clusters[c]) && a.notNull(this.clusters[c][da])) {
						var v = this.mergeCluster(c, da);
						a.notNull(v) && (b = !0)
					}
			return b
		},
		mergeCluster: function (b, c) {
			var da = this.gridSizeInX * this.gridSizeInY,
			v = da,
			E = da,
			M = da,
			N = da,
			O = da,
			y = da,
			r = da,
			m = da;
			b + 1 < this.numInX && a.notNull(this.clusters[b + 1]) && a.notNull(this.clusters[b + 1][c]) && (v = this.getSquareDistance(this.clusters[b][c], this.clusters[b + 1][c]));
			c + 1 < this.numInY && a.notNull(this.clusters[b][c + 1]) && (E = this.getSquareDistance(this.clusters[b][c], this.clusters[b][c + 1]));
			0 <= b - 1 && a.notNull(this.clusters[b - 1]) && a.notNull(this.clusters[b - 1][c]) && (M = this.getSquareDistance(this.clusters[b][c], this.clusters[b - 1][c]));
			0 <= c - 1 && a.notNull(this.clusters[b][c - 1]) && (N = this.getSquareDistance(this.clusters[b][c],
						this.clusters[b][c - 1]));
			b + 1 < this.numInX && c + 1 < this.numInY && a.notNull(this.clusters[b + 1]) && a.notNull(this.clusters[b + 1][c + 1]) && (O = this.getSquareDistance(this.clusters[b][c], this.clusters[b + 1][c + 1]));
			0 <= b - 1 && c + 1 < this.numInY && a.notNull(this.clusters[b - 1]) && a.notNull(this.clusters[b - 1][c + 1]) && (y = this.getSquareDistance(this.clusters[b][c], this.clusters[b - 1][c + 1]));
			b + 1 < this.numInX && 0 <= c - 1 && a.notNull(this.clusters[b + 1]) && a.notNull(this.clusters[b + 1][c - 1]) && (r = this.getSquareDistance(this.clusters[b][c], this.clusters[b +
							1][c - 1]));
			0 <= b - 1 && 0 <= c - 1 && a.notNull(this.clusters[b - 1]) && a.notNull(this.clusters[b - 1][c - 1]) && (m = this.getSquareDistance(this.clusters[b][c], this.clusters[b - 1][c - 1]));
			m = Math.min(v, Math.min(E, Math.min(M, Math.min(N, Math.min(O, Math.min(y, Math.min(r, m)))))));
			if (m < da) {
				if (v === m)
					return this.mergeHorizontal(b, c, 1), {
						directionX: 1,
						directionY: 0
					};
				if (E === m)
					return this.mergeVertical(b, c, 1), {
						directionX: 0,
						directionY: 1
					};
				if (M === m)
					return this.mergeHorizontal(b, c, -1), {
						directionX: -1,
						directionY: 0
					};
				if (N === m)
					return this.mergeVertical(b,
						c, -1), {
						directionX: 0,
						directionY: -1
					};
				if (O === m)
					return this.mergeDiagonal(b, c, 1, 1), {
						directionX: 1,
						directionY: 1
					};
				if (y === m)
					return this.mergeDiagonal(b, c, -1, 1), {
						directionX: -1,
						directionY: 1
					};
				if (r === m)
					return this.mergeDiagonal(b, c, 1, -1), {
						directionX: 1,
						directionY: -1
					};
				this.mergeDiagonal(b, c, -1, -1);
				return {
					directionX: -1,
					directionY: -1
				}
			}
		},
		getSquareDistance: function (a, b) {
			return (a.clusterX - b.clusterX) * (a.clusterX - b.clusterX) + (a.clusterY - b.clusterY) * (a.clusterY - b.clusterY)
		},
		mergeHorizontal: function (a, b, c) {
			this.clusters[a][b].addCluster(this.clusters[a +
					1 * c][b]);
			var v = Math.floor((this.clusters[a][b].clusterX - this.minX) / this.gridSizeInX);
			v == a ? (this.removeAllFeatureInCluster(this.clusters[a + 1 * c][b]), this.clusters[a + 1 * c][b] = null) : v == a + c && (this.removeAllFeatureInCluster(this.clusters[a + 1 * c][b]), this.clusters[a + 1 * c][b] = this.clusters[a][b], this.removeAllFeatureInCluster(this.clusters[a][b]), this.clusters[a][b] = null)
		},
		mergeVertical: function (a, b, c) {
			this.clusters[a][b].addCluster(this.clusters[a][b + 1 * c]);
			var v = Math.floor((this.clusters[a][b].clusterY - this.minY) /
					this.gridSizeInY);
			v == b ? (this.removeAllFeatureInCluster(this.clusters[a][b + 1 * c]), this.clusters[a][b + 1 * c] = null) : v == b + c && (this.removeAllFeatureInCluster(this.clusters[a][b + 1 * c]), this.clusters[a][b + 1 * c] = this.clusters[a][b], this.removeAllFeatureInCluster(this.clusters[a][b]), this.clusters[a][b] = null)
		},
		mergeDiagonal: function (b, c, da, v) {
			this.clusters[b][c].addCluster(this.clusters[b + 1 * da][c + v]);
			var E = Math.floor((this.clusters[b][c].clusterX - this.minX) / this.gridSizeInX),
			M = Math.floor((this.clusters[b][c].clusterY -
						this.minY) / this.gridSizeInY);
			E == b && M == c ? (this.removeAllFeatureInCluster(this.clusters[b + da][c + v]), this.clusters[b + 1 * da][c + 1 * v] = null) : E == b + da && M == c + v ? (this.removeAllFeatureInCluster(this.clusters[b + da][c + v]), this.clusters[b + 1 * da][c + 1 * v] = this.clusters[b][c], this.removeAllFeatureInCluster(this.clusters[b][c]), this.clusters[b][c] = null) : (a.isNull(this.clusters[E][M]) ? this.clusters[E][M] = this.clusters[b][c] : this.clusters[E][M].addCluster(this.clusters[b][c]), this.removeAllFeatureInCluster(this.clusters[b][c]),
				this.clusters[b][c] = null, this.removeAllFeatureInCluster(this.clusters[b + da][c + v]), this.clusters[b + da][c + v] = null)
		},
		removeAllFeatureInCluster: function (b) {
			var c = b.clusterFeatureId,
			da = {
				origin: "removeAllFeatureInCluster"
			};
			if (a.isNull(c))
				for (c = 0; c < b.featureArray.length; c++) {
					var v = b.featureArray[c];
					v.parentLayer && v.parentLayer.clearFeature(v, da)
				}
			else
				for ((c = this.getClusterFeatureById(c)) && c.parentLayer.clearFeature(c, da), b.clusterFeatureId = null, b = this.clusterFeatureArray ? this.clusterFeatureArray.length :
						0, da = 0; da < b; da++)
					if (this.clusterFeatureArray[da] == c) {
						this.clusterFeatureArray.splice(da, 1);
						break
					}
		},
		redrawCluster: function (b, c, da) {
			if (!a.isNull(b)) {
				var v = this.vectorLayer.parentMap.getMapContext().getUniverse().getSRID();
				return b.numberOfPoints >= this.minPointCount ? (da = "-CL" + c + "-" + da, (c = this.getClusterFeatureById(da)) ? (b = new a.geometry.Point(b.clusterX, b.clusterY, v), c.setGeometry(b), this.updateMarkerText(c)) : (this.removeAllFeatureInCluster(b), c = b.createClusterFeature(da, v, this.clusterStyle), this.displayClusterFeature(c)),
					!0) : !1
			}
		},
		getClusterFeatureById: function (a) {
			for (var b = 0; b < this.clusterFeatureArray.length; b++)
				if (this.clusterFeatureArray[b].id === a)
					return this.clusterFeatureArray[b];
			return null
		},
		clearAllClusterFeatures: function () {
			for (var a = (this.clusterFeatureArray ? this.clusterFeatureArray.length : 0) - 1; 0 <= a; a--) {
				var b = this.clusterFeatureArray[a];
				b.shape && (this.vectorLayer.parentMap.graphics.remove(b.shape), b.shape.feature = null, b.shape = null);
				b.group = null;
				b.screenTransformObj = null;
				b.graphics = null;
				b.displayed = !1;
				b.inCluster =
					!1;
				b.parentLayer = null;
				this.clusterFeatureArray.pop()
			}
			this.clusterFeatureArray = [];
			this.clusters = {};
			this.initialized = !1
		},
		updateMarkerText: function (a) {
			1 < a.shape.childrenCount && a.shape.lastChild.applyStyle({
				textValue: a.cluster.numberOfPoints
			})
		},
		addFeature: function (b) {
			var c = this.addFeatureToCluster(b),
			da = this.mergeCluster(c.x, c.y),
			v = this.clusters[c.x][c.y],
			E = !1;
			if (a.isNull(da))
				E = this.redrawCluster(v, c.x, c.y);
			else {
				var M = c.x + da.directionX,
				da = c.y + da.directionY;
				a.notNull(v) ? E = this.redrawCluster(v, c.x, c.y) :
					a.notNull(this.clusters[M][da]) && (E = this.redrawCluster(this.clusters[M][da], M, da))
			}
			E && (b.displayed = !0)
		},
		addClusterFeatureToLabelGrid: function () {
			for (var a = this.clusterFeatureArray ? this.clusterFeatureArray.length : 0, b = 0; b < a; b++) {
				var c = this.clusterFeatureArray[b];
				if (c.displayed && c.screenPoints) {
					var v = c.screenPoints.x,
					E = c.screenPoints.y,
					M = c.renderingStyle.width,
					c = c.renderingStyle.height;
					this.vectorLayer.parentMap.grid.insert([v - M / 2, E - c / 2, v + M / 2, E + c / 2])
				}
			}
		},
		showClusterInWrapAround: function () {
			for (var a = this.vectorLayer.parentMap.getMapContext().getWholeMapNum(),
				b = this.clusterFeatureArray ? this.clusterFeatureArray.length : 0, c = 1; c < a; c++)
				for (var v = 0; v < b; v++) {
					var E = this.clusterFeatureArray[v];
					E.group = this.vectorLayer.featureGroupArr[c];
					E.displayFeature([E.renderingStyle]);
					E.shape && this.showDefaultTooltip && E.shape.applyStyle({
						tooltip: E.cluster.numberOfPoints + ""
					})
				}
		}
	});
	a.layer.EditableFeature = a.Feature.extend({
		initialize: function ga(b, c, E) {
			a.notNull(c) && ga.base.call(this, b, c, E);
			this.edit = !1;
			this.editable = !0;
			this.editing = this.modified = this.dragging = !1;
			this.contextMenu =
				null;
			this.refresh_dragging = this.point_dragging = this.dragging_flag = !1;
			this.mbrMinX = this.mbrMaxX = null;
			this.init();
			this.pointToSnap = null;
			var M = this;
			this.setParentThat = function (a) {
				M = a
			};
			this.endEditing = function (b) {
				if (!b || !b.evt || !b.evt.relatedTarget && !M.dragging) {
					var c;
					b && b.target && (c = b.target.parentFeature);
					!c && b && b.focusFeature && (c = b.focusFeature.parentFeature);
					!c && b && (c = b.focusFeature);
					c || (c = M);
					c.deleteListener(a.event.MouseEvent.MOUSE_RIGHT_CLICK, c.showContextMenu);
					c.deleteListener(a.event.LayerEvent.FEATURE_MOVED,
						c.shapePointMoved);
					a.notNull(c.parentLayer) && a.notNull(c.parentLayer.parentMap) && c.parentLayer.parentMap.deleteListener(a.event.MapEvent.I_MAP_CENTER_ZOOM, this.calDistance, this);
					c.editable = !1;
					c.editing = !1;
					b = c.geo;
					"Point" === b.type || "MultiPoint" === b.type ? (c.deleteEditingProperties(), c.setRenderingStyle(c.normalStyle)) : "OrientedPoint" === b.type ? (c.deleteEditingProperties(), c.displayFeature([c.renderingStyle])) : ("Polygon" !== b.type && "LineString" !== b.type && "MultiPolygon" !== b.type && "MultiLineString" !== b.type ||
						c.deleteEditingProperties(), a.notNull(c.parentLayer) && a.notNull(c.parentLayer.parentMap) && c.parentLayer.parentMap.wraparound && c.parentLayer.parentMap.getLayerByName("ii_oracle_maps_internal_editing").refresh())
				}
			};
			this.shapePointMoving = function (b) {
				a.notNull(a.gv.allowFeaturePointsInteraction) && !1 === a.gv.allowFeaturePointsInteraction || (M.dragging = !0, M.point_dragging = !0, M.featurePointMoving(b, !0))
			};
			this.possiblePointMoving = function (b) {
				a.notNull(a.gv.allowFeaturePointsInteraction) && !1 === a.gv.allowFeaturePointsInteraction ||
				(M.dragging = !0, M.point_dragging = !0, M.featurePointMoving(b, !1))
			};
			this.resizePointMoving = function (b) {
				a.notNull(a.gv.allowFeaturePointsInteraction) && !1 === a.gv.allowFeaturePointsInteraction || this.parentFeature.addResizeHandles(b)
			};
			this.showContextMenu = function (b) {
				if (!a.notNull(a.gv.allowFeaturePointsInteraction) || !1 !== a.gv.allowFeaturePointsInteraction) {
					if (a.notNull(this.parentFeature)) {
						if (!1 === this.parentFeature.parentLayer.isEditingContextMenuEnabled())
							return
					} else if (!1 === this.parentLayer.isEditingContextMenuEnabled())
						return;
					var c = b.target.parentLayer.parentMap,
					v = b.evt.clientX,
					da = b.evt.clientY,
					m = b.target,
					D = new a.layer.Menu(c, {
						left: v,
						top: da
					});
					D.menu.setPosition(v, da);
					var E = function () {
						m && M.deleteShapePoint(m)
					};
					b = function () {
						if (m) {
							var b = D.location.left,
							c = D.location.top,
							N = m.parentLayer.parentMap.getScreenPointLocation(b, c),
							c = m.parentLayer.parentMap.getScreenPointLocation(b - 5, c - 5),
							b = N.coordinates[0] - c.coordinates[0],
							c = c.coordinates[1] - N.coordinates[1],
							b = Math.sqrt(b * b + c * c),
							b = a.util.GeomUtil.findGeometryElement(m.getGeometry(),
									N.coordinates[0], N.coordinates[1], b);
							-1 !== b && (N = m.getGeometry().clone(!0), N = a.util.GeomUtil.removeGeometryElement(N, b), a.notNull(N) && (a.notNull(m.parentLayer.changeManager) && (b = m.parentLayer.changeManager.updateFeature(m.id, m, N, a.edit.EditChangeEvent.SPATIAL_UPDATE), a.notNull(b) && m.parentLayer.getUndoManager().addEdit({
											feature: m,
											changeManager: m.parentLayer.changeManager,
											editChangeEvent: b,
											canUndo: function () {
												return !0
											},
											canRedo: function () {
												return !0
											},
											getPresentationName: function () {
												return "remove feature element"
											},
											undo: function () {
												this.changeManager.undo(this.editChangeEvent);
												var b = new a.event.LayerEvent(a.event.LayerEvent.FEATURE_EDITED, this.feature);
												this.feature.fire(a.event.LayerEvent.FEATURE_EDITED, b);
												this.feature.deleteEditingProperties();
												this.feature.selected && this.feature.addEditProperties()
											},
											redo: function () {
												this.changeManager.redo(this.editChangeEvent);
												var b = new a.event.LayerEvent(a.event.LayerEvent.FEATURE_EDITED, this.feature);
												this.feature.fire(a.event.LayerEvent.FEATURE_EDITED, b);
												this.feature.deleteEditingProperties();
												this.feature.selected && this.feature.addEditProperties()
											}
										})), m.setGeometry(N), N = new a.event.LayerEvent(a.event.LayerEvent.FEATURE_EDITED, m), m.fire(a.event.LayerEvent.FEATURE_EDITED, N), m.deleteEditingProperties(), m.addEditProperties(!0)))
						}
					};
					v = function () {
						if (m) {
							var b = m.parentLayer;
							if (!a.isNull(b)) {
								var N = D.location.left,
								v = D.location.top,
								da = m.parentLayer.parentMap.getScreenPointLocation(N, v),
								v = m.parentLayer.parentMap.getScreenPointLocation(N - 5, v - 5),
								N = da.coordinates[0] - v.coordinates[0],
								v = v.coordinates[1] -
									da.coordinates[1],
								N = Math.sqrt(N * N + v * v),
								da = a.util.GeomUtil.findGeometryElement(m.getGeometry(), da.coordinates[0], da.coordinates[1], N);
								if (-1 === da)
									a.util.Logger.warning("MAPVIEWER_9061", "OM.EditableFeature.showContextMenu", "");
								else {
									var r = m.getGeometry().clone(!0),
									r = a.util.GeomUtil.removeGeometryElement(r, da);
									if (a.isNull(r))
										a.util.Logger.warning("MAPVIEWER_9062", "OM.EditableFeature.showContextMenu", "");
									else {
										var E = a.util.GeomUtil.cloneGeometryElement(m.getGeometry(), da);
										if (a.isNull(E))
											a.util.Logger.warning("MAPVIEWER_9063",
												"OM.EditableFeature.showContextMenu", "");
										else {
											var da = "\x3ctr\x3e\x3ctd\x3e\x3ctable\x3e",
											y = [],
											N = [],
											S = a.layer.VectorLayer,
											v = "" + Math.floor(1E3 * Math.random() + 1);
											if (b.type === S.TYPE_PREDEFINED || b.type === S.TYPE_JDBC)
												if (a.notNull(b.keyColumn))
													y.push(b.keyColumn);
												else
													return;
											else
												y.push("ID");
											if (a.notNull(b.notNullAttributes))
												for (var ga = 0; ga < b.notNullAttributes.length; ga++)
													b.notNullAttributes[ga] !== b.keyColumn && y.push(b.notNullAttributes[ga].toUpperCase());
											for (ga = 0; ga < y.length; ga++) {
												var M = document.getElementById("_wb_attr" +
														ga + c.instanceId);
												a.notNull(M) && (M.outerHTML = "");
												0 !== ga ? N.push("") : N.push(v);
												da += "\x3ctr\x3e\x3ctd\x3e" + y[ga] + " : \x3c/td\x3e\x3ctd\x3e\x3cinput type\x3d'text' style\x3d'width:340px'  id\x3d'_wb_attr" + ga + c.instanceId + "' value\x3d" + N[ga] + "\x3e\x3c/td\x3e\x3c/tr\x3e"
											}
											da += "\x3c/table\x3e\x3c/td\x3e\x3c/tr\x3e";
											c.$featdialog = a.$('\x3cdiv id\x3d"_wb_dialog' + c.mapInstanceId + '" title\x3d"' + a.gv.getLabel("MAPVIEWER_WB_PROPERTIES") + '" style\x3d"overflow:visible"\x3e\x3ctable width\x3d100% cellSpacing\x3d0 borderSpacing\x3d0 style\x3d\'font-size:13px\'\x3e' +
													da + "\x3c/table\x3e\x3c/div\x3e");
											c.$featdialog.dialog({
												position: {
													of: c.$oracleMapDiv,
													at: "center"
												},
												resizable: !1,
												width: a.browser.touchSupported || a.gv.isWin8Touch ? 450 : 510,
												height: a.browser.touchSupported || a.gv.isWin8Touch ? 300 : 360,
												buttons: [{
														closeOnEscape: !0,
														text: a.gv.getLabel("MAPVIEWER_WB_OK"),
														click: function () {
															for (var N = 0; N < y.length; N++) {
																var v = document.getElementById("_wb_attr" + N + c.instanceId).value;
																if (a.isNull(v) || 0 === v.length) {
																	a.util.Logger.warning("MAPVIEWER_9060", "onContextMenuDetachElemClick", y[N]);
																	return
																}
																var da = b.getAttributeType(y[N]);
																if (a.notNull(da) && "string" !== da && !0 === isNaN(v)) {
																	a.util.Logger.warning("MAPVIEWER_9059", "onContextMenuDetachElemClick", y[N]);
																	return
																}
															}
															var v = document.getElementById("_wb_attr0" + c.instanceId).value,
															N = {},
															da = !1,
															w = m.getAttributes(),
															D = null,
															ga = null,
															M = null;
															if (b.type === S.TYPE_PREDEFINED || b.type === S.TYPE_JDBC)
																for (D in w) {
																	ga = D.toUpperCase();
																	M = m.getAttributeValue(ga);
																	for (da = 0; da < y.length; da++)
																		if (y[da] === ga) {
																			M = document.getElementById("_wb_attr" + da + c.instanceId).value;
																			break
																		}
																	N[ga] =
																		M;
																	da = !0
																}
															else
																for (D in w)
																	ga = D.toUpperCase(), N[ga] = m.getAttributeValue(ga), da = !0;
															v = new a.Feature(v, E);
															da && (v.attributes = N);
															a.notNull(m.parentLayer.changeManager) ? (N = a.edit.EditChangeEvent, m.parentLayer.getUndoManager().startChangeBlock("detach feature element"), N = m.parentLayer.changeManager.updateFeature(m.id, m, r, N.SPATIAL_UPDATE), a.notNull(N) && m.parentLayer.getUndoManager().addEdit({
																	feature: m,
																	changeManager: m.parentLayer.changeManager,
																	editChangeEvent: N,
																	canUndo: function () {
																		return !0
																	},
																	canRedo: function () {
																		return !0
																	},
																	getPresentationName: function () {
																		return "update feature element"
																	},
																	undo: function () {
																		this.changeManager.undo(this.editChangeEvent);
																		var b = new a.event.LayerEvent(a.event.LayerEvent.FEATURE_EDITED, this.feature);
																		this.feature.fire(a.event.LayerEvent.FEATURE_EDITED, b);
																		this.feature.deleteEditingProperties();
																		this.feature.selected && this.feature.addEditProperties()
																	},
																	redo: function () {
																		this.changeManager.redo(this.editChangeEvent);
																		var b = new a.event.LayerEvent(a.event.LayerEvent.FEATURE_EDITED, this.feature);
																		this.feature.fire(a.event.LayerEvent.FEATURE_EDITED,
																			b);
																		this.feature.deleteEditingProperties();
																		this.feature.selected && this.feature.addEditProperties()
																	}
																}), N = m.parentLayer.changeManager.addFeature(v.id, v), a.notNull(N) && m.parentLayer.getUndoManager().addEdit({
																	changeManager: m.parentLayer.changeManager,
																	editChangeEvent: N,
																	canUndo: function () {
																		return !0
																	},
																	canRedo: function () {
																		return !0
																	},
																	getPresentationName: function () {
																		return "feature added"
																	},
																	undo: function () {
																		this.changeManager.undo(this.editChangeEvent)
																	},
																	redo: function () {
																		this.changeManager.redo(this.editChangeEvent)
																	}
																}),
																m.parentLayer.getUndoManager().endChangeBlock("detach feature element")) : m.parentLayer.addFeature(v);
															m.setGeometry(r);
															N = new a.event.LayerEvent(a.event.LayerEvent.FEATURE_EDITED, m);
															m.fire(a.event.LayerEvent.FEATURE_EDITED, N);
															m.deleteEditingProperties();
															m.addEditProperties(!0);
															a.$(this).dialog("close")
														}
													}, {
														text: a.gv.getLabel("MAPVIEWER_WB_CANCEL"),
														click: function () {
															a.$(this).dialog("close")
														}
													}
												],
												close: function (a, b) {}
											})
										}
									}
								}
							}
						}
					};
					da = function () {
						if (M.editable && m) {
							var b = "\x3ctr\x3e\x3ctd\x3e\x3ctable\x3e",
							N,
							v,
							da,
							r,
							E,
							y = [],
							S = [];
							da = -1;
							if (m.parentFeature)
								if (N = m.parentFeature.getGeometry(), v = N.getDimension(), "OrientedPoint" === N.type)
									for (var ga = 0; ga < v; ga++)
										y.push(N.getDimensionValue(ga)), S.push(N.getOrientationValue(ga));
								else {
									ga = m.id.indexOf("shapePoints");
									ga = m.id.substring(ga + 11).split("_");
									da = parseInt(ga[0]);
									r = parseInt(ga[1]);
									E = parseInt(ga[2]);
									ga = [];
									"MultiPolygon" === N.type ? ga = N.getOrdinates() : "MultiLineString" === N.type ? ga = [N.getOrdinates()] : "Polygon" === N.type ? ga = [N.getOrdinates()] : "LineString" === N.type && (ga =
												[[N.getOrdinates()]]);
									for (var Ha = 0; Ha < v; Ha++)
										y.push(ga[da][r][E * v + Ha])
								}
							else if (N = m.getGeometry(), v = N.getDimension(), "Point" === N.type)
								for (ga = 0; ga < v; ga++)
									y.push(N.getDimensionValue(ga));
							else {
								var Ha = D.location.left,
								tb = D.location.top,
								ga = m.parentLayer.parentMap.getScreenPointLocation(Ha, tb),
								tb = m.parentLayer.parentMap.getScreenPointLocation(Ha - 5, tb - 5),
								Ha = ga.coordinates[0] - tb.coordinates[0],
								tb = tb.coordinates[1] - ga.coordinates[1];
								da = a.util.GeomUtil.findGeometryElement(N, ga.coordinates[0], ga.coordinates[1],
										Math.sqrt(Ha * Ha + tb * tb));
								if (-1 !== da && "MultiPoint" === N.type)
									for (ga = 0; ga < v; ga++)
										y.push(N.getOrdinates()[da][ga])
							}
							for (ga = 0; ga < v; ga++)
								Ha = document.getElementById("_wb_dim" + ga + c.instanceId), a.notNull(Ha) && (Ha.outerHTML = ""), b += "\x3ctr\x3e\x3ctd\x3e" + a.gv.getLabel("MAPVIEWER_WB_DIMENSION") + " " + ga + "\x3c/td\x3e\x3ctd\x3e\x3cinput type\x3d'text' style\x3d'width:340px'  id\x3d'_wb_dim" + ga + c.instanceId + "' value\x3d" + y[ga] + "\x3e\x3c/td\x3e\x3c/tr\x3e";
							if (0 < S.length)
								for (ga = 0; ga < v; ga++)
									Ha = document.getElementById("_wb_orient" +
											ga + c.instanceId), a.notNull(Ha) && (Ha.outerHTML = ""), b += "\x3ctr\x3e\x3ctd\x3e" + a.gv.getLabel("MAPVIEWER_WB_ORIENTATION") + " " + ga + "\x3c/td\x3e\x3ctd\x3e\x3cinput type\x3d'text' style\x3d'width:340px'  id\x3d'_wb_orient" + ga + c.instanceId + "' value\x3d" + S[ga] + "\x3e\x3c/td\x3e\x3c/tr\x3e";
							b += "\x3c/table\x3e\x3c/td\x3e\x3c/tr\x3e";
							c.$pointdialog = a.$('\x3cdiv id\x3d"_wb_dialog' + c.mapInstanceId + '" title\x3d"' + a.gv.getLabel("MAPVIEWER_WB_GEOM_PROPERTIES") + '" style\x3d"overflow:visible"\x3e\x3ctable width\x3d100% cellSpacing\x3d0 borderSpacing\x3d0 style\x3d\'font-size:13px\'\x3e' +
									b + "\x3c/table\x3e\x3c/div\x3e");
							c.$pointdialog.dialog({
								position: {
									of: c.$oracleMapDiv,
									at: "center"
								},
								resizable: !1,
								width: a.browser.touchSupported || a.gv.isWin8Touch ? 450 : 510,
								height: a.browser.touchSupported || a.gv.isWin8Touch ? 300 : 360,
								buttons: [{
										closeOnEscape: !0,
										text: a.gv.getLabel("MAPVIEWER_WB_UPDATE"),
										click: function () {
											for (var b = a.util.ValidationUtil.isNumber, D = 0; D < y.length; D++)
												if (!b(document.getElementById("_wb_dim" + D + c.instanceId).value)) {
													a.util.Logger.warning("MAPVIEWER_9059", a.gv.getLabel("MAPVIEWER_WB_DIMENSION"),
														D);
													return
												}
											for (D = 0; D < S.length; D++)
												if (!b(document.getElementById("_wb_orient" + D + c.instanceId).value)) {
													a.util.Logger.warning("MAPVIEWER_9059", a.gv.getLabel("MAPVIEWER_WB_ORIENTATION"), D);
													return
												}
											var ga = D = b = null,
											U = null;
											if (m.parentFeature)
												if (D = m.parentFeature, N = m.parentFeature.getGeometry(), b = N.clone(!0), v = N.getDimension(), "OrientedPoint" === N.type) {
													for (ga = 0; ga < v; ga++)
														b.setDimensionValue(ga, parseFloat(document.getElementById("_wb_dim" + ga + c.instanceId).value)), b.setOrientationValue(ga, parseFloat(document.getElementById("_wb_orient" +
																	ga + c.instanceId).value));
													ga = D.screenPoints;
													U = {
														x: ga.x,
														y: ga.y,
														angle: ga.angle
													};
													ga.angle = -Math.atan2(b.getOrientationValue(1), b.getOrientationValue(0))
												} else
													for (var M = b.getOrdinates(), Qa = 0; Qa < v; Qa++)
														"MultiPolygon" === N.type ? M[da][r][E * v + Qa] = parseFloat(document.getElementById("_wb_dim" + Qa + c.instanceId).value) : "MultiLineString" === N.type ? M[r][E * v + Qa] = parseFloat(document.getElementById("_wb_dim" + Qa + c.instanceId).value) : "Polygon" === N.type ? M[r][E * v + Qa] = parseFloat(document.getElementById("_wb_dim" + Qa + c.instanceId).value) :
															"LineString" === N.type && (M[E * v + Qa] = parseFloat(document.getElementById("_wb_dim" + Qa + c.instanceId).value));
											else if (D = m, N = m.getGeometry(), b = N.clone(!0), v = N.getDimension(), "Point" === N.type)
												for (M = 0; M < v; M++)
													b.setDimensionValue(M, parseFloat(document.getElementById("_wb_dim" + M + c.instanceId).value));
											else if (-1 !== da && "MultiPoint" === N.type)
												for (M = b.getOrdinates(), Qa = 0; Qa < v; Qa++)
													M[da][Qa] = parseFloat(document.getElementById("_wb_dim" + Qa + c.instanceId).value);
											a.notNull(b) && (a.notNull(D.parentLayer.changeManager) &&
												(M = D.parentLayer.changeManager.updateFeature(D.id, D, b, a.edit.EditChangeEvent.SPATIAL_UPDATE), a.notNull(M) && D.parentLayer.getUndoManager().addEdit({
														feature: D,
														changeManager: D.parentLayer.changeManager,
														editChangeEvent: M,
														screenPointsOld: U,
														screenPointNew: ga,
														canUndo: function () {
															return !0
														},
														canRedo: function () {
															return !0
														},
														getPresentationName: function () {
															return "point orientation change"
														},
														undo: function () {
															this.changeManager.undo(this.editChangeEvent);
															"OrientedPoint" === this.feature.geo.type && (this.feature.screenPoints =
																	this.screenPointsOld);
															this.feature.deleteEditingProperties();
															this.feature.selected && this.feature.addEditProperties()
														},
														redo: function () {
															this.changeManager.redo(this.editChangeEvent);
															"OrientedPoint" === this.feature.geo.type && (this.feature.screenPoints = this.screenPointsNew);
															this.feature.deleteEditingProperties();
															this.feature.selected && this.feature.addEditProperties()
														}
													})), D.setGeometry(b), "OrientedPoint" === D.geo.type && (D.screenPoints = ga), D.deleteEditingProperties(), D.addEditProperties());
											a.$(this).dialog("close")
										}
									}, {
										text: a.gv.getLabel("MAPVIEWER_WB_CANCEL"),
										click: function () {
											a.$(this).dialog("close")
										}
									}
								],
								close: function (a, b) {}
							})
						}
					};
					if (a.notNull(m.parentFeature))
						"OrientedPoint" !== m.parentFeature.geo.type && D.addMenuItem(a.gv.getLabel("MAPVIEWER_WB_DELETE"), E), D.addMenuItem(a.gv.getLabel("MAPVIEWER_WB_PROPERTIES"), da);
					else {
						E = m.geo.type;
						if ("MultiPolygon" === E || "MultiLineString" === E || "MultiPoint" === E || "MultiOrientedPoint" === E || "GeometryCollection" === E)
							D.addMenuItem(a.gv.getLabel("MAPVIEWER_WB_DELETE_ELEMENT"), b), D.addMenuItem(a.gv.getLabel("MAPVIEWER_WB_UNGROUP_ELEMENT"),
								v);
						("Point" === E || "OrientedPoint" === E || "MultiPoint" === E || "MultiOrientedPoint" === E) && this.editable && D.addMenuItem(a.gv.getLabel("MAPVIEWER_WB_PROPERTIES"), da)
					}
					D.show = !0;
					this.parentFeature && (this.parentFeature.contextMenu = D)
				}
			};
			this.registerUpdate = function (b, c, v, da) {
				a.isNull(b) || a.isNull(c) || a.isNull(v) || (c === v ? v.parentLayer.getUndoManager().addEdit({
						feature: v,
						changeManager: v.parentLayer.changeManager,
						editChangeEvent: b,
						canUndo: function () {
							return !0
						},
						canRedo: function () {
							return !0
						},
						getPresentationName: function () {
							return da
						},
						undo: function () {
							this.changeManager.undo(this.editChangeEvent);
							this.feature.deleteEditingProperties();
							this.feature.selected && this.feature.addEditProperties()
						},
						redo: function () {
							this.changeManager.redo(this.editChangeEvent);
							this.feature.deleteEditingProperties();
							this.feature.selected && this.feature.addEditProperties()
						}
					}) : v.parentLayer.getUndoManager().addEdit({
						feature: c,
						changeManager: v.parentLayer.changeManager,
						editChangeEvent: b,
						canUndo: function () {
							return !0
						},
						canRedo: function () {
							return !0
						},
						getPresentationName: function () {
							return da
						},
						undo: function () {
							this.changeManager.undo(this.editChangeEvent)
						},
						redo: function () {
							this.changeManager.redo(this.editChangeEvent)
						}
					}))
			}
		},
		init: function () {
			this.relatedFeature = []
		},
		startDrag: function (b, c) {
			var v = this;
			if (!a.gv.featureDragDisabled(v) && !v.dragging) {
				var E = v.parentLayer.parentMap.$oracleMapDiv.offset();
				v.startX = b.clientX + E.left;
				v.startY = b.clientY + E.top;
				v.lastX = b.clientX + E.left;
				v.lastY = b.clientY + E.top;
				v.parentLayer.parentMap.enableMapAction.drag ? v.parentLayer.parentMap.enableMapDrag(!1) : v.lockedParMap =
					!0;
				this.dragging = !0;
				if (a.notNull(v.parentFeature) && c) {
					E = v.parentFeature;
					E.relatedFeature = [];
					var M = E.featureEditingProperties;
					v.orientation ? (E = E.featureEditingProperties.shapePoints[0][0][0], v.centerX = E.screenPoints.x, v.centerY = E.screenPoints.y, v.posX = this.screenPoints.x, v.posY = this.screenPoints.y, v.endDragOrietation = function () {
						var b = v.parentLayer;
						b.parentMap.enableMapDrag(!0);
						var c = v.screenPoints.x - v.centerX,
						da = v.centerY - v.screenPoints.y;
						v.startX = null;
						v.startY = null;
						v.posX = null;
						v.posY = null;
						var r,
						m,
						D = v.parentFeature;
						if (D.tool)
							r = D.tool.currentPoint, m = new a.geometry.Point(r.getX(), r.getY(), r.srid, c, da), D.tool.currentPoint = m;
						else {
							r = D.geo;
							m = new a.geometry.Point(r.getX(), r.getY(), r.srid, c, da);
							if (2 < r.dim)
								for (var E = 2; E < r.dim; E++) {
									var ga = r.getOrientationValue(E),
									w = r.getDimensionValue(E);
									m.addDimension(w, ga)
								}
							r = D.screenPoints;
							E = {
								x: r.x,
								y: r.y,
								angle: r.angle
							};
							r.angle = -Math.atan2(da, c);
							a.notNull(D.parentLayer.changeManager) && (c = D.parentLayer.changeManager.updateFeature(D.id, D, m, a.edit.EditChangeEvent.SPATIAL_UPDATE),
								a.notNull(c) && D.parentLayer.getUndoManager().addEdit({
									feature: D,
									changeManager: D.parentLayer.changeManager,
									editChangeEvent: c,
									screenPointsOld: E,
									screenPointNew: r,
									canUndo: function () {
										return !0
									},
									canRedo: function () {
										return !0
									},
									getPresentationName: function () {
										return "point orientation change"
									},
									undo: function () {
										this.changeManager.undo(this.editChangeEvent);
										this.feature.screenPoints = this.screenPointsOld;
										var a = new M(M.FEATURE_MOVED, this.feature);
										this.feature.fire(M.FEATURE_MOVED, a);
										this.feature.deleteEditingProperties();
										this.feature.selected && this.feature.addEditProperties()
									},
									redo: function () {
										this.changeManager.redo(this.editChangeEvent);
										this.feature.screenPoints = this.screenPointNew;
										var a = new M(M.FEATURE_MOVED, this.feature);
										this.feature.fire(M.FEATURE_MOVED, a);
										this.feature.deleteEditingProperties();
										this.feature.selected && this.feature.addEditProperties()
									}
								}));
							D.setGeometry(m);
							D.screenPoints = r
						}
						v.dragging = !1;
						b.labelsVisible() && b.parentMap.refreshVectorLayerLabels();
						var M = a.event.LayerEvent,
						b = new M(M.FEATURE_MOVED, v);
						v.fire(b)
					}) : v.pos ? (M.shapePoints[0][0][1].setVisible(!1), M.shapePoints[0][0][2].setVisible(!1)) : this.calRelatedFeature(M, v)
				}
			}
		},
		calRelatedFeature: function (a, b) {
			this.point_dragging = !0;
			var c = b.parentFeature;
			b.relatedFeature = [];
			var E,
			M,
			N,
			O,
			y,
			r,
			m;
			E = 0;
			for (N = a.shapePoints.length; E < N; E++)
				for (M = 0, O = a.shapePoints[E].length; M < O; M++)
					for (y = a.shapePoints[E][M].length; y--; )
						if (r = a.shapePoints[E][M], m = a.possiblePoints[E][M], r[y] === b && ("Polygon" === c.geo.type || "LineString" === c.geo.type || "MultiPolygon" === c.geo.type ||
								"MultiLineString" === c.geo.type)) {
							if (0 !== y)
								b.relatedFeature.push(m[y - 1]), b.relatedFeature.push(r[y - 1]);
							else if ("Polygon" === c.geo.type || "MultiPolygon" === c.geo.type)
								b.relatedFeature.push(m[r.length - 1]), b.relatedFeature.push(r[m.length - 1]);
							b.relatedFeature.push(m[y]);
							if (y === r.length - 1 && ("Polygon" === c.geo.type || "MultiPolygon" === c.geo.type))
								y = -1;
							else if (y === r.length - 1)
								return;
							b.relatedFeature.push(r[y + 1]);
							return
						}
			E = 0;
			for (N = a.possiblePoints.length; E < N; E++)
				for (M = 0, O = a.possiblePoints[E].length; M < O; M++)
					for (y =
							a.possiblePoints[E][M].length; y--; )
						if (r = a.shapePoints[E][M], m = a.possiblePoints[E][M], m[y] == b && ("Polygon" == c.geo.type || "LineString" == c.geo.type || "MultiPolygon" === c.geo.type || "MultiLineString" === c.geo.type)) {
							b.relatedFeature.push(y);
							b.relatedFeature.push(r[y]);
							y == r.length - 1 && (y = -1);
							b.relatedFeature.push(r[y + 1]);
							b.relatedFeature.push(M);
							b.relatedFeature.push(E);
							return
						}
		},
		featureDragging: function (b) {
			this._activeIndex = this.parentLayer.parentMap.getCursorLocation().wraparoundMapIndex;
			this.dragging_flag ||
			(this.dragging_flag = this._activeIndex, a.isNull(this.dragging_flag) && (this.dragging_flag = !1));
			var c;
			if (this.parentLayer && !a.gv.featureDragDisabled(this)) {
				var v = this.parentLayer.parentMap.getMapContext();
				c = v.getUniverse().getZoomLevels()[v.getZoomLevel()];
				var v = a.event.LayerEvent,
				E = b.pageX - this.lastX,
				M = b.pageY - this.lastY,
				N = E * c.resolution;
				if (!this.mbrMaxX || !this.mbrMinX) {
					var O = new a.geometry.Point(this.geo.getMBR().getMaxX(), this.geo.getMBR().getMaxY(), this.geo.srid),
					y = new a.geometry.Point(this.geo.getMBR().getMinX(),
							this.geo.getMBR().getMinY(), this.geo.srid),
					O = this.parentLayer.parentMap.getACL(O, this.dragging_flag),
					y = this.parentLayer.parentMap.getACL(y, this.dragging_flag);
					this.mbrMaxX = O.getX();
					this.mbrMinX = y.getX()
				}
				this.mbrMaxX += N;
				this.mbrMinX += N;
				if (this.parentLayer.parentMap.wraparound && !this.point_dragging && (this.mbrMaxX >= this.parentLayer.parentMap.mapBBox[this.dragging_flag].maxX || this.mbrMinX <= this.parentLayer.parentMap.mapBBox[this.dragging_flag].minX) || this.parentLayer.parentMap.wraparound && !(this.mbrMaxX <=
						this.parentLayer.parentMap.mapBBox[this.dragging_flag].maxX && this.mbrMinX >= this.parentLayer.parentMap.mapBBox[this.dragging_flag].minX))
					this.lastX = b.pageX, this.lastY = b.pageY;
				else {
					this.mouseLocX = b.pageX;
					this.mouseLocY = b.pageY;
					this.moving = !0;
					if (this.orientation) {
						this.posX += E;
						this.posY += M;
						N = Math.atan2(this.centerY - this.posY, this.posX - this.centerX);
						y = this.parentFeature;
						O = y.geo;
						y.tool && (O = y.tool.currentPoint);
						var r = O.getOrientationPoint(a.layer.EditableFeature.MARKER_SIZE + 20, c, N);
						this.setGeometry(r);
						r =
							O.getOrientationPoint(a.layer.EditableFeature.MARKER_SIZE / 2, c, N);
						c = O.getOrientationPoint(a.layer.EditableFeature.MARKER_SIZE / 2 + 20, c, N);
						c = new a.geometry.LineString([r.getX(), r.getY(), c.getX(), c.getY()], r.srid);
						y.featureEditingProperties.shapePoints[0][0][2].setGeometry(c);
						c = new a.event.LayerEvent(a.event.LayerEvent.FEATURE_ORIENTATION_CHANGING, this.parentLayer);
						c.angle = N;
						y.fire(v.FEATURE_ORIENTATION_CHANGING, c)
					} else if (this.shapeGroup)
						for (N = this.shapeGroup.length, c = 0; c < N; c++)
							this.shapeGroup[c].translate(E,
								M);
					else if (this.scale && ("Point" === this.geo.type || "OrientedPoint" === this.geo.type))
						E /= this.scale, M /= this.scale, this.shape.translate(E, M);
					else if (a.notNull(this.shape))
						if (this.parentLayer.parentMap.wraparound && !this.point_dragging)
							for (c = 0; c < this.parentLayer.featureGroupArr.length; c++)
								this.parentLayer.featureGroupArr[c].translate(E, M);
						else {
							if (this.dragging_flag !== this._activeIndex && this.parentLayer.parentMap.wraparound)
								return;
							this.shape.translate(E, M)
						}
					this.lastX = b.pageX;
					this.lastY = b.pageY;
					this.labelShape &&
					!this.ghostShape && this.labelShape.translate(E, M);
					E = new v(v.FEATURE_MOVING, this);
					E.orgEvt = b;
					this.fire(v.FEATURE_MOVING, E);
					a.notNull(this.parentFeature) && this.parentFeature.fire(v.FEATURE_MOVING, E);
					!this.refresh_dragging && this.parentLayer.parentMap.wraparound && this.parentLayer.parentMap.getLayerByName("ii_oracle_maps_internal_editing").refresh()
				}
			}
		},
		endDrag: function () {
			this.mbrMinX = this.mbrMaxX = null;
			var b = this.parentLayer;
			if (!a.isNull(b) && !a.gv.featureDragDisabled(this)) {
				this.dragging = !1;
				b.parentMap.enableMapAction.drag ||
				(this.lockedParMap ? b.parentMap.enableMapDrag(!1) : b.parentMap.enableMapDrag(!0));
				var c,
				v;
				if (this.moving) {
					this.moving = !1;
					var E = this.startX - this.mouseLocX,
					M = this.startY - this.mouseLocY;
					(E || M) && this.deleteEditingProperties();
					var N = b.parentMap.getMapContext(),
					N = N.getUniverse().getZoomLevels()[N.getZoomLevel()];
					v = this.getGeometry().clone(!0);
					this.point_dragging && this.dragging_flag !== this._activeIndex && this.parentLayer.parentMap.wraparound ? (a.util.Logger.warning(0, "Point is out of bounding", ""), this.point_dragging =
							!1) : this.move(E, M, N);
					this.startY = this.startX = null;
					var O = this.getGeometry().clone(!0),
					y = this.editing;
					c = this;
					if (a.notNull(this.parentFeature) && "OrientedPoint" === this.parentFeature.geo.type) {
						y = this.parentFeature.editing;
						b = this.parentFeature.parentLayer;
						c = this.parentFeature;
						v = this.parentFeature.getGeometry().clone(!0);
						var r = O.getX(),
						m = O.getY(),
						O = this.parentFeature.getGeometry().clone(!0);
						O.setPoint(r, m)
					}
					y && a.notNull(b.changeManager) && (c.geo = v, v = b.changeManager.updateFeature(c.id, c, O, a.edit.EditChangeEvent.SPATIAL_UPDATE),
						a.notNull(v) && b.getUndoManager().addEdit({
							feature: c,
							changeManager: b.changeManager,
							editChangeEvent: v,
							canUndo: function () {
								return !0
							},
							canRedo: function () {
								return !0
							},
							getPresentationName: function () {
								return "feature move"
							},
							undo: function () {
								this.changeManager.undo(this.editChangeEvent);
								var a = new D(D.FEATURE_MOVED, this.feature);
								this.feature.fire(D.FEATURE_MOVED, a);
								this.feature.deleteEditingProperties();
								this.feature.selected && this.feature.addEditProperties()
							},
							redo: function () {
								this.changeManager.redo(this.editChangeEvent);
								var a = new D(D.FEATURE_MOVED, this.feature);
								this.feature.fire(D.FEATURE_MOVED, a);
								this.feature.deleteEditingProperties();
								this.feature.selected && this.feature.addEditProperties()
							}
						}));
					b.labelsVisible() && b.parentMap.refreshVectorLayerLabels();
					var D = a.event.LayerEvent;
					this.pos && (c = this.parentFeature, v = c.featureEditingProperties, v.shapePoints[0][0][1].move(E, M, N), v.shapePoints[0][0][1].shape.translate(-E, -M), v.shapePoints[0][0][2].move(E, M, N), v.shapePoints[0][0][2].shape.translate(-E, -M), v.shapePoints[0][0][1].setVisible(!0),
						v.shapePoints[0][0][2].setVisible(!0), v = this.geo.getX(), O = this.geo.getY(), c.tool ? c.tool.currentPoint.setPoint(v, O) : (N = c.geo, N.setPoint(v, O), v = {
								x: this.screenPoints.x,
								y: this.screenPoints.y,
								angle: c.screenPoints.angle
							}, c.setGeometry(N), c.screenPoints = v));
					N = new D(D.FEATURE_MOVED, this);
					this.fire(D.FEATURE_MOVED, N);
					a.notNull(this.parentFeature) && this.parentFeature.fire(D.FEATURE_MOVED, N);
					this.addEditProperties(!0);
					b.parentMap.wraparound && (this.refresh_dragging = !1, b.parentMap.getLayerByName("ii_oracle_maps_internal_editing").refresh(),
						b.parentMap.getLayerByName("ii_oracle_maps_internal_others").refresh());
					return E && M
				}
				this.pos && (c = this.parentFeature, v = c.featureEditingProperties, v.shapePoints[1].setVisible(!0), v.shapePoints[2].setVisible(!0))
			}
		},
		hideEditVertices: function (b) {
			var c = this.parentLayer;
			return a.isNull(c) ? !1 : "Polygon" === b.type && b.coordinates && 962 === b.coordinates[0].length ? !!c.hideEditCircleVertices : !1
		},
		addEditProperties_OrientedPoint: function (b) {
			var c = b.editpro,
			v = b.geometry;
			if (!a.isNull(c) && !a.isNull(v)) {
				var E = a.layer.EditableFeature,
				M = this.parentLayer.parentMap.getMapContext().getUniverse();
				b = this.parentLayer.parentMap.getDefaultFeatureLayer();
				var N = new a.geometry.Point(v.getX(), v.getY(), v.srid),
				M = new a.layer.EditableFeature(this.id + "pos", N, {
					renderingStyle: E.pointStyle
				});
				M.addListener(a.event.MouseEvent.MOUSE_RIGHT_CLICK, M.showContextMenu);
				M.parentFeature = this;
				M.pos = !0;
				b.addFeature(M);
				c.shapePoints[0][0].push(M);
				N = this.parentLayer.parentMap.getMapContext();
				M = N.getUniverse();
				M = M.getZoomLevels()[N.getZoomLevel()];
				N = v.getOrientationPoint(a.layer.EditableFeature.MARKER_SIZE +
						20, M);
				N = new a.layer.EditableFeature(this.id + "orien", N, {
					renderingStyle: E.ORIENTATION_POINT_STYLE
				});
				N.parentFeature = this;
				N.orientation = !0;
				b.addFeature(N);
				c.shapePoints[0][0].push(N);
				N = v.getOrientationPoint(a.layer.EditableFeature.MARKER_SIZE / 2, M);
				v = v.getOrientationPoint(a.layer.EditableFeature.MARKER_SIZE / 2 + 20, M);
				v = new a.geometry.LineString([N.getX(), N.getY(), v.getX(), v.getY()], N.srid);
				E = new a.Feature(this.id + "orienline", v, {
					renderingStyle: E.ORIENTATION_LINE_STYLE
				});
				E.parentFeature = this;
				b.addFeature(E);
				c.shapePoints[0][0].push(E)
			}
		},
		addEditProperties: function () {
			if (!a.notNull(this.parentFeature))
				if ("Point" === this.geo.type)
					this.hasListener(a.event.MouseEvent.MOUSE_RIGHT_CLICK, this.showContextMenu) || this.addListener(a.event.MouseEvent.MOUSE_RIGHT_CLICK, this.showContextMenu), this.hasListener(a.event.LayerEvent.FEATURE_MOVED, this.shapePointMoved) || this.addListener(a.event.LayerEvent.FEATURE_MOVED, this.shapePointMoved);
				else {
					var b = this.getGeometry();
					if ("Polygon" === b.type || "LineString" === b.type || "MultiPolygon" ===
						b.type || "Point" === b.type || "OrientedPoint" === b.type || "MultiLineString" === b.type || "MultiPoint" === b.type) {
						var c = b.getDimension();
						"MultiPolygon" !== b.type && "MultiLineString" !== b.type && "MultiPoint" !== b.type && "OrientedMultiPoint" !== b.type && "GeometryCollection" !== b.type && "Point" !== b.type && "OrientedPoint" !== b.type || this.addListener(a.event.MouseEvent.MOUSE_RIGHT_CLICK, this.showContextMenu);
						var v = a.layer.EditableFeature;
						if (!a.isNull(v) && !a.isNull(this.parentLayer) && !a.isNull(this.parentLayer.parentMap)) {
							var E =
								this.parentLayer.parentMap.getDefaultFeatureLayer(),
							M = {
								shapePoints: [],
								possiblePoints: []
							};
							this.featureEditingProperties = M;
							"OrientedPoint" == b.type && (M.shapePoints[0] = [], M.shapePoints[0][0] = [], this.addEditProperties_OrientedPoint({
									editpro: M,
									geometry: b
								}));
							var N = [];
							if ("MultiPolygon" === b.type)
								N = b.getOrdinates();
							else if ("MultiLineString" === b.type)
								N = [b.getOrdinates()];
							else if ("Polygon" === b.type)
								N = [b.getOrdinates()];
							else if ("LineString" === b.type)
								N = [[b.getOrdinates()]];
							else
								return;
							if (!this.hideEditVertices(b))
								for (var O =
										0, y = N.length; O < y; O++) {
									var r = N[O];
									r[0]instanceof Array || (r = [r[0]]);
									M.shapePoints[O] = [];
									M.possiblePoints[O] = [];
									for (var m = 0; m < r.length; m++) {
										M.shapePoints[O][m] = [];
										M.possiblePoints[O][m] = [];
										for (var D = null, S = null, U = r[m], w = 0; w < U.length / c; w++) {
											var ja = U[w * c],
											la = U[w * c + 1];
											if ("LineString" === b.type || "MultiLineString" === b.type || w !== U.length / c - 1) {
												var na = new a.layer.EditableFeature(this.id + "shapePoints" + O + "_" + m + "_" + w, new a.geometry.Point(ja, la, b.srid), {
													selectivity: 30,
													renderingStyle: v.pointStyle
												});
												na.parentFeature =
													this;
												na.ringIds = [O, m, w];
												na.addListener(a.event.LayerEvent.FEATURE_MOVING, na.shapePointMoving);
												na.addListener(a.event.MouseEvent.MOUSE_RIGHT_CLICK, na.showContextMenu);
												na.addListener(a.event.LayerEvent.FEATURE_MOVED, na.shapePointMoved);
												var sa = this.parentLayer;
												a.notNull(sa) && a.notNull(sa.getEditingRightClickVertexHandler) && (sa = sa.getEditingRightClickVertexHandler(), na.addListener(a.event.MouseEvent.MOUSE_RIGHT_CLICK, sa));
												M.shapePoints[O][m].push(na);
												E.addFeature(na)
											}
											a.notNull(D) && a.notNull(S) && (D = new a.layer.EditableFeature(this.id +
														"possiblePoints" + O + "_" + m + "_" + (w - 1), new a.geometry.Point(D + (ja - D) / 2, S + (la - S) / 2, b.srid), {
														selectivity: 20,
														renderingStyle: v.possibleStyle
													}), D.parentFeature = this, D.ringIds = [O, m, w], D.addListener(a.event.LayerEvent.FEATURE_MOVING, D.possiblePointMoving), D.addListener(a.event.LayerEvent.FEATURE_MOVED, D.possiblePointMoved), M.possiblePoints[O][m].push(D), E.addFeature(D));
											D = ja;
											S = la
										}
									}
								}
							this.addResizeHandles();
							this.calDistance()
						}
					}
				}
		},
		addResizeHandles: function (b) {
			if (!a.notNull(a.gv.showManipulator) || !1 !== a.gv.showManipulator) {
				var c =
					this.getGeometry(),
				v = c.getType();
				if ("Polygon" === v || "MultiPolygon" === v || "LineString" === v || "MultiLineString" === v) {
					var v = this.parentLayer.parentMap.getDefaultFeatureLayer(),
					E = v.parentMap.getMapContext(),
					M = E.getUniverse().getZoomLevels()[E.getZoomLevel()],
					N = new a.style.Color({
						stroke: "#FF0080",
						strokeThickness: 2,
						strokeOpacity: .5
					}),
					E = this.featureEditingProperties,
					O = c.getMBR(),
					y = O.coordinates[0],
					r = O.coordinates[1],
					m = O.coordinates[2],
					D = O.coordinates[3],
					S;
					if (!E.resizePoints)
						E.resizePoints = [];
					else if (b) {
						S = b.target;
						var O = new this.graphics.oui.geom.Matrix,
						U =  - (S.startX - S.mouseLocX) * M.resolution,
						w = (S.startY - S.mouseLocY) * M.resolution * M.stretchRatio,
						ja = S.getGeometry().coordinates,
						la = S.anchor,
						U = ja[0] + U,
						w = ja[1] + w;
						if (S === E.rotateHandle)
							if (this.parentLayer.parentMap.wraparound)
								a.util.Logger.warning("MAPVIEWER_9010", "OM.EditableFeature.startEditing", "Not support rotation for wraparound");
							else {
								if (m = Math.atan2(w - la.y, U - la.x), O.translate(la.x, la.y), O.rotate(m), O.translate(-la.x, -la.y), E.resizeMBR && E.resizeMBR.setVisible(!1),
									E.resizePoints)
									for (r = 0; r < E.resizePoints.length; r++)
										(D = E.resizePoints[r]) && D.setVisible(!1)
							}
						else
							m = (U - la.x) / (m - y) * S.correction.x, r = (w - la.y) / (D - r) * S.correction.y, S.id === this.id + "resizePointsN" || S.id === this.id + "resizePointsS" ? m = b.orgEvt.shiftKey ? r : 1 : S.id === this.id + "resizePointsW" || S.id === this.id + "resizePointsE" ? r = b.orgEvt.shiftKey ? m : 1 : b.orgEvt.shiftKey && (r = m = Math.max(m, r)), O.translate(la.x, la.y), O.scale(m, r), O.translate(-la.x, -la.y);
						m = a.util.GeomUtil.getTransformedGeometry(c, O);
						E.transitFeature ? E.transitFeature.setGeometry(m) :
						(r = new a.style.Line({
								stroke: "#8684F3",
								strokeThickness: 3,
								strokeOpacity: .5
							}), r = new a.layer.EditableFeature(this.id + "transitFeature", m, {
								renderingStyle: r
							}), r.parentFeature = this, E.transitFeature = r, v.addFeature(r));
						b = m.getMBR();
						y = b.coordinates[0];
						r = b.coordinates[1];
						m = b.coordinates[2];
						D = b.coordinates[3]
					}
					b = y + (m - y) / 2;
					for (var O = r + (D - r) / 2, la = "NW N NE E SE S SW W".split(" "), y = [y, b, m, m, m, b, y, y], w = [D, D, D, O, r, r, r, O], ja = [-1, 1, 1, 1, 1, 1, -1, -1], U = [1, 1, 1, 1, -1, -1, -1, 1], na = [], r = 0; r < y.length; r++) {
						na.push(y[r]);
						na.push(w[r]);
						var D = E.resizePoints[r],
						sa = new a.geometry.Point(y[r], w[r], c.srid);
						D ? D !== S && D.setGeometry(sa) : (D = new a.layer.EditableFeature(this.id + "resizePoints" + la[r], sa, {
								selectivity: 0,
								renderingStyle: a.layer.EditableFeature.resizeHandleStyle
							}), D.parentFeature = this, D.correction = {
								x: ja[r],
								y: U[r]
							}, D.addListener(a.event.LayerEvent.FEATURE_MOVING, D.resizePointMoving), D.addListener(a.event.LayerEvent.FEATURE_MOVED, D.resizePointMoved), E.resizePoints.push(D), v.addFeature(D), D.anchor = 4 > r ? {
								x: y[r + 4],
								y: w[r + 4]
							}
							 : {
							x: y[r - 4],
							y: w[r -
								4]
						})
					}
					na.push(y[0]);
					na.push(w[0]);
					r = new a.geometry.LineString(na, c.srid);
					if (E.resizeMBR)
						E.resizeMBR.setGeometry(r);
					else {
						var N = new a.Feature(this.id + "resizePointsMBR", r, {
							selectivity: -1,
							renderingStyle: N
						}),
						wa = this.id + "resizePointsMBR";
						N.parentFeature = this;
						E.resizeMBR = N;
						N.addListener(a.event.MouseEvent.MOUSE_DOWN, function (a) {
							a.target.id === wa && (a.target.sendBackward(), a.evt.stopPropagation())
						});
						v.addFeature(N)
					}
					c = new a.geometry.Point(m + 20 * M.resolution, O, c.srid);
					E.rotateHandle ? E.rotateHandle !== S && E.rotateHandle.setGeometry(c) :
					(S = new a.layer.EditableFeature(this.id + "rotateHandle", c, {
							renderingStyle: a.layer.EditableFeature.rotateHandleStyle
						}), S.parentFeature = this, S.anchor = {
							x: b,
							y: O
						}, S.addListener(a.event.LayerEvent.FEATURE_MOVING, S.resizePointMoving), S.addListener(a.event.LayerEvent.FEATURE_MOVED, S.resizePointMoved), E.rotateHandle = S, v.addFeature(S))
				}
			}
		},
		calDistance: function () {
			var b = this.getGeometry(),
			c = null,
			c = "Polygon" === b.type || "MultiLineString" === b.type ? [b.coordinates] : "Polygon" === b.type ? b.coordinates : [[b.coordinates]],
			v =
				b.getDimension(),
			E = this.featureEditingProperties;
			if (!this.hideEditVertices(b))
				for (var M = 0, N = c.length; M < N; M++)
					for (var O = 0, y = c[M].length; O < y; O++) {
						var r = c[M][O].length / v;
						"Polygon" !== b.type && "MultiPolygon" !== b.type || r--;
						for (var m = 0; m < r; m++) {
							var D = m + 1;
							if (D === r && ("Polygon" === b.type || "MultiPolygon" === b.type))
								D = 0;
							else if (D === r)
								break;
							var S = E.shapePoints[M][O][m].geo.getX(),
							U = E.shapePoints[M][O][m].geo.getY(),
							w = E.shapePoints[M][O][D].geo.getX(),
							D = E.shapePoints[M][O][D].geo.getY(),
							ja = this.parentLayer.parentMap.getMapContext(),
							ja = ja.getUniverse().getZoomLevels()[ja.getZoomLevel()],
							S = (S - w) / ja.resolution,
							U = (U - D) / ja.resolution * ja.stretchRatio;
							E.possiblePoints[M][O][m].setVisible(Math.sqrt(S * S + U * U) >= a.layer.EditableFeature.NEAREST_DISTANCE)
						}
					}
		},
		startEditing: function () {
			if (!this.dragging && !a.notNull(this.parentFeature)) {
				var b = this.geo,
				c = a.layer.EditableFeature;
				this.editing = !0;
				if ("Point" !== b.type && "MultiPoint" !== b.type || !a.isNull(this.parentFeature))
					if ("OrientedPoint" === b.type && a.isNull(this.parentFeature))
						this.tool && (this.tool.currentPoint =
								this.geo.clone(), b = this.tool, b.textFeature && b.textFeature !== this && b.textFeature.parentLayer.deselectFeature(b.textFeature), a.tool.WhiteBoardTool.showDialog(this.parentLayer.parentMap, this.tool, this)), this.remove(), this.displayed = !1, this.deleteEditingProperties(), this.addEditProperties(!0);
					else if ("Polygon" === b.type || "LineString" === b.type || "MultiPolygon" === b.type || "MultiLineString" === b.type) {
						if (this.deleteEditingProperties(), this.addEditProperties(!0), !a.isNull(this.parentLayer) && !a.isNull(this.parentLayer.parentMap))
							this.parentLayer.parentMap.on(a.event.MapEvent.I_MAP_CENTER_ZOOM,
								this.calDistance, this)
					} else
						a.util.Logger.alert("MAPVIEWER_9010", "OM.EditableFeature.startEditing", "");
				else
					this.normalStyle = this.renderingStyle, this instanceof a.TextFeature ? a.notNull(this.editRenderingStyle) ? this.setRenderingStyle(this.editRenderingStyle) : this.setRenderingStyle(c.textStyle) : this.setRenderingStyle(this.parentLayer.getRenderingStyle_PointEditing() || c.pointStyle), this.deleteEditingProperties(), this.addEditProperties(!0)
			}
		},
		startDragging: function () {
			if (!this.dragging && !a.notNull(this.parentFeature)) {
				var b =
					this.geo;
				b instanceof a.geometry.Circle || b instanceof a.geometry.Rectangle || (this.editing = !0, "Point" !== b.type && "MultiPoint" !== b.type || !a.isNull(this.parentFeature) ? "OrientedPoint" === b.type && a.isNull(this.parentFeature) ? (this.tool && (this.tool.currentPoint = this.geo.clone(), b = this.tool, b.textFeature && b.textFeature !== this && b.textFeature.parentLayer.deselectFeature(b.textFeature), a.tool.WhiteBoardTool.showDialog(this.parentLayer.parentMap, this.tool, this)), this.remove(), this.displayed = !1, this.deleteEditingProperties(),
						this.addEditProperties(!0)) : a.util.Logger.alert("", a.EditableFeature.start) : (this.normalStyle = this.renderingStyle, this.deleteEditingProperties(), this.addEditProperties(!0)))
			}
		},
		deleteEditingProperties: function () {
			var b = this.featureEditingProperties;
			if (!a.isNull(b) && !a.isNull(this.parentLayer) && !a.isNull(this.parentLayer.parentMap)) {
				var da = this.parentLayer.parentMap.getDefaultFeatureLayer();
				da && da.group && a.$("#" + da.group._id).unbind();
				if (!a.isNull(b)) {
					var v,
					E,
					M,
					N,
					O,
					y;
					v = 0;
					for (N = b.shapePoints.length; v <
						N; v++)
						for (O = b.shapePoints[v].length, E = 0; E < O; E++)
							for (y = b.shapePoints[v][E].length, M = 0; M < y; M++)
								da.removeFeature(b.shapePoints[v][E][M]);
					b.shapePoints = [];
					v = 0;
					for (N = b.possiblePoints.length; v < N; v++)
						for (O = b.possiblePoints[v].length, E = 0; E < O; E++)
							for (y = b.possiblePoints[v][E].length, M = 0; M < y; M++)
								da.removeFeature(b.possiblePoints[v][E][M]);
					b.possiblePoints = [];
					if (b.resizePoints) {
						v = b.resizePoints.length;
						for (E = 0; E < v; E++)
							da.removeFeature(b.resizePoints[E]);
						b.resizePoints = []
					}
					b.resizeMBR && (da.removeFeature(b.resizeMBR),
						b.resizeMBR = c);
					b.transitFeature && (da.removeFeature(b.transitFeature), b.transitFeature = c);
					b.rotateHandle && (da.removeFeature(b.rotateHandle), b.rotateHandle = c);
					this.featureEditingProperties = null;
					this.contextMenu && !0 === this.contextMenu.show && this.contextMenu.removeRightClickMenu()
				}
			}
		},
		focusProperties: function (b) {
			var c = this.featureEditingProperties;
			if (a.isNull(c) && (a.notNull(this.parentFeature) && (c = this.parentFeature.featureEditingProperties), a.isNull(c)))
				return;
			var v = 0,
			E,
			M,
			N,
			O;
			if (this.isEditProperties(b,
					c)) {
				v = c.resizePoints.length;
				for (b = 0; b < v; b++)
					c.resizePoints[b].bringToTop();
				c.resizeMBR && c.resizeMBR.bringToTop()
			} else {
				v = c.shapePoints.length;
				for (E = 0; E < v; E++)
					for (M = c.shapePoints[E].length, b = 0; b < M; b++)
						for (N = c.shapePoints[E][b].length, O = 0; O < N; O++)
							c.shapePoints[E][b][O].bringToTop();
				v = c.possiblePoints.length;
				for (E = 0; E < v; E++)
					for (M = c.shapePoints[E].length, b = 0; b < M; b++)
						for (N = c.possiblePoints[E][b].length, O = 0; O < N; O++)
							c.possiblePoints[E][b][O].bringToTop()
			}
		},
		isEditProperties: function (b, c) {
			var v = b.id;
			if (a.isNull(c))
				return !1;
			if (c.resizePoints)
				for (var E = c.resizePoints.length, M = 0; M < E; M++)
					if (c.resizePoints[M].id === v)
						return !0;
			return c.resizeMBR && c.resizeMBR.id === v ? !0 : !1
		},
		shapePointMoved: function (b) {
			a.notNull(a.gv.allowFeaturePointsInteraction) && !1 === a.gv.allowFeaturePointsInteraction || (this.point_dragging = this.dragging = !1, a.isNull(this.parentFeature) && "Point" === this.geo.type ? (this.featurePointMoved_PointType(b, !0), b = new a.event.LayerEvent(a.event.LayerEvent.FEATURE_EDITED), this.fire(a.event.LayerEvent.FEATURE_EDITED, b)) :
				(this.parentFeature.featurePointMoved(b, !0), b = new a.event.LayerEvent(a.event.LayerEvent.FEATURE_EDITED, this.parentFeature), this.parentFeature.fire(a.event.LayerEvent.FEATURE_EDITED, b)))
		},
		possiblePointMoved: function (b) {
			a.notNull(a.gv.allowFeaturePointsInteraction) && !1 === a.gv.allowFeaturePointsInteraction || (this.point_dragging = this.dragging = !1, this.parentFeature.featurePointMoved(b, !1), b = new a.event.LayerEvent(a.event.LayerEvent.FEATURE_EDITED, this.parentFeature), this.parentFeature.fire(a.event.LayerEvent.FEATURE_EDITED,
					b))
		},
		resizePointMoved: function () {
			this.mbrMinX = this.mbrMaxX = null;
			if (!a.notNull(a.gv.allowFeaturePointsInteraction) || !1 !== a.gv.allowFeaturePointsInteraction) {
				var b = this.parentFeature,
				c = b.featureEditingProperties.transitFeature,
				v = c.getGeometry().clone();
				a.notNull(b.parentLayer.changeManager) && (v = b.parentLayer.changeManager.updateFeature(b.id, b, v, a.edit.EditChangeEvent.SPATIAL_UPDATE), a.notNull(v) && b.parentLayer.getUndoManager().addEdit({
						feature: b,
						changeManager: b.parentLayer.changeManager,
						editChangeEvent: v,
						canUndo: function () {
							return !0
						},
						canRedo: function () {
							return !0
						},
						getPresentationName: function () {
							return "feature transform"
						},
						undo: function () {
							this.changeManager.undo(this.editChangeEvent);
							var b = new a.event.LayerEvent(a.event.LayerEvent.FEATURE_EDITED, this.feature);
							this.feature.fire(a.event.LayerEvent.FEATURE_EDITED, b);
							this.feature.deleteEditingProperties();
							this.feature.selected && this.feature.addEditProperties()
						},
						redo: function () {
							this.changeManager.redo(this.editChangeEvent);
							var b = new a.event.LayerEvent(a.event.LayerEvent.FEATURE_EDITED,
									this.feature);
							this.feature.fire(a.event.LayerEvent.FEATURE_EDITED, b);
							this.feature.deleteEditingProperties();
							this.feature.selected && this.feature.addEditProperties()
						}
					}));
				b.setGeometry(c.getGeometry());
				c = new a.event.LayerEvent(a.event.LayerEvent.FEATURE_EDITED, b);
				b.fire(a.event.LayerEvent.FEATURE_EDITED, c);
				b.deleteEditingProperties();
				b.addEditProperties(!0)
			}
		},
		digHole: function () {
			console.info("hole")
		},
		deleteShapePoint: function (b) {
			if (!a.notNull(a.gv.allowFeaturePointsInteraction) || !1 !== a.gv.allowFeaturePointsInteraction) {
				var c =
					b.parentFeature,
				v = c.geo.dim,
				E = c.featureEditingProperties,
				M = b.parentLayer.parentMap.getDefaultFeatureLayer(),
				N = null,
				O = null,
				y = null,
				r = null,
				m = -1,
				D = 0,
				S = 0;
				b.ringIds && 2 < b.ringIds.length && (S = b.ringIds[0], D = b.ringIds[1]);
				var U = E.shapePoints[S][D],
				w = E.possiblePoints[S][D],
				ja;
				if ("Polygon" === c.geo.type || "LineString" === c.geo.type || "MultiPolygon" === c.geo.type || "MultiLineString" === c.geo.type) {
					m = U.length;
					if (2 >= m) {
						a.util.Logger.warning("MAPVIEWER_9011", "OM.EditableFeature.deleteShapePoint", "");
						return
					}
					if (("Polygon" ===
							c.geo.type || "MultiPolygon" === c.geo.type) && 3 >= m) {
						a.util.Logger.warning("MAPVIEWER_9012", "OM.EditableFeature.deleteShapePoint", "");
						return
					}
					for (; m--; )
						if (U[m] === b) {
							if (0 !== m && m !== U.length - 1)
								N = w[m - 1], y = U[m - 1], O = w[m], r = U[m + 1], ja = y.geo.getX() + (r.geo.getX() - y.geo.getX()) / 2, y = y.geo.getY() + (r.geo.getY() - y.geo.getY()) / 2, O.setGeometry(new a.geometry.Point(ja, y, b.geo.srid));
							else if ("Polygon" === c.geo.type || "MultiPolygon" === c.geo.type)
								0 === m ? (N = w[w.length - 1], y = U[U.length - 1], O = w[m], r = U[m + 1]) : m === U.length - 1 && (N = w[m -
											1], y = U[m - 1], O = w[m], r = U[0]), ja = y.geo.getX() + (r.geo.getX() - y.geo.getX()) / 2, y = y.geo.getY() + (r.geo.getY() - y.geo.getY()) / 2, O.setGeometry(new a.geometry.Point(ja, y, b.geo.srid));
							else if ("LineString" === c.geo.type || "MultiLineString" === c.geo.type)
								0 === m ? (O = w[m], M.removeFeature(O), w.splice(m, 1)) : m === U.length - 1 && (N = w[m - 1]);
							break
						}
				}
				for (O = 0; O < U.length; O++)
					if (U[O] === b) {
						U.splice(O, 1);
						M.removeFeature(b);
						break
					}
				if (N)
					for (O = 0; O < w.length; O++)
						if (w[O] === N) {
							w.splice(O, 1);
							M.removeFeature(N);
							break
						}
				N = c.geo.getOrdinates();
				U = [];
				for (M = 0; M < E.shapePoints.length; M++)
					for (U[M] = [], O = 0; O < E.shapePoints[M].length; O++) {
						U[M][O] = [];
						for (ja = 0; ja < E.shapePoints[M][O].length; ja++)
							if (E.shapePoints[M][O][ja].id = c.id + "shapePoints" + M + "_" + O + "_" + ja, U[M][O].push(E.shapePoints[M][O][ja].geo.getX()), U[M][O].push(E.shapePoints[M][O][ja].geo.getY()), 2 < v)
								for (y = 0, ja >= m && M === S && O === D && y++, r = 2; r < v; r++) {
									var la = 0;
									"MultiPolygon" === c.geo.type && (la = N[M][O][(ja + y) * v + r]);
									"Polygon" === c.geo.type ? la = N[O][(ja + y) * v + r] : "LineString" === c.geo.type ? la = N[(ja + y) * v + r] : "MultiLineString" ===
										c.geo.type && (la = N[O][(ja + y) * v + r]);
									U[M][O].push(la)
								}
						if ("Polygon" === c.geo.type || "MultiPolygon" === c.geo.type)
							if (U[M][O].push(E.shapePoints[M][O][0].geo.getX()), U[M][O].push(E.shapePoints[M][O][0].geo.getY()), 2 < v)
								for (ja = 2; ja < v; ja++)
									y = 0, y = "MultiPolygon" === c.geo.type ? N[M][O][N[M][O].length - v + ja] : N[O][N[O].length - v + ja], U[M][O].push(y)
					}
				var na;
				"Polygon" === c.geo.type ? na = new a.geometry.Polygon(U[0], c.geo.srid, v) : "MultiPolygon" === c.geo.type ? na = new a.geometry.MultiPolygon(U, c.geo.srid, v) : "MultiLineString" === c.geo.type ?
					na = new a.geometry.MultiLineString(U[0], c.geo.srid, v) : "LineString" === c.geo.type && (na = new a.geometry.LineString(U[0][0], c.geo.srid, v));
				m = na.clone();
				v = [];
				v.push(c);
				E = {};
				E[c.id] = m;
				if (c.parentLayer.hasSharedBoundary() && (m = [b.geo.getX(), b.geo.getY()], m = a.edit.GeometrySegmentUtil.getLayerSharedPoints(c, m), a.notNull(m)))
					for (D = 0; D < m.length; D++)
						S = m[D].getFeature().id, S !== c.id && (na = m[D].getFeature().getGeometry().clone(!0), a.edit.GeometrySegmentUtil.removeVertexFromGeometry(na, m[D]) && (v.push(m[D].getFeature()),
								E[S] = na));
				if (a.notNull(c.parentLayer.changeManager)) {
					m = a.edit.EditChangeEvent;
					1 < v.length && c.parentLayer.getUndoManager().startChangeBlock("feature point move");
					for (D = 0; D < v.length; D++)
						S = v[D], a.isNull(E[S.id]) || (na = c.parentLayer.changeManager.updateFeature(S.id, S, E[S.id], m.SPATIAL_UPDATE), a.notNull(na) && c.registerUpdate(na, S, c, "feature point delete"));
					1 < v.length && c.parentLayer.getUndoManager().endChangeBlock("feature point move")
				}
				for (m = 0; m < v.length; m++)
					D = v[m], D.setGeometry(E[D.id]);
				for (O = 0; O < w.length; O++)
					w[O].id =
						c.id + "possiblePoints" + O;
				b.parentFeature && (c = new a.event.LayerEvent(a.event.LayerEvent.FEATURE_EDITED, b.parentFeature), b.parentFeature.fire(a.event.LayerEvent.FEATURE_EDITED, c), b.parentFeature.addResizeHandles.apply(b.parentFeature))
			}
		},
		featurePointMoving: function (b, c) {
			this.refresh_dragging = !0;
			this.activeIndex = this.parentLayer.parentMap.getCursorLocation().wraparoundMapIndex;
			a.isNull(this.activeIndex) && (this.activeIndex = 0);
			if (!a.notNull(a.gv.allowFeaturePointsInteraction) || !1 !== a.gv.allowFeaturePointsInteraction) {
				var v =
					b.target.parentFeature,
				E = v.parentLayer.parentMap,
				M = new a.style.Line({
					stroke: "#8684F3",
					strokeThickness: 5,
					strokeOpacity: .5
				}),
				N = b.target.graphics,
				O = null,
				y = null;
				if (v && ("Polygon" === v.geo.type || "LineString" === v.geo.type || "MultiPolygon" === v.geo.type || "MultiLineString" === v.geo.type)) {
					c ? (1 > b.target.relatedFeature.length && v.calRelatedFeature(v.featureEditingProperties, b.target), O = b.target.relatedFeature[1], y = b.target.relatedFeature[3]) : (1 > b.target.relatedFeature.length && v.calRelatedFeature(v.featureEditingProperties,
							b.target), O = b.target.relatedFeature[1], y = b.target.relatedFeature[2]);
					var r = N.getLeftTop(O.parentLayer.group),
					m = N.getLeftTop(E.draggableGroup),
					D = b.orgEvt.pageX - E.$oracleMapDiv.offset().left - r.x - m.x,
					r = b.orgEvt.pageY - E.$oracleMapDiv.offset().top - r.y - m.y,
					m = O.parentLayer.group,
					S;
					v.editingLineBefore || v.editingLineAfter ? (O && (S = a.util.GeomUtil.screenPointsXOffset(O.screenPoints.x, this.activeIndex, E.getMapContext()), N.setPath(v.editingLineBefore, [[S, O.screenPoints.y, D, r]])), y && (S = a.util.GeomUtil.screenPointsXOffset(y.screenPoints.x,
									this.activeIndex, E.getMapContext()), N.setPath(v.editingLineAfter, [[S, y.screenPoints.y, D, r]]))) : (O && (S = a.util.GeomUtil.screenPointsXOffset(O.screenPoints.x, this.activeIndex, E.getMapContext()), v.editingLineBefore = N.drawPath([[S, O.screenPoints.y, D, r]], M, {
									group: m
								}), v.editingLineBefore.setStrokeDashArray([10]), O.bringToTop()), y && (S = a.util.GeomUtil.screenPointsXOffset(y.screenPoints.x, this.activeIndex, E.getMapContext()), v.editingLineAfter = N.drawPath([[S, y.screenPoints.y, D, r]], M, {
									group: m
								}), v.editingLineAfter.setStrokeDashArray([10]),
							y.bringToTop()), b.target.bringToTop())
				}
			}
		},
		featurePointMoved_PointType: function (b, c) {
			if (!a.notNull(a.gv.allowFeaturePointsInteraction) || !1 !== a.gv.allowFeaturePointsInteraction) {
				var v = b.target;
				if (a.notNull(v)) {
					var E = v.pointToSnap;
					a.notNull(E) && (v.geo.setPoint(E[0], E[1]), v.pointToSnap = null)
				}
				v.parentLayer.removeFromRtree(v);
				v.parentLayer.addToRtree(v);
				c && v.geo.getOrdinates();
				var E = v.geo.getOrdinates(),
				M = (new a.geometry.Point(E[0], E[1], v.geo.srid)).clone(),
				E = [];
				E.push(v);
				var N = {};
				N[v.id] = M;
				v.activeIdx =
					null;
				for (M = 0; M < E.length; M++) {
					var O = E[M];
					O.setGeometry(N[O.id]);
					v.parentLayer.parentMap.wraparound && (O.parentLayer.refresh(), v.parentLayer.parentMap.getLayerByName("ii_oracle_maps_internal_editing").refresh())
				}
			}
		},
		featurePointMoved: function (b, c) {
			if (!a.notNull(a.gv.allowFeaturePointsInteraction) || !1 !== a.gv.allowFeaturePointsInteraction) {
				var v = b.target,
				E = v.parentFeature;
				if (0 !== v.relatedFeature.length) {
					v.graphics.remove(this.editingLineBefore);
					this.editingLineBefore = null;
					v.graphics.remove(this.editingLineAfter);
					this.editingLineAfter = null;
					var M = !1;
					if (a.notNull(E)) {
						var N = E.pointToSnap;
						a.notNull(N) && (v.geo.setPoint(N[0], N[1]), E.pointToSnap = null, M = !0)
					}
					var O = E.geo.dim,
					y = E.featureEditingProperties,
					N = E.parentLayer.parentMap.getDefaultFeatureLayer(),
					r = a.layer.EditableFeature,
					m = a.event.LayerEvent;
					E.parentLayer.removeFromRtree(v);
					E.parentLayer.addToRtree(v);
					var D = N.parentMap.getMapContext(),
					S = D.getUniverse().getZoomLevels()[D.getZoomLevel()],
					U,
					w,
					ja,
					la,
					na,
					sa,
					wa,
					Aa,
					D = null,
					Oa,
					Ha,
					tb;
					if (c) {
						if ("Polygon" === E.geo.type || "LineString" ===
							E.geo.type || "MultiPolygon" === E.geo.type || "MultiLineString" === E.geo.type)
							D = [], "MultiPolygon" === E.geo.type ? D = E.geo.getOrdinates() : "MultiLineString" === E.geo.type ? D = [E.geo.getOrdinates()] : "Polygon" === E.geo.type ? D = [E.geo.getOrdinates()] : "LineString" === E.geo.type && (D = [[E.geo.getOrdinates()]]), r = E.geo.getDimension(), Oa = b.target.ringIds[0], Ha = b.target.ringIds[1], tb = b.target.ringIds[2], D = [D[Oa][Ha][tb * r], D[Oa][Ha][tb * r + 1]], U = v.geo.getX() + (b.target.relatedFeature[1].geo.getX() - v.geo.getX()) / 2, w = v.geo.getY() +
								(b.target.relatedFeature[1].geo.getY() - v.geo.getY()) / 2, b.target.relatedFeature[0].setGeometry(new a.geometry.Point(U, w, v.geo.srid)), ja = v.geo.getX(), la = v.geo.getY(), na = b.target.relatedFeature[1].geo.getX(), w = b.target.relatedFeature[1].geo.getY(), na = (ja - na) / S.resolution, w = (la - w) / S.resolution * S.stretchRatio, w = Math.sqrt(na * na + w * w), w < a.layer.EditableFeature.NEAREST_DISTANCE ? b.target.relatedFeature[0].setVisible(!1) : b.target.relatedFeature[0].setVisible(!0), b.target.relatedFeature[3] && (U = v.geo.getX() + (b.target.relatedFeature[3].geo.getX() -
										v.geo.getX()) / 2, w = v.geo.getY() + (b.target.relatedFeature[3].geo.getY() - v.geo.getY()) / 2, b.target.relatedFeature[2].setGeometry(new a.geometry.Point(U, w, v.geo.srid)), na = b.target.relatedFeature[3].geo.getX(), w = b.target.relatedFeature[3].geo.getY(), na = (ja - na) / S.resolution, w = (la - w) / S.resolution * S.stretchRatio, w = Math.sqrt(na * na + w * w), w < a.layer.EditableFeature.NEAREST_DISTANCE ? b.target.relatedFeature[2].setVisible(!1) : b.target.relatedFeature[2].setVisible(!0))
					} else if ("Polygon" === E.geo.type || "LineString" ===
						E.geo.type || "MultiPolygon" === E.geo.type || "MultiLineString" === E.geo.type) {
						wa = b.target.relatedFeature[0];
						Aa = b.target.relatedFeature[3];
						Oa = sa = b.target.relatedFeature[4];
						Ha = Aa;
						tb = wa;
						y.shapePoints[sa][Aa].splice(wa + 1, 0, v);
						v.setRenderingStyle(r.pointStyle);
						v.addListener(m.FEATURE_MOVING, v.possiblePointMoving);
						v.addListener(m.FEATURE_MOVING, v.shapePointMoving);
						v.deleteListener(m.FEATURE_MOVED, v.possiblePointMoved);
						v.addListener(m.FEATURE_MOVED, v.shapePointMoved);
						v.addListener(a.event.MouseEvent.MOUSE_RIGHT_CLICK,
							v.showContextMenu);
						for (ja = 0; ja < y.shapePoints[sa][Aa].length; ja++)
							y.shapePoints[sa][Aa][ja].id = E.id + "shapePoints" + sa + "_" + Aa + "_" + ja;
						D = b.target.relatedFeature[1].geo.getX();
						ja = b.target.relatedFeature[1].geo.getY();
						la = b.target.relatedFeature[2].geo.getX();
						U = b.target.relatedFeature[2].geo.getY();
						D = [D + (la - D) / 2, ja + (U - ja) / 2];
						ja = b.target.relatedFeature[1].geo;
						la = v.geo;
						U = ja.getX() + (la.getX() - ja.getX()) / 2;
						w = ja.getY() + (la.getY() - ja.getY()) / 2;
						U = new a.layer.EditableFeature(E.id + "possiblePoints" + sa + "_" + Aa + "_" + wa,
								new a.geometry.Point(U, w, v.geo.srid), {
								selectivity: 20,
								renderingStyle: r.pointStyle
							});
						U.parentFeature = E;
						U.addListener(m.FEATURE_MOVING, U.possiblePointMoving);
						U.addListener(m.FEATURE_MOVED, U.possiblePointMoved);
						N.addFeature(U);
						y.possiblePoints[sa][Aa].splice(wa, 1, U);
						ja = v.geo.getX();
						la = v.geo.getY();
						na = b.target.relatedFeature[1].geo.getX();
						w = b.target.relatedFeature[1].geo.getY();
						na = (ja - na) / S.resolution;
						w = (la - w) / S.resolution * S.stretchRatio;
						w = Math.sqrt(na * na + w * w);
						w < a.layer.EditableFeature.NEAREST_DISTANCE ?
						U.setVisible(!1) : U.setVisible(!0);
						U = v.geo.getX() + (b.target.relatedFeature[2].geo.getX() - v.geo.getX()) / 2;
						w = v.geo.getY() + (b.target.relatedFeature[2].geo.getY() - v.geo.getY()) / 2;
						U = new a.layer.EditableFeature(E.id + "possiblePoints" + sa + "_" + Aa + "_" + y.possiblePoints[sa][Aa].length, new a.geometry.Point(U, w, v.geo.srid), {
							selectivity: 20,
							renderingStyle: r.pointStyle
						});
						U.parentFeature = E;
						U.addListener(m.FEATURE_MOVING, U.possiblePointMoving);
						U.addListener(m.FEATURE_MOVED, U.possiblePointMoved);
						N.addFeature(U);
						y.possiblePoints[sa][Aa].splice(wa +
							1, 0, U);
						na = b.target.relatedFeature[2].geo.getX();
						w = b.target.relatedFeature[2].geo.getY();
						na = (ja - na) / S.resolution;
						w = (la - w) / S.resolution * S.stretchRatio;
						w = Math.sqrt(na * na + w * w);
						w < a.layer.EditableFeature.NEAREST_DISTANCE ? U.setVisible(!1) : U.setVisible(!0);
						S = 0;
						for (m = y.possiblePoints.length; S < m; S++)
							for (ja = 0, wa = y.possiblePoints[S].length; ja < wa; ja++)
								for (sa = 0, Aa = y.possiblePoints[S][ja].length; sa < Aa; sa++)
									y.possiblePoints[S][ja][sa].id = E.id + "possiblePoints" + S + "_" + ja + "_" + sa, y.possiblePoints[S][ja][sa].setRenderingStyle(r.possibleStyle)
					} else
						"Point" ===
						E.geo.type && (v.addListener(m.FEATURE_MOVING, v.shapePointMoving), v.addListener(m.FEATURE_MOVED, v.shapePointMoved));
					r = E.geo.getOrdinates();
					Aa = [];
					S = 0;
					for (m = y.shapePoints.length; S < m; S++)
						for (Aa[S] = [], ja = 0, wa = y.shapePoints[S].length; ja < wa; ja++) {
							Aa[S][ja] = [];
							sa = 0;
							for (la = y.shapePoints[S][ja].length; sa < la; sa++)
								if (U = y.shapePoints[S][ja][sa].geo, Aa[S][ja].push(U.getX()), Aa[S][ja].push(U.getY()), 2 < O)
									for (U = 0, !c && sa > tb + 1 && S === Oa && ja === Ha && U--, w = 2; w < O; w++)
										na = 0, c || sa !== tb + 1 || S !== Oa || ja !== Ha ? ("MultiPolygon" === E.geo.type &&
											(na = r[S][ja][(sa + U) * O + w]), "Polygon" === E.geo.type ? na = r[ja][(sa + U) * O + w] : "LineString" === E.geo.type ? na = r[(sa + U) * O + w] : "MultiLineString" === E.geo.type && (na = r[ja][(sa + U) * O + w]), Aa[S][ja].push(na)) : Aa[S][ja].push(0);
							if (("Polygon" === E.geo.type || "MultiPolygon" === E.geo.type) && y.shapePoints[S][ja]instanceof Array && (sa = y.shapePoints[S][ja][0].geo, Aa[S][ja].push(sa.getX()), Aa[S][ja].push(sa.getY()), 2 < O))
								for (sa = 2; sa < O; sa++)
									la = 0, la = "MultiPolygon" === E.geo.type ? r[S][ja][r[S][ja].length - O + sa] : r[ja][r[ja].length - O + sa],
									Aa[S][ja].push(la)
						}
					var yb;
					"MultiPolygon" === E.geo.type && (yb = new a.geometry.MultiPolygon(Aa, E.geo.srid, O));
					"Polygon" === E.geo.type ? yb = new a.geometry.Polygon(Aa[0], E.geo.srid, O) : "LineString" === E.geo.type ? yb = new a.geometry.LineString(Aa[0][0], E.geo.srid, O) : "MultiLineString" === E.geo.type && (yb = new a.geometry.MultiLineString(Aa[0], E.geo.srid, O));
					y = yb.clone();
					yb = [];
					yb.push(E);
					O = {};
					O[E.id] = y;
					if (E.parentLayer.hasSharedBoundary() && (y = a.edit.GeometrySegmentUtil.getLayerSharedPoints(E, [D[0], D[1]]), a.notNull(y) &&
							0 < y.length))
						for (Oa = 0; Oa < y.length; Oa++)
							Ha = y[Oa].getFeature(), D = Ha.id, D !== E.id && (tb = y[Oa].getPointLocation(), r = Ha.getGeometry().clone(!0), 2 === tb ? (y[Oa].setPoint([v.geo.getX(), v.geo.getY()]), a.edit.GeometrySegmentUtil.addVertexToGeometry(r, y[Oa]) && (yb.push(Ha), O[D] = r)) : a.edit.GeometrySegmentUtil.moveGeometryVertex(r, y[Oa], [v.geo.getX(), v.geo.getY()]) && (yb.push(Ha), O[D] = r));
					if (a.notNull(E.parentLayer.changeManager)) {
						v = a.edit.EditChangeEvent;
						1 < yb.length && E.parentLayer.getUndoManager().startChangeBlock("feature point move");
						for (y = 0; y < yb.length; y++)
							Oa = yb[y], a.isNull(O[Oa.id]) || (Ha = E.parentLayer.changeManager.updateFeature(Oa.id, Oa, O[Oa.id], v.SPATIAL_UPDATE), a.notNull(Ha) && E.registerUpdate(Ha, Oa, E, "feature point move"));
						1 < yb.length && E.parentLayer.getUndoManager().endChangeBlock("feature point move")
					}
					E.activeIdx = null;
					for (v = 0; v < yb.length; v++)
						y = yb[v], y.setGeometry(O[y.id]), E.parentLayer.parentMap.wraparound && (y.parentLayer.refresh(), E.parentLayer.parentMap.getLayerByName("ii_oracle_maps_internal_editing").refresh());
					a.notNull(N) &&
					M && N.refresh();
					this.addResizeHandles()
				}
			}
		}
	});
	a.layer.EditableFeature.MARKER_SIZE = 10;
	a.layer.EditableFeature.NEAREST_DISTANCE = 35;
	if (a.browser.touchSupported || a.gv.isWin8Touch)
		a.layer.EditableFeature.MARKER_SIZE = 20, a.layer.EditableFeature.NEAREST_DISTANCE = 50;
	a.layer.EditableFeature.POINT_BACKGROUND = new a.style.Marker({
		width: 30,
		height: 30,
		vectorDef: [{
				shape: {
					type: "rectangle",
					x: 0,
					y: 0,
					width: 30,
					height: 30
				},
				style: {
					fill: "#ffffff",
					stroke: "#0000ff",
					strokeThickness: 1,
					fillOpacity: 0,
					strokeOpacity: 0
				}
			}
		]
	});
	a.layer.EditableFeature.ORIENTEDPOINT_BACKGROUND =
		new a.style.Marker({
			width: 70,
			height: 70,
			vectorDef: [{
					shape: {
						type: "rectangle",
						x: 0,
						y: 0,
						width: 70,
						height: 70
					},
					style: {
						fill: "#ffffff",
						stroke: "#0000ff",
						strokeThickness: 1,
						fillOpacity: 0,
						strokeOpacity: 0
					}
				}
			]
		});
	a.layer.EditableFeature.ORIENTATION_POINT_STYLE = new a.style.Marker({
		styleName: "_orientationPointStyle",
		width: a.layer.EditableFeature.MARKER_SIZE,
		height: a.layer.EditableFeature.MARKER_SIZE,
		vectorDef: [{
				shape: {
					type: "circle",
					cx: a.layer.EditableFeature.MARKER_SIZE / 2,
					cy: a.layer.EditableFeature.MARKER_SIZE / 2
				},
				style: {
					fill: "#ffffff",
					stroke: "#0000ff",
					strokeThickness: 1
				}
			}
		]
	});
	a.layer.EditableFeature.ORIENTATION_LINE_STYLE = new a.style.Line({
		styleName: "_orientationLinetyle",
		stroke: "#0000ff",
		strokeThickness: 1
	});
	a.layer.EditableFeature.pointStyle = new a.style.Marker({
		width: a.layer.EditableFeature.MARKER_SIZE,
		height: a.layer.EditableFeature.MARKER_SIZE,
		vectorDef: [{
				shape: {
					type: "circle",
					x: 0,
					y: 0,
					width: a.layer.EditableFeature.MARKER_SIZE,
					height: a.layer.EditableFeature.MARKER_SIZE
				},
				style: {
					fill: "#ffffff",
					fillOpacity: 1,
					stroke: "#027BC7",
					strokeThickness: 1
				}
			}
		]
	});
	a.layer.EditableFeature.possibleStyle = new a.style.Marker({
		width: a.layer.EditableFeature.MARKER_SIZE,
		height: a.layer.EditableFeature.MARKER_SIZE,
		vectorDef: [{
				shape: {
					type: "circle",
					x: 0,
					y: 0,
					width: a.layer.EditableFeature.MARKER_SIZE,
					height: a.layer.EditableFeature.MARKER_SIZE
				},
				style: {
					fill: "#ffffff",
					stroke: "#878C90",
					strokeThickness: 1,
					fillOpacity: 1,
					strokeOpacity: 2
				}
			}
		]
	});
	a.layer.EditableFeature.resizeHandleStyle = new a.style.Marker({
		width: a.layer.EditableFeature.MARKER_SIZE,
		height: a.layer.EditableFeature.MARKER_SIZE,
		vectorDef: [{
				shape: {
					type: "circle",
					x: 0,
					y: 0,
					width: a.layer.EditableFeature.MARKER_SIZE,
					height: a.layer.EditableFeature.MARKER_SIZE
				},
				style: {
					fill: "#ffffff",
					stroke: "#ff00ff",
					strokeThickness: 1,
					fillOpacity: .75,
					strokeOpacity: 1
				}
			}
		]
	});
	a.layer.EditableFeature.rotateHandleStyle = new a.style.Marker({
		width: a.layer.EditableFeature.MARKER_SIZE,
		height: a.layer.EditableFeature.MARKER_SIZE,
		vectorDef: [{
				shape: {
					type: "circle",
					cx: 0,
					cy: 0,
					width: a.layer.EditableFeature.MARKER_SIZE,
					height: a.layer.EditableFeature.MARKER_SIZE
				},
				style: {
					fill: "#ffffff",
					stroke: "#ff00ff",
					strokeThickness: 1,
					fillOpacity: .75,
					strokeOpacity: 1
				}
			}
		]
	});
	a.layer.EditableFeature.bgPolyStyle = new a.style.Color({
		styleName: "polygonToolStyle",
		fillOpacity: 0,
		fill: "#8D8DFF",
		stroke: "#C0C0C0",
		strokeThickness: 15,
		strokeOpacity: 0
	});
	a.layer.EditableFeature.bgLineStyle = new a.style.Line({
		styleName: "polygonToolStyle",
		fillOpacity: 0,
		fill: "#8D8DFF",
		stroke: "#C0C0C0",
		strokeThickness: 15,
		strokeOpacity: 0
	});
	a.layer.EditableFeature.textStyle = new a.style.Text({
		styleName: "editableTextStyle",
		fill: "#000000",
		stroke: "#C0C0C0",
		fontFamily: "Arial",
		fontStyle: a.Text.FONTSTYLE_ITALIC
	});
	a.layer.XMLMapLayer = a.layer.Layer.extend({
		setXMLRequest: function (a) {
			this.xmlRequest = a
		}
	});
	a.layer.OSMTileLayer = a.layer.TileLayer.extend({
		initialize: function da(b, c, M, N) {
			da.base.call(this, b, {
				tileLayerConfig: a.layer.TileLayerConfig.CONFIG_OSM,
				getTileURL: function (b, v, r, m) {
					r = this.tileLayerConfig.tileImageHeight;
					var D = this.tileLayerConfig.zoomLevels[b];
					m = (this.tileLayerConfig.bounds.getMaxY() - m.getMaxY()) / D.resolution / r;
					r = null;
					if (a.isNull(c)) {
						r =
							"a";
						switch ((v + m) % 3) {
						case 1:
							r = "b";
							break;
						case 2:
							r = "c"
						}
						r = a.gv.secureHttp() + "//" + r + ".tile.openstreetmap.org/" + b + "/" + v + "/" + m + ".png"
					} else
						r = (v + m) % c.length, r = c[r], r = !0 === this.isInZYXOrder ? r + "/" + b + "/" + m + "/" + v : r + "/" + b + "/" + v + "/" + m, r = a.isNull(M) ? r + ".png" : "." === M[0] ? r + M : r + ("." + M);
					if (a.notNull(N)) {
						b = "?";
						for (var da in N)
							N.hasOwnProperty(da) && (r = r + b + da + "\x3d" + N[da], b = "\x26")
					}
					return r
				}
			})
		},
		setInZYXOrder: function (a) {
			if (!0 === a || "true" === a.toLowerCase)
				this.isInZYXOrder = !0
		}
	});
	a.layer.Menu = a.Class.extend({
		initialize: function (b,
			c) {
			var E = this;
			this.map = b;
			this.menuId = "menu_0";
			this.menuTableId = "mvmenu_table_0";
			this.menuTableBodyId = "mvmenu_table_body_0";
			this.show = !1;
			this.location = c;
			for (var M = 0; M < this.map.decorationArray.length; M++)
				this.map.decorationArray[M] && "menu_0" == this.map.decorationArray[M].sblx && this.map.removeMapDecoration(this.map.decorationArray[M]);
			this.menu = new a.control.MapDecoration("\x3ctable id\x3d'" + this.menuTableId + "' cellpadding\x3d0 cellspacing\x3d0 style\x3d'width:0px'\x3e\x3ctr\x3e\x3ctd style\x3d'border-width:0px;border-style:solid;border-color:black;background-color:white'\x3e\x3ctable width\x3d100%\x3e\x3ctbody id\x3d'" +
					this.menuTableBodyId + "'\x3e\x3c/tbody\x3e\x3c/table\x3e\x3c/td\x3e\x3c/tr\x3e\x3c/table\x3e", {
					offsetX: c.left,
					offsetY: c.top
				}, {
					draggable: !0,
					panelOptions: {
						style: {
							"border-style": "solid",
							"border-color": "#0000ff",
							"border-width": "1px",
							backgroundColor: "#FDFDFD",
							filter: "alpha(Opacity\x3d80)",
							"-moz-opacity": "0.8",
							opacity: "0.8"
						}
					}
				});
			this.menu.sblx = "menu_0";
			this.map.addMapDecoration(this.menu);
			a.layer.Menu.count += 1;
			this.removeRightClickMenu = function () {
				E.menu && E.show && (E.map.removeMapDecoration(E.menu), E.map.deleteListener(a.event.MouseEvent.MOUSE_CLICK,
						E.removeRightClickMenu), E.menu = null, E.show = !1)
			};
			this.map.on(a.event.MouseEvent.MOUSE_CLICK, E.removeRightClickMenu)
		},
		addMenuItem: function (b, c, E) {
			var M = document.getElementById(this.menuTableBodyId),
			N,
			O;
			a.notNull(E) && (N = E.width, O = E.fontSize);
			document.getElementById(this.menuTableId).style.width = a.notNull(N) ? N : 12 * b.length + "px";
			E = document.createElement("tr");
			M.appendChild(E);
			E.style.fontFamily = "Arial, Helvetica, Geneva, sans-serif";
			E.style.fontSize = a.notNull(O) ? O : "12px";
			E.style.cursor = "pointer";
			E.align =
				"center";
			M = document.createElement("td");
			M.innerHTML = b;
			E.appendChild(M);
			E.onmouseover = function () {
				this.style.backgroundColor = "#336699";
				this.style.color = "#ffffff"
			};
			E.onmouseout = function () {
				this.style.backgroundColor = "transparent";
				this.style.color = "#000000"
			};
			if (c) {
				b = function (a) {
					a.stopPropagation();
					a.preventDefault();
					y.removeRightClickMenu();
					c()
				};
				var y = this;
				a.browser.touchSupported ? a.$(E).bind("touchstart", b) : a.$(E).mousedown(b)
			}
		}
	});
	a.layer.Menu.count = 0;
	a.layer.VectorLayerHeatMap = a.Class.extend({
		initialize: function (b,
			c) {
			this.opacity = b && 0 < b.opacity && 1 > b.opacity ? b.opacity : 1;
			a.browser.android && 4 >= a.browser.androidVersion && (this.opacity = 1);
			this.initColor(b.colorStops);
			this.vectorLayer = c;
			this.maxValue = b.maxValue;
			this.minValue = b.minValue;
			this.loadingBoundaray = !1;
			this.scale = b.sampleFactor;
			this.bigCanvas = this.smallCanvas = null;
			var E = this;
			(this.containerVectorLayer = b.containerVectorLayer) && a.isNull(this.containerVectorLayer.serverURL) && (this.containerVectorLayer.serverURL = c.parentMap.mapviewerURL);
			if (this.containerVectorLayer &&
				!this.containerVectorLayer.dataLoaded && !this.containerVectorLayer.loading && !this.containerVectorLayer.usedInOverview)
				E.containerVectorLayer.parentMap = E.vectorLayer.parentMap, E.loadingBoundaray = !0, E.containerVectorLayer.dataBufferWindow = E.vectorLayer.dataBufferWindow, E.containerVectorLayer.getThemeData(null, function () {
					E.containerVectorLayer.loading = !1;
					E.loadingBoundaray = !1
				}, function () {
					E.containerVectorLayer.loading = !1;
					E.loadingBoundaray = !1
				});
			else if (this.containerVectorLayer) {
				E.loadingBoundaray = !0;
				var M = function () {
					E.containerVectorLayer.dataLoaded ? E.loadingBoundaray = !1 : setTimeout(M, 100)
				};
				M()
			}
		},
		init: function (a, b, c, M, N) {
			this.realWidth = a;
			this.realHeight = b;
			this.width = a;
			this.height = b;
			1 < this.scale && (this.width = a / this.scale, this.height = b / this.scale);
			this.width |= 0;
			this.height |= 0;
			this.minX = c;
			this.minY = M;
			this.data = [];
			this.realMaxValue = Number.NEGATIVE_INFINITY;
			this.realMinValue = Number.POSITIVE_INFINITY;
			a = N / this.scale;
			this.radius = 1 < a ? Math.floor(a) : 1;
			50 < this.radius && (this.radius = 50);
			this.smallCanvas && (a =
					this.smallCanvas, a.width !== this.width || a.height !== this.height) && (this.smallCanvas = null);
			this.sX = parseInt(c / this.scale);
			this.sY = parseInt(M / this.scale)
		},
		addData: function (a, b, c) {
			this.data[a] || (this.data[a] = []);
			this.data[a][b] || (this.data[a][b] = {
					num: 0,
					value: 0
				});
			var M = this.data[a][b].num;
			c = this.isValued ? (this.data[a][b].value * M + c) / (M + 1) : this.data[a][b].value + c;
			this.data[a][b] = {
				num: M + 1,
				value: c
			};
			c > this.realMaxValue && (this.realMaxValue = c);
			c < this.realMinValue && (this.realMinValue = c)
		},
		drawHeatMap: function (b) {
			this.numClass =
				this.origNum;
			this.max = this.realMaxValue;
			this.min = this.realMinValue;
			a.notNull(this.maxValue) && (this.max = this.maxValue, this.maxValue < this.realMaxValue && this.numClass--);
			a.notNull(this.minValue) && (this.min = this.minValue, this.minValue > this.realMinValue && this.numClass--);
			0 >= this.numClass && (this.numClass = 1);
			this.step = (this.max - this.min) / this.numClass;
			var c = this.drawShrunkenMap(),
			E = document.createElement("canvas");
			E.width = this.realWidth;
			E.height = this.realHeight;
			var M = E.getContext("2d");
			(!a.browser.android ||
				4 < a.browser.androidVersion) && this.clip(M);
			1 < this.scale ? (M = Math.round(this.scale / 2), b(E, c, 0, 0, this.width, this.height, 0 - M, 0 - M, this.realWidth - this.scale / 2, this.realHeight - this.scale / 2)) : b(E, c, 0, 0, this.width, this.height, 0, 0, this.realWidth, this.realHeight)
		},
		initColor: function (a) {
			var b = document.createElement("canvas");
			b.width = "1";
			b.height = "256";
			for (var b = b.getContext("2d"), c = b.createLinearGradient(0, 0, 1, 256), M = a.length, N = 0; N < M; N++)
				c.addColorStop(N / M, a[N]);
			b.fillStyle = c;
			b.fillRect(0, 0, 1, 256);
			this.colorData =
				b.getImageData(0, 0, 1, 256).data;
			this.origNum = M
		},
		drawShrunkenMap: function () {
			var b = this.smallCanvas;
			b || (b = document.createElement("canvas"), b.width = this.width, b.height = this.height, this.smallCanvas = b);
			var c = b.getContext("2d");
			c.clearRect(0, 0, b.width, b.height);
			console && console.time && a.util.Logger.finest("", "OM.VectorLayerHeatMap.drawShrunkenMap", console.time("computingHeatMap"));
			b = this.calculateHeatMap(b, c);
			console && console.timeEnd && a.util.Logger.finest("", "OM.VectorLayerHeatMap.drawShrunkenMap", console.timeEnd("computingHeatMap"));
			return b
		},
		calculateHeatMap: function (a, b) {
			this.isValued ? this.metricHeatMap3(a, b) : this.classicalHeatMap(b);
			for (var c = b.getImageData(0, 0, this.width, this.height), M = c.data, N = M.length, O = 3; O < N; O += 4) {
				var y = M[O];
				0 !== y && (y *= 4, M[O - 3] = this.colorData[y], M[O - 2] = this.colorData[y + 1], M[O - 1] = this.colorData[y + 2], M[O] = 255)
			}
			c.data = M;
			b.putImageData(c, 0, 0);
			return a
		},
		classicalHeatMap: function (a) {
			for (var b = 0; b < this.width; b++)
				for (var c = 0; c < this.height; c++) {
					var M = b + this.sX,
					N = c + this.sY;
					this.data[M] && this.data[M][N] && (M = this.data[M][N].value /
							this.max, N = a.createRadialGradient(b, c, 0, b, c, this.radius), N.addColorStop(0, "rgba(0,0,0," + M + ")"), N.addColorStop(1, "rgba(0,0,0,0)"), a.fillStyle = N, a.beginPath(), a.arc(b, c, this.radius, 0, 2 * Math.PI, !0), a.closePath(), a.fill())
				}
		},
		metricHeatMap: function (a) {
			var b = this.radius;
			3 > b && (b = 3);
			var c = document.createElement("canvas");
			c.width = 2 * b;
			c.height = 2 * b;
			for (var M = c.getContext("2d"), N = 0; N < this.width; N++)
				for (var O = 0; O < this.height; O++) {
					var y = N + this.sX,
					r = O + this.sY;
					if (this.data[y] && this.data[y][r]) {
						y = this.data[y][r].value /
							this.max;
						r = M.createRadialGradient(b, b, 0, b, b, b);
						r.addColorStop(0, "rgba(0,0,0," + y + ")");
						r.addColorStop(1, "rgba(0,0,0,0)");
						M.fillStyle = r;
						M.beginPath();
						M.arc(b, b, b, 0, 2 * Math.PI, !0);
						M.closePath();
						M.fill();
						for (var y = M.getImageData(0, 0, 2 * b, 2 * b).data, r = a.getImageData(N - b, O - b, 2 * b, 2 * b), m = r.data, D = 3, S = y.length; D < S; D += 4)
							m[D] = Math.max(y[D], m[D]);
						r.data = m;
						a.putImageData(r, N - b, O - b);
						M.clearRect(0, 0, c.width, c.height)
					}
				}
		},
		metricHeatMap2: function (a, b) {
			var c = this.radius;
			3 > c && (c = 3);
			var M = document.createElement("canvas"),
			N = 2 * c;
			M.width = N;
			M.height = N;
			for (var M = M.getContext("2d"), O = b.getImageData(0, 0, a.width, a.height), y = O.data, r = a.width, m = 0; m < this.width; m++)
				for (var D = 0; D < this.height; D++) {
					var S = m + this.sX,
					U = D + this.sY;
					if (this.data[S] && this.data[S][U]) {
						S = this.data[S][U].value / this.max;
						U = M.createRadialGradient(c, c, 0, c, c, c);
						U.addColorStop(0, "rgba(0,0,0," + S + ")");
						U.addColorStop(1, "rgba(0,0,0,0)");
						M.fillStyle = U;
						M.beginPath();
						M.arc(c, c, c, 0, 2 * Math.PI, !0);
						M.closePath();
						M.fill();
						for (var w = M.getImageData(0, 0, 2 * c, 2 * c).data, U = 0; U < N; U++)
							for (S =
									0; S < N; S++) {
								var ja = 4 * ((D - c + U) * r + (m - c + S));
								0 > ja || (y[ja + 3] = Math.max(w[4 * (U * N + S) + 3], y[ja + 3]))
							}
						M.clearRect(0, 0, N, N)
					}
				}
			O.data = y;
			b.putImageData(O, 0, 0)
		},
		metricHeatMap3: function (a, b) {
			var c = this.radius;
			3 > c && (c = 3);
			var M = document.createElement("canvas"),
			N = 2 * c;
			M.width = N;
			M.height = N;
			var O = M.getContext("2d"),
			M = b.getImageData(0, 0, a.width, a.height),
			y = M.data,
			r = a.width,
			m = O.createRadialGradient(c, c, 0, c, c, c);
			m.addColorStop(0, "rgba(0,0,0,1)");
			m.addColorStop(1, "rgba(0,0,0,0)");
			O.fillStyle = m;
			O.beginPath();
			O.arc(c, c, c, 0, 2 * Math.PI,
				!0);
			O.closePath();
			O.fill();
			O = O.getImageData(0, 0, 2 * c, 2 * c).data;
			for (m = 0; m < this.width; m++)
				for (var D = 0; D < this.height; D++) {
					var S = m + this.sX,
					U = D + this.sY;
					if (this.data[S] && this.data[S][U]) {
						var w = this.data[S][U].value / this.max;
						1 < w && (w = 1);
						for (U = 0; U < N; U++)
							for (S = 0; S < N; S++) {
								var ja = 4 * ((D - c + U) * r + (m - c + S));
								0 > ja || (y[ja + 3] = Math.max(parseInt(O[4 * (U * N + S) + 3] * w), y[ja + 3]))
							}
					}
				}
			M.data = y;
			b.putImageData(M, 0, 0)
		},
		clip: function (b) {
			if (this.containerVectorLayer) {
				var c = this.vectorLayer.parentMap.getMapContext().getTransform(),
				E = this.containerVectorLayer.size();
				if (0 === E)
					this.clipByBounds(b);
				else {
					b.beginPath();
					for (var M = 0; M < E; M++) {
						var N = this.containerVectorLayer.featureArray[M].getGeometry(),
						O = N.getMBR(),
						y = this.vectorLayer.dataBufferWindow;
						if (!a.notNull(O) || !(O.maxX < y.x || O.maxY < y.y || O.minX > y.x + y.w || O.minY > y.y + y.h)) {
							var r,
							m,
							D;
							if ("Polygon" === N.type)
								for (O = N.coordinates.slice(0), r = 0; 1 > r; r++) {
									if (y = O[r].slice(0), y = c.transformHeatMapSegment(y, 1, N.dim, this.minX, this.minY, 1))
										if (m = y.length, !(6 > m))
											for (b.moveTo(y[0], y[1]), D = 2; D < m; D += 2)
												b.lineTo(y[D], y[D + 1])
								}
							else if ("MultiPolygon" ===
								N.type) {
								var O = N.coordinates.slice(0),
								S = O.length;
								for (r = 0; r < S; r++)
									if (y = O[r][0].slice(0), y = c.transformHeatMapSegment(y, 1, N.dim, this.minX, this.minY, 1))
										if (m = y.length, !(6 > m))
											for (b.moveTo(y[0], y[1]), D = 2; D < m; D += 2)
												b.lineTo(y[D], y[D + 1])
							}
						}
					}
					b.closePath();
					b.clip()
				}
			} else
				this.clipByBounds(b)
		},
		clipByBounds: function (a) {
			var b = this.vectorLayer.parentMap.getMapContext(),
			c = b.getTransform(),
			b = b.getUniverse().getMapBounds().coordinates.slice(0),
			b = c.transformHeatMapSegment(b, 1, 2, this.minX, this.minY, 1);
			4 > b.length || (a.beginPath(),
				a.moveTo(b[0], b[1]), a.lineTo(b[0], b[3]), a.lineTo(b[2], b[3]), a.lineTo(b[2], b[1]), a.closePath(), a.clip())
		},
		getPixelValue: function (b) {
			b > this.max && a.notNull(this.maxValue) && (b = this.max);
			b < this.min && a.notNull(this.minValue) && (b = this.min);
			b = parseInt((b - this.min) / this.step);
			b = 4 * parseInt(255 * b / this.numClass);
			return {
				r: this.colorData[b],
				g: this.colorData[b + 1],
				b: this.colorData[b + 2]
			}
		},
		getRadius: function (a, b) {
			return a + parseInt((b - this.min) / ((this.max - this.min) / 3))
		},
		calculate: function (a, b, c, M) {
			3 > M && (M = 3);
			M = this.getRadius(M,
					a[b][c].value);
			for (var N = -M; N <= M; N++) {
				var O = c + N;
				if (!(0 > O))
					for (var y = Math.sqrt(M * M - N * N), r = Math.floor(b - y), y = Math.ceil(b + y), r = 0 > r ? 0 : r; r <= y; r++)
						if (a[r] || (a[r] = []), b != r || c != O) {
							var m = Math.sqrt((r - b) * (r - b) + N * N);
							if (!(m > M)) {
								var D = a[b][c].num * Math.sqrt((M - m) / M),
								m = a[b][c].value * Math.sqrt((M - m) / M);
								a[r][O] ? (D = a[r][O].num + D, m > a[r][O].value && (a[r][O] = {
											num: D,
											value: m
										})) : a[r][O] = {
									num: D,
									value: m
								}
							}
						}
			}
		}
	});
	a.layer.MultiFeature = a.Class.extend({
		initialize: function (a) {
			this.fList = a
		},
		add: function (a) {
			this.fList ? this.fList.push(a) :
			this.fList = [a]
		},
		createFeature: function (b, c) {
			var E = this.fList.length,
			M = new a.Feature(b, this.fList[0].geo, {
				renderingStyle: c
			});
			M.setMarkerText(E + "");
			return M
		}
	});
	a.layer.VectorLayerMultiFeature = a.Class.extend({
		initialize: function (b) {
			this.vectorLayer = b;
			this.mfList = [];
			this.group = b.parentMap.graphics.createGroup();
			b.group.appendChild(this.group);
			var c = this;
			b.parentMap.graphics.attachEventListener(a.event.MouseEvent.MOUSE_LEAVE, function () {
				c.clear()
			}, this.group)
		},
		checkLocation: function () {
			for (var b = this.vectorLayer.featureArray,
				c = 0, E = b.length; c < E - 1; c++)
				if ((!this.vectorLayer.mapping || b[c].mapping || this.vectorLayer.nsdp.fullDisplay) && !b[c].multi && b[c].geo && b[c].geo.type === a.GeomTypes.POINT) {
					for (var M = b[c].geo.coordinates[0], N = b[c].geo.coordinates[1], O = null, y = c + 1; y < E; y++)
						if ((!this.vectorLayer.mapping || b[y].mapping || this.vectorLayer.nsdp.fullDisplay) && !b[y].multi && b[y].geo && b[y].geo.type === a.GeomTypes.POINT) {
							var r = b[y].geo.coordinates[1];
							M === b[y].geo.coordinates[0] && N === r && (O ? O.add(b[y]) : O = new a.layer.MultiFeature([b[c], b[y]]),
								b[c].multi = b[y].multi = !0)
						}
					O && this.mfList.push(O)
				}
		},
		display: function () {
			for (var b = this, c = function (c, N) {
				return function () {
					N.graphics.attachEventListener(a.event.MouseEvent.MOUSE_ENTER, function () {
						b.showFeatures(c.fList, N.screenPoints)
					}, N.shape)
				}
				()
			}, E = function (a) {
				a = a.target;
				var c = a.mf;
				c.open ? b.clear() : (b.showFeatures(c.fList, a.screenPoints), c.open = !0)
			}, M = 0, N = this.mfList.length; M < N; M++) {
				var O = this.mfList[M];
				O.open = !1;
				var y = O.createFeature("_mul" + M, this.vectorLayer.mfMarker);
				y.mf = O;
				y.group = this.vectorLayer.realGroup;
				y.screenTransformObj = this.vectorLayer.parentMap.getMapContext().getTransform();
				y.graphics = this.vectorLayer.parentMap.graphics;
				y.parentLayer = this.vectorLayer;
				y.displayFeature([this.vectorLayer.mfMarker]);
				a.browser.touchSupported ? y.addListener(a.event.MouseEvent.MOUSE_CLICK, E, y.shape) : c(O, y)
			}
		},
		showFeatures: function (b, c) {
			var E = b.length;
			if (!(2 > E)) {
				var M = this.vectorLayer.parentMap.graphics;
				this.clear();
				var N = 2 * Math.PI / E,
				O = this.algorith1;
				N < Math.PI / 5 && (O = this.algorith2, N = Math.PI / 5);
				this.group.applyStyle({
					opacity: 1
				});
				this.lineGroup = M.createGroup();
				this.markerGroup = M.createGroup();
				this.markerGroup.applyStyle({
					cursor: this.vectorLayer.mouseCursor
				});
				this.group.appendChild(this.lineGroup);
				this.group.appendChild(this.markerGroup);
				this.group.parentNode || (this.vectorLayer.group.appendChild(this.group), M.sendToBottom(this.group));
				for (var y = function (a, b) {
					return function () {
						b.vectorLayer.showInfoWindow(a, a.getGeometry());
						b.clear();
						M.clearToolTips()
					}
				}, r = 0; r < E; r++) {
					var m = N * r + Math.PI / 2,
					D = O(r),
					S = Math.cos(m) * D.r2 + c.x,
					U = -Math.sin(m) *
						D.r2 + c.y,
					w = b[r];
					M.drawPath([[Math.cos(m) * D.r1 + c.x, -Math.sin(m) * D.r1 + c.y, S, U]], {
						stroke: "#003286",
						strokeThickness: 1
					}, {
						group: this.lineGroup
					});
					w.screenPoints = {
						x: S,
						y: U
					};
					w.parentLayer = this.vectorLayer;
					this.vectorLayer.getFeatureStyles(w).draw(w, this.vectorLayer.parentMap.getMapContext(), {
						group: this.markerGroup,
						type: w.geo.type,
						screenPoints: {
							x: S,
							y: U
						}
					});
					w.displayed = !0;
					a.browser.touchSupported ? M.attachEventListener(a.event.MouseEvent.TOUCH_TAP, y(w, this), w.shape) : M.attachEventListener(a.event.MouseEvent.MOUSE_CLICK,
						y(w, this), w.shape)
				}
				E = 2 * O(r).r2;
				E = M.drawEllipse({
					cx: c.x,
					cy: c.y,
					width: E,
					height: E
				}, {
					fill: "#ffffff",
					fillOpacity: 0
				}, {
					group: this.group
				});
				M.sendToBottom(E)
			}
		},
		algorith1: function () {
			return {
				r1: 15,
				r2: 30
			}
		},
		algorith2: function (a) {
			return {
				r1: 15,
				r2: 30 + 3 * a
			}
		},
		clear: function () {
			for (var b = 0, c = this.mfList.length; b < c; b++)
				this.mfList[b].open = !1;
			a.notNull(this.vectorLayer) && a.notNull(this.vectorLayer.parentMap) && a.notNull(this.vectorLayer.parentMap.graphics) && this.vectorLayer.parentMap.graphics.clearGroup(this.group)
		},
		destroy: function () {
			for (var b =
					this.mfList.length - 1; 0 <= b; b--) {
				var c = this.mfList[b];
				c.shape = null;
				c.screenPoints = null;
				c.parentLayer = null;
				c.graphics = null;
				this.mfList.pop()
			}
			a.notNull(this.vectorLayer) && a.notNull(this.vectorLayer.parentMap) && a.notNull(this.vectorLayer.parentMap.graphics) && this.vectorLayer.parentMap.graphics.clearGroup(this.group)
		}
	});
	a.layer.KMLParser = a.Class.extend({
		initialize: function (a) {
			this.vLayer = a;
			this.minY = this.minX = Number.POSITIVE_INFINITY;
			this.maxY = this.maxX = Number.NEGATIVE_INFINITY
		},
		parse: function (b, c) {
			var E =
				0,
			M = this.vLayer;
			M.featureArray = [];
			var N = this;
			b.find("Placemark").each(function () {
				var b = a.$(this),
				c = "KML" + E,
				v = N.parseExtendedData(b),
				O = b.find("name").text(),
				r = b.find("addresss").text(),
				y = b.find("phoneNumber").text();
				a.notNull(O) && "" !== O && (v.name = O);
				a.notNull(r) && "" !== r && (v.address = r);
				a.notNull(y) && "" !== y && (v.phone = y);
				O = b.find("gx\\:Track, Track");
				r = 0;
				for (y = O.length; r < y; r++) {
					var da = N.parseTrack(a.$(O[r]), c, v);
					0 < da.length && (M.addFeatures(da), E++)
				}
				var O = b.find("MultiGeometry"),
				na;
				if (0 < O.length) {
					var sa =
						[],
					wa,
					Aa = [];
					O.children().each(function () {
						var b = N.parseSimpleGeometry(a.$(this));
						b && (sa.push(b), Aa.push(b.getOrdinates()), wa ? wa !== b.getType() && (wa = "GeometryCollection") : wa = b.getType())
					});
					1 < sa.length && ("GeometryCollection" == wa ? na = new a.geometry.GeometryCollection(sa, 8307) : "Point" == wa ? na = new a.geometry.MultiPoint(Aa, 8307) : "LineString" == wa ? na = new a.geometry.MultiLineString(Aa, 8307) : "Polygon" == wa && (na = new a.geometry.MultiPolygon(Aa, 8307)), na.dimension = sa[0].dimension)
				} else
					na = N.parseSimpleGeometry(b);
				na && (b = new a.Feature(c, na, {
						attributes: v
					}), M.featureArray.push(b), E++)
			});
			M.dataLoaded = !0;
			if (!M.featureArray || 0 === M.featureArray.length)
				return !1;
			var O = a.event,
			y = function (a) {
				var b = new O.LayerEvent(O.LayerEvent.FEATURES_LOADED, M);
				b.mapContext = M.parentMap.getMapContext();
				M.fire(O.LayerEvent.FEATURES_LOADED, b);
				c(a)
			},
			r = M.parentMap.getMapContext().getUniverse().getSRID();
			8307 !== r ? (new a.geometry.Rectangle(this.minX, this.minY, this.maxX, this.maxY, 8307)).transform(r, function (a) {
				a = [a.getMinX(), a.getMinY(), a.getMaxX(),
					a.getMaxY()];
				y(a)
			}) : y([this.minX, this.minY, this.maxX, this.maxY]);
			return !0
		},
		parseSimpleGeometry: function (b) {
			var c = b.find("coordinates"),
			E;
			if (0 < c.length)
				if (E = c.parent()[0].nodeName, "LinearRing" == E) {
					if (c = b.find("outerBoundaryIs").find("coordinates").text(), a.notNull(c) && "" !== c)
						return E = this.parseCoordinates(c), c = b.find("innerBoundaryIs").find("coordinates").text(), b = [E.coords], a.notNull(c) && "" !== c && (c = this.parseCoordinates(c), b.push(c.coords)), b = new a.geometry.Polygon(b, 8307), b.dimension = E.dimension,
						b
				} else {
					c = c.text();
					if ("Point" == E)
						return b = c.split(","), E = Number(b[0]), b = Number(b[1]), c = new a.geometry.Point(E, b, 8307), E < this.minX && (this.minX = E), E > this.maxX && (this.maxX = E), b < this.minY && (this.minY = b), b > this.maxY && (this.maxY = b), c;
					if ("LineString" == E)
						return E = this.parseCoordinates(c), b = new a.geometry.LineString(E.coords, 8307), b.dimension = E.dimension, b
				}
			return null
		},
		parseCoordinates: function (a) {
			var b = a.trim().split(/\s+/g)[0].split(",").length;
			a = a.trim().split(/\s+|,/g);
			for (var c = 0, M = a.length; c < M; c++)
				a[c] =
					Number(a[c]), 0 === c % b ? (a[c] < this.minX && (this.minX = a[c]), a[c] > this.maxX && (this.maxX = a[c])) : 1 === c % b && (a[c] < this.minY && (this.minY = a[c]), a[c] > this.maxY && (this.maxY = a[c]));
			return {
				coords: a,
				dimension: b
			}
		},
		parseTrack: function (b, c, E) {
			var M = b.find("when"),
			N = b.find("gx\\:coord, coord"),
			O,
			y,
			r;
			if (0 < M.length && 0 < N.length && M.length == N.length) {
				var m = [];
				b = [];
				for (var D = 0, S = M.length; D < S; D++) {
					var U = a.$(N[D]).text().trim().split(" ");
					O = U.length;
					y = Number(U[0]);
					var w = Number(U[1]),
					ja = new a.geometry.Point(y, w, 8307);
					y < this.minX &&
					(this.minX = y);
					y > this.maxX && (this.maxX = y);
					w < this.minY && (this.minY = w);
					w > this.maxY && (this.maxY = w);
					y = {
						when: a.$(M[D]).text()
					};
					for (r in E)
						E[r]instanceof Array && E[r].length > D && (y[r] = E[r][D]);
					b.push(new a.Feature(c + "_" + D, ja, {
							attributes: y
						}));
					Array.prototype.push.apply(m, U)
				}
				if (1 < S) {
					M = new a.geometry.LineString(m, 8307);
					M.dimension = O;
					O = {};
					for (r in E)
						!E[r]instanceof Array && (y[O] = E[O]);
					b.splice(0, 0, new a.Feature(c + "_" + D, M, {}))
				}
				return b
			}
		},
		parseExtendedData: function (b) {
			var c = {},
			E = b.find("ExtendedData").find("Data"),
			M,
			N,
			O,
			y,
			r;
			M = 0;
			for (N = E.length; M < N; M++) {
				O = a.$(E[M]);
				y = O.attr("name");
				var m = O.find("displayName").text();
				r = O.find("value").text();
				a.notNull(m) && "" !== m ? c[m] = r : c[y] = r
			}
			E = b.find("ExtendedData").find("SimpleData");
			M = 0;
			for (N = E.length; M < N; M++)
				O = a.$(E[M]), y = O.attr("name"), r = O.find("value").text(), c[y] = r;
			E = b.find("ExtendedData").find("gx\\:SimpleArrayData, SimpleArrayData");
			b = function () {
				r.push(a.$(this).text())
			};
			M = 0;
			for (N = E.length; M < N; M++)
				O = a.$(E[M]), y = O.attr("name"), r = [], O.children().each(b), c[y] = r;
			return c
		}
	});
	a.layer.GeoJSONParser = a.Class.extend({
		initialize: function (a) {
			this.layer = a;
			this.count = 0
		},
		parse: function (b, c, E) {
			var M = !b || b.mds_error || b.error;
			if (M) {
				var N = M.message;
				(M = M.details) && (N += " [details]:" + M);
				this.layer.dataLoaded = !1;
				a.util.Logger.severe("MAPVIEWER_9007", "OM.layer.VectorLayer.getThemeData", N);
				E()
			} else {
				this.layer.getDataRequest = null;
				this.parseSRID(b);
				this.parselayerLevelStyle(b);
				this.parseEditParameters(b);
				this.parseFeatures(b);
				var O = this,
				y = function () {
					if (0 === O.count) {
						if (!O.layer.dataLoaded) {
							O.layer.dataLoaded =
								!0;
							var N = a.event,
							m = new N.LayerEvent(N.LayerEvent.FEATURES_LOADED, O.layer);
							m.mapContext = O.layer.parentMap.getMapContext();
							O.layer.fire(N.LayerEvent.FEATURES_LOADED, m)
						}
						c(O.bbox);
						b = null
					} else
						setTimeout(y, 100)
				};
				y()
			}
		},
		parseSRID: function (b) {
			this.srid = b.srs;
			!this.srid && b.crs && "name" === b.crs.type && b.crs.properties && b.crs.properties.name && (this.srid = a.util.GeomUtil.parseCRSName(b.crs.properties.name));
			a.isNull(this.srid) && (this.srid = 8307)
		},
		parseBBox: function (b) {
			if (this.bbox = b.bbox) {
				b = new a.geometry.Rectangle(this.bbox[0],
						this.bbox[1], this.bbox[2], this.bbox[3], this.srid);
				4 < this.bbox.length && (b = parseInt(this.bbox.length / 2), b = new a.geometry.Rectangle(this.bbox[0], this.bbox[1], this.bbox[b], this.bbox[b + 1], this.srid));
				var c = this.layer.parentMap.getMapContext().getUniverse().getSRID();
				if (this.srid !== c) {
					var E = this;
					(new a.geometry.LineString([b.getMinX(), b.getMinY(), b.getMaxX(), b.getMaxY()], this.srid)).transform(c, function (b) {
						b = b.coordinates;
						E.layer.mbr = new a.geometry.Rectangle(b[0], b[1], b[2], b[3], E.srid);
						E.bbox = [b[0], b[1],
							b[2], b[3]];
						505050 === c && (E.layer.mbr = null, E.bbox = null)
					})
				} else
					this.layer.mbr = b
			}
		},
		parselayerLevelStyle: function (a) {
			!this.layer.renderingStyle && a.renderStyle && this.layer.setRenderingStyle({
				dataSource: this.layer.dataSource,
				name: a.renderStyle,
				url: this.layer.serverURL
			});
			!this.layer.hoverStyle && a.hoverStyle && this.layer.setHoverStyle({
				dataSource: this.layer.dataSource,
				name: a.hoverStyle,
				url: this.layer.serverURL
			});
			!this.layer.selectionStyle && a.selectStyle && this.layer.setSelectStyle({
				dataSource: this.layer.dataSource,
				name: a.selectStyle,
				url: this.layer.serverURL
			});
			!this.layer.labelingStyle && a.labelStyle && this.layer.setLabelingStyle({
				dataSource: this.layer.dataSource,
				name: a.labelStyle,
				url: this.layer.serverURL
			})
		},
		parseEditParameters: function (b) {
			a.notNull(b.not_null_attr_names) ? this.layer.notNullAttributes = b.not_null_attr_names : this.layer.notNullAttributes = [];
			if (!a.isNull(b.edit_properties)) {
				a.isNull(this.layer.keyColumn) && (this.keyColumn = b.edit_properties.id_attr, a.notNull(this.keyColumn) && (this.layer.keyColumn = this.keyColumn.toUpperCase()));
				this.baseTable = b.edit_properties.base_table;
				a.notNull(this.baseTable) ? this.layer.baseTable = this.baseTable.toUpperCase() : this.layer.baseTable = null;
				a.isNull(this.layer.geometryColumn) && (this.spatialAttr = b.edit_properties.spatial_attr, a.notNull(this.spatialAttr) && (this.layer.geometryColumn = this.spatialAttr.toUpperCase()));
				this.spatialType = b.edit_properties.spatial_type;
				a.notNull(this.spatialType) ? this.layer.spatialType = this.spatialType : this.layer.spatialType = "geometry";
				this.workspace = b.edit_properties.workspace;
				a.notNull(this.workspace) && "LIVE" !== this.workspace.toUpperCase() && (this.layer.workspace = this.workspace.toUpperCase());
				var c = b.attr_names;
				b = b.attr_types;
				this.layer.attributeTypes = {};
				if (a.notNull(c) && a.notNull(b) && c.length === b.length)
					for (var E = 0; E < c.length; E++) {
						var M = c[E].toUpperCase();
						this.layer.attributeTypes[M] = b[E]
					}
			}
		},
		upperCaseArray: function (b) {
			if (!(a.isNull(b) || 1 > b.length)) {
				for (var c = [], E = 0, M = b.length; E < M; E += 1)
					c.push(b[E].toUpperCase());
				return c
			}
		},
		uppercCaseKeys: function (b) {
			if (!(a.isNull(b) || !b instanceof
					Object)) {
				for (var c, E = Object.keys(b), M = E.length, N = {}; M--; )
					c = E[M], N[c.toUpperCase()] = b[c];
				return N
			}
		},
		uppercCaseKeysAndValues: function (b) {
			if (!(a.isNull(b) || !b instanceof Object)) {
				for (var c, E = Object.keys(b), M = E.length, N = {}; M--; )
					c = E[M], N[c.toUpperCase()] = b[c].toUpperCase();
				return N
			}
		},
		parseFeatures: function (b) {
			var c = this.layer.getSelectedFeatures(),
			E = b.features,
			M = E.length,
			N = {};
			this.layer.featureArray = [];
			this.layer.mapping = !1;
			this.layer.attrNames = this.upperCaseArray(b.attr_names);
			this.layer.columnMap = this.uppercCaseKeysAndValues(b.columnMap);
			var O = this;
			b = function (b) {
				N[b] || (N[b] = b, O.count++, a.style.StyleStore.getServerSideStyle(O.layer.dataSource, b, {
						url: O.layer.serverURL,
						callback: function (b) {
							"undefined" !== typeof a.style.HeatMap && b instanceof a.style.HeatMap && !O.layer.renderingStyle && (O.layer.renderingStyle = b);
							O.count--
						}
					}))
			};
			for (var y = 0; y < M; y++)
				try {
					var r = E[y],
					m = r.geometry;
					if (!a.isNull(m) && !a.$.isEmptyObject(m)) {
						this.layer.type === a.layer.VectorLayer.TYPE_DATAPACK && (m = a.util.GeomUtil.parseGeoJson(m));
						var D = "undefined" !== typeof r._id ? r._id :
							y;
						if (this.layer.loadOnDemand) {
							if (this.layer.featureEditable && a.notNull(this.layer.changeManager) && this.layer.changeManager.hasChanges())
								if (this.layer.changeManager.isModifiedFeature(D)) {
									this.layer.featureArray.push(this.layer.changeManager.modifiedFeatures[D]);
									this.layer.changeManager.modifiedFeatures[D].rtreeKeys = [];
									continue
								} else if (this.layer.changeManager.isRemovedFeature(D))
									continue;
							if (a.notNull(c) && 0 < c.length) {
								for (var S = -1, U = 0; U < c.length; U++)
									if (c[U].id === D) {
										S = U;
										break
									}
								if (-1 < S) {
									this.layer.featureArray.push(c[S]);
									c[S].rtreeKeys = [];
									continue
								}
							}
						}
						m.srid = this.srid;
						var w = new a.Feature(D, m, {
							attributes: r.properties
						});
						a.notNull(this.layer.columnMap) && (w.columnMap = this.layer.columnMap);
						w.srid = this.srid;
						w.parentLayer = this.layer;
						if (!this.layer.doFilter(w)) {
							w.labelBox = r.label_box;
							if (this.layer.type !== a.layer.VectorLayer.TYPE_DATAPACK) {
								if (r.styles && r.styles.rendering && r.styles.rendering.style) {
									r.styles && r.styles.rendering && r.styles.rendering.columns && (w.columns = r.styles.rendering.columns);
									var ja = r.styles.rendering.style;
									w.styleName = ja;
									b(ja)
								}
								r.styles && r.styles.labeling && r.styles.labeling.style && (r.styles && r.styles.labeling && r.styles.labeling.columns && (w.labelColumn = r.styles.labeling.columns[0]), w.labelStyleName = r.styles.labeling.style, b(w.labelStyleName))
							}
							this.layer.featureArray.push(w)
						}
					}
				} catch (la) {
					a.util.Logger.warning("MAPVIEWER_9101", "OM.layer.GeoJsonParser.parseFeatures", la.message + " (Feature id: " + D + ")")
				}
			if (this.layer.loadOnDemand && this.layer.featureEditable && a.notNull(this.layer.changeManager)) {
				c = this.layer.changeManager.getNewFeatures();
				for (E = 0; E < c.length; E++)
					this.layer.featureArray.push(c[E]), c[E].rtreeKeys = [];
				this.layer.rtree = null;
				this.layer.segmentRtree = {}
			}
		}
	});
	a.layer.GeoRSSParser = a.Class.extend({
		initialize: function (a) {
			this.vLayer = a
		},
		parse: function (b, c) {
			var E = this.vLayer,
			M = Number.POSITIVE_INFINITY,
			N = Number.POSITIVE_INFINITY,
			O = Number.NEGATIVE_INFINITY,
			y = Number.NEGATIVE_INFINITY;
			E.featureArray = [];
			var r = E.parentMap.getMapContext().getUniverse().getSRID();
			a.$(b).find("entry").each(function () {
				var b = a.$(this),
				c = b.find("title").text(),
				m = b.find("link").attr("href"),
				D = b.find("id").text(),
				r = b.find("updated").text(),
				v = b.find("content").text(),
				sa = b.find("summary").text(),
				da = b.find("georss\\:point").text();
				"" === da && (da = b.find("point").text());
				if (a.notNull(da) && "" !== da) {
					var da = da.split(" "),
					b = Number(da[1]),
					da = Number(da[0]),
					Aa = new a.geometry.Point(b, da, 8307),
					Oa = {};
					a.notNull(c) && (Oa._LABEL_ = c);
					a.notNull(m) && (Oa.link = "\x3ca href\x3d'" + m + "' target\x3d'_blank'\x3elink\x3c/a\x3e");
					a.notNull(r) && (Oa.updated = r);
					a.notNull(v) && (Oa.content = v);
					a.notNull(sa) &&
					(Oa.summary = sa);
					c = new a.Feature(D, Aa, {
						attributes: Oa
					});
					b < M && (M = b);
					b > O && (O = b);
					da < N && (N = da);
					da > y && (y = da);
					E.featureArray.push(c)
				}
			});
			E.dataLoaded = !0;
			if (!E.featureArray || 0 === E.featureArray.length)
				return !1;
			var m = a.event,
			D = function (a) {
				var b = new m.LayerEvent(m.LayerEvent.FEATURES_LOADED, E);
				b.mapContext = E.parentMap.getMapContext();
				E.fire(m.LayerEvent.FEATURES_LOADED, b);
				c(a)
			};
			8307 !== r ? (new a.geometry.Rectangle(M, N, O, y, 8307)).transform(r, function (a) {
				a = [a.getMinX(), a.getMinY(), a.getMaxX(), a.getMaxY()];
				D(a)
			}) :
			D([M, N, O, y]);
			return !0
		}
	});
	a.layer.DynamicTileLayer = a.layer.TileLayer.extend({
		initialize: function v(b, c, N) {
			c = a.$.extend(!0, {}, c);
			if (a.notNull(N) && "[object Object]" === Object.prototype.toString.call(N))
				try {
					c.serverMapRequest = N,
					a.isNull(c.dataSource) && (a.notNull(N.dataSource) ? c.dataSource = N.dataSource : a.notNull(N.datasource) ? c.dataSource = N.datasource : a.util.Logger.warning("MAPVIEWER_9099", "OM.layer.DynamicTileLayer.initialize")),
					a.isNull(c.tileServerURL) && (a.notNull(N.baseURL) ? c.tileServerURL = N.baseURL +
							"/omserver" : a.util.Logger.warning("MAPVIEWER_9100", "OM.layer.DynamicTileLayer.initialize"))
				} catch (O) {
					a.util.Logger.warning("MAPVIEWER_9082", "OM.layer.DynamicTileLayer.initialize")
				}
			a.isNull(c.isWMSTileLayer) && (c.isDynamicTileLayer = !0);
			a.notNull(c.isDynamicTileLayer && c.tileServerURL) && (c.tileServerURL = this.fixTileServerUrl(c.tileServerURL));
			v.base.call(this, b, c);
			this.initialize_DTL(c);
			this.bindingParameters = null
		},
		fixTileServerUrl: function (b) {
			if (a.notNull(b) && -1 === b.indexOf("/omserver")) {
				a.util.Logger.warning("MAPVIEWER_9075",
					"OM.layer.Tilelayer.initialize");
				var c = b.indexOf("/mcserver");
				0 < c && (b = b.substring(0, c) + "/omserver", a.util.Logger.warning("MAPVIEWER_9076", "OM.layer.Tilelayer.initialize"))
			}
			return b
		},
		initialize_DTL: function (b) {
			this.layerType = a.LayerTypes.DYNAMIC_TILE;
			a.isNull(b.isWMSTileLayer) ? this.isDynamicTileLayer = !0 : this.isWMSTileLayer = !0;
			var c;
			if (a.isNull(b))
				a.util.Logger.warning("MAPVIEWER_9070", "OM.layer.TileLayer.initialize_DTL");
			else {
				this.yOffset_DynamicTL = this.xOffset_DynamicTL = 0;
				this.tileLayerConfig = {};
				if (b.tileLayerConfig) {
					this.tileLayerConfig.tileImageHeight = b.tileLayerConfig.tileImageHeight;
					this.tileLayerConfig.tileImageWidth = b.tileLayerConfig.tileImageWidth;
					this.tileLayerConfig.tileImageFormat = b.tileLayerConfig.tileImageFormat;
					if (a.isNull(this.tileLayerConfig.tileImageFormat) || "PNG" === this.tileLayerConfig.tileImageFormat)
						this.tileLayerConfig.tileImageFormat = "image/png";
					if (a.isNull(this.tileLayerConfig.tileImageHeight) || a.isNull(this.tileLayerConfig.tileImageWidth) || 0 >= this.tileLayerConfig.tileImageHeight ||
						0 >= this.tileLayerConfig.tileImageWidth)
						this.tileLayerConfig.tileImageHeight = 256, this.tileLayerConfig.tileImageWidth = 256
				} else
					c = new a.layer.TileLayerConfig, this.tileLayerConfig.tileImageHeight = c.tileImageHeight, this.tileLayerConfig.tileImageWidth = c.tileImageHeight, this.tileLayerConfig.tileImageFormat = "image/png";
				b.universe ? (this.tileLayerConfig.bounds = b.universe.bound, this.tileLayerConfig.srid = b.universe.srid, this.tileLayerConfig.zoomLevels = b.universe.zoomLevels) : a.isNull(this.parentMap) ? (c = new a.universe.ElocationUniverse,
					this.tileLayerConfig.bounds = c.bound, this.tileLayerConfig.srid = c.srid, this.tileLayerConfig.zoomLevels = c.zoomLevels, a.util.Logger.warning("MAPVIEWER_9072", "OM.layer.TileLayer.initialize_DTL")) : (c = this.parentMap.getMapContext(), a.isNull(c) ? a.util.Logger.warning("MAPVIEWER_9084", "OM.layer.TileLayer.initialize_DTL") : (c = c.getUniverse(), a.isNull(c) && (c = new a.universe.ElocationUniverse, a.util.Logger.warning("MAPVIEWER_9072", "OM.layer.TileLayer.initialize_DTL")), this.tileLayerConfig.bounds = c.bound, this.tileLayerConfig.srid =
							c.srid, this.tileLayerConfig.zoomLevels = c.zoomLevels));
				a.notNull(b.urlBuilder) && (this.getURLBuilderURL = b.urlBuilder, a.notNull(b.urlBuilderOptions) && (this.urlBuilderParams = b.urlBuilderOptions));
				a.notNull(b.tileURLTemplate) && (this.tileURLTemplate = this.extractCustomTileURL(b.tileURLTemplate));
				a.notNull(b.hideInOverviewMap) ? this.hideInOverviewMap = b.hideInOverviewMap : this.hideInOverviewMap = !0;
				this.serverMapRequest = b.serverMapRequest
			}
		},
		getDefaultImgURL: function (b, c, M, N, O, y) {
			var r,
			m = this.parentMap;
			a.notNull(this.serverMapRequest) &&
			(r = this.serverMapRequest.clone(), r.setImageWidth(b), r.setImageHeight(c), r.setBBox(M, N, O, y, this.tileLayerConfig.srid), b = this.serverURL, a.notNull(this.serverArray) && (b = this.serverArray[this.serverCounter], this.serverCounter += 1, this.serverCounter %= this.serverArray.length), r.setProperties({
					isclienttilereq: !0,
					tileServerURL: b,
					applicationID: a.notNull(m.applicationID) ? m.applicationID : null
				}), this.enableUTFGrid && (r.setEnableUTFGrid(!0), r.setUTFGridResolution(this.utfgridResolution)), r = r.toXMLString());
			return r
		},
		getCustomURL: function (b, c, M) {
			var N,
			O;
			if (a.notNull(this.tileURLTemplate) && 0 < this.tileURLTemplate.length) {
				O = this.tileURLTemplate[(b + c) % this.tileURLTemplate.length];
				N = Math.ceil((this.tileLayerConfig.bounds.getMaxY() - this.tileLayerConfig.bounds.getMinY()) / this.centerMesh.mh) - 1;
				O = a.util.MiscUtil.substituteStr(O, "{x}", "" + b);
				O = a.util.MiscUtil.substituteStr(O, "{y}", "" + (N - c));
				O = a.util.MiscUtil.substituteStr(O, "{z}", "" + (M + (a.notNull(this.z_offset) ? this.z_offset : 0)));
				if (a.notNull(this.tileCustomURLProps))
					for (var y in this.tileCustomURLProps)
						O =
							a.util.MiscUtil.substituteStr(O, "{" + y + "}", this.tileCustomURLProps[y]);
				return O
			}
			a.util.Logger.warning("", "OM.Layer.DynamicTileLayer.getCustomURLNo valid url template.")
		},
		getDynamicTL_URL: function (b, c, M) {
			if (a.notNull(this.tileURLTemplate) && 0 < this.tileURLTemplate.length)
				return this.getCustomURL(b, c, M);
			var N = this.tileLayerConfig.zoomLevels[M];
			M = this.tileLayerConfig.tileImageWidth;
			var O = this.tileLayerConfig.tileImageHeight,
			y = M * N.resolution,
			N = O * N.resolution * N.stretchRatio;
			b = this.tileLayerConfig.bounds.getMinX() +
				b * y;
			y = b + y;
			c = this.tileLayerConfig.bounds.getMinY() + c * N;
			N = c + N;
			return a.isNull(this.getURLBuilderURL) ? this.getDefaultImgURL(M, O, b, c, y, N) : this.getURLBuilderURL(M, O, b, c, y, N, this.urlBuilderParams)
		},
		setBindingParameters: function (b) {
			var c = this.serverMapRequest;
			a.notNull(c) && c.setBindingParameters(b)
		},
		getStaticMapURL: function (b, c) {
			var M = new a.geometry.Point(this.parentMap.getMapWindowBoundingBox().getMinX(), this.parentMap.getMapWindowBoundingBox().getMinY(), this.tileLayerConfig.srid),
			N = new a.geometry.Point(this.parentMap.getMapWindowBoundingBox().getMaxX(),
					this.parentMap.getMapWindowBoundingBox().getMaxY(), this.tileLayerConfig.srid);
			return a.isNull(this.getURLBuilderURL) ? this.getDefaultImgURL(b, c, M.getX(), M.getY(), N.getX(), N.getY()) : this.getURLBuilderURL(b, c, M.getX(), M.getY(), N.getX(), N.getY(), this.urlBuilderParams)
		},
		extractCustomTileURL: function (b) {
			var c,
			M,
			N;
			if (!0 === Array.isArray(b)) {
				0 === b.length && a.util.Logger.warning("", "OM.layer.DynamicTileLayer.extractCustomTileURL", "URL template cannot be empty.");
				this.checkRequiredPlaceHolders(b[0]);
				for (var O =
						[], y = 0, r = b.length; y < r; y += 1)
					c = b[y].trim().replace(/^[\'\"]/g, "").replace(/[\'\"]$/g, ""), M = c.indexOf("http://"), N = c.indexOf("https://"), -1 === M && -1 === N && (c = "http://" + c), O.push(c);
				return O
			}
			this.checkRequiredPlaceHolders(b);
			c = b.trim().replace(/^[\'\"]/g, "").replace(/[\'\"]$/g, "");
			M = c.indexOf("http://");
			N = c.indexOf("https://");
			-1 === M && -1 === N && (c = "http://" + c);
			return [c]
		},
		checkRequiredPlaceHolders: function (b) {
			var c = b.toUpperCase().indexOf("{X}"),
			M = b.toUpperCase().indexOf("{Y}");
			b = b.toUpperCase().indexOf("{Z}");
			return 0 < c && 0 < M && 0 < b ? !0 : (a.util.Logger.warning("MAPVIEWER_9097", "OM.layer.DynamicTileLayer.checkRequiredPlaceHolders"), !1)
		},
		setZoomLevelOffset: function (a) {
			this.z_offset = a
		}
	});
	a.layer.DynamicTileLayer.combineDTLURLs = function (a) {
		var b = this.combineDTLThemes(a);
		a = this.combineDTLStyles(a);
		return b + a
	};
	a.layer.DynamicTileLayer.combineDTLThemes = function (b) {
		for (var c = "", M = 0; M < b.length; M++) {
			var N = b[M],
			N = decodeURIComponent(N),
			O = -1,
			y = -1,
			r = -1,
			m = "";
			a.notNull(N) && (O = N.indexOf('datasource\x3d"'), 0 < O && (y = N.indexOf('"',
							O), 0 < y && (r = N.indexOf(" ", y)), 0 < O, 0 < y && 0 < r)) && (m = N.substring(y, r));
			a.isNull(m) && a.util.Logger.warning("MAPVIEWER_9099", "OM.Map.combineDTLThemes", "No datasource attribute found in [" + N + "]");
			r = 0;
			do
				O = N.indexOf("\x3ctheme ", r), 0 < O && (y = N.indexOf("\x3c/theme\x3e", r), 0 < y && (c += "\x3ctheme datasource\x3d" + m + " " + N.substring(O + 7, y) + "\x3c/theme\x3e", r = y + 8));
			while (0 < O)
		}
		return a.notNull(c) && 0 < c.trim().length ? "\x3cthemes\x3e" + c + "\x3c/themes\x3e" : ""
	};
	a.layer.DynamicTileLayer.combineDTLStyles = function (b) {
		for (var c =
				"", M = 0; M < b.length; M++) {
			var N = b[M],
			N = decodeURIComponent(N),
			O = -1,
			y = -1,
			O = N.indexOf("\x3cstyles\x3e");
			0 < O && (y = N.indexOf("\x3c/styles\x3e"), 0 < y && (c += N.substring(O + 8, y)))
		}
		return a.notNull(c) && 0 < c.trim().length ? "\x3cstyles\x3e" + c + "\x3c/styles\x3e" : ""
	};
	a.layer.WMSTileLayer = a.layer.DynamicTileLayer.extend({
		initialize: function E(b, c) {
			a.notNull(c) && (c.isWMSTileLayer = !0);
			E.base.call(this, b, c);
			this.initialize_WMSTL(c);
			this.bindingParameters = null
		},
		initialize_WMSTL: function (b) {
			this.isWMSTileLayer = !0;
			this.layerType =
				a.LayerTypes.DYNAMIC_TILE;
			a.isNull(b) ? a.util.Logger.warning("MAPVIEWER_9069", "OM.layer.TileLayer.initialize_WMSTL") : (this.serverURL = b.wmsServerURL.trim(), -1 === this.serverURL.indexOf("http://") && -1 === this.serverURL.indexOf("https://") && (this.serverURL = a.gv.secureHttp() + "//" + this.serverURL), a.isNull(this.serverURL) && a.util.Logger.warning("MAPVIEWER_9066", "OM.layer.TileLayer.initialize_WMSTL"), a.isNull(b.urlBuilderOptions) || (this.optParams_WMSTL = b.urlBuilderOptions, a.isNull(this.optParams_WMSTL.layers) &&
					a.util.Logger.warning("MAPVIEWER_9067", "OM.layer.TileLayer.initialize_WMSTL"), a.isNull(this.optParams_WMSTL.version) && a.util.Logger.warning("MAPVIEWER_9068", "OM.layer.TileLayer.initialize_WMSTL")), a.notNull(b.hideInOverviewMap) ? this.hideInOverviewMap = b.hideInOverviewMap : this.hideInOverviewMap = !0)
		},
		buildWMSTL_URL: function (b, c, N, O, y, r) {
			var m = "",
			D = this.serverURL + "?request\x3dGetMap",
			D = this.optParams_WMSTL && this.optParams_WMSTL.CRS && "EPSG:4326" === this.optParams_WMSTL.CRS.toUpperCase() ? "1.3.0" === this.optParams_WMSTL.VERSION ?
				D + ("\x26bbox\x3d" + O + "," + N + "," + r + "," + y) : D + ("\x26bbox\x3d" + N + "," + O + "," + y + "," + r) : D + ("\x26bbox\x3d" + N + "," + O + "," + y + "," + r),
			D = D + ("\x26width\x3d" + b + "\x26height\x3d" + c);
			if (!a.isNull(this.optParams_WMSTL))
				for (var S in this.optParams_WMSTL)
					m = "bgcolor" === S.toLowerCase() ? m + "\x26" + S + "\x3d" + encodeURIComponent(this.optParams_WMSTL[S]) : m + "\x26" + S + "\x3d" + this.optParams_WMSTL[S];
			return D + m
		},
		getWMSTL_URL: function (a, b, c) {
			c = this.tileLayerConfig.zoomLevels[c];
			var O = this.tileLayerConfig.tileImageWidth * c.resolution;
			c = this.tileLayerConfig.tileImageHeight *
				c.resolution * c.stretchRatio;
			a = this.tileLayerConfig.bounds.getMinX() + a * O;
			O = a + O;
			b = this.tileLayerConfig.bounds.getMinY() + b * c;
			return this.buildWMSTL_URL(this.tileLayerConfig.tileImageWidth, this.tileLayerConfig.tileImageHeight, a, b, O, b + c)
		}
	});
	a.layer.WMTSTileLayer = a.layer.TileLayer.extend({
		initialize: function M(a, b) {
			var c = b || {};
			M.base.call(this, a, c);
			this.initialize_WMTS(c)
		},
		initialize_WMTS: function (b) {
			this.layerType = a.LayerTypes.WMTS_TILE;
			this.getCapabilitiesURL = b.url;
			this.getTileTemplate = b.getTileTemplate;
			this.layerID = b.layerID;
			this.tileMatrixSetID = b.tileMatrixSetID;
			a.notNull(b.hideInOverviewMap) ? this.hideInOverviewMap = b.hideInOverviewMap : this.hideInOverviewMap = !0
		},
		buildConfig: function (b) {
			if (null === b)
				a.util.Logger.warning("", "OM.layer.WMTSTileLayer.buildConfig", "The WMTS config cannot be null.");
			else {
				if (a.notNull(this.getTileTemplate))
					this.tileURLTemplate = this.getTileTemplate;
				else if (b.urls && 0 < b.urls.length)
					this.tileURLTemplate = b.urls[0];
				else {
					a.util.Logger.warning("", "OM.layer.WMTSTileLayer.buildConfig",
						"The WMTS URL template does not present.");
					return
				}
				this.style = b.style;
				for (var c = [], O = 0, y = b.tileGrid.resolutions.length; O < y; O += 1)
					c.push(new a.universe.ZoomLevel(b.tileGrid.resolutions[O]));
				return {
					srid: b.projection.SRID,
					bounds: b.projection.bounds,
					zoomLevels: c,
					tileImageWidth: b.tileGrid.tileSizes[0],
					tileImageHeight: b.tileGrid.tileSizes[0]
				}
			}
		},
		getWMTS_URL: function (b, c, O) {
			var y;
			if (a.notNull(this.tileURLTemplate)) {
				y = Math.ceil((this.tileLayerConfig.bounds.getMaxY() - this.tileLayerConfig.bounds.getMinY()) / this.centerMesh.mh -
						1);
				b = a.util.MiscUtil.substituteStr(this.tileURLTemplate, "{TileCol}", "" + b);
				b = a.util.MiscUtil.substituteStr(b, "{TileRow}", "" + (y - c));
				b = a.util.MiscUtil.substituteStr(b, "{TileMatrix}", "" + (O + (a.notNull(this.z_offset) ? this.z_offset : 0)));
				b = a.util.MiscUtil.substituteStr(b, "{style}", this.style);
				b = a.util.MiscUtil.substituteStr(b, "{TileMatrixSet}", "" + this.tileMatrixSetID);
				if (a.notNull(this.tileCustomURLProps))
					for (var r in this.tileCustomURLProps)
						b = a.util.MiscUtil.substituteStr(b, "{" + r + "}", this.tileCustomURLProps[r]);
				return b
			}
		}
	});
	a.layer.VectorTileLayer = a.layer.VectorLayer.extend({
		initialize: function N(b, c) {
			if (a.isNull(c) || a.isNull(c.def))
				throw Error("Invalid or null VectorTileLayer options found.");
			var r = this;
			c.def.type = a.layer.VectorLayer.TYPE_MAPBOX;
			var m = c.def;
			this.options = c;
			N.base.call(this, b, c);
			this.type = m.type;
			this.dataSource = m.dataSource || m.datasource;
			this.themeName = m.theme;
			this.keyColumn = m.keyColumn ? m.keyColumn.toUpperCase() : null;
			this.serverURL = m.url;
			a.isNull(this.serverURL) && (this.serverURL = a.gv._baseURL);
			this.featuresMap = {};
			this.tileFeatures = {};
			this.loadTileFeaturesTask = null;
			a.notNull(this.themeName) && (a.isNull(this.keyColumn) || a.isNull(this.renderingStyle)) && a.util.HttpRequest.send("/mapviewer/omserver", {
				xml_request: '\x3cnon_map_request\x3e\x3cget_theme_info data_source\x3d"' + r.dataSource + '" theme\x3d"' + r.themeName + '"/\x3e\x3c/non_map_request\x3e'
			}, function (b) {
				if (a.isNull(r.keyColumn)) {
					var c = a.$(b).find("key_column").text();
					console.log("Key column: " + c);
					a.notNull(c) && (r.keyColumn = c)
				}
				a.isNull(r.renderingStyle) &&
				(b = a.$(b).find("theme_style[label\x3d'false']").attr("name"), console.log("Theme render style: " + b), a.notNull(b) && (r.renderingStyle = {
							name: b,
							dataSource: r.dataSource
						}))
			}, "xml")
		},
		enableFeatureEditing: function (a) {
			return !1
		},
		getFeatureGeometryType: function () {
			if (this.featureArray && 0 < this.featureArray.length) {
				var b = this.featureArray[0].geo.geometries;
				if (a.notNull(b) && 0 < b.length) {
					b = b[0];
					if ("Point" === b.type || "OrientedPoint" === b.type || "MultiPoint" === b.type || "OrientedMultiPoint" === b.type)
						return "POINT";
					if ("LineString" ===
						b.type || "MultiLineString" === b.type)
						return "LINESTRING";
					if ("Polygon" === b.type || "MultiPolygon" === b.type)
						return "POLYGON"
				}
			}
			return ""
		},
		addFeature: function (a) {},
		addFeatures: function (a) {},
		refreshImpl: function (b, c, y) {
			if (!a.isNull(this.group))
				if (y = b && b.type === a.event.MapEvent.MAP_BEFORE_REFRESH ? b.bigPan : !1, c ? (y || (this.loaded = !1), y || (this.dataLoaded = !1)) : b && null !== b.beforeZoomLevel && null !== b.afterZoomLevel && b.beforeZoomLevel !== b.afterZoomLevel && this.setWindow(), this.clearFeatureShapes(), this.clearAllLabels(),
					this.checkVisible()) {
					b = this.parentMap.getMapContext();
					c = b.getUniverse();
					var r = c.getZoomLevels()[b.getZoomLevel()],
					m = b.getCenterPoint();
					y = this.orgWidth * this.xRatio * r.resolution;
					r = this.orgHeight * this.yRatio * r.resolution * r.stretchRatio;
					this.dataBufferWindow = {
						x: m.getX() - y / 2,
						y: m.getY() - r / 2,
						w: y,
						h: r
					};
					this.emptyCustomLayer();
					var m = c.getSRID(),
					D = null,
					S = this.visibleBound ? Math.max(this.dataBufferWindow.x, this.visibleBound.getMinX()) : this.dataBufferWindow.x,
					U = this.visibleBound ? Math.max(this.dataBufferWindow.y,
							this.visibleBound.getMinY()) : this.dataBufferWindow.y;
					y = this.visibleBound ? Math.min(this.dataBufferWindow.x + y, this.visibleBound.getMaxX()) : this.dataBufferWindow.x + y;
					r = this.visibleBound ? Math.min(this.dataBufferWindow.y + r, this.visibleBound.getMaxY()) : this.dataBufferWindow.y + r;
					c.geodetic && (-180 > S && (S = -180), -90 > U && (U = -90), 180 < y && (y = 180), 90 < r && (r = 90));
					D = new a.geometry.Rectangle(S, U, y, r, m);
					D.transform(3857, function (a) {
						D = a
					});
					r = a.util.WorldMercatorUtil.metersToPixels(b.getZoomLevel(), D.getMinX(), D.getMinY());
					S = a.util.WorldMercatorUtil.metersToPixels(b.getZoomLevel(), D.getMaxX(), D.getMaxY());
					m = Math.round(r[0] / 256);
					c = Math.round(S[0] / 256);
					y = Math.min(Math.round(r[1] / 256), Math.round(S[1] / 256));
					r = Math.max(Math.round(r[1] / 256), Math.round(S[1] / 256));
					S = y;
					y = (1 << b.getZoomLevel()) - 1 - r;
					r = (1 << b.getZoomLevel()) - 1 - S;
					0 > m && (m = 0);
					0 > y && (y = 0);
					this.tileFeatures = {};
					this.featuresMap = {};
					this.featureArray = [];
					this.rtree = this.attrNames = null;
					this.numberOfTilesToLoad = (c - m + 1) * (r - y + 1);
					if (1 > this.numberOfTilesToLoad)
						a.util.Logger.info(null,
							"VectorTileLayer", "[" + this.name + "]  No tiles to load.");
					else {
						this.loadedTiles = [];
						this.loading = !0;
						this.loaded = !1;
						a.util.Logger.fine(null, "VectorTileLayer", "[" + this.name + "]  tile loading started. [" + this.numberOfTilesToLoad + "]");
						a.util.Logger.finest(null, "VectorTileLayer", "[" + this.name + "]  tile retrieval and rendering started.");
						a.util.Logger.finest(null, "VectorTileLayer", "[" + this.name + "]  number of tiles to process: " + this.numberOftilesToProcess);
						!1 === a.gv.progressBarDisabled && (this.loadTileFeaturesTask =
								this.startNewTask());
						for (; m <= c; m++)
							for (S = y; S <= r; S++)
								U = b.getZoomLevel() + "_" + m + "_" + S, a.util.Logger.finest(null, "VectorTileLayer", "[" + this.name + "] processing tile " + U + "."), a.notNull(this.tileFeatures[U]) ? this.checkVisible() && this.displayTileFeatures(b.getZoomLevel(), m, S) : this.getTileData(b.getZoomLevel(), m, S);
						a.util.Logger.fine(null, "VectorTileLayer", "[" + this.name + "]  all tiles processed (but some may be in rendering phase).");
						a.notNull(this.initTask) && (this.initTask.complete(), this.initTask = null)
					}
				} else
					b =
						a.event, c = new b.MapEvent(b.LayerEvent.FINISH_LOAD, this), c.mapContext = this.parentMap.getMapContext(), this.fire(b.LayerEvent.FINISH_LOAD, c)
		},
		getTileData: function (b, c, y) {
			var r = new protobuf.Root,
			m = this;
			protobuf.load(a.gv.getProtoResourcePath() + "vector_tile.proto", r, function () {
				var D = r.lookup("vector_tile"),
				S = a.util.WorldMercatorUtil.getTileCoverage(b, c, y),
				U = new XMLHttpRequest;
				U.open("GET", m.serverURL + "/vt/" + m.dataSource + "/" + b + "/" + c + "/" + y + ".mvt?t\x3d" + m.themeName, !0);
				U.responseType = "arraybuffer";
				U.onload =
				function (r) {
					r = D.Tile.decode(new Uint8Array(U.response));
					r = m.decodeFeatures(r, S);
					var ja = b + "_" + c + "_" + y;
					if (a.isNotNull(r) && 0 < r.length) {
						m.featureArray || (m.featureArray = []);
						var la = m.parentMap.getMapContext().getUniverse().getSRID();
						S.transform(la, function (a) {
							S = a
						});
						for (var na = 0; na < r.length; na++)
							if (a.isNotNull(r[na].id)) {
								var sa = m.featuresMap[r[na].id],
								wa = {},
								Aa = null,
								Aa = Aa = Aa = null;
								if (a.isNull(sa)) {
									var Oa = r[na].geo;
									Oa.transform(la, function (a) {
										Oa = a
									});
									Aa = [];
									Aa.push(Oa);
									Aa = new a.geometry.GeometryCollection(Aa,
											la);
									sa = new a.Feature(r[na].id, Aa, {
										attributes: r[na].getAttributes()
									});
									sa.tiledFeature = !0;
									m.featureArray.push(sa);
									wa[r[na].id] = Oa;
									sa.tileGeometries[ja] = wa;
									sa.clipMap[ja] = S;
									sa.zoomLevelsGeometries["zoomlevel_" + b] = Aa;
									Aa = [];
									Aa.push(S);
									sa.zoomLevelsGeomClipArea["zoomlevel_" + b] = Aa;
									m.featuresMap[r[na].id] = sa;
									if (a.isNull(m.attrNames) && a.isNotNull(sa.getAttributes())) {
										wa = sa.getAttributes();
										m.attrNames = [];
										for (var Ha in wa)
											wa.hasOwnProperty(Ha) && m.attrNames.push(Ha);
										m.nsdpTitleArray && (m.attrNames ? (m.nsdpTitleArray[0].toUpperCase() ===
												m.nsdpKey && m.nsdpTitleArray.shift(), m.attrNames = m.attrNames.concat(m.nsdpTitleArray)) : this.nsdpTitleArray[0].toUpperCase() === m.nsdpKey && (m.attrNames = m.nsdpTitleArray.slice(1)))
									}
								} else
									Oa = r[na].geo, Oa.transform(la, function (a) {
										Oa = a
									}), wa = sa.tileGeometries[ja], a.isNull(wa) && (wa = {}, sa.tileGeometries[ja] = wa), wa[r[na].id] = Oa, sa.clipMap[ja] = S, Aa = sa.zoomLevelsGeometries["zoomlevel_" + b], a.isNull(Aa) ? (Aa = [], Aa.push(Oa), Aa = new a.geometry.GeometryCollection(Aa, la), sa.zoomLevelsGeometries["zoomlevel_" + b] = Aa, Aa =
											[], Aa.push(S), sa.zoomLevelsGeomClipArea["zoomlevel_" + b] = Aa) : (Aa = Aa.geometries, Aa.push(Oa), Aa = sa.zoomLevelsGeomClipArea["zoomlevel_" + b], Aa.push(S));
								Aa = m.tileFeatures[ja];
								a.isNull(Aa) && (Aa = [], m.tileFeatures[ja] = Aa);
								Aa.push(r[na].id);
								m.mappingFeatureNSDP(sa)
							}
						!m.checkVisible() || m.renderingStyle && ("HeatMap" === m.renderingStyle.styleType || m.renderingStyle instanceof a.style.BucketStyle && !m.renderingStyle.isServerSide && m.renderingStyle.buckets && 0 < m.renderingStyle.buckets.length && !(m.renderingStyle.buckets[0]instanceof
								a.style.CollectionBucket)) || m.displayTileFeatures(b, c, y)
					}
					m.addToTileLoadedList(ja)
				};
				U.onerror = function (D) {
					D = b + "_" + c + "_" + y;
					a.util.Logger.warning(null, "VectorTileLayer", "[" + m.name + "]  error while processing tile " + D + ".");
					console.log("[" + m.name + "]  error while processing tile " + D + ".");
					m.addToTileLoadedList(D)
				};
				U.send(null)
			})
		},
		addToTileLoadedList: function (b) {
			if (!(a.isNull(b) || 1 > this.numberOfTilesToLoad) && (this.loadedTiles.push(b), a.notNull(this.loadTileFeaturesTask) && this.loadedTiles.length !== this.numberOfTilesToLoad &&
					this.loadTileFeaturesTask.update(this.loadedTiles.length / this.numberOfTilesToLoad), this.loadedTiles.length === this.numberOfTilesToLoad)) {
				this.loading = !1;
				this.loaded = !0;
				a.util.Logger.fine(null, "VectorTileLayer", "Finished loading of " + this.numberOfTilesToLoad + " tiles.");
				if (this.checkVisible())
					if (this.renderingStyle && "HeatMap" === this.renderingStyle.styleType)
						console.log("Going to display heat map ..."), this.displayHeatMap();
					else if (this.renderingStyle && this.renderingStyle instanceof a.style.BucketStyle &&
						!this.renderingStyle.isServerSide && this.renderingStyle.buckets && 0 < this.renderingStyle.buckets.length && !(this.renderingStyle.buckets[0]instanceof a.style.CollectionBucket) && (this.renderingStyle.generateBuckets(this.featureArray, this.styleAttributes, !0), a.isNotNull(this.featureArray)))
						for (b = 0; b < this.featureArray.length; b++)
							this.displayFeature(this.featureArray[b]);
				a.notNull(this.loadTileFeaturesTask) && (this.loadTileFeaturesTask.complete(), this.loadTileFeaturesTask = null)
			}
		},
		displayEnd: function (a) {
			console.log("Vector tile layer displayEnd called.")
		},
		displayTileFeatures: function (b, c, y) {
			var r = null;
			!1 === a.gv.progressBarDisabled && (r = this.startNewTask());
			b = b + "_" + c + "_" + y;
			c = this.tileFeatures[b];
			if (a.isNotNull(c)) {
				y = {};
				for (var m = .3, D = 0; D < c.length; D++) {
					var S = D / c.length;
					a.isNotNull(y[c[D]]) || (S >= m && (a.notNull(r) && r.update(S), m += .3), y[c[D]] = D, this.displayFeature(this.featuresMap[c[D]], b))
				}
			}
			a.notNull(r) && r.complete()
		},
		displayFeature: function (b, c) {
			if (!a.isNull(b)) {
				if (!b.displayed) {
					var y = this.parentMap.getMapContext();
					y.getWholeMapNum();
					y.getBaseWholeMapIndex();
					a.notNull(this.featureGroupArr) && 0 < this.featureGroupArr.length && (a.notNull(b.activeIdx) ? this.realGroup = this.featureGroupArr[b.activeIdx] : this.realGroup = this.featureGroupArr[0]);
					a.isNull(this.realGroup) && (this.realGroup = this.parentMap.graphics.createGroup(), this.realGroup.applyStyle({
							cursor: this.mouseCursor
						}), this.pointerSensitivity || this.realGroup.applyStyle({
							pointerSensitivity: !1
						}), this.group.appendChild(this.realGroup));
					b.group = this.realGroup;
					b.screenTransformObj = this.parentMap.getMapContext().getTransform();
					b.graphics = this.parentMap.graphics;
					b.parentLayer = this
				}
				y = null;
				y = a.isNotNull(c) ? b.tileGeometries[c][b.id].getMBR() : b.geo.getMBR();
				this.display(b, y, c)
			}
		},
		decodeFeatures: function (b, c) {
			if (a.isNull(b.layers) || 0 === b.layers.length | a.isNull(c))
				return null;
			var y = b.layers[0].extent,
			r = [];
			if (a.isNotNull(b.layers[0].keys) && 0 < b.layers[0].keys.length)
				for (var m = 0; m < b.layers[0].keys.length; m++)
					r.push(b.layers[0].keys[m]);
			var D = [];
			if (a.isNotNull(b.layers[0].values) && 0 < b.layers[0].values.length)
				for (m = 0; m < b.layers[0].values.length; m++) {
					var S =
						null,
					U;
					for (U in b.layers[0].values[m])
						if (b.layers[0].values[m].hasOwnProperty(U)) {
							S = b.layers[0].values[m][U];
							break
						}
					D.push(S)
				}
			S = [];
			if (a.isNotNull(b.layers[0].features) && 0 < b.layers[0].features.length)
				for (m = 0; m < b.layers[0].features.length; m++)
					U = this.decodeFeature(b.layers[0].features[m].type, b.layers[0].features[m].geometry, b.layers[0].features[m].tags, r, D, c, y), a.isNotNull(U) && S.push(U);
			return S
		},
		decodeFeature: function (b, c, y, r, m, D, S) {
			if (a.isNull(c) || a.isNull(D))
				return null;
			var U = null;
			1 === b ? U = this.decodePointGeometry(c,
					D, S) : 2 === b ? U = this.decodeLineGeometry(c, D, S) : 3 === b && (U = this.decodePolygonGeometry(c, D, S));
			if (a.isNull(U))
				return null;
			b = this.decodeFeatureAttributes(y, r, m);
			return a.notNull(b) && a.notNull(b[this.keyColumn]) ? new a.Feature(b[this.keyColumn], U, {
				attributes: b
			}) : null
		},
		decodePointGeometry: function (b, c, y) {
			if (a.isNull(b) || a.isNull(c) || a.isNull(y))
				return null;
			var r = b[0] >> 3,
			m = null,
			m = b[1] >> 1 ^  - (b[1] & 1),
			D = b[2] >> 1 ^  - (b[2] & 1),
			S = this.getMapPoint(c, y, m, D),
			U = m,
			w = D;
			if (1 === r)
				m = new a.geometry.Point(S[0], S[1], 3857);
			else {
				for (var ja =
						[], la = 0; la < r; la++) {
					var na = [];
					0 === la ? (na.push(S[0]), na.push(S[1])) : (m = b[1 + 2 * la] >> 1 ^  - (b[1 + 2 * la] & 1), D = b[2 * la + 2] >> 1 ^  - (b[2 * la + 2] & 1), m += U, D += w, S = this.getMapPoint(c, y, m, D), na.push(S[0]), na.push(S[1]), U = m, w = D);
					ja.push(na)
				}
				m = new a.geometry.MultiPoint(ja, 3857, 2)
			}
			return m
		},
		decodeLineGeometry: function (b, c, y) {
			if (a.isNull(b) || a.isNull(c) || a.isNull(y))
				return null;
			var r = b.length,
			m = b[3] >> 3,
			D = null,
			D = [];
			if (r === 2 * m + 4) {
				var S = b[1] >> 1 ^  - (b[1] & 1),
				U = b[2] >> 1 ^  - (b[2] & 1),
				w = S,
				ja = U,
				la = this.getMapPoint(c, y, S, U);
				D.push(la[0]);
				D.push(la[1]);
				for (S = 0; S < m; S++) {
					var U = b[4 + 2 * S] >> 1 ^  - (b[4 + 2 * S] & 1),
					na = b[2 * S + 5] >> 1 ^  - (b[2 * S + 5] & 1);
					if (U !== w || na !== ja)
						U += w, na += ja, la = this.getMapPoint(c, y, U, na), D.push(la[0]), D.push(la[1]), w = U, ja = na
				}
				D = new a.geometry.LineString(D, 3857, 2)
			} else {
				for (var ja = w = -1, sa = 0, wa = []; sa < r; ) {
					D = [];
					S = b[sa + 1] >> 1 ^  - (b[sa + 1] & 1);
					U = b[sa + 2] >> 1 ^  - (b[sa + 2] & 1);
					0 < sa && (S += w, U += ja);
					la = this.getMapPoint(c, y, S, U);
					D.push(la[0]);
					D.push(la[1]);
					w = S;
					ja = U;
					m = b[sa + 3] >> 3;
					for (S = 0; S < m; S++)
						if (la = sa + 4, U = b[la + 2 * S] >> 1 ^  - (b[la + 2 * S] & 1), na = b[la + 2 * S + 1] >> 1 ^  - (b[la + 2 * S + 1] & 1), U !==
							w || na !== ja)
							U += w, na += ja, la = this.getMapPoint(c, y, U, na), D.push(la[0]), D.push(la[1]), w = U, ja = na;
					wa.push(D);
					sa = sa + 4 + 2 * m
				}
				D = new a.geometry.MultiLineString(wa, 3857, 2)
			}
			return D
		},
		decodePolygonGeometry: function (b, c, y) {
			if (a.isNull(b) || a.isNull(c) || a.isNull(y))
				return null;
			for (var r = b.length, m = b[3] >> 3, D = null, S = [], U = -1, w = -1, ja = 0; ja < r; ) {
				var la = [],
				na = b[ja + 1] >> 1 ^  - (b[ja + 1] & 1),
				m = b[ja + 2] >> 1 ^  - (b[ja + 2] & 1);
				0 < ja && (na += U, m += w);
				U = this.getMapPoint(c, y, na, m);
				la.push(U[0]);
				la.push(U[1]);
				U = na;
				w = m;
				m = b[ja + 3] >> 3;
				for (na = 0; na < m; na++) {
					var sa =
						ja + 4,
					wa = b[sa + 2 * na] >> 1 ^  - (b[sa + 2 * na] & 1),
					sa = b[sa + 2 * na + 1] >> 1 ^  - (b[sa + 2 * na + 1] & 1);
					if (wa !== U || sa !== w)
						wa += U, sa += w, U = this.getMapPoint(c, y, wa, sa), la.push(U[0]), la.push(U[1]), U = wa, w = sa
				}
				na = la[1];
				la.push(la[0]);
				la.push(na);
				S.push(la);
				ja = ja + 4 + 2 * m + 1
			}
			if (0 < S.length) {
				b = [];
				for (na = 0; na < S.length; na++) {
					c = [];
					c.push(S[na]);
					y = a.util.GeomUtil.isClockwise(S[na], 2);
					for (r = na + 1; r < S.length; r++)
						if (a.util.GeomUtil.isClockwise(S[r], 2) === y) {
							na = r - 1;
							break
						} else
							c.push(S[r]);
					b.push(c)
				}
				0 < b.length && (D = 1 === b.length ? new a.geometry.Polygon(b[0],
							3857, 2) : new a.geometry.MultiPolygon(b, 3857, 2))
			}
			return D
		},
		decodeFeatureAttributes: function (b, c, y) {
			if (a.isNull(c))
				return null;
			for (var r = {}, m = 0; m < c.lenght; m++)
				r[c[m]] = "";
			for (m = 0; m < b.length; m += 2)
				r[c[b[m]]] = y[b[m + 1]];
			return r
		},
		getMapPoint: function (b, c, y, r) {
			if (a.isNull(b) || a.isNull(c) || a.isNull(y) || a.isNull(r))
				return null;
			y = y * b.getWidth() / c + b.getMinX();
			b = b.getMaxY() - r * b.getHeight() / c;
			return [y, b]
		},
		mappingFeatureNSDP: function (b) {
			if (!a.isNull(b) && !b.mapping && this.nsdpData && this.nsdpKey) {
				var c = this.getNsdpDataForFeature(b);
				if (a.notNull(c)) {
					a.$.extend(b.attributes, c);
					b.columns = [];
					for (var y in c)
						b.columns.push(y);
					b.mapping = !0
				} else
					b.mapping = !1
			}
		}
	});
	a.visualfilter.VisualFilter = a.Class.extend({
		initialize: function () {}
	});
	a.visualfilter.DropShadow = a.visualfilter.VisualFilter.extend({
		initialize: function (b) {
			this.type = "DROPSHADOW";
			this.angle = b && a.notNull(b.angle) ? b.angle : 45;
			this.color = b && a.notNull(b.color) ? b.color : null;
			this.knockout = b && a.notNull(b.knockout) ? b.knockout : null;
			this.offset = b && a.notNull(b.offset) ? b.offset : 2;
			this.opacity =
				b && a.notNull(b.opacity) ? b.opacity : .5;
			this.radius = b && a.notNull(b.radius) ? b.radius : 2;
			this.applyToLayer = b && a.notNull(b.applyToLayer) ? b.applyToLayer : !0
		}
	});
	a.visualfilter.Glow = a.visualfilter.VisualFilter.extend({
		initialize: function (b) {
			this.type = "GLOW";
			this.color = b && a.notNull(b.color) ? b.color : null;
			this.strength = b && a.notNull(b.strength) ? b.strength : 3;
			this.applyToLayer = b && a.notNull(b.applyToLayer) ? b.applyToLayer : !0
		}
	});
	a.infowindow.InfoWindow = a.Class.extend({
		initialize: function (b, c) {
			this.maxY = this.maxX = this.minY =
				this.minX = 0;
			var y = b.getMapContext();
			this.width = y.getDeviceWidth();
			this.height = y.getDeviceHeight();
			this.parentMap = b;
			this.wininfo = null;
			this.$div = a.$("\x3cdiv style\x3d'position:absolute;width:0px;height:0px;z-index:3000'\x3e\x3c/div\x3e");
			this.parentMap.$topLayerDIV.append(this.$div);
			this.div = this.$div[0];
			this.infoWindows = [];
			this.$infoWindow = null;
			this.mouseOver = this.clrIntervalFlag = this.enablePropagation = !1;
			this.id = c;
			this.idPrefix = "omv2_ifw_";
			y = a.event.MapEvent;
			b.addListener(y.I_MAP_DRAGGING, this.panEventAction);
			b.addListener(y.MAP_BEFORE_REFRESH, this.refreshEventAction);
			b.addListener(y.I_MAP_CENTER_ZOOM, this.zoomEventAction);
			b.addListener(y.MAP_RESIZED, this.resizeEventAction);
			b.addListener(y.MAP_DESTROY, this.destroyEventAction);
			b.addListener(y.MAP_CLEAN, this.refreshEventAction);
			var r = this;
			r.infoStopPropagation = function (b) {
				a.event.EventSource.stopEvents[b.type] = !0
			};
			r.infoMouseMove = function (a) {
				r.mouseOnInfoWindow = !0;
				r.div && (r.div.style.zIndex = 3002);
				r.infoStopPropagation(a)
			};
			r.infoMouseOver = function (a) {
				r.mouseOnInfoWindow =
					!0;
				r.div && (r.div.style.zIndex = 3001);
				r.infoStopPropagation(a)
			};
			r.infoMouseOut = function (a) {
				r.mouseOnInfoWindow = !1;
				r.div && (r.div.style.zIndex = 3E3);
				r.infoStopPropagation(a)
			};
			this.$div.bind("mousemove", r.infoMouseMove);
			this.$div.bind("mouseover", r.infoMouseOver);
			this.$div.bind("mouseout", r.infoMouseOut);
			this.$div.bind("touchmove touchend mousewheel DOMMouseScroll mousedown mouseover mouseout click keyup keydown keypress dblclick", this.infoStopPropagation)
		},
		init: function (b) {
			b = b ? b : {};
			this.ellipsis = !1 ===
				b.ellipsis ? !1 : !0;
			this.infoWidth = parseInt(b.width);
			this.infoHeight = parseInt(b.height);
			this.background = b.background ? b.background : "#F5F5F9";
			this.title_string = b.title ? b.title : "";
			this.tailStyle = this.closeButtonStyle = null;
			b.infoWindowStyle ? ("string" == typeof b.infoWindowStyle ? (this.infoWindowStyle = {}, this.infoWindowStyle = this.toJsonCss(b.infoWindowStyle)) : this.infoWindowStyle = b.infoWindowStyle, this.infoWindowStyle["background-color"] && (this.infoWindowStyle.background = this.infoWindowStyle["background-color"]),
				this.background = this.infoWindowStyle.background, this.infoWindowStyle && this.infoWindowStyle.background || (this.background = this.infoWindowStyle.background = "#F5F5F9")) : this.infoWindowStyle = {};
			b.titleStyle ? "string" == typeof b.titleStyle ? (this.titleStyle = {}, this.titleStyle = this.toJsonCss(b.titleStyle)) : this.titleStyle = b.titleStyle : this.titleStyle = {};
			b.contentStyle ? "string" == typeof b.contentStyle ? (this.contentStyle = {}, this.contentStyle = this.toJsonCss(b.contentStyle)) : this.contentStyle = b.contentStyle : this.contentStyle = {};
			this.tailStyle = b.tailStyle ? b.tailStyle : {};
			b.closeButtonStyle && (this.closeButtonStyle = b.closeButtonStyle);
			this.infoWinId = this.idPrefix + b.id + "_";
			this.clrIntervalFlag = !1;
			this.typeId = b.typeId ? b.typeId : this.parentMap.mapInstanceId + "_1";
			this.$infoWindow = a.$("\x3cdiv class\x3d'omv2_infoWindow_info' id\x3d\"" + this.infoWinId + '"\x3e\x3c/div\x3e');
			this.$container = a.$("\x3cdiv\x3e\x3c/div\x3e")
		},
		showTabInfoWindow: function (b, c, y) {
			this.init(y);
			b = this.parentMap.getScreenLocation(b);
			for (var r = 0; r < this.infoWindows.length; r++) {
				if (this.infoWinId &&
					this.infoWindows[r].nid == this.infoWinId) {
					this.deleteInfoWindow(this.infoWindows[r]);
					return
				}
				this.typeId && this.infoWindows[r].typeId == this.typeId && this.deleteInfoWindow(this.infoWindows[r])
			}
			this.infoWidth || (this.infoWidth = 150);
			this.infoHeight || (this.infoHeight = 50);
			this.getPageDirection();
			this.$infoWindow.css({
				background: "none repeat scroll 0 0 " + this.background,
				width: this.infoWidth,
				height: this.infoHeight
			});
			this.$infoWindow.css(this.infoWindowStyle);
			this.$container.css({
				position: "absolute",
				width: this.infoWidth -
				5,
				height: this.infoHeight - 3,
				left: "6px",
				"z-index": "2"
			});
			this.div.appendChild(this.$infoWindow[0]);
			this.createCloseButtonDiv();
			var m = a.$("\x3cimg class\x3d'omv2_l_arrow_info' src\x3d'" + a.gv.resourcePath() + "overflow_left_ena.png'\x3e\x3c/img\x3e"),
			D = a.$("\x3cimg class\x3d'omv2_r_arrow_info' src\x3d'" + a.gv.resourcePath() + "overflow_right_ena.png'\x3e\x3c/img\x3e");
			this.pageDirection ? (D.css({
					right: "10px",
					top: "14px"
				}), m.css({
					left: "0px",
					top: "14px"
				}), D.bind("click touchstart", function () {
					m.css({
						visibility: "visible"
					});
					ja.css({
						left: parseInt(ja.css("left")) - 60
					});
					parseInt(ja.css("left")) <= 60 *  - (c.length - 1) && D.css({
						visibility: "hidden"
					})
				}).mouseover(function () {
					a.$(this)[0].src = a.gv.resourcePath() + "overflow_right_ovr.png"
				}).mouseout(function () {
					a.$(this)[0].src = a.gv.resourcePath() + "overflow_right_ena.png"
				}), m.bind("click touchstart", function () {
					D.css({
						visibility: "visible"
					});
					ja.css({
						left: parseInt(ja.css("left")) + 60
					});
					0 <= parseInt(ja.css("left")) && (m.css({
							visibility: "hidden"
						}), D.css({
							visibility: "visible"
						}))
				}).mouseover(function () {
					a.$(this)[0].src =
						a.gv.resourcePath() + "overflow_left_ovr.png"
				}).mouseout(function () {
					a.$(this)[0].src = a.gv.resourcePath() + "overflow_left_ena.png"
				})) : (D.css({
					right: "0px",
					top: "14px"
				}), m.css({
					left: "12px",
					top: "14px"
				}), D.bind("click touchstart", function () {
					m.css({
						visibility: "visible"
					});
					ja.css({
						right: parseInt(ja.css("right")) - 60
					});
					parseInt(ja.css("right")) <= 60 *  - (c.length - 1) && D.css({
						visibility: "hidden"
					})
				}).mouseover(function () {
					a.$(this)[0].src = a.gv.resourcePath() + "overflow_right_ovr.png"
				}).mouseout(function () {
					a.$(this)[0].src =
						a.gv.resourcePath() + "overflow_right_ena.png"
				}), m.bind("click touchstart", function () {
					D.css({
						visibility: "visible"
					});
					ja.css({
						right: parseInt(ja.css("right")) + 60
					});
					0 <= parseInt(ja.css("right")) && (m.css({
							visibility: "hidden"
						}), D.css({
							visibility: "visible"
						}))
				}).mouseover(function () {
					a.$(this)[0].src = a.gv.resourcePath() + "overflow_left_ovr.png"
				}).mouseout(function () {
					a.$(this)[0].src = a.gv.resourcePath() + "overflow_left_ena.png"
				}));
			var r = this.infoWinId + "tabs",
			S = this.infoWinId + "tab_",
			U = this.infoWinId + "subTab_",
			w =
				a.$("\x3cdiv class\x3d'omv2_tabDiv_info'\x3e\x3c/div\x3e"),
			ja = a.$("\x3cdiv class\x3d'omv2_tab_info' id\x3d'" + r + "'\x3e\x3c/div\x3e"),
			la;
			if (0 === c.length)
				r = a.$("\x3cdiv class\x3d'omv2_tab_select_info' name\x3d'#tab'\x3esample\x3c/div\x3e"), r.data("ts", "sample"), ja[0].appendChild(r[0]);
			else
				for (r = 0; r < c.length; r++)
					la = 0 === r ? "omv2_tab_select_info" : "omv2_tab_unselect_info", la = this.pageDirection ? a.$("\x3cdiv id\x3d'" + U + r + "' class\x3d'" + la + "' style\x3d'left:" + 60 * r + "px' name\x3d'#tab" + r + "'\x3e" + c[r].title + "\x3c/div\x3e") :
						a.$("\x3cdiv id\x3d'" + U + r + "' class\x3d'" + la + "' style\x3d'text-align:right;text-indent:6px;right:" + 60 * r + "px' name\x3d'#tab" + r + "'\x3e" + c[r].title + "\x3c/div\x3e"), la.data("ts", c[r].title), a.browser.touchSupported || this.tipLengthAdjust(la, 60), ja[0].appendChild(la[0]);
			this.pageDirection || ja.css({
				right: "0px"
			});
			this.createTip(ja.find("div"));
			la = this.infoWinId + "content";
			var na = a.$("\x3cdiv id\x3d'" + la + "' class\x3d'omv2_defaultContent_info'\x3e\x3c/div\x3e");
			if (0 === c.length)
				U = a.$("\x3cdiv id\x3d'" + S + "' style\x3d'margin-top:5px;'\x3e \x3ch2\x3etab sample\x3c/h2\x3e  \x3c/div\x3e"),
				na[0].appendChild(U[0]);
			else
				for (r = 0; r < c.length; r++)
					U = this.pageDirection ? a.$("\x3cdiv id\x3d'" + S + r + "' style\x3d'margin-top:5px;'\x3e " + c[r].content + "  \x3c/div\x3e") : a.$("\x3cdiv id\x3d'" + S + r + "' style\x3d'text-align:right;margin-top:5px;'\x3e " + c[r].content + "  \x3c/div\x3e"), na[0].appendChild(U[0]);
			this.createGeneralDiv();
			this.$infoWindow[0].appendChild(D[0]);
			this.$infoWindow[0].appendChild(m[0]);
			this.infoWindows.push(this.$infoWindow);
			this.$infoWindow.nid = this.infoWinId;
			this.$infoWindow.typeId = this.typeId;
			this.$infoWindow.winX = b.x;
			this.$infoWindow.winY = b.y;
			w[0].appendChild(ja[0]);
			this.$container[0].appendChild(w[0]);
			this.$container[0].appendChild(na[0]);
			this.$infoWindow[0].appendChild(this.$container[0]);
			for (r = 0; r < c.length; r++)
				this.touchscroll("subtab" + r);
			this.touchscroll(la);
			w.css({
				width: this.$infoWindow.width() - 38
			});
			this.pageDirection ? w.css({
				left: "8px"
			}) : w.css({
				right: "12px"
			});
			60 * c.length < this.$infoWindow.width() ? (m.css({
					visibility: "hidden"
				}), D.css({
					visibility: "hidden"
				})) : m.css({
				visibility: "hidden"
			});
			na.css({
				position: "absolute",
				top: w.height(),
				height: this.infoHeight - w.height(),
				width: this.$infoWindow.width() - 12,
				overflow: "auto"
			});
			na.css(this.contentStyle);
			0 < na.find("a").length && na.find("a").bind("touchstart", function () {
				h.location.href = na.find("a").attr("href")
			});
			b = this.checkInfoWindowOverLayer(this, this.$infoWindow, b);
			S = this.pageDirection ? b.x : b.x + this.$infoWindow.width();
			this.$infoWindow.css({
				left: S,
				top: b.y,
				visibility: "visible"
			});
			this.tabControl();
			a.$("#tabs").find("div").mouseover(function () {
				a.$(this).css({
					cursor: "pointer"
				})
			});
			na.mouseover(function () {
				a.$(this).css({
					cursor: "default"
				})
			});
			if (a.notNull(y) && a.notNull(y.activeIndex))
				for (a.$("#tabs div[name\x3d#tab" + (y.activeIndex - 1) + "]").click(), r = 0; r < y.activeIndex - 1; r++);
		},
		showInfoWindow: function (a, b, c) {
			var r = this;
			r.init(c);
			b.wraparoundMapIndex && (b = r.parentMap.getACL(b, b.wraparoundMapIndex));
			r.screenLoc = r.parentMap.getScreenLocation(b);
			for (b = 0; b < r.infoWindows.length; b++)
				r.infoWinId && r.infoWindows[b].nid == r.infoWinId ? r.deleteInfoWindow(r.infoWindows[b]) : r.typeId && r.infoWindows[b].typeId ==
				r.typeId && r.deleteInfoWindow(r.infoWindows[b]);
			r.getPageDirection();
			r.infoWindows.push(r.$infoWindow);
			r.$infoWindow.nid = r.infoWinId;
			r.$infoWindow.typeId = r.typeId;
			r.$infoWindow.winX = r.screenLoc.x;
			r.$infoWindow.winY = r.screenLoc.y;
			r.createCloseButtonDiv();
			a = r.initCss(a);
			var m = a[0],
			D = a[1];
			r.calculatePosition(m, D, r.screenLoc, c);
			var S = setInterval(function () {
				r.$closeButton && m && D && (clearInterval(S), r.titleContentCloseAdjust(m, D, r.$closeButton))
			}, 10)
		},
		initCss: function (b) {
			var c = this.infoWinId + "content",
			y = a.$("\x3cdiv id\x3d'" +
					(this.infoWinId + "title") + "' class\x3d'omv2_defaultTitle_info'\x3e" + this.title_string.replace(/[ ]/g, "\x26nbsp;") + "\x3c/div\x3e"),
			r = a.$("\x3cdiv id\x3d'" + c + "' class\x3d'omv2_defaultContent_info'\x3e" + b + "\x3c/div\x3e");
			this.$infoWindow.css({
				width: this.infoWidth,
				height: this.infoHeight
			});
			this.$infoWindow.css(this.infoWindowStyle);
			this.$container.css({
				position: "absolute",
				width: this.infoWidth - 5,
				height: this.infoHeight - 3,
				"z-index": "2"
			});
			this.div.appendChild(this.$infoWindow[0]);
			this.pageDirection ? y.css({
				left: "5px"
			}) :
			y.css({
				right: "5px",
				"text-align": "right"
			});
			this.$container[0].appendChild(y[0]);
			this.$container[0].appendChild(r[0]);
			this.$infoWindow[0].appendChild(this.$container[0]);
			r.css({
				top: parseInt(y.height()) + 2,
				height: "",
				width: ""
			});
			this.infoWidth && ("" !== this.title_string ? r.css({
					width: this.$infoWindow.width() - 10
				}) : r.css({
					width: this.$infoWindow.width() - 20
				}));
			this.infoHeight && ("" !== this.title_string ? r.css({
					height: this.$infoWindow.height() - y.height() - 3
				}) : r.css({
					height: this.$infoWindow.height() - 3
				}));
			r.css(this.contentStyle);
			0 < r.find("a").length && r.find("a").bind("touchstart", function () {
				h.location.href = r.find("a").attr("href")
			});
			this.touchscroll(c);
			this.pageDirection ? r.css({
				left: "5px",
				"margin-right": "5px"
			}) : r.css({
				right: "5px"
			});
			y.data("ts", y.html());
			this.titleStyle.width && !a.browser.touchSupported && this.tipLengthAdjust(y, parseInt(this.titleStyle.width) - 20);
			1 < this.$infoWindow.width() && y.width(this.$infoWindow.width() - 20);
			y.css(this.titleStyle);
			this.touchscroll("title");
			r.mouseover(function () {
				a.$(this).css({
					cursor: "default"
				})
			});
			y.mouseover(function () {
				a.$(this).css({
					cursor: "default"
				})
			});
			"" === this.title_string && (y.width("0px"), y.height("0px"));
			return [y, r]
		},
		infoResize: function (b, c, y, r) {
			var m = this.height - y.y,
			D = this.width - y.x;
			if (this.$infoWindow.height() > m - 20 && this.$infoWindow.height() > y.y - 20 && (parseInt(this.$infoWindow.css("top")) + this.$infoWindow.height() > this.height || 0 > parseInt(this.$infoWindow.css("top"))) || this.$infoWindow.width() > D - 20 && this.$infoWindow.width() > y.x - 20)
				this.infoDomResize(b, c, y), this.$infoWindow.height() >
				m - 20 && this.$infoWindow.height() > y.y - 20 && (parseInt(this.$infoWindow.css("top")) + this.$infoWindow.height() > this.height || 0 > parseInt(this.$infoWindow.css("top"))) && (m >= y.y ? 0 > parseInt(this.$infoWindow.css("top")) ? (c.height(m - 60), a.browser.firefox && "" !== this.title_string ? c.width(c.width() + 45) : c.width(c.width() + 25), "" !== this.title_string ? this.$infoWindow.width(c.width() + 11) : this.$infoWindow.width(c.width() + 20), this.$infoWindow.height(m + 5 - 60)) : (c.height(m), a.browser.firefox && "" !== this.title_string ? c.width(c.width() +
							45) : c.width(c.width() + 25), "" !== this.title_string ? this.$infoWindow.width(c.width() + 11) : this.$infoWindow.width(c.width() + 20), this.$infoWindow.height(m + 5)) : 50 > m ? (c.height(y.y - 60), a.browser.firefox && "" !== this.title_string ? c.width(c.width() + 45) : c.width(c.width() + 25), "" !== this.title_string ? this.$infoWindow.width(c.width() + 11) : this.$infoWindow.width(c.width() + 20), this.$infoWindow.height(y.y + 5 - 60)) : (c.height(y.y), a.browser.firefox && "" !== this.title_string ? c.width(c.width() + 45) : c.width(c.width() + 25), "" !== this.title_string ?
						this.$infoWindow.width(c.width() + 11) : this.$infoWindow.width(c.width() + 20), this.$infoWindow.height(y.y + 5))), this.$infoWindow.width() > D - 20 && this.$infoWindow.width() > y.x - 20 && (D >= y.x ? (c.width(D - 40), this.$infoWindow.width(D - 40 + 20)) : (c.width(y.x - 40), this.$infoWindow.width(y.x - 40 + 20))), 5 <= b.height() + c.height() - this.$infoWindow.height() && this.$infoWindow.height(b.height() + c.height() + 5), r && a.notNull(r.title) && (b.width() > this.$infoWindow.width() - 20 && b.width(this.$infoWindow.width() - 20), a.browser.touchSupported ||
					this.tipLengthAdjust(b, parseInt(this.$infoWindow.width()) - 19)), 30 > this.$infoWindow.height() && this.checkMinHeightInfowindow(b, c), this.adjustInfowindowLayout(this, y);
			this.clrIntervalFlag = !0
		},
		infoDomResize: function (a, b, c) {
			b.width() > this.$infoWindow.width() && (this.$infoWindow.width(b.width() + 20), this.$infoWindow[0].removeChild(this.$hideDiv[0]), this.$infoWindow[0].removeChild(this.$fadeDiv[0]), this.$infoWindow[0].removeChild(this.$vancantDiv[0]), this.createGeneralDiv(), this.adjustInfowindowLayout(this,
					c), this.clrIntervalFlag = !0);
			b.height() > this.$infoWindow.height() - a.height() && (0 === a.height() ? (b.css({
						width: this.$infoWindow.width() - 19
					}), b.height(b.height()), this.$infoWindow.height(b.height() + parseInt(a.css("top")) + 2)) : (b.css({
						width: this.$infoWindow.width() - 11
					}), this.$infoWindow.height(b.height() + a.height() + parseInt(a.css("top")) + 2)), 30 > this.$infoWindow.height() && this.checkMinHeightInfowindow(a, b), this.$infoWindow[0].removeChild(this.$hideDiv[0]), this.$infoWindow[0].removeChild(this.$fadeDiv[0]),
				this.$infoWindow[0].removeChild(this.$vancantDiv[0]), this.createGeneralDiv(), this.adjustInfowindowLayout(this, c), this.clrIntervalFlag = !0)
		},
		setInfoSize: function (b, c) {
			this.infoWidth ? (b.width() > this.$infoWindow.width() - 20 && b.width(this.$infoWindow.width() - 20), "" !== this.title_string ? c.width() > this.$infoWindow.width() - 10 && c.width(this.$infoWindow.width() - 10) : c.width() > this.$infoWindow.width() - 20 && c.width(this.$infoWindow.width() - 20), !a.browser.touchSupported && (a.isNull(this.titleStyle.width) || this.titleStyle.width >=
					this.infoWidth || "" === this.titleStyle.width) && this.tipLengthAdjust(b, parseInt(this.$infoWindow.width()) - 20)) : (b.width() + 6 > c.width() ? (b.width(b.width() + 6), b.width() > 1.5 * c.width() && this.ellipsis && b.width(1.5 * c.width()), this.$infoWindow.width(b.width() + 20), this.contentStyle.width || c.width(b.width())) : ("" !== this.title_string ? this.$infoWindow.width(c.width() + 11) : this.$infoWindow.width(c.width() + 20), this.titleStyle.width || "" === this.title_string || b.width(c.width() - 10)), 120 > this.$infoWindow.width() && this.checkMinWidthInfowindow(b,
					c), a.browser.touchSupported || this.tipLengthAdjust(b, parseInt(this.$infoWindow.width()) - 18), this.infoWidth = this.$infoWindow.width());
			this.infoHeight ? (b.height() > this.$infoWindow.height() - 2 && b.height(this.$infoWindow.height()), c.height() > this.infoHeight - parseInt(b.height()) && c.height(this.infoHeight - parseInt(b.height()) - 3), c.css({
					top: parseInt(b.height()) + 2
				})) : (this.$infoWindow.height(c.height() + b.height() + parseInt(b.css("top")) + 2), 30 > this.$infoWindow.height() && this.checkMinHeightInfowindow(b, c), c.css({
					top: parseInt(b.height()) +
					2
				}), this.infoHeight = this.$infoWindow.height())
		},
		checkMinWidthInfowindow: function (a, b) {
			this.$infoWindow.width("120px");
			"" !== this.title_string ? (a.width("100px"), b.width("110px")) : b.width("100px")
		},
		checkMinHeightInfowindow: function (a, b) {
			this.$infoWindow.height("30px");
			b.height(30 - parseInt(a.height()) - 3)
		},
		calculatePosition: function (b, c, y, r) {
			var m = this;
			m.setInfoSize(b, c);
			m.createGeneralDiv();
			m.t_h = b.height();
			(a.browser.chrome || a.browser.touchSupported) && 0 === c.find("img").length && 6 > m.$infoWindow.width() -
			c.width() && c.width(c.width() - 1);
			var D = 0;
			if (!m.infoHeight || !m.infoWidth)
				if (a.isNull(m.contentStyle.width) || a.isNull(m.contentStyle.height))
					var S = setInterval(function () {
						121 >= m.$infoWindow.width() ? m.checkMinWidthInfowindow(b, c) : m.infoWidth || c.width("");
						30 >= m.$infoWindow.height() ? m.checkMinHeightInfowindow(b, c) : m.infoHeight || c.height("");
						(a.browser.chrome || a.browser.touchSupported) && 0 === c.find("img").length && 6 > m.$infoWindow.width() - c.width() && c.width(c.width() - 1);
						D++;
						20 < D && clearInterval(S);
						m.infoDomResize(b,
							c, y);
						m.infoResize(b, c, y, r);
						m.clrIntervalFlag && (clearInterval(S), "" !== m.title_string && (b.width(m.$infoWindow.width() - 20), b.html(b.data("ts")), a.browser.touchSupported || m.tipLengthAdjust(b, parseInt(m.$infoWindow.width()) - 19)));
						"" !== m.title_string && b.width() > c.width() && c.width(b.width());
						m.$infoWindow.css({
							visibility: "visible"
						})
					}, 100);
			var U = 0,
			w = setInterval(function () {
				U++;
				m.infoResize(b, c, y, r);
				if (20 < U || m.clrIntervalFlag)
					clearInterval(w), 0 !== c.find("img").length && c.height(m.$infoWindow.height() - b.height() -
						3)
			}, 100);
			if (a.browser.chrome && c.find("img") && c.find("img").length)
				try {
					c.find("img").load(function () {
						c.width(a.$("#content").children().first().width() + 25);
						m.infoDomResize(b, c, y)
					})
				} catch (ja) {}
			m.adjustInfowindowLayout(m, y);
			m.infoHeight && m.infoWidth || (a.isNull(m.contentStyle.width) || a.isNull(m.contentStyle.height)) && m.$infoWindow.css({
				visibility: "hidden"
			});
			m.createTip(b)
		},
		adjustInfowindowLayout: function (a, b) {
			var c = a.checkInfoWindowOverLayer(a, a.$infoWindow, b),
			r = a.$infoWindow[0].offsetParent ? a.$infoWindow[0].offsetParent.offsetLeft :
				0,
			m = a.$infoWindow.width(),
			D = c.x;
			a.pageDirection || (D += m - r);
			a.$infoWindow.css({
				left: D,
				top: c.y,
				visibility: "visible"
			})
		},
		titleContentCloseAdjust: function (a, b, c) {
			var r;
			r = a.width() > b.width() ? a.width() : b.width();
			b.width() == this.$infoWindow.width() - 10 && (r = a.width());
			var m = parseInt(c.width()),
			D = parseInt(c.height()),
			S,
			U;
			this.closeButtonStyle ? (S = parseInt(this.closeButtonStyle.xOffset), U = parseInt(this.closeButtonStyle.yOffset)) : U = S = 0;
			S || (S = 0);
			U || (U = 0);
			this.$infoWindow.width() - r < c.width() + parseInt(c.css("right")) &&
			(this.pageDirection ? c.css({
					right: this.$infoWindow.width() - r - 6 - c.width()
				}) : c.css({
					left: this.$infoWindow.width() - r - 6 - c.width()
				}));
			0 > this.$infoWindow.width() - r - 6 - c.width() && (this.pageDirection ? c.css({
					right: "0"
				}) : c.css({
					left: "0"
				}));
			this.$infoWindow.width() - r <= c.width() ? c.width(this.$infoWindow.width() - r - 6) : 21 > this.$infoWindow.width() - r && (this.pageDirection ? c.css({
					right: "0"
				}) : c.css({
					left: "0"
				}), c.width("14px"));
			c.height() + parseInt(c.css("top")) > this.$infoWindow.height() && c.css({
				top: this.$infoWindow.height() -
				c.height()
			});
			c.height() > this.$infoWindow.height() - parseInt(c.css("top")) && c.height(this.$infoWindow.height() - parseInt(c.css("top")));
			c.height() > this.$infoWindow.height() && (c.css({
					top: "0"
				}), c.height(this.$infoWindow.height()));
			m + S < this.$infoWindow.width() - r && (this.pageDirection ? c.css({
					right: S + "px"
				}) : c.css({
					left: S + "px"
				}), c.width(m));
			m + S >= this.$infoWindow.width() - r && m < this.$infoWindow.width() - r && (this.pageDirection ? c.css({
					right: this.$infoWindow.width() - r - m - 6 + "px"
				}) : c.css({
					left: this.$infoWindow.width() -
					r - m - 6 + "px"
				}), c.width(m));
			D + U < this.$infoWindow.height() && (c.css({
					top: U + "px"
				}), c.height(D));
			D + U >= this.$infoWindow.height() && D < this.$infoWindow.height() && (c.css({
					top: this.$infoWindow.height() - D - 6 + "px"
				}), c.height(D));
			11 >= this.$infoWindow.width() - b.width() && (m + S < this.$infoWindow.width() - a.width() - 5 ? (this.pageDirection ? c.css({
						right: S + "px"
					}) : c.css({
						left: S + "px"
					}), c.width(m)) : m + S >= this.$infoWindow.width() - a.width() - 5 && m < this.$infoWindow.width() - a.width() - 5 ? (this.pageDirection ? c.css({
						right: this.$infoWindow.width() -
						a.width() - 5 - m + "px"
					}) : c.css({
						left: this.$infoWindow.width() - a.width() - 5 - m + "px"
					}), c.width(m)) : (this.pageDirection ? c.css({
						right: "0px"
					}) : c.css({
						left: "0px"
					}), c.width("14px")), D + U < a.height() ? (c.css({
						top: U + "px"
					}), c.height(D)) : D + U >= a.height() && D < a.height() ? (c.css({
						top: a.height() - D + "px"
					}), c.height(D)) : (c.css({
						top: "0px"
					}), c.height("14px")));
			this.infoHeight || this.infoWidth || this.contentStyle.width || this.contentStyle.height || this.titleStyle.width || this.titleStyle.height || (this.pageDirection ? c.css({
					right: "0px"
				}) :
				c.css({
					left: "0px"
				}), c.width("14px"), c.css({
					top: "0px"
				}), c.height("14px"))
		},
		tipLengthAdjust: function (b, c) {
			var y;
			if ("omv2_defaultTitle_info" != b.attr("class")) {
				if (y = a.$("\x3cdiv class\x3d'omv2_temp_info' \x3e" + b.html() + "\x3c/div\x3e"), this.$infoWindow[0].appendChild(y[0]), y.width() > c)
					for (var r = y.html().length - 1; -1 < r; r--) {
						var m = y.html();
						if (y.width() < c) {
							b.html(y.html().substring(0, y.html().length - 3) + "...");
							break
						}
						y.html(m.substring(0, r))
					}
			} else if (y = a.$("\x3cdiv class\x3d'omv2_temp_info' \x3e" + b.text() + "\x3c/div\x3e"),
				y.css({
					"font-size": "16px",
					"font-family": "Tahoma",
					"font-weight": "bold"
				}), this.titleStyle["font-size"] && y.css({
					"font-size": this.titleStyle["font-size"]
				}), this.titleStyle["font-family"] && y.css({
					"font-family": this.titleStyle["font-family"]
				}), this.titleStyle["font-weight"] && y.css({
					"font-weight": this.titleStyle["font-weight"]
				}), this.$infoWindow[0].appendChild(y[0]), y.width() > c)
				for (y.html("..."), r = 0; r < b.text().length; r++) {
					if (y.width() > c) {
						b.html(y.text());
						break
					}
					y.html(b.text().substring(0, r) + "...")
				}
		},
		createCloseButtonDiv: function () {
			var b =
				this;
			b.$closeButton = this.closeButtonStyle && this.closeButtonStyle.mouseOutButton && this.closeButtonStyle.mouseOutButton.src ? a.$("\x3cimg class\x3d'omv2_closeButton_info' src\x3d'" + this.closeButtonStyle.mouseOutButton.src + "'\x3e\x3c/img\x3e") : a.$("\x3cimg class\x3d'omv2_closeButton_info' src\x3d'" + a.gv.resourcePath() + "close_en.png'\x3e\x3c/img\x3e");
			this.pageDirection ? (b.$closeButton.css({
					right: "0"
				}), this.closeButtonStyle && this.closeButtonStyle.xOffset && b.$closeButton.css({
					right: this.closeButtonStyle.xOffset
				})) :
			(b.$closeButton.css({
					left: "0"
				}), this.closeButtonStyle && this.closeButtonStyle.xOffset && b.$closeButton.css({
					left: this.closeButtonStyle.xOffset
				}));
			this.closeButtonStyle && this.closeButtonStyle.yOffset && b.$closeButton.css({
				top: this.closeButtonStyle.yOffset
			});
			a.browser.touchSupported && b.$closeButton.bind("touchstart", function () {
				b.deleteInfoWindow(b.infoWindows[0]);
				return !1
			});
			b.$closeButton.click(function () {
				b.deleteInfoWindow(b.infoWindows[0]);
				return !1
			}).mouseover(function () {
				b.closeButtonStyle && b.closeButtonStyle.mouseOverButton &&
				b.closeButtonStyle.mouseOverButton.src ? a.$(this)[0].src = b.closeButtonStyle.mouseOverButton.src : a.$(this)[0].src = a.gv.resourcePath() + "close_ov.png"
			}).mouseout(function () {
				b.closeButtonStyle && b.closeButtonStyle.mouseOutButton && b.closeButtonStyle.mouseOutButton.src ? a.$(this)[0].src = b.closeButtonStyle.mouseOutButton.src : a.$(this)[0].src = a.gv.resourcePath() + "close_en.png"
			});
			this.closeButtonStyle && this.closeButtonStyle.width && b.$closeButton.width(this.closeButtonStyle.width);
			this.closeButtonStyle && this.closeButtonStyle.height &&
			b.$closeButton.height(this.closeButtonStyle.height);
			this.$infoWindow[0].appendChild(b.$closeButton[0])
		},
		createGeneralDiv: function () {
			var b = a.$("\x3cdiv class\x3d'omv2_tail_info'\x3e\x3c/div\x3e"),
			c = a.$("\x3cdiv\x3e\x3c/div\x3e"),
			y = a.$("\x3cdiv style\x3d'position:absolute;overflow:hidden;border:0px solid black;'\x3e\x3c/div\x3e"),
			r = a.$("\x3cdiv style\x3d'z-index:3001;position:absolute;background:" + this.background + "'\x3e\x3c/div\x3e");
			c.css({
				position: "absolute",
				background: this.background,
				"z-index": "1",
				"border-radius": "5px 5px 5px 5px"
			});
			this.infoWindowStyle && this.infoWindowStyle.border ? c.css({
				width: parseInt(this.infoWindowStyle.border.split(" ")[0]) + 1 + "px"
			}) : c.css({
				width: "1px"
			});
			b.width("25px");
			b.height("25px");
			60 > this.$infoWindow.height() && (b.width("15px"), b.height("15px"));
			this.tailStyle && (b.css(this.tailStyle), "" !== this.tailStyle.offset && (b.width(this.tailStyle.offset), b.height(this.tailStyle.offset)));
			1.414 * b.width() > this.$infoWindow.width() && (b.width(this.$infoWindow.width()), b.height(b.width()));
			1.414 * b.height() > this.$infoWindow.height() && (b.height(.707 * (this.$infoWindow.height() - 25)), b.width(b.height()));
			if (130 < b.width() || 130 < b.height())
				b.width("130px"), b.height("130px");
			this.$tail_h_backup = b.height();
			this.$tail_w_backup = b.width();
			y.width(.707 * parseInt(b.width()) + 3);
			y.height(1.414 * parseInt(b.height()) + 3);
			y[0].appendChild(b[0]);
			this.$infoWindow[0].appendChild(r[0]);
			this.$infoWindow[0].appendChild(y[0]);
			this.$infoWindow[0].appendChild(c[0]);
			this.$tail = b;
			this.$hideDiv = y;
			this.$fadeDiv = c;
			this.$vancantDiv =
				r
		},
		createTip: function (b) {
			var c = a.$("\x3cspan class\x3d'omv2_tip_info'\x3e\x3c/span\x3e");
			this.$infoWindow[0].appendChild(c[0]);
			var y,
			r,
			m;
			b.mouseover(function () {
				var D = this;
				y = !1;
				var S;
				S = "omv2_tab_info" == b.parent().attr("class") ? a.$(D).position().left + parseInt(b.parent().css("left")) + 30 : a.$(D).position().left + 30;
				r = setTimeout(function () {
					y = !0
				}, 1E3);
				m = setInterval(function () {
					y && (a.$(D).data("ts") && c.html(a.$(D).data("ts").replace(/[ ]/g, "\x26nbsp;")), c.css({
							display: "block",
							left: S
						}))
				}, 100);
				"current" != a.$(this)[0].id &&
				"omv2_tab_info" == b.parent().attr("class") && a.$(this).css({
					background: "#2F4F4F",
					color: "#9cd9fe"
				})
			}).mouseout(function () {
				y = !1;
				clearTimeout(r);
				clearInterval(m);
				c.css({
					display: "none"
				});
				"current" != a.$(this)[0].id && "omv2_tab_info" == b.parent().attr("class") && a.$(this).css({
					background: "#2F4F4F",
					color: "#e9f6fe"
				})
			})
		},
		panEventAction: function (b) {
			var c = b.target.infoLayer;
			if (!a.isNull(c) && c.$div) {
				var y = parseInt(c.$infoWindow[0].style.left),
				r = parseInt(c.$infoWindow[0].style.top),
				r = isNaN(r) ? 0 : r,
				y = isNaN(y) ? 0 : y;
				c.$infoWindow.css({
					left: y +
					b.xOffset,
					top: r + b.yOffset
				});
				c.screenLoc.x += b.xOffset;
				c.screenLoc.y += b.yOffset
			}
		},
		refreshEventAction: function (a) {
			a.target.infoLayer.deleteInfoWindow()
		},
		zoomEventAction: function (a) {
			a.target.infoLayer.closeInfoWindows()
		},
		destroyEventAction: function (b) {
			b = b.target.infoLayer;
			a.isNotNull(b) && b.destroy()
		},
		resizeEventAction: function (a) {
			a = a.target.infoLayer;
			a.closeInfoWindows();
			var b = a.parentMap.getMapContext();
			a.width = b.getDeviceWidth();
			a.height = b.getDeviceHeight()
		},
		deleteInfoWindow: function (a) {
			for (var b = 0,
				b = 0; b < this.infoWindows.length; b++)
				this.infoWindows[b] == a && this.infoWindows.splice(b, 1);
			this.$div.off("mouseover mouseout mousedown mouseup click touchend", "**");
			this.$div.empty();
			this.mouseOnInfoWindow = !1
		},
		closeInfoWindows: function () {
			for (var b = 0, c = this.infoWindows.length; b < c; b++) {
				this.deleteInfoWindow(this.infoWindows[b]);
				var y = this.parentMap;
				if (!a.isNull(y)) {
					var r = a.event.MapEvent;
					y.deleteListener(r.I_MAP_DRAGGING, this.panEventAction);
					y.deleteListener(r.MAP_BEFORE_REFRESH, this.refreshEventAction);
					y.deleteListener(r.I_MAP_CENTER_ZOOM, this.zoomEventAction);
					y.deleteListener(r.MAP_RESIZED, this.resizeEventAction);
					y.deleteListener(r.MAP_DESTROY, this.destroyEventAction);
					y.deleteListener(r.MAP_CLEAN, this.refreshEventAction)
				}
			}
		},
		checkInfoWindowOverLayer: function (a, b, c) {
			this.tailStyle && this.tailStyle.border || (this.tailStyle.border = "1px solid #c3d0df");
			var r = b.width(),
			m = b.height(),
			D = a.height,
			S = c.x,
			U = c.y,
			w = !0,
			ja = !0;
			S > a.width / 2 && (w = !1);
			U < D / 2 && (ja = !1);
			a = this.$tail_h_backup;
			var la = this.$tail_w_backup;
			ja ?
			(80 >= m ? this.$hideDiv.css({
					bottom: m / 10 + "px"
				}) : this.$hideDiv.css({
					bottom: "25px"
				}), U = U + parseInt(this.$hideDiv.css("bottom")) - m + this.$hideDiv.height() / 2 - 1) : (80 >= m ? this.$hideDiv.css({
					top: m / 7.5 + "px"
				}) : this.$hideDiv.css({
					top: "25px"
				}), U = U - parseInt(this.$hideDiv.css("top")) - this.$hideDiv.height() / 2 - 1);
			w ? (this.$tail.css({
					right: .707 * -this.$hideDiv.width(),
					top: .2 * la
				}), this.$hideDiv.css({
					left: -this.$hideDiv.width() + 1
				}), this.$vancantDiv.height(m - 10), this.$vancantDiv.css({
					left: "0px",
					width: "3px",
					top: "5px"
				}), S = S +
					.707 * la - 2, b.css({
					"box-shadow": "5px 5px 5px rgba(0,0,0,0.5)"
				})) : (this.pageDirection ? this.$tail.css({
					left: .707 * -this.$hideDiv.width(),
					top: .2 * la
				}) : this.$tail.css({
					right: .707 * this.$hideDiv.width() / 2,
					top: .2 * la
				}), this.$hideDiv.css({
					right: -this.$hideDiv.width() + 1
				}), this.$vancantDiv.height(m - 10), this.$vancantDiv.css({
					right: "0px",
					width: "3px",
					top: "5px"
				}), S = S - r - .707 * la, b.css({
					"box-shadow": "-5px 5px 5px rgba(0,0,0,0.5)"
				}));
			this.$tail.css({
				"box-shadow": "3px 3px 3px rgba(0,0,0,0.5)"
			});
			if (D > c.y + m + 20 || 0 < c.y - m - 20)
				0 >
				D - U - m && w ? (this.$hideDiv.width(1.414 * parseInt(a) + 3), this.$hideDiv.height(.707 * parseInt(la) + 3), this.pageDirection ? this.$tail.css({
						top: .707 * -this.$hideDiv.height(),
						left: .2 * la
					}) : this.$tail.css({
						top: .707 * -this.$hideDiv.height(),
						right: .2 * la
					}), this.$hideDiv.css({
						bottom: -this.$hideDiv.height() + 1
					}), this.$vancantDiv.width(r - 10), this.$vancantDiv.css({
						bottom: "0px",
						height: "3px",
						left: "5px",
						top: ""
					}), U = 80 >= m ? U - this.$hideDiv.height() - m / 10 - this.$hideDiv.width() / 2 + 1 : U - this.$hideDiv.height() - 25 - this.$hideDiv.width() /
						2 + 1, this.$hideDiv.css({
						left: "20px"
					}), S = S - 20 - this.$hideDiv.width() / 2 - this.$hideDiv.width() / 2 + 2, b.css({
						"box-shadow": "5px -5px 5px rgba(0,0,0,0.5)"
					}), this.$tail.css({
						"box-shadow": "3px -3px 3px rgba(0,0,0,0.5)"
					})) : 0 > D - U - m && !w ? (this.$hideDiv.width(1.414 * parseInt(a) + 3), this.$hideDiv.height(.707 * parseInt(la) + 3), this.$tail.css({
						top: .707 * -this.$hideDiv.height(),
						left: .2 * la
					}), this.$hideDiv.css({
						bottom: -this.$hideDiv.height() + 1
					}), this.$vancantDiv.width(r - 10), this.$vancantDiv.css({
						bottom: "0px",
						height: "3px",
						right: "5px",
						top: ""
					}), U = 80 >= m ? U - this.$hideDiv.height() - m / 10 - this.$hideDiv.width() / 2 + 1 : U - this.$hideDiv.height() - 25 - this.$hideDiv.width() / 2 + 1, this.$hideDiv.css({
						right: "20px"
					}), S = S + this.$hideDiv.width() / 2 + this.$hideDiv.width() / 2 + 20, b.css({
						"box-shadow": "-5px -5px 5px rgba(0,0,0,0.5)"
					}), this.$tail.css({
						"box-shadow": "-3px 3px 3px rgba(0,0,0,0.5)"
					})) : 0 > U && w ? (this.$hideDiv.width(1.414 * parseInt(a) + 3), this.$hideDiv.height(.707 * parseInt(la) + 3), this.pageDirection ? this.$tail.css({
						top: .28 * la,
						left: .2 * la
					}) : this.$tail.css({
						top: .28 *
						la,
						right: .2 * la
					}), this.$hideDiv.css({
						top: -this.$hideDiv.height() + 1
					}), this.$vancantDiv.width(r - 10), this.$vancantDiv.css({
						top: "0px",
						height: "3px",
						left: "5px",
						bottom: ""
					}), U = 80 >= m ? U + m / 7.5 + this.$hideDiv.height() + this.$hideDiv.width() / 2 + 1 - 5 : U + 25 + this.$hideDiv.height() + this.$hideDiv.width() / 2 + 1 - 5, this.$hideDiv.css({
						left: "20px"
					}), S = S - 20 - this.$hideDiv.width() / 2 - this.$hideDiv.width() / 2 + 2, b.css({
						"box-shadow": "5px 5px 5px rgba(0,0,0,0.5)"
					}), this.$tail.css({
						"box-shadow": "3px -3px 3px rgba(0,0,0,0.5)"
					})) : 0 > U && !w &&
				(this.$hideDiv.width(1.414 * parseInt(a) + 3), this.$hideDiv.height(.707 * parseInt(la) + 3), this.$tail.css({
						top: .28 * la,
						left: .2 * la
					}), this.$hideDiv.css({
						top: -this.$hideDiv.height() + 1
					}), this.$vancantDiv.width(r - 10), this.$vancantDiv.css({
						top: "0px",
						height: "3px",
						right: "5px",
						bottom: ""
					}), U = 80 >= m ? U + m / 7.5 + this.$hideDiv.height() + this.$hideDiv.width() / 2 + 1 - 6 : U + 25 + this.$hideDiv.height() + this.$hideDiv.width() / 2 + 1 - 6, this.$hideDiv.css({
						right: "20px"
					}), S = S + this.$hideDiv.width() / 2 + this.$hideDiv.width() / 2 + 20, b.css({
						"box-shadow": "-5px 5px 5px rgba(0,0,0,0.5)"
					}),
					this.$tail.css({
						"box-shadow": "-3px 3px 3px rgba(0,0,0,0.5)"
					}));
			return {
				x: S,
				y: U
			}
		},
		destroy: function () {
			a.isNull(this.$div) || (this.deleteInfoWindow(), this.$div.unbind("touchmove touchend mousewheel DOMMouseScroll mousedown mouseup mouseover mouseout click keyup keydown keypress", this.infoStopPropagation), this.$div.unbind("mousemove", this.infoMouseMove), this.$div.unbind("mouseover", this.infoMouseOver), this.$div.unbind("mouseout", this.infoMouseOut), this.infoMouseOut = this.infoMouseOver = this.infoMouseMove =
					this.infoStopPropagation = null, a.$(this.infoTip).empty(), this.wininfo = this.infoWindows = this.$div = this.div = this.infoTip = null)
		},
		getPageDirection: function () {
			var a = document.createElement("table"),
			b = document.createElement("tr"),
			c = document.createElement("td"),
			r = document.createElement("td"),
			m = document.createElement("tbody");
			a.cellSpacing = 0;
			a.cellPadding = 0;
			c.innerHTML = "fsdfsds";
			r.innerHTML = "p";
			m.appendChild(b);
			a.appendChild(m);
			b.appendChild(c);
			b.appendChild(r);
			this.div.appendChild(a);
			this.pageDirection = 2 >
				c.offsetLeft ? !0 : !1;
			this.div.removeChild(a)
		},
		touchscroll: function (b) {
			var c,
			y;
			a.browser.touchSupported && a.notNull(document.getElementById(b)) && (document.getElementById(b).addEventListener("touchstart", function (a) {
					c = a.targetTouches[0].pageX;
					y = a.targetTouches[0].pageY
				}, !1), document.getElementById(b).addEventListener("touchmove", function (a) {
					a.preventDefault();
					var b = y - a.targetTouches[0].pageY;
					this.scrollLeft += c - a.targetTouches[0].pageX;
					this.scrollTop += b
				}, !1))
		},
		tabControl: function () {
			(function () {
				a.$("#content \x3e div").hide();
				a.$("#tabs div:first").attr("id", "current");
				a.$("#content \x3e div:first").fadeIn();
				a.$("#tabs div").bind("click touchstart", function (b) {
					b.preventDefault();
					"current" != a.$(this).attr("id") && (a.$("#content \x3e div").hide(), a.$("#tabs div").attr("id", ""), a.$("#tabs div").removeClass("omv2_tab_select_info"), a.$("#tabs div").addClass("omv2_tab_unselect_info"), a.$("#tabs div").css({
							color: a.$("#tabs div:first").css("color")
						}), a.$(this).attr("id", "current"), a.$(a.$(this).attr("name")).fadeIn(), a.$(this).removeClass("omv2_tab_unselect_info"),
						a.$(this).addClass("omv2_tab_select_info"))
				})
			})()
		},
		toJsonCss: function (a) {
			var b = {};
			a = a.split(";");
			for (var c = 0; c < a.length; c++) {
				var r = a[c].split(":");
				b[r[0]] = r[1]
			}
			return b
		},
		deleteInfoWindows: function () {
			this.infoWindows && 0 < this.infoWindows.length && this.infoWindows.pop();
			this.$div.off("mouseover mouseout mousedown mouseup click touchend", "**");
			this.$div.empty();
			this.mouseOnInfoWindow = !1
		},
		deleteInfoWindowById: function (a) {
			a = "infowin_" + a;
			for (var b = this.infoWindows.length, c = 0; c < b; c++)
				if (this.infoWinId && this.infoWindows[c].nid ==
					a) {
					this.deleteInfoWindow(this.infoWindows[c]);
					break
				}
		}
	});
	a.tool.Tool = a.Class.extend({
		mixin: a.event.EventSource,
		initialize: function (b) {
			this._$container = b.$oracleMapDiv;
			this._geometry = null;
			this._graphic = b.graphics;
			this._map = b;
			this._mapActionState = b._getMapActionState();
			this._group = this._toolShape = null;
			this._style = new a.style.Line({
				stroke: "#000000",
				strokeThickness: 1
			});
			this._style.fill = b.graphics.oui.NO_PAINT;
			this.toolFeature = null;
			this.featureStyle = this._style;
			this.status = a.tool.Tool.STOPPED;
			this.allowZeroSize =
				!1
		},
		start: function () {
			a.util.Logger.info("MAPVIEWER_9036", "OM.tool.Tool.start", "")
		},
		clear: function () {
			a.util.Logger.info("MAPVIEWER_9037", "OM.tool.Tool.clear", "")
		},
		clear_base: function () {
			this._group && (this._graphic.remove(this._group), this._group = null);
			this._toolShape = null;
			this.status = a.tool.Tool.STOPPED;
			if (this.toolFeature) {
				this.toolFeature.deleteEditingProperties && this.toolFeature.deleteEditingProperties();
				var b = this._map.getToolFeatureLayer();
				a.isNotNull(b) && b.removeFeature(this.toolFeature);
				this.toolFeature =
					null;
				b = a.event.ToolEvent;
				b = new b(b.TOOL_CLEAR, this);
				this.fire(b.type, b)
			}
		},
		getStatus: function () {
			return this.status
		},
		getGeometry: function () {
			return this._geometry
		},
		setDrawingStyle: function (b) {
			if (!b)
				return this;
			this._style = b.clone();
			a.isNull(b.fill) && (this._style.fill = this._map.graphics.oui.NO_PAINT);
			return this
		},
		setStyle: function (a) {
			this.featureStyle = a.clone();
			this.toolFeature && this.toolFeature.setRenderingStyle(this.featureStyle);
			return this
		},
		setZeroSizeAllowed: function (a) {
			this.allowZeroSize = a
		},
		restoreMapActionState: function () {
			this._map &&
			this._mapActionState && this._map._restoreMapActionState(this._mapActionState)
		}
	});
	a.tool.Tool.STOPPED = 0;
	a.tool.Tool.STARTED = 1;
	a.tool.Tool.FINISHED = 3;
	a.tool.CircleTool = a.tool.Tool.extend({
		initialize: function O(b, c) {
			O.base.call(this, b);
			this._radius = 0;
			this._toPntOfCircle = this._geoCenter = null;
			var m = this,
			D = a.event.ToolEvent,
			S = null;
			this._path = this._txtNode = null;
			a.notNull(c) && a.notNull(c.showRadius) ? this.setShowRadius(c.showRadius) : this.setShowRadius(!0);
			a.notNull(c) && a.notNull(c.radiusUnitSystem) ? this.setRadiusUnitSystem(c.radiusUnitSystem) :
			this.setRadiusUnitSystem("METRIC");
			a.notNull(c) && a.notNull(c.labelBackgroundStyle) ? this.setLabelBackgroundStyle(c.labelBackgroundStyle) : this.setLabelBackgroundStyle(new a.style.Color({
					fill: "#ffffff",
					fillOpacity: .3
				}));
			a.notNull(c) && a.notNull(c.decimalDigits) ? this.setDecimalDigits(c.decimalDigits) : this.setDecimalDigits(2);
			a.notNull(c) && a.notNull(c.decimalDigitsFunction) ? this.setDecimalDigitsFunction(c.decimalDigitsFunction) : this.setDecimalDigitsFunction(function (a) {
				return a.toFixed(this.getDecimalDigits())
			});
			this.RADIUS_UNIT_SYSTEMS = {
				METRIC: [{
						unitName: "kilometer",
						unitShortName: "km",
						conversionFactor: 1
					}, {
						unitName: "meter",
						unitShortName: "m",
						conversionFactor: 1E3
					}, {
						unitName: "centimeter",
						unitShortName: "cm",
						conversionFactor: 100
					}
				],
				IMPERIAL: [{
						unitName: "mile",
						unitShortName: "mi",
						conversionFactor: 1
					}, {
						unitName: "yard",
						unitShortName: "yd",
						conversionFactor: 1760
					}, {
						unitName: "foot",
						unitShortName: "ft",
						conversionFactor: 3
					}, {
						unitName: "inch",
						unitShortName: "in",
						conversionFactor: 12
					}
				]
			};
			this.begin = function (b) {
				if (m.status == a.tool.Tool.STARTED &&
					!(a.isNull(b) || 0 !== b.button && a.isNull(b.touches))) {
					m._geoCenter = m._map.getCursorLocation();
					var c = b.pageX - m._$container.offset().left;
					b = b.pageY - m._$container.offset().top;
					var r = m._graphic.getLeftTop(m._map.draggableGroup),
					y = r.x,
					r = r.y,
					O = {
						cx: c - y,
						cy: b - r,
						width: 1,
						height: 1
					},
					sa = {
						cx: c - y,
						cy: b - r,
						width: 10,
						height: 10
					};
					S = {
						x: c,
						y: b
					};
					var wa = m._graphic.oui,
					Aa = new wa.style.Color(255, 255, 255, 255);
					Aa.setAlpha(150);
					m._style.fill = Aa;
					m._toolShape ? m._graphic.setEllipse(m._toolShape, O) : m._toolShape = m._graphic.drawEllipse(O,
							m._style, {
							group: m._group
						});
					m.isShowRadiusEnabled() && (m._centerStyle = jQuery.extend(!0, {}, m._style), m._centerStyle.fill = new wa.style.Color(0, 0, 255, 255), m._toolCenterShape ? m._graphic.setEllipse(m._toolCenterShape, sa) : m._toolCenterShape = m._graphic.drawEllipse(sa, m._centerStyle, {
							group: m._group
						}), m._textBackground = m._graphic.drawRectangle({
							x: c - y + 4,
							y: b - r,
							width: 1,
							height: 1
						}, m.getLabelBackgroundStyle(), {
							group: m._group
						}), m._txtNode = m._graphic.createTextNode("", {}, c - y + 4, b - r), m._group.appendChild(m._txtNode),
						m._path = m._graphic.drawPath([[c - y, b - r, c - y, b - r]], {
							stroke: "#003286",
							strokeThickness: 1
						}, {
							group: m._group
						}));
					a.$(document).bind("mousemove", m.drawShape);
					a.browser.touchSupported && m._$container.bind("touchmove", m.drawShape_touch);
					b = new D(D.TOOL_START, m);
					m.fire(b.type, b)
				}
			};
			this.begin_touch = function (b) {
				var c = a.util.DomUtil;
				1 < c.getTouchCount(b) || (c = c.getTouchesPosition(b), b.pageX = c.x, b.pageY = c.y, m.begin(b))
			};
			this.drawShape = function (b) {
				if (m.status === a.tool.Tool.STARTED) {
					var c = m._graphic.getLeftTop(m._map.draggableGroup),
					r = b.pageX - m._$container.offset().left,
					y = b.pageY - m._$container.offset().top;
					(0 >= r || 0 > y || r > m._map.getMapContext().getDeviceWidth() || y > m._map.getMapContext().getDeviceHeight()) && m.finish();
					b = Math.round(Math.sqrt((r - S.x) * (r - S.x) + (y - S.y) * (y - S.y)));
					var O = m._map.getPixelResolution();
					m._radius = b * O;
					m._toPntOfCircle = m._map.getScreenPointLocation(r, y);
					m._graphic.setEllipse(m._toolShape, {
						width: 2 * b,
						height: 2 * b
					});
					if (m.isShowRadiusEnabled()) {
						var r = S.x - c.x,
						c = S.y - c.y,
						y = r + b,
						O = r + b / 2,
						sa = c - 5;
						m._graphic.setEllipse(m._toolCenterShape, {
							width: 5,
							height: 5
						});
						m._graphic.setPath(m._path, [[r, c, y, c]]);
						m._txtNode.setTextValue(m.getFixedRadius(m.getRadiusUnitSystem()));
						r = m.calculateTextNodeWidth(m._txtNode);
						b <= r ? (m._txtNode.setX(y + 4), m._txtNode.setY(c), b = {
								x: y + 4,
								y: c - m._txtNode.getFontSize() - 1,
								width: m.calculateTextNodeWidth(m._txtNode),
								height: m.calculateTextNodeHeight(m._txtNode)
							}, m._textBackground._style.fillOpacity = m.getLabelBackgroundStyle().fillOpacity) : (m._txtNode.setX(O - r / 2), m._txtNode.setY(sa), b = {
								x: O - r / 2,
								y: sa - m._txtNode.getFontSize() -
								1,
								width: m.calculateTextNodeWidth(m._txtNode),
								height: m.calculateTextNodeHeight(m._txtNode)
							}, m._textBackground._style.fillOpacity = 0);
						m._graphic.setRectangle(m._textBackground, b)
					}
					b = new D(D.CIRCLE_DRAG, m);
					m.fire(b.type, b)
				}
			};
			this.drawShape_touch = function (b) {
				var c = a.util.DomUtil;
				1 < c.getTouchCount(b) || (c = c.getTouchesPosition(b), b.pageX = c.x, b.pageY = c.y, m.drawShape(b))
			};
			this.finish = function (b) {
				m._map.enableMapDrag(!0);
				m._map.enableMapAction.mouse = !0;
				a.isNull(b) || 0 !== b.button && a.isNull(b.touches) || (S = null,
					m._$container.unbind("mousedown", m.begin), m.drawShape && a.$(document).unbind("mousemove", m.drawShape), m._$container.unbind("mouseup", m.finish), a.browser.touchSupported && (m._$container.unbind("touchstart", m.begin_touch), m._$container.unbind("touchmove", m.drawShape_touch), m._$container.unbind("touchend", m.finish)), m._graphic.remove(m._toolShape), m._graphic.remove(m._toolCenterShape), m._graphic.remove(m._txtNode), m._graphic.remove(m._path), m._graphic.remove(m._textBackground), m._toolCenterShape = null,
					m.status = a.tool.Tool.FINISHED, m._geoCenter && (b = m._map.getSnapToleranceOnGround(), m._radius <= b && !m.allowZeroSize ? a.util.Logger.warning("", "OM.tool.CircleTool.finish", "Circle is too small; radius must be larger than " + m._map.getSnapTolerance().value + " pixels.") : (m._geometry = new a.geometry.Circle(m._geoCenter.getX(), m._geoCenter.getY(), m._radius, m._geoCenter.srid), m.toolFeature = new a.Feature("circleTool" + (new Date).getTime(), m._geometry, {
								renderingStyle: m.featureStyle
							}), m._map.getToolFeatureLayer().addFeature(m.toolFeature)),
						b = new D(D.TOOL_END, m), m.fire(b.type, b), m._geoCenter = null))
			}
		},
		start: function () {
			var b = a.event.ToolEvent;
			this._radius = 0;
			this._geoCenter = null;
			this.clear();
			this._map.enableMapDrag(!1);
			this._map.enableMapAction.mouse = !1;
			this._group || (this._group = this._graphic.createGroup(), this._graphic.addGroup(this._group, this._map.draggableGroup));
			this._$container.bind("mousedown", this.begin);
			this._$container.bind("mouseup", this.finish);
			a.browser.touchSupported && (this._$container.bind("touchstart", this.begin_touch),
				this._$container.bind("touchend", this.finish));
			this.status = a.tool.Tool.STARTED;
			b = new b(b.TOOL_START, this);
			this.fire(b.type, b);
			return this
		},
		clear: function () {
			this.finish();
			this.clear_base()
		},
		getCenter: function () {
			return this._geoCenter
		},
		getRadius: function (b, c) {
			if (!b)
				return null;
			var r = [];
			this._geoCenter ? (r.push(this._geoCenter.getX()), r.push(this._geoCenter.getY())) : this._geometry && (r.push(this._geometry.centerX), r.push(this._geometry.centerY));
			r.push(this._toPntOfCircle.getX());
			r.push(this._toPntOfCircle.getY());
			var m = null;
			this._geoCenter ? m = new a.geometry.LineString(r, this._geoCenter.srid) : this._geometry && (m = new a.geometry.LineString(r, this._geometry.srid));
			return m ? a.util.GeomUtil.getLength(m, c, {
				unit: b,
				transformToGeodetic: !0
			}) : null
		},
		getDrawingRadius: function () {
			return this._radius
		},
		setShowRadius: function (a) {
			this.showRadius = a
		},
		isShowRadiusEnabled: function () {
			return this.showRadius
		},
		setRadiusUnitSystem: function (a) {
			this.radiusUnitSystem = a
		},
		getRadiusUnitSystem: function () {
			return this.radiusUnitSystem
		},
		getFixedRadius: function (a) {
			for (var b =
					this.RADIUS_UNIT_SYSTEMS[a][0], c = this.getRadius(b.unitName), b = b.unitShortName, m = this.RADIUS_UNIT_SYSTEMS[a].length, D = 1; 1 > c && D < m; D++)
				c *= this.RADIUS_UNIT_SYSTEMS[a][D].conversionFactor, b = this.RADIUS_UNIT_SYSTEMS[a][D].unitShortName;
			return this._decimalDigitsFunction(c) + " " + b
		},
		setLabelBackgroundStyle: function (a) {
			this._backgroundRectangleStyle = a
		},
		getLabelBackgroundStyle: function () {
			return this._backgroundRectangleStyle
		},
		calculateTextNodeWidth: function (a) {
			var b = a.getFontSize();
			return a.getTextValue().length *
			(4 / 3) * b / 2
		},
		calculateTextNodeHeight: function (a) {
			return a.getFontSize() + .5 * a.getFontSize()
		},
		setDecimalDigits: function (a) {
			this._decimalDigits = a
		},
		getDecimalDigits: function () {
			return this._decimalDigits
		},
		setDecimalDigitsFunction: function (a) {
			this._decimalDigitsFunction = a
		}
	});
	a.tool.RectangleTool = a.tool.Tool.extend({
		initialize: function y(b) {
			y.base.call(this, b);
			var c = this,
			D = a.event.ToolEvent,
			S,
			U,
			w = null;
			this.dragGeoPoint = this.startGeoPoint = null;
			this.begin = function (b) {
				if (c.status === a.tool.Tool.STARTED && !(a.isNull(b) ||
						0 !== b.button && a.isNull(b.touches))) {
					c.startGeoPoint = c._map.getCursorLocation();
					c.dragGeoPoint = c._map.getCursorLocation();
					var D = b.pageX - c._$container.offset().left;
					b = b.pageY - c._$container.offset().top;
					S = D;
					U = b;
					var r = c._graphic.getLeftTop(c._map.draggableGroup),
					D = {
						x: D - r.x,
						y: b - r.y,
						width: 1,
						height: 1
					};
					a.isNull(c._style.fill) && (c._style.fill = c._graphic.oui.NO_PAINT);
					c._toolShape ? c._graphic.setRectangle(c._toolShape, D) : c._toolShape = c._graphic.drawRectangle(D, c._style, {
						group: c._group
					});
					a.$(document).bind("mousemove",
						c.drawShape);
					a.browser.touchSupported && c._$container.bind("touchmove", c.drawShape_touch)
				}
			};
			this.begin_touch = function (b) {
				var D = a.util.DomUtil;
				1 < D.getTouchCount(b) || (D = D.getTouchesPosition(b), b.pageX = D.x, b.pageY = D.y, c.begin(b))
			};
			this.drawShape = function (b) {
				if (c.status === a.tool.Tool.STARTED) {
					var r = S,
					w = U,
					y = b.pageX - c._$container.offset().left;
					b = b.pageY - c._$container.offset().top;
					(0 >= y || 0 > b || y > c._map.getMapContext().getDeviceWidth() || b > c._map.getMapContext().getDeviceHeight()) && c.finish();
					c.dragGeoPoint =
						c._map.getCursorLocation();
					var wa = c._graphic.getLeftTop(c._map.draggableGroup);
					c._graphic.setRectangle(c._toolShape, {
						width: Math.abs(y - r),
						height: Math.abs(b - w),
						x: r < y ? r - wa.x : y - wa.x,
						y: w < b ? w - wa.y : b - wa.y
					});
					b = new D(D.RECTANGLE_DRAG, c);
					c.fire(b.type, b)
				}
			};
			this.drawShape_touch = function (b) {
				var D = a.util.DomUtil;
				1 < D.getTouchCount(b) || (D = D.getTouchesPosition(b), b.pageX = D.x, b.pageY = D.y, c.drawShape(b))
			};
			this.finish = function (b) {
				if (!(a.isNull(b) || 0 !== b.button && a.isNull(b.touches)) && (c._map.enableMapDrag(!0), c._map.enableMapAction.mouse =
							!0, a.gv.featureDrag = !0, a.gv.allowFeaturePointsInteraction = !0, c._$container.unbind("mousedown", c.begin), c.drawShape && a.$(document).unbind("mousemove", c.drawShape), c._$container.unbind("mouseup", c.finish), a.browser.touchSupported && (c._$container.unbind("touchstart", c.begin_touch), c._$container.unbind("touchmove", c.drawShape_touch), c._$container.unbind("touchend", c.finish)), c._graphic.remove(c._toolShape), c.status = a.tool.Tool.FINISHED, c.dragGeoPoint = null, c.startGeoPoint)) {
					w = c._map.getCursorLocation();
					b = c.startGeoPoint.getX();
					var r = c.startGeoPoint.getY(),
					S = w.getX(),
					y = w.getY();
					b -= S;
					r -= y;
					y = Math.sqrt(b * b + r * r);
					S = c._map.getSnapToleranceOnGround();
					(y <= S || 0 === b || 0 === r) && !c.allowZeroSize ? (c._geometry = null, c.startGeoPoint = null, a.util.Logger.warning("MAPVIEWER_9045", "OM.tool.RectangleTool.finish", "Tolerance in pixels: " + c._map.getSnapTolerance().value), c.start()) : (b = [c.startGeoPoint.getX(), c.startGeoPoint.getY(), w.getX(), w.getY()], r = 0, b[0] > b[2] && (r = b[0], b[0] = b[2], b[2] = r), b[1] > b[3] && (r = b[1], b[1] = b[3], b[3] =
								r), c._geometry = new a.geometry.Rectangle(b[0], b[1], b[2], b[3], w.srid), c.toolFeature = new a.Feature("rectangleTool" + (new Date).getTime(), c._geometry, {
								renderingStyle: c.featureStyle
							}), c._map.getToolFeatureLayer().addFeature(c.toolFeature), c.startGeoPoint = null, b = new D(D.TOOL_END, c), c.fire(b.type, b))
				}
			}
		},
		start: function () {
			var b = a.event.ToolEvent;
			this.clear();
			this._map.enableMapDrag(!1);
			this._map.enableMapAction.mouse = !1;
			this._group || (this._group = this._graphic.createGroup(), this._graphic.addGroup(this._group,
					this._map.draggableGroup));
			this._$container.bind("mousedown", this.begin);
			this._$container.bind("mouseup", this.finish);
			a.browser.touchSupported && (this._$container.bind("touchstart", this.begin_touch), this._$container.bind("touchend", this.finish));
			this.status = a.tool.Tool.STARTED;
			a.gv.featureDrag = !1;
			a.gv.allowFeaturePointsInteraction = !1;
			b = new b(b.TOOL_START, this);
			this.fire(b.type, b);
			return this
		},
		clear: function () {
			this.finish();
			this.clear_base()
		},
		getDraggingWidth: function () {
			return this.status !== a.tool.Tool.STARTED ||
			a.isNull(this.startGeoPoint) || a.isNull(this.dragGeoPoint) ? 0 : Math.abs(this.startGeoPoint.getX() - this.dragGeoPoint.getX())
		},
		getDraggingHeight: function () {
			return this.status !== a.tool.Tool.STARTED || a.isNull(this.startGeoPoint) || a.isNull(this.dragGeoPoint) ? 0 : Math.abs(this.startGeoPoint.getY() - this.dragGeoPoint.getY())
		}
	});
	a.tool.DistanceTool = a.tool.Tool.extend({
		initialize: function r(b, c) {
			r.base.call(this, b);
			this._tool = new a.tool.RedlineTool(b, a.tool.RedlineTool.TYPE_LINESTRING, {
				continuousMode: !1
			});
			this.unit =
				"kilometer";
			c && c.unit && (this.unit = c.unit);
			this.transformToGeodetic = !0;
			c && !1 === c.transformToGeodetic && (this.transformToGeodetic = c.transformToGeodetic);
			c && c.dataSource && (this.dataSource = c.dataSource);
			this._map = b;
			this._distanceInfo = null;
			this._lastSubTotalDis = this._subTotalDis = 0;
			this.segmentsDisArray = [];
			var S = this,
			U = a.event.ToolEvent;
			this.newPoint = function () {
				var b = S._tool;
				if (1 < b._points.length) {
					for (var c = [], m = null, D = 0; D < b._points.length; D++)
						m = b._points[D].geo, c.push(m.getX()), c.push(m.getY());
					S.calTotalDistance(new a.geometry.LineString(c,
							S._map.getMapContext().getUniverse().srid))
				}
			};
			this.drawing = function (b) {
				S._map.getMapContext().getUniverse();
				a.$("#sub_tr_1") && a.$("#sub_tr_1").show();
				S._distanceInfo.setVisible(!0);
				var c = S._map.getAbsoluteCursorLocation();
				a.isNotNull(b.loc) && (c = b.loc);
				b = S._tool._points[S._tool._points.length - 1].geo;
				c = a.util.GeomUtil.getLength(new a.geometry.LineString([c.getX(), c.getY(), b.getX(), b.getY()], S._map.getMapContext().getUniverse().srid), null, {
					unit: S.unit,
					transformToGeodetic: S.transformToGeodetic,
					dataSource: S.dataSource,
					toServerTranform: !1
				});
				c = Math.round(100 * c) / 100;
				a.$("#distance_total_1").text(Math.round(100 * (S._subTotalDis + c)) / 100 + S.getUnitLabel(S.unit));
				a.$("#distance_sub_1").text(c + S.getUnitLabel(S.unit))
			};
			this.finish = function () {
				if (S.status == a.tool.Tool.STARTED) {
					S.status = a.tool.Tool.FINISHED;
					a.notNull(S._tool.toolFeature) && S.calTotalDistance(S._tool.toolFeature.geo);
					S._tool.finish();
					var b = new U(U.TOOL_END, S);
					S.fire(b.type, b);
					if (a.notNull(S._tool.toolFeature))
						S._tool.toolFeature.on(a.event.LayerEvent.FEATURE_EDITED,
							S.edit, S._tool.toolFeature)
				}
			};
			this.edit = function () {
				S.calSegmentsDistance(S._tool.toolFeature.geo)
			};
			this._tool.on(U.REDLINE_POINT_CREATE, S.newPoint);
			this._tool.on(U.REDLINE_DRAW, S.drawing);
			this._tool.on(U.TOOL_END, S.finish);
			this._tool.on(U.REDLINE_EDITED, S.edit)
		},
		start: function () {
			this.clear();
			this._distanceInfo = new a.control.MapDecoration("\x3ctable style\x3d'width:100%;border:0'\x3e \x3ctr\x3e\x3ctd align\x3d'right'\x3e" + a.gv.getLabel("MAPVIEWER_SB_TOTAL_DISTANCE").replace(/[ ]/g, "\x26nbsp;") + ":\x3c/td\x3e\x3ctd align\x3d'left'\x3e\x3cspan id\x3d'distance_total_1'\x3e0" +
					this.getUnitLabel(this.unit) + "\x3c/span\x3e\x3c/td\x3e\x3c/tr\x3e\x3ctr id\x3d'sub_tr_1'\x3e\x3ctd align\x3d'right'\x3e" + a.gv.getLabel("MAPVIEWER_SB_SUB_DISTANCE").replace(/[ ]/g, "\x26nbsp;") + ":\x3c/td\x3e\x3ctd align\x3d'left'\x3e\x3cspan id\x3d'distance_sub_1'\x3e0" + this.getUnitLabel(this.unit) + "\x3c/span\x3e\x3c/td\x3e\x3c/tr\x3e\x3c/table\x3e", {
					left: .5,
					top: .7
				}, {
					draggable: !0,
					panelOptions: {
						style: {
							"border-style": "solid",
							"border-color": "#0000ff",
							"border-width": "1px",
							backgroundColor: "#FDFDFD",
							filter: "alpha(Opacity\x3d80)",
							"-moz-opacity": "0.8",
							opacity: "0.8"
						}
					}
				});
			this._map.addMapDecoration(this._distanceInfo);
			this._distanceInfo.setVisible(!1);
			this._tool.start();
			this.status = a.tool.Tool.STARTED;
			var b = new a.event.ToolEvent(a.event.ToolEvent.TOOL_START, this);
			this.fire(b.type, b);
			return this
		},
		clear: function () {
			this._distanceInfo && (this._distanceInfo.setVisible(!1), this._map.removeMapDecoration(this._distanceInfo), this._distanceInfo = null);
			this._subTotalDis = 0;
			this.segmentsDisArray = [];
			this._tool.clear()
		},
		getGeometry: function () {
			return this._tool.getGeometry()
		},
		getSegmentsArray: function () {
			return this.segmentsDisArray
		},
		getTotalDistance: function () {
			return Math.round(100 * this._subTotalDis) / 100
		},
		calTotalDistance: function (b) {
			var c = this,
			D = function (D) {
				0 !== D && (c._subTotalDis = D, c._distanceInfo.setVisible(!0), a.$("#distance_total_1").text(Math.round(100 * c._subTotalDis) / 100 + c.getUnitLabel(c.unit)), c.segmentsDisArray.length && c.status != a.tool.Tool.FINISHED && c.segmentsDisArray.push(Math.round(100 * (c._subTotalDis - c._lastSubTotalDis)) / 100), 0 === c.segmentsDisArray.length &&
					c.segmentsDisArray.push(Math.round(100 * c._subTotalDis) / 100), a.$("#sub_tr_1") && a.$("#sub_tr_1").hide(), c._lastSubTotalDis = D, D = a.event.ToolEvent, D = new D(D.DISTANCE_UPDATE, c), D.point = b.getLastPoint(), c.fire(D.type, D))
			};
			c.transformToGeodetic ? b.transform(8307, function (b) {
				4 <= b.coordinates.length && a.util.GeomUtil.getLength(b, D, {
					unit: c.unit,
					transformToGeodetic: c.transformToGeodetic,
					dataSource: c.dataSource
				})
			}) : 4 <= b.coordinates.length && a.util.GeomUtil.getLength(b, D, {
				unit: c.unit,
				transformToGeodetic: c.transformToGeodetic,
				dataSource: c.dataSource
			})
		},
		calSegmentsDistance: function (b) {
			var c = this;
			c.segmentsDisArray = [];
			var D = [],
			S = 0,
			U = [],
			w = function (a, b) {
				0 !== a && (c.segmentsDisArray[b] = Math.round(100 * a) / 100)
			};
			if (c.transformToGeodetic)
				b.transform(8307, function (b) {
					for (var r = 0; r < b.getOrdinates().length / 2 - 1; r++)
						U[r] = w, D[r] = new a.geometry.LineString([b.getOrdinates()[2 * r], b.getOrdinates()[2 * r + 1], b.getOrdinates()[2 * r + 2], b.getOrdinates()[2 * r + 3]], b.srid), 4 <= D[r].coordinates.length && a.util.GeomUtil.getLength(D[r], U[r], {
							idx: r,
							unit: c.unit,
							transformToGeodetic: c.transformToGeodetic,
							dataSource: c.dataSource
						})
				});
			else
				for (var ja = 0; ja < b.getOrdinates().length / 2 - 1; ja++)
					U[ja] = w, D[ja] = new a.geometry.LineString([b.getOrdinates()[2 * ja], b.getOrdinates()[2 * ja + 1], b.getOrdinates()[2 * ja + 2], b.getOrdinates()[2 * ja + 3]], b.srid), 4 <= D[ja].coordinates.length && a.util.GeomUtil.getLength(D[ja], U[ja], {
						idx: ja,
						unit: c.unit,
						transformToGeodetic: c.transformToGeodetic,
						dataSource: c.dataSource
					});
			var la = setInterval(function () {
				if (c.segmentsDisArray.length == b.getOrdinates().length /
					2 - 1) {
					for (var D = 0; D < c.segmentsDisArray.length; D++)
						S += c.segmentsDisArray[D];
					c._distanceInfo.setVisible(!0);
					c._subTotalDis = S;
					a.$("#distance_total_1").text(Math.round(100 * c._subTotalDis) / 100 + c.getUnitLabel(c.unit));
					a.$("#sub_tr_1") && a.$("#sub_tr_1").hide();
					D = a.event.ToolEvent;
					D = new D(D.DISTANCE_UPDATE, c);
					D.point = b.getLastPoint();
					c.fire(D.type, D);
					clearInterval(la)
				}
			}, 100)
		},
		getUnitLabel: function (b) {
			b || (b = this.unit);
			return b ? (b = b.toUpperCase(), "KILOMETER" === b || "KM" === b ? a.gv.getLabel("MAPVIEWER_SB_KILOMETERS") :
				"METER" === b || "M" === b ? a.gv.getLabel("MAPVIEWER_SB_METERS") : "MILE" === b ? a.gv.getLabel("MAPVIEWER_SB_MILES") : "FOOT" === b ? a.gv.getLabel("MAPVIEWER_SB_FEET") : "CENTIMETER" === b || "CM" === b ? a.gv.getLabel("MAPVIEWER_SB_CENTIMETER") : "YARD" === b ? a.gv.getLabel("MAPVIEWER_SB_YARD") : b) : "KM"
		},
		setDrawingStyle: function (a) {
			if (!a)
				return this;
			this._tool && this._tool.setDrawingStyle(a)
		},
		setStyle: function (b) {
			this._tool && this._tool.setStyle({
				type: a.tool.DistanceTool.TYPE_LINESTRING,
				style: b
			})
		}
	});
	a.tool.DistanceTool.TYPE_POINT =
		1;
	a.tool.DistanceTool.TYPE_LINESTRING = 2;
	a.tool.RedlineTool = a.tool.Tool.extend({
		initialize: function m(b, S, U) {
			m.base.call(this, b);
			var w = this;
			this.activeMapIndex = null;
			this.finishMode = a.tool.RedlineTool.FINISH_ON_CLICK;
			this.simplified = !0;
			U && (a.notNull(U.simplified) && (this.simplified = U.simplified), a.notNull(U.finishMode) && (this.finishMode = U.finishMode));
			this.start_move_line_mode = !1;
			this._geoType = S && "number" == typeof S ? S : a.tool.RedlineTool.TYPE_POLYGON;
			b = a.layer.EditableFeature.MARKER_SIZE;
			this._pointStyle =
				new a.style.Marker({
					width: b,
					height: b,
					vectorDef: [{
							shape: {
								type: "circle",
								x: 0,
								y: 0,
								width: 10,
								height: 10
							},
							style: {
								fill: "#ffffff",
								fillOpacity: .75,
								stroke: "#0000ff",
								strokeThickness: 1
							}
						}
					]
				});
			this._pointStyle_1stPolygonVertex = new a.style.Marker({
				width: b,
				height: b,
				vectorDef: [{
						shape: {
							type: "circle",
							x: 0,
							y: 0,
							width: 10,
							height: 10
						},
						style: {
							fill: "#0000ff",
							fillOpacity: .75,
							stroke: "#0000ff",
							strokeThickness: 1
						}
					}
				]
			});
			this._pointEndHoverStyle = new a.style.Marker({
				width: b + 4,
				height: b + 4,
				vectorDef: [{
						shape: {
							type: "circle",
							width: 15,
							height: 15
						},
						style: {
							fill: "#ffffff",
							fillOpacity: .75,
							stroke: "#0000ff",
							strokeThickness: 1
						}
					}
				]
			});
			this.featurePointStyle = this._pointStyle;
			this.featurePolygonStyle = this.featureStyle = this._style;
			this._nextPointId = 0;
			w._nextLineId = 0;
			this._points = [];
			this._continuousPoints = [];
			this._screenPoints = [];
			this._lines = [];
			this._shapeGroup = null;
			this._lastVertexAddedTimestamp = 0;
			this._editFlag = !0;
			var ja = null,
			la = null,
			na = null,
			sa = null,
			wa = null,
			Aa = null;
			this.dragging = !1;
			var Oa = a.event.ToolEvent;
			this.snapPoint = null;
			this.mouseDown = function (b) {
				0 ===
				b.button && (ja = b.pageX, la = b.pageY, w.dragging = !0, w._group && w._group.bringToFront(), w._geoType !== a.tool.RedlineTool.TYPE_POINT && w._map.enableMapDrag(!1));
				b.stopPropagation()
			};
			this.nextPoint = function (b, c) {
				if (w.status === a.tool.Tool.STARTED) {
					var m = a.util.ValidationUtil.isNumber;
					a.notNull(b) && a.notNull(c) && m(b) && m(c) && (m = a.MapContext(w._map).getUniverse().srid, m = new a.geometry.Point(b, c, m), w.addVertex(null, m))
				}
			};
			this.mouseUp = function (b) {
				if (2 === b.button)
					b = new Oa(a.event.ToolEvent.MOUSE_RIGHT_CLICK, w), w.fire(b.type,
						b);
				else if (w.status !== a.tool.Tool.STOPPED && w.status !== a.tool.Tool.FINISHED) {
					var c = !1;
					w._graphic.getLeftTop(w._map.draggableGroup);
					w._$container.offset();
					w._$container.offset();
					if (0 < w._continuousPoints.length) {
						var m;
						m = w.simplified ? a.util.GeomUtil.simplify(w._continuousPoints, 3) : w._continuousPoints;
						w._continuousPoints = [];
						w._screenPoints = [];
						w._map.getUndoManager().startChangeBlock();
						for (var D = 1; D < m.length; D++) {
							var S = m[D];
							S && w.addVertex(null, S)
						}
						w.endBlock = w._map.getUndoManager().endChangeBlock()
					}
					w.dragging =
						!1;
					a.notNull(w.snapPoint) && 2 === w.snapPoint.length && (w._map.mLocX = w.snapPoint[0], w._map.mLocY = w.snapPoint[1]);
					if (b.isRedo || b.pageX === ja && ja !== wa || b.pageY === la && la !== Aa)
						c = w.addVertex(null, {
							x: w._map.mLocX,
							y: w._map.mLocY
						});
					wa = b.pageX;
					Aa = b.pageY;
					w.done(b, w.finishMode === a.tool.RedlineTool.FINISH_ON_RELEASE, {
						bLinestringVertexAdded: c
					})
				}
			};
			this.done = function (b, c, m) {
				if (m && !1 === m.bLinestringVertexAdded && !0 !== w.dragging && w._geoType === a.tool.RedlineTool.TYPE_LINESTRING && 2 <= w._points.length && a.notNull(w.finishFeature)) {
					var D =
						w._points[w._points.length - 1].geo.coordinates,
					S = w._map.getAbsoluteCursorLocation().coordinates;
					m = S[0] - D[0];
					D = S[1] - D[1];
					m = Math.sqrt(m * m + D * D);
					D = w._map.getSnapToleranceOnGround();
					S = Date.now() - w._lastVertexAddedTimestamp;
					if (m <= D && S > a.tool.RedlineTool.LINESTRING_FINISH_DEBOUNCE_TIME)
						return w.finishAndCleanUp(), !0
				}
				return w.clicktofinish || c ? (w.finishAndCleanUp(b), !0) : !1
			};
			this.finishAndCleanUp = function (a) {
				a && a.preventDefault();
				w.finish();
				w.finishFeature = null;
				sa = na = w.clicktofinish = null;
				w.dragging = !1
			};
			this.mouseMove =
			function (b) {
				w.snapPoint = null;
				if (a.isNotNull(w.finishFeature)) {
					var c = w._map.getScreenLocation(w.finishFeature.getGeometry()),
					m = w._map.getSnapTolerance().value,
					D = w._map.getScreenLocation(w._map.getAbsoluteCursorLocation()),
					S = D.x - c.x,
					c = D.y - c.y;
					if (Math.sqrt(S * S + c * c) <= m) {
						var U;
						switch (w._geoType) {
						case a.tool.RedlineTool.TYPE_POINT:
							U = 1;
							break;
						case a.tool.RedlineTool.TYPE_LINESTRING:
							U = 2;
							break;
						case a.tool.RedlineTool.TYPE_POLYGON:
							U = 3
						}
						if (w._points.length >= U && (w.finishFeature.bringToTop(), a.isNotNull(w.finishFeature.movedOut) ||
								w.touchEnabled) && (w.finishFeature.setRenderingStyle(w._pointEndHoverStyle), w.clicktofinish = !0, w._geoType === a.tool.RedlineTool.TYPE_LINESTRING)) {
							w.setPath(w._shapeGroup, [[0, 0, 0, 0]], w._style);
							b = new Oa(Oa.REDLINE_DRAW, w);
							b.loc = w.finishFeature.getGeometry();
							w.fire(b.type, b);
							return
						}
					} else
						w.clicktofinish = !1, m = w._pointStyle, w._geoType === a.tool.RedlineTool.TYPE_POLYGON && (m = w._pointStyle_1stPolygonVertex), w.finishFeature.setRenderingStyle(m), w.finishFeature.bringToTop(), w.finishFeature.movedOut = !0
				}
				if (w.status !==
					a.tool.Tool.STOPPED && w.status !== a.tool.Tool.FINISHED) {
					if (a.isNull(w.clicktofinish) || !1 === w.clicktofinish)
						m = new Oa(a.event.ToolEvent.SNAP_POINT, w), w.fire(m.type, m);
					w._geoType !== a.tool.RedlineTool.TYPE_POINT && (S = w._graphic.getLeftTop(w._map.draggableGroup), m = b.pageX - w._$container.offset().left - S.x, b = b.pageY - w._$container.offset().top - S.y, w.dragging ? (w._screenPoints.push(m), w._screenPoints.push(b), b = w._map.getAbsoluteCursorLocation(), b = new a.Feature("_rlcpt" + w._continuousPoints.length, b, {
								renderingStyle: w._pointStyle
							}),
							b.x = w._map.mLocX, b.y = w._map.mLocY, w._continuousPoints.push(b), 1 < w._continuousPoints.length ? w._shapeGroup ? w.setPath(w._shapeGroup, [w._screenPoints], w._style) : w._shapeGroup = w.drawLine([w._continuousPoints], w._style, {
								group: w._group
							}) : w.addVertex(null, {
								x: w._map.mLocX,
								y: w._map.mLocY
							})) : na && sa && (w._shapeGroup ? w.setPath(w._shapeGroup, [[na, sa, m, b]], w._style) : (w._zoom && (S = w._map.getScreenLocation(w._points[w._points.length - 1].geo), na = S[0], sa = S[1], w._zoom = !1), w._shapeGroup = w.drawLine([[na, sa, m, b]], w._style, {
									group: w._group
								})), b = new Oa(Oa.REDLINE_DRAW, w), w.fire(b.type, b)))
				}
			};
			this.addVertex = function (b, c, m) {
				if (1 <= w._points.length) {
					var D = w._points[w._points.length - 1].geo.coordinates,
					S = w._map.getSnapToleranceOnGround(),
					U = w._map.getAbsoluteCursorLocation().coordinates,
					ja = U[0] - D[0],
					D = U[1] - D[1];
					if (Math.sqrt(ja * ja + D * D) <= S)
						return !1
				}
				var U = a.MapContext(w._map),
				S = w._points,
				ja = w._lines,
				D = w._map.getToolFeatureLayer(),
				Qa;
				if ("number" !== typeof b || 0 > b || b > S.length)
					b = S.length;
				c instanceof a.geometry.Point ? (Qa = a.MapContext(w._map).getUniverse(),
					Qa = Qa.srid, Qa !== c.srid && (c = c.transform(Qa)), c.wraparoundMapIndex = U.getBaseWholeMapIndex()) : c = w._map.getScreenPointLocation(c.x, c.y);
				w.activeMapIndex || (w.activeMapIndex = c.wraparoundMapIndex);
				if (c.wraparoundMapIndex === w.activeMapIndex) {
					c.wraparoundMapIndex && (c = w._map.getACL(c, c.wraparoundMapIndex));
					var Ta;
					if (0 === S.length || w._geoType !== a.tool.RedlineTool.TYPE_POINT) {
						U = w._pointStyle;
						w._geoType === a.tool.RedlineTool.TYPE_POLYGON && 0 === S.length && (U = w._pointStyle_1stPolygonVertex);
						U = new a.Feature("RedlinePoints" +
								w._nextPointId++, c, {
								renderingStyle: U
							});
						U.activeIdx = w.activeIdx;
						S.splice(b, 0, U);
						D.addFeature(U);
						switch (w._geoType) {
						case a.tool.RedlineTool.TYPE_POINT:
							w.finish();
							break;
						case a.tool.RedlineTool.TYPE_LINESTRING:
							1 < S.length && (w.finishFeature = U);
							break;
						case a.tool.RedlineTool.TYPE_POLYGON:
							1 === S.length ? w.finishFeature = U : a.isNotNull(w.finishFeature) && w.finishFeature.bringToTop()
						}
						U = !1;
						S[b - 1] && (Qa = S[b - 1].getGeometry(), Qa = new a.geometry.LineString([Qa.getX(), Qa.getY(), c.getX(), c.getY()], Qa.srid), Qa = new a.Feature("RedlineLines" +
									w._nextLineId++, Qa, {
									renderingStyle: w._style
								}), Qa.activeIdx = w.activeIdx, ja.splice(b, 0, Qa), D.addFeature(Qa), U = !0);
						S[b + 1] && (Qa = S[b + 1].getGeometry(), Qa = new a.geometry.LineString([c.getX(), c.getY(), Qa.getX(), Qa.getY()], Qa.srid), Qa = new a.Feature("RedlineLines" + w._nextLineId++, Qa, {
								renderingStyle: w._style
							}), U && (D.removeFeature(ja[b - 1]), ja.splice(b - 1, 1)), ja.splice(b, 0, Qa), D.addFeature(Qa))
					} else
						Ta = S[0].getGeometry(), S[0].setGeometry(c), w.finishFeature = S[0], w.finishFeature.movedOut = null;
					m || w._geoType === a.tool.RedlineTool.TYPE_POINT ||
					(m = w._map.getUndoManager().addEdit({
							index: b,
							vertex: c,
							prevVertex: Ta,
							canUndo: function () {
								return !0
							},
							canRedo: function () {
								return !0
							},
							getPresentationName: function () {
								return "Redline tool point (" + this.x + "," + this.y + ")"
							},
							undo: function () {
								this.prevVertex ? w.addVertex(this.index, this.prevVertex, !0) : w.removeVertex(this.index, !0)
							},
							redo: function () {
								w.addVertex(this.index, this.vertex, !0)
							}
						}), a.isNull(w.startBlock) && (w.startBlock = m), w.endBlock = m);
					b === S.length - 1 && (w.removeShapeGroup(w), w._shapeGroup = null, b = w._map.getScreenLocation(c),
						c = w._graphic.getLeftTop(w._map.draggableGroup), na = b.x - c.x, sa = b.y - c.y);
					b = new Oa(Oa.REDLINE_POINT_CREATE, w);
					w.fire(b.type, b);
					w._lastVertexAddedTimestamp = Date.now();
					return !0
				}
			};
			this.removeVertex = function (b, c) {
				var m = w._points;
				if (!(0 > b || b >= m.length)) {
					var D = w._lines,
					S = w._map.getToolFeatureLayer(),
					U,
					ja = 1,
					Qa = m[b - 1],
					Ta = m[b + 1];
					Qa && Ta && (ja = 2, U = Qa.getGeometry(), Ta = Ta.getGeometry(), U = new a.geometry.LineString([U.getX(), U.getY(), Ta.getX(), Ta.getY()], U.srid), U = new a.Feature("RedlineLines" + w._nextLineId++, U, {
							renderingStyle: w._style
						}),
						S.addFeature(U));
					Ta = m.splice(b, 1)[0];
					S.removeFeature(Ta);
					Ta = Ta.getGeometry();
					D = U ? D.splice(Math.max(0, b - 1), ja, U) : D.splice(Math.max(0, b - 1), ja);
					for (ja = 0; ja < D.length; ja++)
						S.removeFeature(D[ja]);
					c || w._geoType === a.tool.RedlineTool.TYPE_POINT || (S = w._map.getUndoManager().addEdit({
							index: b,
							vertex: Ta,
							canUndo: function () {
								return !0
							},
							canRedo: function () {
								return !0
							},
							getPresentationName: function () {
								return "Redline tool point (" + this.x + "," + this.y + ")"
							},
							undo: function () {
								w.addVertex(this.index, this.vertex, !0)
							},
							redo: function () {
								w.removeVertex(this.index,
									!0)
							}
						}), a.isNull(w.startBlock) && (w.startBlock = S), w.endBlock = S);
					b == m.length && (w.removeShapeGroup(w), sa = na = w._shapeGroup = null, Qa && (m = w._map.getScreenLocation(Qa.getGeometry()), Qa = w._graphic.getLeftTop(w._map.draggableGroup), na = m.x - Qa.x, sa = m.y - Qa.y));
					m = new Oa(Oa.REDLINE_POINT_REMOVE, w);
					w.fire(m.type, m)
				}
			};
			this.newShapePoint = function (a, b, c, m, D) {
				this.addVertex(null, w._map.getScreenPointLocation(a, b, !0))
			};
			this.zoomAction = function () {
				w.finish()
			};
			this.isWithinTolerance = function (b) {
				if (a.isNull(b))
					return !1;
				var c =
					b.x2 - b.x1;
				b = b.y2 - b.y1;
				c = Math.sqrt(c * c + b * b);
				b = this._map.getSnapTolerance().value;
				var m = this._map.getPixelResolution();
				return b >= c / m
			};
			this.finish = function () {
				if (w.status != a.tool.Tool.STARTED)
					w.restoreMapActionState();
				else {
					a.isNotNull(this.startBlock) && a.isNotNull(this.endBlock) && (w._map.getUndoManager().trimEdits(this.startBlock, this.endBlock + 1), this.endBlock = this.startBlock = c);
					var b = w._map.getToolFeatureLayer();
					w._map.deleteListener(a.event.MapEvent.MAP_BEFORE_ZOOM, w.zoomAction, w);
					var m = !0;
					a.browser.touchSupported ||
					a.gv.isWin8Touch || (m = !1);
					w._$container.unbind("mousemove", w.mouseMove);
					w._$container.unbind("mouseup", w.mouseUp);
					w._$container.unbind("mousedown", w.mouseDown);
					a.gv.isWin8Touch && (w._$container[0].removeEventListener("MSPointerUp", w.mouseUp), w._$container[0].removeEventListener("MSPointerDown", w.mouseDown));
					a.browser.touchSupported && (w._$container.unbind("touchstart", w.touchStart), w._$container.unbind("touchmove", w.touchMove), w._$container.unbind("touchend", w.touchEnd));
					w.touchEnabled = null;
					m && a.Hammer(w._$container[0]).off("hold",
						w.finishAndCleanUp);
					w.removeShapeGroup(w);
					if (0 === w._points.length)
						w.status = a.tool.Tool.FINISHED, w.restoreMapActionState();
					else {
						var m = [],
						D;
						for (D = 0; D < w._points.length; D++) {
							var S = w._points[D].getGeometry().getX(),
							U = w._points[D].getGeometry().getY();
							if (0 < D) {
								var na = m.length;
								this.isWithinTolerance({
									x1: m[na - 2],
									y1: m[na - 1],
									x2: S,
									y2: U
								}) || (m.push(S), m.push(U))
							} else
								m.push(S), m.push(U);
							b.removeFeature(w._points[D])
						}
						for (D = 0; D < w._lines.length; D++)
							b.removeFeature(w._lines[D]);
						try {
							switch (w._geoType) {
							case a.tool.RedlineTool.TYPE_POINT:
								w._geometry =
									new a.geometry.Point(m[m.length - 2], m[m.length - 1], w._points[0].getGeometry().srid);
								break;
							case a.tool.RedlineTool.TYPE_LINESTRING:
								if (4 > m.length) {
									w.status = a.tool.Tool.FINISHED;
									a.util.Logger.warning("MAPVIEWER_9011", "OM.tool.RedlineTool.finish", "");
									w._map.moveflag = !1;
									break
								}
								w._geometry = new a.geometry.LineString(m, w._points[0].getGeometry().srid);
								break;
							case a.tool.RedlineTool.TYPE_POLYGON:
								var sa = w._points[0].getGeometry();
								this.isWithinTolerance({
									x1: m[m.length - 2],
									y1: m[m.length - 1],
									x2: sa.getX(),
									y2: sa.getY()
								}) &&
								(m.pop(), m.pop());
								m.push(sa.getX());
								m.push(sa.getY());
								8 > m.length ? (w.status = a.tool.Tool.FINISHED, a.util.Logger.warning("MAPVIEWER_9012", "OM.tool.RedlineTool.finish", ""), w._map.moveflag = !1) : w._geometry = new a.geometry.Polygon(m, sa.srid)
							}
						} catch (Qa) {
							w._geometry = null,
							a.util.Logger.warning("", "OM.tool.RedlineTool.finish", Qa)
						} finally {
							w.end(),
							w.status = a.tool.Tool.FINISHED,
							w.restoreMapActionState(),
							b = new Oa(Oa.TOOL_END, w),
							w.fire(b.type, b)
						}
					}
				}
			};
			this.touchStart = function (b) {
				var c = a.util.DomUtil,
				m = c.getTouchCount(b);
				if (1 == m)
					b.button = 0, c = c.getTouchesPosition(b), w.touchPos = c, b.pageX = c.x, b.pageY = c.y;
				else if (2 == m)
					b.button = 2;
				else
					return;
				w.mouseDown(b)
			};
			this.touchMove = function () {
				w.touchPos = null
			};
			this.touchEnd = function (a) {
				w.touchPos && (a.pageX = w.touchPos.x, a.pageY = w.touchPos.y, w.mouseMove(a), w.mouseUp(a))
			}
		},
		start: function () {
			var b = a.event.ToolEvent;
			this.clear();
			this._map.enableMapAction.dbclick = !1;
			this._map.enableMapAction.mouse = !1;
			this._group || (this._group = this._graphic.createGroup(), this._graphic.addGroup(this._group,
					this._map.draggableGroup));
			this.domainArea = {};
			this.activeIdx = null;
			this._points = [];
			this._lines = [];
			this._map.on(a.event.MapEvent.MAP_BEFORE_ZOOM, this.zoomAction, this);
			var c = !0;
			a.browser.touchSupported || a.gv.isWin8Touch || (c = !1);
			this._$container.bind("mouseup", this.mouseUp);
			this._$container.bind("mousedown", this.mouseDown);
			this._$container.bind("mousemove", this.mouseMove);
			a.gv.isWin8Touch && (this._$container[0].addEventListener("MSPointerUp", this.mouseUp), this._$container[0].addEventListener("MSPointerDown",
					this.mouseDown));
			a.browser.touchSupported ? (this._$container.bind("touchstart", this.touchStart), this._$container.bind("touchmove", this.touchMove), this._$container.bind("touchend", this.touchEnd), this.touchEnabled = !0) : this.touchEnabled = !1;
			if (c)
				a.Hammer(this._$container[0]).on("hold", this.finishAndCleanUp);
			this.status = a.tool.Tool.STARTED;
			b = new b(b.TOOL_START, this);
			this.fire(b.type, b);
			return this
		},
		end: function () {
			var b = null;
			switch (this._geoType) {
			case a.tool.RedlineTool.TYPE_POINT:
				b = this.featurePointStyle;
				break;
			case a.tool.RedlineTool.TYPE_LINESTRING:
				b = this.featureStyle;
				break;
			case a.tool.RedlineTool.TYPE_POLYGON:
				b = this.featurePolygonStyle
			}
			var c = this._map.getToolFeatureLayer();
			this.toolFeature = new a.Feature("RedlineTool" + c.featureArray.length, this._geometry, {
				renderingStyle: b
			});
			this._map.getToolFeatureLayer();
			c.enableFeatureEditing(!0);
			c.addFeature(this.toolFeature);
			this.toolFeature.on(a.event.LayerEvent.FEATURE_MOVED, function () {
				this._geometry = this.toolFeature.geo;
				var b = new a.event.ToolEvent(a.event.ToolEvent.REDLINE_EDITED,
						this);
				this.fire(b.type, b)
			}, this);
			this.toolFeature.on(a.event.LayerEvent.FEATURE_EDITED, function () {
				this._geometry = this.toolFeature.geo;
				var b = new a.event.ToolEvent(a.event.ToolEvent.REDLINE_EDITED, this);
				this.fire(b.type, b)
			}, this)
		},
		clear: function () {
			this.finish();
			this.clear_base()
		},
		getGeometryType: function () {
			return this._geoType
		},
		getGeometry: function () {
			return this._geometry
		},
		setDrawingStyle: function (b) {
			if (!b)
				return this;
			var c = a.tool.RedlineTool;
			b.type === c.TYPE_POINT && (this._pointStyle = b.style.clone());
			if (b.type === c.TYPE_LINESTRING || b.type === c.TYPE_POLYGON)
				this._style = b.style.clone();
			return this
		},
		drawLine: function (b, c, S) {
			var U = [];
			if (c && "Line" == c.styleType) {
				a.style.Style.calculateStyleSize(c, this._map.getMapContext());
				c = c.stylelist;
				for (var w = c.length, ja = 0; ja < w; ja++) {
					var la = c[ja];
					la.stroke && U.push(this._graphic.drawPath(b, la, S))
				}
			} else
				S = {
					group: this._group,
					id: "lstr"
				},
			c.stroke || (c.stroke = c.fill ? c.fill : "#000000"),
			c.fill = null,
			U.push(this._graphic.drawPath(b, c, S));
			return U
		},
		setPath: function (b, c, S) {
			if (!a.isNull(b)) {
				b =
					b.length;
				a.style.Style.calculateStyleSize(S, this._map.getMapContext());
				S = S.stylelist;
				for (var U = 0; U < b; U++)
					this._graphic.setPath(this._shapeGroup[U], c, S[U])
			}
		},
		removeShapeGroup: function (a) {
			if (a && a._shapeGroup) {
				for (var b = a._shapeGroup.length, c = 0; c < b; c++)
					a._graphic.remove(a._shapeGroup[c]);
				a._shapeGroup.length = 0;
				a._shapeGroup = null
			}
		},
		setStyle: function (b) {
			b.type == a.tool.RedlineTool.TYPE_POINT && (this.featurePointStyle = b.style.clone(), this.toolFeature && this._geoType == a.tool.RedlineTool.TYPE_POINT && this.toolFeature.setRenderingStyle(this.featurePointStyle));
			b.type == a.tool.RedlineTool.TYPE_LINESTRING && (this.featureStyle = b.style.clone(), this.toolFeature && this._geoType == a.tool.RedlineTool.TYPE_LINESTRING && this.toolFeature.setRenderingStyle(this.featureStyle));
			b.type == a.tool.RedlineTool.TYPE_POLYGON && (this.featurePolygonStyle = b.style.clone(), this.toolFeature && this._geoType == a.tool.RedlineTool.TYPE_POLYGON && this.toolFeature.setRenderingStyle(this.featurePolygonStyle));
			return this
		}
	});
	a.tool.RedlineTool.TYPE_POINT = 1;
	a.tool.RedlineTool.TYPE_LINESTRING = 2;
	a.tool.RedlineTool.TYPE_POLYGON =
		3;
	a.tool.RedlineTool.FINISH_ON_CLICK = 1;
	a.tool.RedlineTool.FINISH_ON_RELEASE = 2;
	a.tool.RedlineTool.LINESTRING_FINISH_DEBOUNCE_TIME = 500;
	a.tool.MarqueeZoomTool = a.tool.RectangleTool.extend({
		initialize: function D(b, c) {
			D.base.call(this, b);
			var w = this;
			this.mode = c ? c : a.tool.MarqueeZoomTool.PROMPT;
			this.setStyle(new a.style.Color({
					stroke: "#00FF00",
					fill: "#FF0000",
					strokeThickness: 1,
					fillOpacity: .5
				}));
			this.setDrawingStyle(new a.style.Color({
					stroke: "#00FF00",
					fill: "#FF0000",
					strokeThickness: 1,
					fillOpacity: .5
				}));
			this.on(a.event.ToolEvent.TOOL_END,
				function () {
				var c = w.getGeometry(),
				D = function (b) {
					w.clear();
					b && (w._map.zoomToExtent(c), w.status = a.tool.Tool.FINISHED)
				},
				U = function () {
					D(!1);
					b.deleteListener(a.event.MouseEvent.MOUSE_CLICK, U)
				},
				sa = function () {
					D(!0);
					b.deleteListener(a.event.MouseEvent.MOUSE_CLICK, U)
				};
				w.mode != a.tool.MarqueeZoomTool.PROMPT ? D(!0) : (w.toolFeature.on(a.event.MouseEvent.MOUSE_CLICK, sa), b.on(a.event.MouseEvent.MOUSE_CLICK, U));
				w.mode == a.tool.MarqueeZoomTool.CONTINUOUS && w.start()
			})
		},
		setMode: function (a) {
			this.mode = a
		}
	});
	a.tool.MarqueeZoomTool.ONE_TIME =
		1;
	a.tool.MarqueeZoomTool.CONTINUOUS = 2;
	a.tool.MarqueeZoomTool.PROMPT = 3;
	a.tool.ButtonGroup = a.Class.extend({
		initialize: function (a) {
			this.butGroupId = a;
			this.buttonArray = []
		},
		createHTML: function () {
			for (var a = "\x3ctable\x3e\x3ctbody\x3e\x3ctr\x3e", b = this.buttonArray.length, c = 0; c < b; c++)
				a += "\x3ctd\x3e", a += this.buttonArray[c].createHTML(), a += "\x3c/td\x3e";
			return a + "\x3c/tr\x3e\x3c/tbody\x3e\x3c/table\x3e"
		},
		addButton: function (a) {
			a.parent = this;
			this.buttonArray.push(a)
		},
		removeButton: function (a) {
			for (var b = this.buttonArray.length,
				c = 0; c < b; c++)
				this.buttonArray[c] == a && (this.buttonArray.splice(c, 1), a.parent = null)
		},
		attachEvents: function () {
			for (var a = this.buttonArray.length, b = 0; b < a; b++)
				this.buttonArray[b].attachEvents()
		},
		setDownButton: function (a) {
			for (var b = this.buttonArray.length, c = 0; c < b; c++) {
				var w = this.buttonArray[c];
				w == a ? w.setStatus(!0) : w.setStatus(!1)
			}
		}
	});
	a.tool.ImageButton = a.Class.extend({
		initialize: function (b, c) {
			this.btID = b;
			c && (this.btIcon = c.buttonEnableIcon, this.btOverIcon = c.buttonOverIcon, this.btDownIcon = c.buttonDownIcon,
				this.btDisableIcon = c.buttonDisableIcon, this.tip = c.toolTip, this.width = c.width, this.height = c.height);
			this.status = c && c.status ? c.status : a.tool.ImageButton.STATUS_UP
		},
		createHTML: function () {
			var b;
			b = '\x3ca href\x3d"javascript:void(0)" style\x3d"vertical-align:bottom"' + (a.isNull(this.tip) ? "\x3e" : ' title\x3d"' + this.tip + '"\x3e');
			return b += '\x3cimg id\x3d"' + this.btID + '" src\x3d' + this.btIcon + " border\x3d0\x3e\x3c/a\x3e"
		},
		attachEvents: function () {
			this.$icon = a.$("#" + this.btID);
			this.status == a.tool.ImageButton.STATUS_DOWN &&
			(this.$icon.attr("src", this.btDownIcon), this.$icon[0].down = !0);
			if (!this.attched) {
				this.attched = !0;
				var b = this;
				a.$(this.$icon).hover(function (a) {
					b.btOverIcon && !this.down && b.$icon.attr("src", b.btOverIcon)
				}, function (a) {
					b.btOverIcon && !this.down && b.$icon.attr("src", b.btIcon)
				}).mousedown(function (a) {
					b.btDownIcon && b.$icon.attr("src", b.btDownIcon)
				}).click(function (c) {
					b.parent instanceof a.tool.ButtonGroup ? this.down || (this.down = !0, b.parent.setDownButton(b)) : b.setStatus(!this.down)
				})
			}
		},
		setStatus: function (b) {
			b ?
			(this.$icon.attr("src", this.btDownIcon), this.$icon[0].down = !0, this.status = a.tool.ImageButton.STATUS_DOWN) : (this.$icon.attr("src", this.btIcon), this.$icon[0].down = !1, this.status = a.tool.ImageButton.STATUS_UP)
		}
	});
	a.tool.ImageButton.STATUS_DOWN = "DOWN";
	a.tool.ImageButton.STATUS_UP = "UP";
	a.control.MapDecoration = a.Class.extend({
		mixin: a.event.EventSource,
		initialize: function (b, c) {
			this.dragDiv = !1;
			this._randomId = "" + this.s4() + this.s4();
			this.id = "decorationDiv_" + this._randomId;
			this.visible = !0;
			this.minimized = this.collapsible =
				!1;
			this.title = "";
			this.isMapDeco = !1;
			a.isNull(this.isHtml) && (this.isHtml = !1);
			this.cleaned = !1;
			this.Y = this.X = 0;
			this.inAnimation = this.draggable = this.relativePosition = this.anchored = !1;
			this.collapsibleContainer = null;
			if (b && b.substr) {
				try {
					"string" === typeof b && (b.startsWith("MapDeco") || b.startsWith("\x3cdiv")) && (this.isMapDeco = !0)
				} catch (U) {
					a.util.Logger.warning("", "OM.MapDecoration.initialize", "Map deco content is: " + b)
				}
				this.isHtml = !0;
				this.content = b;
				this.type = "CustomHtmlDecoration"
			} else
				c && c.title && (this.isHtml =
						!0, this.type = "CustomHtmlDecoration");
			if (c) {
				this.restoredWidth = c.width ? c.width : 0;
				this.restoredHeight = c.height ? c.height : 0;
				this.mapType = c.mapType;
				this.draggable = c.draggable ? c.draggable : !1;
				a.isNull(c.draggable) && (this.draggable = !0);
				this.X = a.notNull(c.offsetX) ? c.offsetX : 20;
				this.Y = a.notNull(c.offsetY) ? c.offsetY : 20;
				this.isPanel = !0;
				this.width = c.width ? c.width : 0;
				this.height = c.height ? c.height : 0;
				this.title = c.title ? c.title : "";
				this.collapsible = c.collapsible ? c.collapsible : !1;
				this.titleStyle = c.titleStyle ? c.titleStyle :
					null;
				this.contentStyle = c.contentStyle ? c.contentStyle : null;
				if (a.notNull(c.anchorPosition)) {
					this.anchorPosition = parseInt(c.anchorPosition);
					if (1 > this.anchorPosition || 6 < this.anchorPosition)
						a.util.Logger.warning("", "OM.MapDecoration.initialize", "anchorPosition value is out of range, default value is used."), this.anchorPosition = 1;
					this.anchored = !0
				}
				a.notNull(c.enableAnimation) && (this.enableAnimation = c.enableAnimation)
			}
		},
		display: function (b) {
			b = this.map || b;
			var c = this.graphics = b.graphics,
			U = b.getMapContext();
			this.parentMapWidth = U.getDeviceWidth();
			this.parentMapHeight = U.getDeviceHeight();
			this.isHtml ? (this.container = b.$topLayerDIV, this.generateHtmlDecoration(), this.setDraggable(this.draggable), this.isMapDeco || (this.delegate("mousedown", function (b) {
						a.event.EventSource.stopEvents[b.type] = !0
					}), this.delegate("dblclick", function (b) {
						a.event.EventSource.stopEvents[b.type] = !0
					}))) : (this.container = b.fixedGroup, this.defaultGroup = c.createGroup(), c.addGroup(this.defaultGroup, this.container), this.delegate("dblclick",
					function (a) {
					a.stopPropagation();
					a.preventDefault()
				}), this.delegate("mousedown", function (a) {
					a.stopPropagation();
					a.preventDefault()
				}), this.delegate("mouseup", function (a) {
					a.stopPropagation();
					a.preventDefault()
				}));
			this.map.on(a.event.MapEvent.MAP_RESIZED, this.resize, this);
			"NavigationPanelBar" !== this.type && this.setPosition();
			a.notNull(this.anchorPosition) && !0 === this.anchored && this.setAnchorPosition(this.anchorPosition);
			this.relativePosition && !this.draggable && this.map.addListener(a.event.MapEvent.MAP_RESIZED,
				this.setPosition, this);
			this.graphics && this.defaultGroup && !this.visible && this.graphics.setVisible(this.defaultGroup, this.visible);
			b = new a.event.MapDecorationEvent(a.event.MapDecorationEvent.DISPLAYED, this);
			this.fire(a.event.MapDecorationEvent.DISPLAYED, b)
		},
		remove: function () {
			this.relativePosition && this.map.deleteListener(a.event.MapEvent.MAP_RESIZED, this.setPosition, this);
			this.unDelegate();
			this.isHtml && this.$DecorationDiv && (this.$DecorationBtnDiv && this.$DecorationBtnDiv.off(), this.$title && this.$title.off(),
				this.$Content && this.$Content.off(), this.$DecorationDiv.off(), this.map && (this.map.$oracleMapDiv.off("mousemove", this.mapDiv_msmove), this.map.$oracleMapDiv.off("touchmove", this.mapDiv_touchmove), this.map.$oracleMapDiv.off("touchend", this.mapDiv_touchend)), this.$DecorationDiv.remove(), this.$DecorationBtnDiv && this.$DecorationBtnDiv.remove());
			a.$(document).off("mouseup", this.mapDeco_mouseupHandler)
		},
		clean: function () {
			this.unDelegate && this.unDelegate();
			this.isHtml ? (this.$DecorationDiv.remove(), this.$DecorationBtnDiv &&
				this.$DecorationBtnDiv.remove()) : this.graphics.clearGroup(this.defaultGroup);
			this.cleaned = !0
		},
		setPosition: function (b, c) {
			1 <= b && (b = parseInt(b));
			1 <= c && (c = parseInt(c));
			this.X = b || this.X;
			this.Y = c || this.Y;
			this.map && this.parentMapWidth && (1 > this.X && 0 < this.X && (this.X *= this.parentMapWidth, this.relativePosition = !0), 1 > this.Y && 0 < this.Y && (this.Y *= this.parentMapHeight, this.relativePosition = !0));
			this.defaultGroup && this.graphics ? this.graphics.setLeftTop(this.defaultGroup, this.X, this.Y) : this.isHtml && a.notNull(this.$DecorationDiv) &&
			(this.container.append(this.$DecorationDiv), this.$DecorationDiv.css({
					top: this.Y,
					left: this.X,
					bottom: "",
					right: ""
				}))
		},
		setAnchorPosition: function (b) {
			isNaN(b) && (b = this.anchorPosition);
			var c = b || this.anchorPosition;
			this.anchorPosition = c;
			this.anchored = !0;
			if (!a.isNull(this.map)) {
				var U = this.container.find("div[id^\x3domv2_anchorBox]");
				"ScaleBar" === this.type ? (this.setMainDecorationAnchorCss(b), $(U[b - 1]).append(this.$DecorationDiv[0])) : "CopyRight" === this.type ? (this.setCopyRightStyle(b), this.container.append(this.$DecorationDiv)) :
				"NavigationPanelBar" === this.type ? (this.setMainDecorationAnchorCss(b), $(U[b - 1]).append(this.$DecorationDiv[0])) : "OverviewMap" === this.type ? (this.setMainDecorationAnchorCss(b), $(U[b - 1]).append(this.$DecorationDiv)) : "Magnifier" === this.type ? (this.$DecorationDiv.detach(), this.setMainDecorationAnchorCss(b), $(U[b - 1]).append(this.$DecorationDiv)) : "LayerControl" === this.type ? (this.$DecorationDiv.detach(), this.setMainDecorationAnchorCss(b), $(U[b - 1]).append(this.$DecorationDiv)) : (this.$DecorationDiv || this.graphics) &&
				this.doSetAnchorPosition(c)
			}
		},
		getOffsetFromCopyright: function () {
			var b = 0,
			c = this.anchorPosition;
			if (1 < this.map.decorationArray.length && "CopyRight" !== this.type)
				if (4 === c || 5 === c || 6 === c)
					for (c = 0; c < this.map.decorationArray.length; c++) {
						if (a.notNull(this.map.decorationArray[c].$DecorationDiv) && "CopyRight" === this.map.decorationArray[c].type && (4 === this.map.decorationArray[c].anchorPosition || 5 === this.map.decorationArray[c].anchorPosition || 6 === this.map.decorationArray[c].anchorPosition)) {
							b = this.map.decorationArray[c].$DecorationDiv.height();
							break
						}
					}
				else
					for (c = 0; c < this.map.decorationArray.length; c++)
						if (a.notNull(this.map.decorationArray[c].$DecorationDiv) && "CopyRight" === this.map.decorationArray[c].type && (1 === this.map.decorationArray[c].anchorPosition || 2 === this.map.decorationArray[c].anchorPosition || 3 === this.map.decorationArray[c].anchorPosition)) {
							b = this.map.decorationArray[c].$DecorationDiv.height();
							break
						}
			return b
		},
		getAnchorPosition: function (b) {
			if (a.isNull(b) || isNaN(b) || 1 > b || 6 < b)
				return {
					left: 0,
					top: 0
				};
			var c = this.map.getMapContext(),
			U = a.isNull(this.anchorOffsetX) ?
				this.minOffset : this.anchorOffsetX,
			w = a.isNull(this.anchorOffsetY) ? this.minOffset : this.anchorOffsetY,
			ja = c.getDeviceWidth(),
			c = c.getDeviceHeight(),
			la = this.width,
			na,
			sa;
			na = a.browser.touchSupported ? sa = a.gv.decorationCollapseButtonSizeTouch : sa = a.gv.decorationCollapseButtonSizeNoTouch;
			var wa = {
				left: 0,
				top: 0
			};
			this.minOffset && (U += 1.5 * this.minOffset, w += this.minOffset);
			this.minimized && (la = 0, U = this.minOffset);
			w += this.getOffsetFromCopyright();
			switch (b) {
			case 1:
				wa.left = U + la;
				wa.top = w;
				break;
			case 2:
				wa.left = 1 * ja / 2 + 1 * U /
					2;
				wa.top = w;
				break;
			case 3:
				wa.left = ja - la - sa - U;
				wa.top = w;
				break;
			case 4:
				wa.left = U + la;
				wa.top = c - na - w;
				break;
			case 5:
				wa.left = 1 * ja / 2 + 1 * U / 2;
				wa.top = c - na - w;
				break;
			case 6:
				wa.left = ja - la - sa - U,
				wa.top = c - na - w
			}
			return wa
		},
		getMainDecorationAnchorPosition: function (b) {
			var c = this.map.getMapContext(),
			U = a.isNull(this.anchorOffsetX) ? 0 : this.anchorOffsetX,
			w = a.isNull(this.anchorOffsetY) ? 0 : this.anchorOffsetY,
			ja = c.getDeviceWidth(),
			c = c.getDeviceHeight(),
			la = this.width,
			na = this.height,
			sa = {
				left: 0,
				top: 0
			};
			this.minOffset && (U += this.minOffset,
				w += this.minOffset);
			w += this.getOffsetFromCopyright();
			switch (b) {
			case 1:
				sa.left = 0 + U;
				sa.top = 0 + w;
				break;
			case 2:
				sa.left = 1 * ja / 2 - 1 * la / 2 + U;
				sa.top = 0 + w;
				break;
			case 3:
				sa.left = ja - la - U;
				sa.top = 0 + w;
				break;
			case 4:
				sa.left = 0 + U;
				sa.top = c - na - w;
				break;
			case 5:
				sa.left = 1 * ja / 2 - 1 * la / 2 + U;
				sa.top = c - na - w;
				break;
			case 6:
				sa.left = ja - la - U,
				sa.top = c - na - w
			}
			return sa
		},
		setHtmlAnchorPosition: function (b) {
			var c = this.getMainDecorationAnchorPosition(b);
			b = this.getAnchorPosition(b);
			var U = this.width,
			w = this.height,
			ja = c.top,
			c = c.left;
			a.notNull(this.$DecorationBtnDiv) &&
			this.$DecorationBtnDiv.css({
				left: b.left,
				top: b.top
			});
			a.notNull(this.$DecorationDiv) && (this.$DecorationDiv.css({
					width: U,
					height: w,
					opacity: 1,
					top: ja,
					left: c
				}), 0 === U || 0 === w ? this.$DecorationDiv.css("visibility", "hidden") : this.$DecorationDiv.css("visibility", "visible"))
		},
		setGraphicsAnchorPosition: function (a) {
			a = this.getMainDecorationAnchorPosition(a);
			this.graphics.setLeftTop(this.defaultGroup, a.left, a.top);
			this.X = a.left;
			this.Y = a.top
		},
		setMainDecorationAnchorCss: function (a) {
			switch (a) {
			case 1:
			case 2:
			case 3:
				this.$DecorationDiv.css({
					top: "0px",
					bottom: ""
				});
				break;
			case 4:
			case 5:
			case 6:
				this.$DecorationDiv.css({
					bottom: "0px",
					top: ""
				})
			}
			switch (a) {
			case 1:
			case 4:
				this.$DecorationDiv.css({
					left: "0px",
					right: ""
				});
				break;
			case 2:
			case 5:
				this.$DecorationDiv.css({
					left: "",
					right: ""
				});
				break;
			case 3:
			case 6:
				this.$DecorationDiv.css({
					left: "",
					right: "0px"
				})
			}
		},
		setCopyRightStyle: function (a) {
			this.$DecorationDiv.css({
				display: "inline-flex"
			});
			switch (a) {
			case 1:
				this.$DecorationDiv.css({
					display: "inline-flex",
					left: "0px",
					"justify-content": "center",
					"align-items": "flex-start",
					"align-content": "flex-start",
					top: "0px",
					right: "",
					bottom: ""
				});
				break;
			case 2:
				this.$DecorationDiv.css({
					display: "inline-flex",
					left: "calc(50% - " + this.$DecorationDiv.width() / 2 + "px )",
					"justify-content": "center",
					"align-items": "flex-start",
					"align-content": "flex-start",
					top: "0px",
					right: "",
					bottom: ""
				});
				break;
			case 3:
				this.$DecorationDiv.css({
					display: "inline-flex",
					right: "0px",
					"justify-content": "center",
					"align-items": "flex-end",
					"align-content": "flex-end",
					top: "0px",
					left: "",
					bottom: ""
				});
				break;
			case 4:
				this.$DecorationDiv.css({
					display: "inline-flex",
					left: "0px",
					"justify-content": "center",
					"align-items": "flex-start",
					"align-content": "flex-start",
					bottom: "0px",
					right: "",
					top: ""
				});
				break;
			case 5:
				this.$DecorationDiv.css({
					display: "inline-flex",
					left: "calc(50% - " + this.$DecorationDiv.width() / 2 + "px )",
					"justify-content": "center",
					"align-items": "flex-start",
					"align-content": "flex-start",
					bottom: "0px",
					right: "",
					top: ""
				});
				break;
			case 6:
				this.$DecorationDiv.css({
					display: "inline-flex",
					right: "0px",
					"justify-content": "center",
					"align-items": "flex-end",
					"align-content": "flex-end",
					bottom: "0px",
					left: "",
					top: ""
				})
			}
		},
		doSetAnchorPosition: function (a) {
			if (1 > a || 6 < a)
				a = 4;
			this.isHtml && this.setHtmlAnchorPosition ? this.setHtmlAnchorPosition(a) : this.graphics && this.setGraphicsAnchorPosition && this.setGraphicsAnchorPosition(a)
		},
		setSize: function (a, b) {
			a && b && (this.width = a, this.height = b, this.restoredWidth = a, this.restoredHeight = b, this.isHtml && (this.$DecorationDiv.width(this.width), this.$DecorationDiv.height(this.height)))
		},
		setDraggable: function (a) {
			this.draggable = a
		},
		setVisible: function (b) {
			this.visible =
				b;
			this.isHtml ? a.isNull(this.$DecorationDiv) && a.isNull(this.$DecorationBtnDiv) || (b ? (this.$DecorationDiv.css("display", ""), a.notNull(this.$DecorationBtnDiv) && this.$DecorationBtnDiv.css("display", "")) : (this.$DecorationDiv.css("display", "none"), a.notNull(this.$DecorationBtnDiv) && this.$DecorationBtnDiv.css("display", "none"))) : this.graphics && this.graphics.setVisible(this.defaultGroup, b)
		},
		getHtmlElementId: function (b) {
			return a.isNull(b) ? this.id : this._randomId
		},
		s4: function () {
			return (65536 * (1 + Math.random()) |
				0).toString(16).substring(1)
		},
		generateHtmlDecoration: function () {
			var b = this;
			this.$DecorationDiv = a.$("\x3cdiv onselectstart\x3d'return false'\x3e\x3c/div\x3e");
			this.$DecorationDiv.attr("id", this.id);
			a.isNull(this.type) ? this.$DecorationDiv.css({
				"z-index": "6",
				position: "absolute",
				overflow: "auto"
			}) : this.$DecorationDiv.css({
				"z-index": "6",
				position: "absolute"
			});
			this.visible || this.$DecorationDiv.css("display", "none");
			this.mapWidth = this.map.getMapContext().getDeviceWidth();
			this.mapHeight = this.map.getMapContext().getDeviceHeight();
			this.container.append(this.$DecorationDiv);
			this.$DecorationBtnDiv && this.$DecorationBtnDiv.bind("mouseup mousedown", function (a) {
				a.stopPropagation()
			});
			this.$DecorationDiv.bind("mouseup mousedown", function (a) {
				a.stopPropagation()
			});
			"Magnifier" === this.type && (this.$Content = a.$("\x3cdiv class\x3d'defaultStyle_magni'\x3e\x3c/div\x3e"), this.$hideDiv = a.$("\x3cdiv class\x3d'hideStyle_magni'\x3e\x3c/div\x3e"), this.$hideDiv.css({
					width: this.width,
					height: this.height
				}), this.$Content.css({
					width: this.width,
					height: this.height
				}),
				this.$DecorationDiv.append(this.$Content), this.$DecorationDiv.append(this.$hideDiv));
			"LayerControl" === this.type && (this.$Content = a.$("\x3cdiv class\x3d'defaultStyle_layerctrl'\x3e\x3c/div\x3e"), this.$Content.css({
					width: this.width,
					"z-index": 0
				}), this.$title = a.$("\x3cdiv class\x3d'titleStyleBasic_layerctrl titleStyleEna_layerctrl'\x3e" + a.gv.getLabel("MAPVIEWER_LC_TITLE") + "\x3c/div\x3e"), this.$title.css({
					width: this.width - 4,
					"font-size": this.title_font_size,
					"font-family": this.title_font_family,
					"z-index": 1
				}),
				this.collapsibleContainer = a.$("\x3cdiv id\x3d'_customContainer' \x3e\x3c/div\x3e"), this.collapsibleContainer.css({
					display: "inline-flex",
					margin: "5px",
					"flex-direction": "column",
					flex: "content"
				}), this.collapsibleContainer.append(this.$title, this.$Content), this.$DecorationDiv.append(this.collapsibleContainer));
			"OverviewMap" === this.type && (this.$DecorationDiv.css({
					display: "inline-flex",
					"flex-direction": "row",
					"align-items": "flex-end",
					"align-content": "flex-end"
				}), this.overviewMapDIV = a.$("\x3cdiv id\x3d'_DecorationOverview' class\x3d'style_overviewMap'\x3e\x3c/div\x3e"),
				this.overviewMapDIV.css({
					height: .3 * this.parentMapHeight,
					width: .3 * this.parentMapWidth
				}));
			if ("ToolBar" === this.type || this.mapType) {
				var c = this.$Content = a.$("\x3cdiv style\x3d'overflow:false'\x3e\x3c/div\x3e"),
				U = this.$realContent = a.$("\x3cdiv\x3e" + this.content + "\x3c/div\x3e"),
				w = this.$tb_title = a.$("\x3cdiv class\x3d'titleStyleEna_layerctrl'\x3e\x3c/div\x3e");
				w.css({
					height: "6px"
				});
				this.defaultStyle = {
					"border-style": "solid",
					"border-color": "#101418",
					"border-width": "1px",
					padding: "0px",
					"font-size": "16px",
					color: "#000000",
					backgroundColor: "#FDFDFD"
				};
				this.contentStyle ? U.css(this.contentStyle) : U.css(this.defaultStyle);
				if (this.title) {
					this.title = this.title.replace(/\ /g, "\x26nbsp;");
					var ja = this.$titleDiv = a.$("\x3cdiv\x3e" + this.title + "\x3c/div\x3e");
					this.defaultTitleStyle = {
						"border-style": "solid",
						"border-color": "#391EA6",
						"border-width": "1px",
						backgroundColor: "#0D0D0D",
						"font-size": "18px",
						"font-weight": "bold",
						color: "#FDFDFD"
					};
					this.titleStyle ? ja.css(this.titleStyle) : ja.css(this.defaultTitleStyle);
					c.append(this.$titleDiv)
				}
				c.append(U);
				"ToolBar" === this.type && this.draggable && this.$DecorationDiv.append(w);
				this.$DecorationDiv.append(c);
				this.width && c.width(this.width);
				this.height && c.height(this.height);
				this.width || (this.width = this.$DecorationDiv.width());
				this.height || (this.height = this.$DecorationDiv.height())
			}
			if ("CustomHtmlDecoration" === this.type && !this.mapType) {
				c = a.$('\x3ctable border\x3d"0" cellspacing\x3d"0"\x3e');
				this.title && (this.title = this.title.replace(/\ /g, "\x26nbsp;"), U = a.$("\x3ctr\x3e\x3c/tr\x3e"), U.appendTo(c), w = a.$("\x3ctd\x3e" +
							this.title + "\x3c/td\x3e"), w.appendTo(U), this.titleStyle ? w.css(this.titleStyle) : w.addClass("defaultTitleStyle_noType"));
				if (a.notNull(this.content)) {
					U = a.$("\x3ctr\x3e\x3c/tr\x3e");
					U.appendTo(c);
					var la = a.$("\x3ctd id\x3d'content_td'\x3e" + this.content + "\x3c/td\x3e");
					0 < la.find("a").length && la.find("a").bind("touchstart", function () {
						h.location.href = la.find("a").attr("href")
					});
					la.appendTo(U);
					this.contentStyle ? la.css(this.contentStyle) : la.addClass("defaultContentStyle_noType")
				}
				this.collapsibleContainer = a.$("\x3cdiv id\x3d'_customContainer' \x3e\x3c/div\x3e");
				this.collapsibleContainer.css({
					display: "inline-flex",
					margin: "5px"
				});
				this.collapsibleContainer.append(c);
				this.$DecorationDiv.append(this.collapsibleContainer);
				"ScaleBar" !== this.type && (this.width = this.$DecorationDiv.width(), this.restoredHeight = this.height = this.$DecorationDiv.height(), this.restoredWidth = this.width);
				this.width && c.width(this.width);
				this.height && c.height(this.height);
				this.width || (this.width = this.$DecorationDiv.width());
				this.height || (this.height = this.$DecorationDiv.height())
			}
			this.collapsible &&
			(a.browser.touchSupported ? (this.btnW = this.btnH = a.gv.decorationCollapseButtonSizeTouch, this.$DecorationBtnDiv = a.$("\x3cdiv id\x3d'_DecorationBtnDiv' class\x3d'omv2_collapse_button'\x3e\x3cimg src\x3d'" + a.control.MapDecoration.getImage(this) + "' style\x3d'height:24px;width:24px'\x3e\x3c/div\x3e"), this.$DecorationBtnDiv.bind("touchstart", function (c) {
						"OverviewMap" === b.type ? b.collapsible && (b.minimized ? b.restore() : b.collapse()) : b.minimized ? b.restore() : b.collapse();
						a.event.EventSource.stopEvents[c.type] =
							!0
					})) : (this.btnW = this.btnH = a.gv.decorationCollapseButtonSizeNoTouch, this.$DecorationBtnDiv = a.$("\x3cdiv id\x3d'_DecorationBtnDiv' class\x3d'omv2_collapse_button'\x3e\x3cimg src\x3d'" + a.control.MapDecoration.getImage(this) + "' style\x3d'height:18px;width:18px'\x3e\x3c/div\x3e")), this.$DecorationBtnDiv.css({
					"z-index": "201",
					position: "relative"
				}), this.visible || this.$DecorationBtnDiv.css("display", "none"), this.$DecorationBtnDiv.mouseover(function (c) {
					c.target.src = !0 === b.minimized ? b.getMinimizeIcon() : b.getRestoreIcon();
					a.event.EventSource.stopEvents[c.type] = !0
				}).mouseout(function (c) {
					c.target.src = a.control.MapDecoration.getImage(b);
					a.event.EventSource.stopEvents[c.type] = !0
				}).click(function (c) {
					b.collapsible && (b.minimized ? b.restore() : b.collapse());
					a.event.EventSource.stopEvents[c.type] = !0
				}), this.$DecorationBtnDiv.bind("dblclick mousemove mousedown", function (b) {
					a.event.EventSource.stopEvents[b.type] = !0
				}), "OverviewMap" === this.type ? this.$DecorationDiv.append(this.$DecorationBtnDiv[0], this.overviewMapDIV[0]) : "CustomHtmlDecoration" ===
				this.type || "LayerControl" === this.type ? (this.$DecorationBtnDiv.css({
						position: "absolute"
					}), this.$DecorationDiv.css({
						"flex-direction": "column"
					}), this.$DecorationDiv.append(this.$DecorationBtnDiv)) : this.container.append(this.$DecorationBtnDiv));
			"Magnifier" === this.type && (this.width && this.$Content.width(this.width), this.height && this.$Content.height(this.height), this.width || (this.width = this.$DecorationDiv.width()), this.height || (this.height = this.$DecorationDiv.height()));
			b = this;
			this.moveY = this.moveX = 0;
			this.flag =
				!1;
			"LayerControl" === this.type && (this.$title.mousedown(function (a) {
					b.mousedown(a)
				}).mouseup(function (c) {
					b.mouseup(c);
					a.event.EventSource.stopEvents[c.type] = !0
				}).dblclick(function (b) {
					a.event.EventSource.stopEvents[b.type] = !0
				}).mouseover(function (c) {
					b.map.$oracleMapDiv.css("cursor", "pointer");
					a.event.EventSource.stopEvents[c.type] = !0
				}).mouseout(function (c) {
					b.map.$oracleMapDiv.css("cursor", "default");
					a.event.EventSource.stopEvents[c.type] = !0
				}), this.$title.bind("touchstart", function (a) {
					a.preventDefault();
					b.touchstart(a)
				}), this.$title.bind("touchend", function (a) {
					a.stopPropagation();
					a.preventDefault();
					b.touchend(a)
				}), this.$Content.bind("touchmove touchstart touchend", function (a) {
					a.stopPropagation();
					a.preventDefault()
				}), this.$DecorationDiv.bind("mousedown mouseup mouseover mouseout mousewheel click dblclick", function (c) {
					b.fire(c.type, c);
					a.event.EventSource.stopEvents[c.type] = !0
				}));
			if (a.isNull(this.type) || "Magnifier" === this.type || "ToolBar" === this.type || "CustomHtmlDecoration" === this.type)
				this.$tb_title &&
				this.$tb_title.mouseover(function () {
					b.dragging || (a.$(this).removeClass("titleStyleEna_layerctrl"), a.$(this).removeClass("titleStyleDwn_layerctrl"), a.$(this).addClass("titleStyleOvr_layerctrl"), a.$(this).css("cursor", "move"))
				}).mouseout(function () {
					b.dragging || (a.$(this).removeClass("titleStyleOvr_layerctrl"), a.$(this).removeClass("titleStyleDwn_layerctrl"), a.$(this).addClass("titleStyleEna_layerctrl"), a.$(this).css("cursor", "default"))
				}).mousedown(function () {
					a.$(this).removeClass("titleStyleOvr_layerctrl");
					a.$(this).removeClass("titleStyleEna_layerctrl");
					a.$(this).addClass("titleStyleDwn_layerctrl")
				}).mouseup(function () {
					a.$(this).removeClass("titleStyleDwn_layerctrl");
					a.$(this).removeClass("titleStyleEna_layerctrl");
					a.$(this).addClass("titleStyleOvr_layerctrl")
				}), this.$DecorationDiv.bind("touchend", function (b) {
					var c = this.lastTouchTimeStamp,
					w = b.timeStamp;
					this.lastTouchTimeStamp = w;
					500 > w - c && (a.event.EventSource.stopEvents[b.type] = !0)
				}), this.$DecorationDiv.bind("touchstart", function (a) {
					b.touchstart(a)
				}),
				this.$DecorationDiv.mousedown(function (c) {
					a.browser.chrome && (c.offsetY > a.$(this).height() - 21 && c.offsetY < a.$(this).height() || c.offsetX > a.$(this).width() - 21) || a.browser.msie && (c.offsetY > a.$(this).height() - 17 && c.offsetY < a.$(this).height() || c.offsetX > a.$(this).width() - 17) || (a.$(this).css("cursor", "default"), b.draggable && a.$(this).css("cursor", "move"), b.mousedown(c))
				}).mouseup(function (c) {
					a.$(this).css("cursor", "default");
					b.map.moveflag = !1;
					b.mouseup(c);
					a.event.EventSource.stopEvents[c.type] = !0
				}).scroll(function (c) {
					b.mouseup(c);
					a.event.EventSource.stopEvents[c.type] = !0
				}), this.$DecorationDiv.bind("dblclick mouseover mouseout mousewheel click keyup keydown keypress", function (b) {
					a.event.EventSource.stopEvents[b.type] = !0
				});
			"OverviewMap" !== this.type && (b.mapDeco_mouseupHandler = function (a) {
				b.mouseup(a)
			}, a.$(document).on("mouseup", b.mapDeco_mouseupHandler), this.mapDiv_msmove = function (c) {
				a.browser.msie && 1 !== h.event.button && b.mouseup(c);
				b.mousemove(c)
			}, this.mapDiv_touchmove = function (a) {
				a.stopPropagation();
				a.preventDefault();
				b.touchmove(a)
			},
				this.mapDiv_touchend = function (a) {
				a.preventDefault();
				b.touchend(a)
			}, this.map.$oracleMapDiv.mousemove(this.mapDiv_msmove), this.map.$oracleMapDiv.bind("touchmove", this.mapDiv_touchmove), this.map.$oracleMapDiv.bind("touchend", this.mapDiv_touchend));
			a.isNull(this.type) && this.map._decoration[this.type] && this.map._decoration[this.type].$DecorationDiv.append(this.$DecorationDiv)
		},
		resize: function () {
			this.mapWidth = this.map.getMapContext().getDeviceWidth();
			this.mapHeight = this.map.getMapContext().getDeviceHeight()
		},
		mousedown: function (b) {
			!a.isNull(this.map) && this.draggable && (this.dragDiv = !0, this.map.enableMapAction.drag && (this.dragging = !0, this.map.enableMapDrag(!1), this.startX = parseInt(b.clientX), this.startY = parseInt(b.clientY), this.positionX = parseInt(this.$DecorationDiv.css("left")), this.positionY = parseInt(this.$DecorationDiv.css("top")), this.dragStartFlag = !0, a.event.EventSource.stopEvents[b.type] = !0))
		},
		mousemove: function (b) {
			this.parentMapHeight = this.map.getMapContext().getDeviceHeight();
			this.parentMapWidth =
				this.map.getMapContext().getDeviceWidth();
			this.height = this.$DecorationDiv.height();
			"LayerControl" === this.type && (this.height = this.$Dom.height());
			if (this.dragging) {
				if (!0 === this.dragStartFlag) {
					var c = new a.event.MapDecorationEvent(a.event.MapDecorationEvent.DRAG_START, this);
					this.fire(a.event.MapDecorationEvent.DRAG_START, c);
					this.dragStartFlag = !1
				}
				this.moveX = this.positionX + b.clientX - this.startX;
				this.moveY = this.positionY + b.clientY - this.startY;
				this.$DecorationDiv.css("left", this.moveX);
				this.$DecorationDiv.css("top",
					this.moveY);
				this.top = this.moveY;
				c = new a.event.MapDecorationEvent(a.event.MapDecorationEvent.DRAG, this);
				this.fire(a.event.MapDecorationEvent.DRAG, c);
				a.event.EventSource.stopEvents[b.type] = !0
			}
		},
		mouseup: function (b) {
			a.isNull(this.map) || (this.v_isDrag = this.dragDiv = this.flag = !1, !0 === this.dragging && this.startX !== parseInt(b.clientX) && this.startY !== parseInt(b.clientY) && (b = new a.event.MapDecorationEvent(a.event.MapDecorationEvent.DRAG_END, this), this.fire(a.event.MapDecorationEvent.DRAG_END, b)), this.dragging &&
				(this.dragging = this.dragStartFlag = !1, this.map.enableMapDrag(!0)))
		},
		touchstart: function (b) {
			if (!a.isNull(this.map) && this.draggable && (this.dragDiv = !0, this.map.enableMapAction.drag)) {
				this.dragging = !0;
				this.map.enableMapDrag(!1);
				var c = a.util.DomUtil;
				this.touchCount = c.getTouchCount(b);
				if (!(2 < this.touchCount)) {
					var U = [];
					1 === this.touchCount && (b = c.getTouchesPosition(b), U.push(b), this.touchStartX = parseInt(U[0].x), this.touchStartY = parseInt(U[0].y), this.touchPositionX = parseInt(this.$DecorationDiv.css("left")),
						this.touchPositionY = parseInt(this.$DecorationDiv.css("top")), this.dragStartFlag = !0)
				}
			}
		},
		touchmove: function (b) {
			var c = a.util.DomUtil,
			U = [];
			1 === this.touchCount && (c = c.getTouchesPosition(b), U.push(c));
			this.dragging && (!0 === this.dragStartFlag && (c = new a.event.MapDecorationEvent(a.event.MapDecorationEvent.DRAG_START, this), this.fire(a.event.MapDecorationEvent.DRAG_START, c), this.dragStartFlag = !1), this.touchMoveX = this.touchPositionX + U[0].x - this.touchStartX, this.touchMoveY = this.touchPositionY + U[0].y - this.touchStartY,
				this.moveX = this.touchMoveX, this.moveY = this.touchMoveY, this.$DecorationDiv.css("left", this.touchMoveX), this.$DecorationDiv.css("top", this.touchMoveY), U = new a.event.MapDecorationEvent(a.event.MapDecorationEvent.DRAG, this), this.fire(a.event.MapDecorationEvent.DRAG, U), 0 > parseInt(this.$DecorationDiv.css("left")) && (this.$DecorationDiv.css("left", "0px"), this.touchend(b)), 0 > parseInt(this.$DecorationDiv.css("top")) && (this.$DecorationDiv.css("top", "0px"), this.touchend(b)), this.parentMapWidth - parseInt(this.$DecorationDiv.css("left")) <
				this.width && (this.$DecorationDiv.css("left", this.parentMapWidth - this.width), this.touchend(b)), this.parentMapHeight - parseInt(this.$DecorationDiv.css("top")) < this.height && (this.$DecorationDiv.css("top", this.parentMapHeight - this.height), this.touchend(b)))
		},
		touchend: function (b) {
			if (!a.isNull(this.map)) {
				this.dragDiv = this.flag = !1;
				var c = a.util.DomUtil,
				U = [];
				1 == this.touchCount && (b = c.getTouchesPosition(b), U.push(b));
				!0 === this.dragging && this.touchStartX !== parseInt(U[0].x) && this.touchStartY !== parseInt(U[0].y) &&
				(U = new a.event.MapDecorationEvent(a.event.MapDecorationEvent.DRAG_END, this), this.fire(a.event.MapDecorationEvent.DRAG_END, U));
				this.dragging && (this.dragging = this.dragStartFlag = !1, this.map.enableMapDrag(!0));
				this.map.touchStartLocs = []
			}
		},
		touchscroll: function (b) {
			var c,
			U;
			a.browser.touchSupported && (document.getElementById(b).addEventListener("touchstart", function (a) {
					c = a.targetTouches[0].pageX;
					U = a.targetTouches[0].pageY;
					a.stopPropagation()
				}, !1), document.getElementById(b).addEventListener("touchmove", function (a) {
					a.preventDefault();
					a.stopPropagation();
					var b = U - a.targetTouches[0].pageY;
					this.scrollLeft += c - a.targetTouches[0].pageX;
					this.scrollTop += b
				}, !1))
		},
		delegate: function (b, c, U) {
			var w,
			ja = c instanceof Object ? !0 : !1;
			if (this.isHtml)
				if (w = this.$DecorationDiv, ja && a.notNull(U)) {
					var la = c.attr("id") || "selector_" + Math.random().toString().replace(/\./, 0);
					c.attr("id", la);
					a.$(w).on(b, "#" + la, U)
				} else
					a.$(w).on(b, c, U);
			else {
				w = this.defaultGroup;
				if (c && "function" === typeof c)
					return this.delegate(b, w, c);
				la = this.delegateListeners = this.delegateListeners ||
					[];
				la[b] = la[b] || [];
				var na = U.id = U.id || "fn_" + Math.random().toString().replace(/\./, 0),
				sa;
				sa = function (a) {
					for (var b = a.target.getAncestors(), w = b.length - 1; 0 < w && (ja ? b[w] === c && (a.delegateTarget = b[w], U.call(null, a)) : b[w].queryType && -1 != b[w].queryType.indexOf("#" + c) && (a.delegateTarget = b[w], U.call(null, a)), b[w] !== a.currentTarget); w--);
				};
				sa.id = na;
				w.addEventListener(b, sa);
				la[b].push(sa)
			}
			return this
		},
		unDelegate: function (b, c, U) {
			var w;
			b = b || "mouseover mouseout mousemove mousedown mouseup click dblclick";
			var ja = c instanceof
				Object ? !0 : !1;
			if (this.isHtml)
				if (w = this.$DecorationDiv, ja) {
					var la = c.attr("id");
					a.$(w).off(b, "#" + la, U)
				} else
					a.$(w).off(b, c, U);
			else if (this.defaultGroup)
				for (w = this.defaultGroup, c = this.delegateListeners, b = b.split(" "), ja = 0; ja < b.length; ja++) {
					var na = b[ja];
					if (w.listeners && w.listeners[na])
						if (U) {
							for (var sa = 0; sa < c[na].length; sa++)
								if (c[na][sa].id === U.id) {
									la = c[na][sa];
									c[na].splice(sa, 1);
									break
								}
							w.removeEventListener(na, la)
						} else
							w.listeners[na] = [], this.delegateListeners[na] = []
				}
			return this
		},
		getRestoreIcon: function () {
			switch (this.anchorPosition ||
				1) {
			case 1:
				return a.control.MapDecoration.BUTTON_RESTORE_TOP_LEFT;
			case 2:
				return a.control.MapDecoration.BUTTON_RESTORE_TOP_LEFT;
			case 3:
				return a.control.MapDecoration.BUTTON_RESTORE_TOP_RIGHT;
			case 4:
				return a.control.MapDecoration.BUTTON_RESTORE_LOWER_LEFT;
			case 5:
				return a.control.MapDecoration.BUTTON_RESTORE_LOWER_LEFT;
			case 6:
				return a.control.MapDecoration.BUTTON_RESTORE_LOWER_RIGHT
			}
		},
		getMinimizeIcon: function () {
			switch (this.anchorPosition || 1) {
			case 1:
				return a.control.MapDecoration.BUTTON_MINIMIZE_TOP_LEFT;
			case 2:
				return a.control.MapDecoration.BUTTON_MINIMIZE_TOP_LEFT;
			case 3:
				return a.control.MapDecoration.BUTTON_MINIMIZE_TOP_RIGHT;
			case 4:
				return a.control.MapDecoration.BUTTON_MINIMIZE_LOWER_LEFT;
			case 5:
				return a.control.MapDecoration.BUTTON_MINIMIZE_LOWER_LEFT;
			case 6:
				return a.control.MapDecoration.BUTTON_MINIMIZE_LOWER_RIGHT
			}
		},
		collapse: function () {
			if (!this.inAnimation && !this.minimized && this.collapsible) {
				var b = new a.event.MapDecorationEvent(a.event.MapDecorationEvent.BEFORE_COLLAPSE, this);
				this.fire(b.type,
					b);
				this.collapsibleContainer.detach();
				this.inAnimation = !1;
				this.minimized = !0;
				this.$DecorationBtnDiv.children("img").attr("src", this.getMinimizeIcon())
			}
		},
		restore: function () {
			this.collapsible && (this.minimized = this.inAnimation = !1, this.$DecorationDiv.append(this.collapsibleContainer, this.$DecorationBtnDiv), this.$DecorationBtnDiv.children("img").attr("src", this.getRestoreIcon()))
		},
		isVisible: function () {
			return this.visible
		}
	});
	a.control.MapDecoration.POSITION_UPPER_LEFT = 1;
	a.control.MapDecoration.POSITION_UPPER_CENTER =
		2;
	a.control.MapDecoration.POSITION_UPPER_RIGHT = 3;
	a.control.MapDecoration.POSITION_LOWER_LEFT = 4;
	a.control.MapDecoration.POSITION_LOWER_CENTER = 5;
	a.control.MapDecoration.POSITION_LOWER_RIGHT = 6;
	a.control.MapDecoration.setIconsPath = function () {
		var b = a.gv.resourcePath(),
		c = a.control.MapDecoration;
		c.OVER_VIEW_ICON = b + "overviewicon.gif";
		c.BUTTON_MINIMIZE_LOWER_LEFT = b + "button_minimize_l.gif";
		c.BUTTON_RESTORE_LOWER_LEFT = b + "button_restore_l.gif";
		c.BUTTON_MINIMIZE_LOWER_RIGHT = b + "button_minimize.gif";
		c.BUTTON_RESTORE_LOWER_RIGHT =
			b + "button_restore.gif";
		c.BUTTON_MINIMIZE_TOP_LEFT = b + "button_restore.gif";
		c.BUTTON_RESTORE_TOP_LEFT = b + "button_minimize.gif";
		c.BUTTON_MINIMIZE_TOP_RIGHT = b + "button_restore_l.gif";
		c.BUTTON_RESTORE_TOP_RIGHT = b + "button_minimize_l.gif";
		c.MAGNIFIER = b + "func_search_16_ena.png";
		c.TH_BG_S = b + "th_bg_s.png"
	};
	a.control.MapDecoration.setIconsPath();
	a.control.MapDecoration.setCustomIcons = function (b) {
		b && (b.overview && (a.control.MapDecoration.OVER_VIEW_ICON = b.overview), b.minimize && (a.control.MapDecoration.BUTTON_MINIMIZE =
					b.minimize), b.restore && (a.control.MapDecoration.BUTTON_RESTORE = b.restore), b.magnifier && (a.control.MapDecoration.MAGNIFIER = b.magnifier))
	};
	a.control.MapDecoration.getImage = function (b) {
		return "Magnifier" == b.type ? a.control.MapDecoration.MAGNIFIER : a.control.MapDecoration.OVER_VIEW_ICON
	};
	a.control.NavigationPanelBar = a.control.MapDecoration.extend({
		initialize: function S(b) {
			S.base.call(this, "MapDeco_NavigationPanelBar", a.$.extend({}, b));
			b = b ? b : {};
			this.isInternal = !0;
			this.type = "NavigationPanelBar";
			a.isNull(this.anchorPosition) &&
			(this.anchorPosition = a.control.MapDecoration.POSITION_UPPER_LEFT);
			this.style = a.control.NavigationPanelBar.STYLE_ZOOM_BUTTONS_ONLY;
			a.notNull(b.style) && (this.style = parseInt(b.style), 1 > this.style || 5 < this.style) && (a.util.Logger.warning("", "OM.control.NavigationPanelBar.initialize", "style value is out of range, default value is used."), this.style = a.control.NavigationPanelBar.STYLE_ZOOM_BUTTONS_ONLY);
			a.notNull(b.infoTips) && (this.infoTips = b.infoTips);
			a.isNull(b.offsetX) ? this.left = this.getOffset().offsetX :
				this.left = b.offsetX;
			a.isNull(b.offsetY) ? this.top = this.getOffset().offsetY : this.top = b.offsetY;
			this.tipTimer = new a.util.TimerManager;
			this.centerCss = {
				"margin-left": "auto",
				"margin-right": "auto",
				display: "inline-block"
			};
			this.borderAndBackgroundCss = {
				"border-style": "solid",
				"border-width": "1px",
				"border-color": "#dddddd",
				"border-radius": "2px",
				"background-color": "#fefefe",
				opacity: "0.75"
			};
			this.zoomInFont = "\ue65c";
			this.zoomOutFont = "\ue65d";
			this.defaultColor = "#878c90";
			this.hoverColor = "#85bbe7";
			this.disabledColor =
				"#c3c3c3"
		},
		getButtons: function (b) {
			a.isNull(this.buttons) && (this.buttons = [{
						name: "up",
						icon_class: "navigation_panel_bar_up",
						icon_class_hov: "navigation_panel_bar_up_hov",
						css: {
							top: "0px",
							left: "20px"
						}
					}, {
						name: "right",
						icon_class: "navigation_panel_bar_right",
						icon_class_hov: "navigation_panel_bar_right_hov",
						css: {
							right: "0px",
							top: "20px"
						}
					}, {
						name: "down",
						icon_class: "navigation_panel_bar_down",
						icon_class_hov: "navigation_panel_bar_down_hov",
						css: {
							bottom: "0px",
							left: "20px"
						}
					}, {
						name: "left",
						icon_class: "navigation_panel_bar_left",
						icon_class_hov: "navigation_panel_bar_left_hov",
						css: {
							left: "0px",
							top: "20px"
						}
					}
				]);
			return a.isNull(b) ? this.buttons : this.buttons[b]
		},
		display: function U(b, c) {
			U.base.call(this, b, c);
			var la = this,
			na = this.map;
			if (na.displayed || na.getMapContext().getZoomLevel())
				la.$DecorationDiv.css({
					"text-align": "center"
				}), la.hasPanel() && la.$DecorationDiv.append(la.createPanHtml()), (la.hasZoombar() || la.hasZoombtn()) && la.$DecorationDiv.append(la.createZoomHtml()), na.navigationPanelBar = la, 0 !== la.$DecorationDiv.width() && (la.width =
						la.$DecorationDiv.width(), la.height = la.$DecorationDiv.height()), (!1 === this.anchored || 1 > this.anchorPosition || 6 < this.anchorPosition) && this.setPosition(), la.hasZoombar() && (la.recenter = function () {
					la.updateBarByLevel()
				}, na.on(a.event.MapEvent.I_MAP_CENTER_ZOOM, this.recenter, this), la.recenter()), la.hasZoombtn() && (la.updateIamge = function () {
					var b = la.map.getMapContext(),
					c = b.getUniverse().getZoomLevelNumber(),
					b = b.getZoomLevel();
					0 === b ? (a.util.DomUtil.setFontIcon(a.$(la.zoomOut).find("div"), la.zoomOutFont, la.disabledColor),
						a.$(this.zoomOut).css("cursor", "")) : (a.util.DomUtil.setFontIcon(a.$(la.zoomOut).find("div"), la.zoomOutFont, la.defaultColor), a.$(this.zoomOut).css("cursor", "pointer"));
					b === c - 1 ? (a.util.DomUtil.setFontIcon(a.$(la.zoomIn).find("div"), la.zoomInFont, la.disabledColor), a.$(this.zoomIn).css("cursor", "")) : (a.util.DomUtil.setFontIcon(a.$(la.zoomIn).find("div"), la.zoomInFont, la.defaultColor), a.$(this.zoomIn).css("cursor", "pointer"))
				}, na.on(a.event.MapEvent.I_MAP_CENTER_ZOOM, la.updateIamge, this), na.on(a.event.MapEvent.MAP_RESIZED,
						function () {
						this.anchorPosition && this.setAnchorPosition(this.anchorPosition)
					}
						.bind(this)), la.updateIamge())
		},
		setPosition: function (b, c) {
			a.notNull(b) && a.notNull(c) && (this.anchored = !1);
			a.isNull(this.$DecorationDiv) && (this.$DecorationDiv = a.$("\x3cdiv onselectstart\x3d'return false'\x3e\x3c/div\x3e"), this.$DecorationDiv.attr("id", this.id));
			1 <= b && (b = parseInt(b));
			1 <= c && (c = parseInt(c));
			this.X = b || this.X;
			this.Y = c || this.Y;
			this.map && this.parentMapWidth && (1 > this.X && 0 < this.X && (this.X *= this.parentMapWidth, this.relativePosition =
						!0), 1 > this.Y && 0 < this.Y && (this.Y *= this.parentMapHeight, this.relativePosition = !0));
			a.notNull(this.$DecorationDiv) && this.$DecorationDiv.css({
				top: this.Y,
				left: this.X,
				bottom: "",
				right: ""
			})
		},
		createPanHtml: function () {
			for (var b = {
					cursor: "pointer",
					position: "absolute",
					width: "16px",
					height: "16px"
				}, c = a.$.extend({}, this.borderAndBackgroundCss, {
					width: "56px",
					height: "56px",
					margin: 5,
					position: "relative",
					"border-radius": "28px",
					cursor: "pointer"
				}), c = a.$("\x3cdiv\x3e\x3c/div\x3e").css(c), ja = this.getButtons(), la = this.map.getMapContext(),
				na = .25 * (la.getDeviceHeight() + la.getDeviceWidth()), sa = this.map, wa = 0; wa < ja.length; wa++) {
				var Aa = a.$("\x3cdiv\x3e\x3c/div\x3e");
				Aa.css(b).addClass(ja[wa].icon_class);
				(function () {
					var b = ja[wa],
					c = wa;
					Aa.hover(function () {
						a.$(this).addClass(b.icon_class_hov)
					}, function () {
						a.$(this).removeClass(b.icon_class_hov)
					});
					Aa.click(function () {
						0 === c ? sa.pan(0, na, !1) : 1 === c ? sa.pan(-na, 0, !1) : 2 === c ? sa.pan(0, -na, !1) : 3 === c && sa.pan(na, 0, !1)
					})
				})();
				c.append(Aa);
				c.on("dblclick", function (a) {
					a.stopPropagation()
				})
			}
			return c
		},
		createZoomHtml: function () {
			var b =
				this,
			c = this.map,
			ja = a.$.extend({}, b.borderAndBackgroundCss, {
				"border-radius": "2px 2px 2px 2px",
				cursor: "pointer"
			}),
			la = {
				width: "26px",
				height: "26px",
				"background-position": "center",
				margin: "0px",
				"text-align": "center",
				"line-height": "26px"
			},
			na = this.centerCss,
			na = a.$("\x3cdiv\x3e\x3c/div\x3e").css(na),
			sa = a.$("\x3cdiv\x3e\x3c/div\x3e").css(la),
			la = a.$("\x3cdiv\x3e\x3c/div\x3e").css(la);
			a.util.DomUtil.setFontIcon(la, b.zoomOutFont, b.defaultColor);
			a.util.DomUtil.setFontIcon(sa, b.zoomInFont, b.defaultColor);
			sa = a.$('\x3cdiv id\x3d"zoomin_' +
					this._randomId + '"\x3e\x3c/div\x3e').css(ja).append(sa);
			ja = a.$('\x3cdiv id\x3d"zoomout_' + this._randomId + '"\x3e\x3c/div\x3e').css(ja).append(la);
			sa.attr("aria-label", "zoom in button");
			ja.attr("aria-label", "zoom out button");
			sa.attr("tabindex", "0");
			ja.attr("tabindex", "0");
			b.zoomIn = sa;
			b.zoomOut = ja;
			b.style !== a.control.NavigationPanelBar.STYLE_ZOOM_BUTTONS_ONLY && b.style !== a.control.NavigationPanelBar.STYLE_PAN_AND_ZOOM_BUTTONS || sa.css({
				"margin-bottom": "5px"
			});
			sa.hover(function () {
				b.zoomdisabled(!0) || a.util.DomUtil.setFontIcon(a.$(this).find("div"),
					b.zoomInFont, b.hoverColor)
			}, function () {
				b.zoomdisabled(!0) || a.util.DomUtil.setFontIcon(a.$(this).find("div"), b.zoomInFont, b.defaultColor)
			});
			var wa = function (a) {
				b.zoomdisabled(!0) || (a.preventDefault(), c.zoomIn())
			},
			Aa = function (a) {
				b.zoomdisabled() || (a.preventDefault(), c.zoomOut())
			};
			sa.on("touchend click", wa);
			sa.on("keydown", function (a) {
				13 === a.keyCode && wa(a)
			});
			ja.on("touchend click", Aa);
			ja.on("keydown", function (a) {
				13 === a.keyCode && Aa(a)
			});
			ja.hover(function () {
				b.zoomdisabled() || a.util.DomUtil.setFontIcon(a.$(this).find("div"),
					b.zoomOutFont, b.hoverColor)
			}, function () {
				b.zoomdisabled() || a.util.DomUtil.setFontIcon(a.$(this).find("div"), b.zoomOutFont, b.defaultColor)
			});
			if (b.hasZoombar())
				na.on("mouseover", function () {
					b.tipTimer.schedule("tip", 2E3, function () {
						b.tipContainer.fadeOut()
					});
					b.tipContainer.show()
				});
			b.hasZoombtn() && na.append(sa);
			b.hasZoombar() && na.append(b.createBarHtml());
			b.hasZoombtn() && na.append(ja);
			return b.zoomContainer = na
		},
		zoomdisabled: function (a) {
			var b = this.map.getMapContext(),
			c = b.getZoomLevel(),
			b = b.getUniverse().getZoomLevelNumber();
			return !0 === a ? c === b - 1 : 0 === c
		},
		createBarHtml: function () {
			var b = this,
			c = a.$("\x3cdiv\x3e\x3c/div\x3e").css({
				position: "relative",
				top: 0,
				left: 0,
				bottom: 0,
				right: 0,
				height: "100px"
			}),
			ja = a.$('\x3cdiv class\x3d"navigation_panel_dragbar_zoomout_btn"\x3e\x3c/div\x3e'),
			la = a.$("\x3cdiv\x3e\x3c/div\x3e").css({
				width: 3,
				height: "98px",
				cursor: "pointer"
			}).css(this.centerCss).css(this.borderAndBackgroundCss),
			na = a.$("\x3cdiv\x3e\x3c/div\x3e").css({
				position: "absolute",
				cursor: "pointer",
				top: 0,
				left: 5,
				bottom: 0,
				width: "16px",
				height: "12px"
			}).css(this.centerCss).css(this.borderAndBackgroundCss);
			na.append(ja);
			na.hover(function () {
				a.$(this).find("div").addClass("navigation_panel_dragbar_zoomout_btn_hov")
			}, function () {
				a.$(this).find("div").removeClass("navigation_panel_dragbar_zoomout_btn_hov")
			});
			var sa,
			wa,
			Aa;
			na.on("mousedown", function (a) {
				sa = !0;
				wa = a.clientY;
				Aa = na.position().top
			});
			na.on("mouseup", function () {
				!0 === sa && b.updateBar();
				sa = !1
			});
			na.on("mousemove", function (a) {
				!0 === sa && b.updateBarPos(Aa + a.clientY - wa)
			});
			la.on("mousedown", function (a) {
				b.updateBarPos(a.offsetY);
				b.updateBar()
			});
			b.draggerBarContainer =
				na;
			c.append(la).append(na).append(b.createTips());
			return c
		},
		createTips: function () {
			var b = this,
			c = a.$("\x3cdiv\x3e\x3c/div\x3e").css({
				position: "absolute",
				top: 0,
				left: "5px",
				display: "none"
			}),
			ja = {
				position: "absolute",
				"border-radius": "1px",
				left: "20px",
				"z-index": 1,
				"text-align": "left",
				cursor: "pointer"
			},
			la;
			for (la in this.infoTips)
				if (!(0 > parseInt(la))) {
					var na = a.$("\x3cdiv\x3e\x3c/div\x3e").css(ja);
					na.attr("maplevel", la);
					na.on("click", function () {
						b.map.setMapZoomLevel(a.$(this).attr("maplevel"))
					});
					na.hover(function () {
						a.$(this).parent().find("\x3ediv").css({
							"z-index": 1,
							"font-weight": "normal"
						});
						a.$(this).css({
							"z-index": 2,
							"font-weight": "bold"
						});
						b.tipTimer.cancel("tip")
					}, function () {
						a.$(this).parent().find("\x3ediv").css({
							"z-index": 1,
							"font-weight": "normal"
						});
						b.tipTimer.schedule("tip", 2E3, function () {
							b.tipContainer.fadeOut()
						})
					});
					na.on("mouseover", function () {
						return !1
					});
					na.css({
						top: this.levelToTop(la) + "px"
					});
					var sa = a.$("\x3cdiv\x3e\x3c/div\x3e").css({
						"line-height": "15px",
						position: "absolute",
						left: "15px"
					}).css(b.borderAndBackgroundCss).css({
						"border-left": ""
					}).html(this.infoTips[la]),
					wa = a.$('\x3cdiv class\x3d"navigation_panel_arrow_btn"\x3e\x3c/div\x3e');
					na.append(wa).append(sa);
					c.append(na)
				}
			return b.tipContainer = c
		},
		updateBarPos: function (a) {
			var b = this.draggerBarContainer.height(),
			c = this.draggerBarContainer.parent().height() - 2;
			a = Math.max(0, Math.min(a, c - b));
			this.draggerBarContainer.css("top", a)
		},
		levelToTop: function (b) {
			var c = this.map.getMapContext(),
			ja = c.getUniverse().getZoomLevelNumber();
			a.isNull(b) && (b = c.getZoomLevel());
			b = Math.max(0, Math.min(b, ja - 1));
			c = this.draggerBarContainer.height();
			return (this.draggerBarContainer.parent().height() - 2 - c) * (ja - b - 1) / (ja - 1)
		},
		updateBar: function () {
			var a = this.map.getMapContext().getUniverse().getZoomLevelNumber(),
			b = this.draggerBarContainer.height(),
			c = this.draggerBarContainer.parent().height() - 2,
			la = this.draggerBarContainer.position().top;
			this.updateBarByLevel(a - 1 - parseInt(la / (c - b) * (a - 1)))
		},
		updateBarByLevel: function (b) {
			var c = !0,
			ja = this.map.getMapContext(),
			la = ja.getUniverse().getZoomLevelNumber();
			a.isNull(b) && (b = ja.getZoomLevel(), c = !1);
			b = Math.max(0, Math.min(b,
						la - 1));
			ja = this.draggerBarContainer.height();
			la = (this.draggerBarContainer.parent().height() - 2 - ja) * (la - b - 1) / (la - 1);
			this.draggerBarContainer.css("top", la);
			!0 === c && this.map.setMapZoomLevel(b)
		},
		setZoomLevelInfoTips: function (a) {
			this.infoTips = a
		},
		setStyle: function (b) {
			a.isNull(b) || (a.notNull(b.position) && this.setPosition(b.position.left, b.position.top), a.notNull(b.backgroundColor) && a.$.extend(this.borderAndBackgroundCss, {
					"background-color": b.backgroundColor
				}), a.notNull(b.borderColor) && a.$.extend(this.borderAndBackgroundCss, {
					"border-color": b.borderColor
				}))
		},
		remove: function w() {
			w.base.call(this);
			this.map.navigationPanelBar = null;
			this.map.deleteListener(a.event.MapEvent.I_MAP_CENTER_ZOOM, this.recenter, this)
		},
		hasPanel: function () {
			switch (this.style) {
			case a.control.NavigationPanelBar.STYLE_FULL:
				return !0;
			case a.control.NavigationPanelBar.STYLE_ZOOM_ONLY:
				return !1;
			case a.control.NavigationPanelBar.STYLE_ZOOM_BUTTONS_ONLY:
				return !1;
			case a.control.NavigationPanelBar.STYLE_PAN_ONLY:
				return !0;
			case a.control.NavigationPanelBar.STYLE_PAN_AND_ZOOM_BUTTONS:
				return !0
			}
		},
		hasZoombar: function () {
			switch (this.style) {
			case a.control.NavigationPanelBar.STYLE_FULL:
				return !0;
			case a.control.NavigationPanelBar.STYLE_ZOOM_ONLY:
				return !0;
			case a.control.NavigationPanelBar.STYLE_ZOOM_BUTTONS_ONLY:
				return !1;
			case a.control.NavigationPanelBar.STYLE_PAN_ONLY:
				return !1;
			case a.control.NavigationPanelBar.STYLE_PAN_AND_ZOOM_BUTTONS:
				return !1
			}
		},
		hasZoombtn: function () {
			switch (this.style) {
			case a.control.NavigationPanelBar.STYLE_FULL:
				return !0;
			case a.control.NavigationPanelBar.STYLE_ZOOM_ONLY:
				return !0;
			case a.control.NavigationPanelBar.STYLE_ZOOM_BUTTONS_ONLY:
				return !0;
			case a.control.NavigationPanelBar.STYLE_PAN_ONLY:
				return !1;
			case a.control.NavigationPanelBar.STYLE_PAN_AND_ZOOM_BUTTONS:
				return !0
			}
		},
		getOffset: function () {
			switch (this.style) {
			case a.control.NavigationPanelBar.STYLE_FULL:
				return {
					offsetX: 0,
					offsetY: 0
				};
			case a.control.NavigationPanelBar.STYLE_ZOOM_ONLY:
				return {
					offsetX: 10,
					offsetY: 10
				};
			case a.control.NavigationPanelBar.STYLE_ZOOM_BUTTONS_ONLY:
				return {
					offsetX: 0,
					offsetY: 0
				};
			case a.control.NavigationPanelBar.STYLE_PAN_ONLY:
				return {
					offsetX: 0,
					offsetY: 0
				};
			case a.control.NavigationPanelBar.STYLE_PAN_AND_ZOOM_BUTTONS:
				return {
					offsetX: 0,
					offsetY: 0
				}
			}
		}
	});
	a.control.NavigationPanelBar.STYLE_FULL = 1;
	a.control.NavigationPanelBar.STYLE_ZOOM_ONLY = 2;
	a.control.NavigationPanelBar.STYLE_ZOOM_BUTTONS_ONLY = 3;
	a.control.NavigationPanelBar.STYLE_PAN_ONLY = 4;
	a.control.NavigationPanelBar.STYLE_PAN_AND_ZOOM_BUTTONS = 5;
	a.control.NavigationPanelBar.ORIENTATION_VERTICAL = 1;
	a.control.NavigationPanelBar.ORIENTATION_HORIZONTAL = 2;
	a.control.CopyRight = a.control.MapDecoration.extend({
		initialize: function ja(b) {
			ja.base.call(this,
				"MapDeco_CopyRight", a.$.extend({}, {
					offsetX: 0,
					offsetY: 0
				}, b));
			this.isInternal = !0;
			this.anchorPosition = a.control.MapDecoration.POSITION_LOWER_RIGHT;
			this.anchored = !0;
			this.fontSize = 12;
			this.textValue = "";
			this.type = "CopyRight";
			b && (this.textValue = b.textValue ? b.textValue : "", this.anchorPosition = b.anchorPosition ? b.anchorPosition : a.control.MapDecoration.POSITION_LOWER_CENTER, this.fontSize = b.fontSize ? b.fontSize : 12, this.fontFamily = b.fontFamily ? b.fontFamily : "Tahoma", this.fill = b.fontColor ? b.fontColor : "black")
		},
		setStyle: function (a) {
			a &&
			(a.fontSize && (this.fontSize = a.fontSize), a.fontFamily && (this.fontFamily = a.fontFamily), a.fontColor && (this.fill = a.fontColor))
		},
		display: function la(a, b) {
			la.base.call(this, a, b);
			this.$DecorationDiv.empty();
			this.$DecorationDiv = this.createHtml();
			this.setAnchorPosition(this.anchorPosition)
		},
		createHtml: function () {
			return this.createDiv()
		},
		createDiv: function () {
			var b = a.$('\x3cdiv class\x3d"cpdiv"\x3e\x3c/div\x3e').css({
				"font-size": this.fontSize,
				"font-family": this.fontFamily,
				color: this.fill,
				"white-space": "nowrap",
				display: "inline-flex",
				"align-items": "baseline",
				position: "absolute",
				"z-index": 6
			});
			b.html(this.textValue);
			b.wrapInner('\x3cspan style\x3d"background-color: white; opacity:0.7; width:100%"\x3e\x3c/span\x3e');
			return b
		},
		remove: function na() {
			na.base.call(this);
			this.map.CopyRight = null
		}
	});
	a.control.DrawerPanel = a.Class.extend({
		initialize: function (b, c) {
			var wa = this,
			Aa = (new Date).getTime();
			this.title = b.title;
			this.ID = "omv2_drp_" + Aa;
			this.drawer = c;
			this.editPanel = null;
			this.panelTab = a.$("\x3cli\x3e\x3c/li\x3e");
			this.panelTab.id =
				this.ID;
			this.panelTab.addClass("omv2_drp_drawer_tabs");
			this.singleTabContainer = a.$("\x3cdiv\x3e\x3c/div\x3e");
			this.singleTabContainer.id = "omv2_drp_singleTabContainer_" + Aa;
			this.singleTabContainer.addClass("omv2_drp_single_tab_container");
			this.singleTabContainer.appendTo(this.panelTab);
			this.singleTabContainer_a = a.$("\x3ca\x3e\x3c/a\x3e");
			this.singleTabContainer_a.id = "omv2_drp_singleTabContainer_a_" + Aa;
			this.singleTabContainer_a.href = "#";
			this.singleTabContainer_a.role = "presentation";
			this.singleTabContainer_a.tabindex =
				-1;
			this.singleTabContainer_a.appendTo(this.singleTabContainer);
			this.tabHeader = a.$("\x3cdiv\x3e\x3c/div\x3e");
			this.tabHeader.id = "omv2_drp_tabHeader_" + Aa;
			this.tabHeader.addClass("omv2_drp_tab_header");
			this.tabHeader.appendTo(this.singleTabContainer_a);
			if (b.mode === a.control.DrawerPanel.TEXT_AND_ICON || b.mode === a.control.DrawerPanel.ICON_ONLY)
				this.tabHeader_icon = a.$("\x3cspan\x3e\x3c/span\x3e", {
					title: wa.title
				}), this.tabHeader_icon.id = "omv2_drp_tabHeader_icon_" + Aa, this.tabHeader_icon.role = "img", b.urlIcon &&
				null !== b.urlIcon ? (this.tabHeader_icon.css("width", "21px"), this.tabHeader_icon.css("height", "21px"), this.tabHeader_icon.css("display", "inline-block"), this.tabHeader_icon.css("vertical-align", "middle"), this.tabHeader_icon.css("background-image", "url(" + b.urlIcon + ")"), this.tabHeader_icon.css("background-repeat", "no-repeat"), this.tabHeader_icon.css("background-size", "contain")) : b.altaIcon && null !== b.altaIcon && this.tabHeader_icon.addClass("omv2_drp_tab_header_icon " + b.altaIcon), this.tabHeader_icon.appendTo(this.tabHeader);
			this.tabHeader_title = null;
			if (b.mode === a.control.DrawerPanel.TEXT_AND_ICON || b.mode === a.control.DrawerPanel.TEXT_ONLY)
				this.tabHeader_title = a.$("\x3cspan\x3e\x3c/span\x3e"), this.tabHeader_title.id = "omv2_drp_tabHeader_title" + Aa, this.tabHeader_title.addClass("omv2_drp_tab_header_title"), this.tabHeader_title.appendTo(this.tabHeader), this.tabHeader_title.text(b.title);
			this.tabHeader_closeIcon = a.$("\x3cspan\x3e\x3c/span\x3e");
			this.tabHeader_closeIcon.id = "omv2_drp_tabHeader_closeIcon" + Aa;
			this.tabHeader_closeIcon.addClass("omv2_drp_tab_header_close_icon");
			this.tabHeader_closeIcon.appendTo(this.tabHeader);
			this.panelContent = a.$("\x3cdiv\x3e\x3c/div\x3e");
			this.panelContent.id || (this.panelContent.id = "omv2_drp_panel_" + Aa);
			this.panelContent.addClass("omv2_drp_drawer_tabs_content");
			b.panelDiv && a.isNotNull(b.panelDiv) && b.panelDiv.appendTo(this.panelContent);
			this.tabHeader_closeIcon.click(function () {
				wa.panelTab.remove();
				wa.panelContent.remove();
				wa.drawer.updateScrollButtons();
				"edit_panel" === b.type && wa.drawer.removeEditPanel()
			})
		},
		getID: function () {
			return this.ID
		},
		getTitle: function () {
			return this.title
		},
		getPanelTab: function () {
			return this.panelTab
		},
		getPanelContent: function () {
			return this.panelContent
		},
		getSingleTabContainer: function () {
			return this.singleTabContainer
		},
		getTabHeaderTitle: function () {
			return this.tabHeader_title
		}
	});
	a.control.DrawerPanel.ICON_ONLY = 1;
	a.control.DrawerPanel.TEXT_ONLY = 2;
	a.control.DrawerPanel.TEXT_AND_ICON = 3;
	a.control.DrawerPanel.ALTA_ICON_HOME = "home";
	a.control.DrawerPanel.ALTA_ICON_TOOLS = "tools";
	a.control.Drawer = a.Class.extend({
		mixin: a.event.EventSource,
		initialize: function (b, c) {
			var wa = this;
			a.isNull(c) ? (c = {}, c.width = a.control.Drawer.MINIMUM_WIDTH, c.height = a.control.Drawer.MINIMUM_HEIGHT, c.position = a.control.Drawer.LEFT) : (c.width || (c.width = a.control.Drawer.MINIMUM_WIDTH), c.height || (c.height = a.control.Drawer.MINIMUM_HEIGHT), c.position || (c.position = a.control.Drawer.LEFT));
			this.parentID = b;
			this.minWidth = a.control.Drawer.MINIMUM_WIDTH;
			this.minHeight = a.control.Drawer.MINIMUM_HEIGHT;
			this.fixedTabWidth = a.control.Drawer.TAB_SIZE;
			this.tabBarPosition = c.position;
			var Aa = (new Date).getTime();
			this.parent = a.$("#" + b);
			this.drawerID = "omv2_drawer__" + Aa;
			this.visible = !1;
			this.width = Math.max(c.width, this.minWidth);
			this.height = Math.max(c.height, this.minHeight);
			this.position = c.position;
			this.direction = this.position === a.control.Drawer.LEFT ? "left" : "right";
			this.drawerContainer = a.$("\x3cdiv\x3e\x3c/div\x3e");
			this.drawerContainer.id = this.drawerID;
			this.drawerContainer.addClass("omv2_drawer_container");
			this.drawerContainer.css("width", this.width + "px");
			this.drawerContainer.css("height",
				this.height + "px");
			this.drawerContainer.css("display", "none");
			this.drawerContainer.draggable({
				containment: "parent",
				cursor: "move",
				handle: ".omv2_drawer_title_container"
			});
			this.drawerContainer.resizable({
				minWidth: this.minWidth,
				minHeight: this.minHeight,
				handles: "sw, se"
			});
			this.drawerIcon = a.$("\x3cdiv\x3e\x3c/div\x3e");
			this.drawerIcon.id = "omv2_drawer_icon_" + Aa;
			this.drawerIcon.addClass("omv2_drawer_circle");
			this.drawerContainer.appendTo(this.parent);
			this.drawerIcon.appendTo(this.parent);
			this.setPosition(this.position);
			this.drawerIcon.click(function () {
				wa.showDrawer()
			});
			this.titleContainer = a.$("\x3cdiv\x3e\x3c/div\x3e");
			this.titleContainer.id = "omv2_drawer_title_container_" + Aa;
			this.titleContainer.addClass("omv2_drawer_title_container");
			this.titleContainer.appendTo(this.drawerContainer);
			var Oa = a.$("\x3cdiv\x3e\x3c/div\x3e");
			Oa.addClass("omv2_drawer_title_div");
			Oa.appendTo(this.titleContainer);
			a.$("\x3cspan\x3e\x3c/span\x3e", {
				text: "Editing Tool Panel"
			}).appendTo(Oa);
			Oa = a.$("\x3cdiv\x3e\x3c/div\x3e");
			Oa.addClass("omv2_drawer_title_close_icon_div");
			Oa.appendTo(this.titleContainer);
			var Ha = a.$("\x3cspan\x3e\x3c/span\x3e");
			Ha.addClass("omv2_drawer_title_close_icon_span");
			Ha.bind("click", function () {
				wa.hideDrawer()
			});
			Ha.appendTo(Oa);
			this.tabAndContentContainer = a.$("\x3cdiv\x3e\x3c/div\x3e");
			this.tabAndContentContainer.id = "omv2_drawer_tabAndContentContainer_" + Aa;
			this.tabAndContentContainer.addClass("omv2_drawer_tab_and_content_container");
			this.tabAndContentContainer.appendTo(this.drawerContainer);
			Oa = a.$("\x3cdiv\x3e\x3c/div\x3e");
			Oa.addClass("omv2_drawer_tab_bar");
			Oa.appendTo(this.tabAndContentContainer);
			this.leftArrow_div = a.$("\x3cdiv\x3e\x3c/div\x3e");
			this.leftArrow_div.addClass("omv2_drawer_tabs_arrow_div");
			this.leftArrow_div.appendTo(Oa);
			this.leftArrow_icon = a.$("\x3cspan\x3e\x3c/span\x3e");
			this.leftArrow_icon.addClass("omv2_drawer_left_arrow_icon");
			this.leftArrow_icon.css("visibility", "hidden");
			this.leftArrow_icon.appendTo(this.leftArrow_div);
			this.leftArrow_icon.click(function () {
				wa.moveTabsToLeft()
			});
			this.tabContainer = a.$("\x3cdiv\x3e\x3c/div\x3e");
			this.tabContainer.id =
				"omv2_drawer_tabContainer_" + Aa;
			this.tabContainer.addClass("omv2_drawer_tabs_container");
			this.tabContainer.appendTo(Oa);
			this.rightArrow_div = a.$("\x3cdiv\x3e\x3c/div\x3e");
			this.rightArrow_div.addClass("omv2_drawer_tabs_arrow_div");
			this.rightArrow_div.appendTo(Oa);
			this.rightArrow_icon = a.$("\x3cspan\x3e\x3c/span\x3e");
			this.rightArrow_icon.addClass("omv2_drawer_right_arrow_icon");
			this.rightArrow_icon.css("visibility", "hidden");
			this.rightArrow_icon.appendTo(this.rightArrow_div);
			this.rightArrow_icon.click(function () {
				wa.moveTabsToRight()
			});
			this.tabTable = a.$("\x3cdiv\x3e\x3c/div\x3e");
			this.tabTable.id = "omv2_drawer_tabTable_" + Aa;
			this.tabTable.css("display", "table");
			this.tabTable.appendTo(this.tabContainer);
			Ha = a.$("\x3cdiv\x3e\x3c/div\x3e");
			Ha.id = "omv2_drawer_tabTableRow_" + Aa;
			Ha.css("display", "table-row");
			Ha.appendTo(this.tabTable);
			Oa = a.$("\x3cdiv\x3e\x3c/div\x3e");
			Oa.id = "omv2_drawer_tabTableRow_" + Aa;
			Oa.css("display", "table-cell");
			Oa.appendTo(Ha);
			Ha = a.$("\x3cdiv\x3e\x3c/div\x3e");
			Ha.id = "omv2_drawer_cellContainer_" + Aa;
			Ha.css("overflow",
				"hidden");
			Ha.css("display", "inline_block");
			Ha.css("position", "relative");
			Ha.css("vertical-align", "top");
			Ha.css("margin-bottom", "0px");
			Ha.appendTo(Oa);
			Oa = a.$("\x3cdiv\x3e\x3c/div\x3e");
			Oa.id = "omv2_drawer_cellContainerChild_" + Aa;
			Oa.css("display", "inline_block");
			Oa.css("position", "relative");
			Oa.appendTo(Ha);
			Ha = a.$("\x3cdiv\x3e\x3c/div\x3e");
			Ha.id = "omv2_drawer_tabInnerTable_" + Aa;
			Ha.css("display", "table");
			Ha.appendTo(Oa);
			Oa = a.$("\x3cdiv\x3e\x3c/div\x3e");
			Oa.id = "omv2_drawer_tabInnerRow_" + Aa;
			Oa.css("display",
				"table-row");
			Oa.appendTo(Ha);
			Ha = a.$("\x3cdiv\x3e\x3c/div\x3e");
			Ha.id = "omv2_drawer_tabInnerCell_" + Aa;
			Ha.css("display", "table-cell");
			Ha.appendTo(Oa);
			this.tabListContainer = a.$("\x3cdiv\x3e\x3c/div\x3e");
			this.tabListContainer.id = "omv2_drawer_tabListContainer_" + Aa;
			this.tabListContainer.addClass("omv2_drawer_tabs_list_container");
			this.tabListContainer.appendTo(Ha);
			this.tabList = a.$("\x3cul\x3e\x3c/ul\x3e");
			this.tabList.id = "omv2_drawer_tabList_" + Aa;
			this.tabList.addClass("omv2_drawer_tabs-list");
			this.tabList.appendTo(this.tabListContainer)
		},
		moveTabsToRight: function () {
			var a = 0,
			a = this.fixedTabWidth,
			b = this.tabContainer.width(),
			c = this.tabListContainer.width() - this.tabBarPosition;
			c <= b || (a = Math.min(a, c - b), this.tabListContainer.animate({
					marginLeft: "-\x3d" + a
				}), this.tabBarPosition += a, this.updateScrollButtons())
		},
		moveTabsToLeft: function () {
			var a = 0,
			a = this.fixedTabWidth,
			b = this.tabBarPosition;
			0 >= b || (a = Math.min(a, b), this.tabListContainer.animate({
					marginLeft: "+\x3d" + a
				}), this.tabBarPosition -= a, this.updateScrollButtons())
		},
		updateScrollButtons: function () {
			var a =
				this.tabContainer.width(),
			b = this.tabListContainer.width() - this.tabBarPosition;
			0 === this.tabList.children().length ? (this.leftArrow_icon.css("visibility", "hidden"), this.rightArrow_icon.css("visibility", "hidden")) : (this.leftArrow_icon.css("visibility", "visible"), this.rightArrow_icon.css("visibility", "visible"));
			b <= a ? this.rightArrow_icon.removeClass("enabled") : this.rightArrow_icon.addClass("enabled");
			0 >= this.tabBarPosition ? this.leftArrow_icon.removeClass("enabled") : this.leftArrow_icon.addClass("enabled")
		},
		setPosition: function (b) {
			var c = (this.parent.height() - this.drawerContainer.height()) / 2,
			wa = this.parent.width() - this.drawerContainer.width() - 5;
			switch (b) {
			case a.control.Drawer.LEFT:
				this.drawerContainer.removeClass();
				this.drawerContainer.addClass("omv2_drawer_container");
				this.drawerContainer.css("left", "5px");
				this.drawerContainer.css("top", c + "px");
				this.drawerIcon.removeClass();
				this.drawerIcon.addClass("omv2_drawer_circle left");
				this.position = a.control.Drawer.LEFT;
				this.direction = "left";
				break;
			case a.control.Drawer.RIGHT:
				this.drawerIcon.removeClass(),
				this.drawerIcon.addClass("omv2_drawer_circle right"),
				this.drawerContainer.removeClass(),
				this.drawerContainer.addClass("omv2_drawer_container"),
				this.drawerContainer.css("top", c + "px"),
				this.drawerContainer.css("left", wa + "px"),
				this.position = a.control.Drawer.RIGHT,
				this.direction = "right"
			}
		},
		isVisible: function () {
			return this.visible
		},
		showDrawer: function () {
			this.isVisible() || (this.drawerIcon.hide(), this.visible = !this.visible, this.setPosition(this.position), this.drawerContainer.toggle("slide", {
					direction: this.direction
				},
					function () {}))
		},
		hideDrawer: function () {
			this.isVisible() && (this.visible = !1, this.drawerContainer.hide(), this.drawerIcon.show())
		},
		addTab: function (b) {
			if (b.title) {
				b.type || (b.type = "regular_tab");
				b = new a.control.DrawerPanel(b, this);
				this.attachTab(b);
				var c = b.getPanelTab().width(),
				wa = b.getTabHeaderTitle().width(),
				c = c - this.fixedTabWidth;
				b.getTabHeaderTitle().css("width", wa - c);
				this.updateScrollButtons()
			}
		},
		attachTab: function (b) {
			var c = b.getPanelTab(),
			wa = b.getPanelContent(),
			Aa = b.getSingleTabContainer(),
			Oa = b.getTabHeaderTitle();
			c.appendTo(this.tabList);
			wa.appendTo(this.tabAndContentContainer);
			c.click(function () {
				a.$(".omv2_drp_drawer_tabs").removeClass("selected");
				a.$(".omv2_drp_single_tab_container").removeClass("selected");
				a.$(".omv2_drp_drawer_tabs_content").removeClass("selected");
				a.$(".omv2_drp_tab_header_title").removeClass("selected");
				c.addClass("selected");
				Aa.addClass("selected");
				wa.addClass("selected");
				null !== Oa && Oa.addClass("selected")
			})
		},
		addEditPanel: function (b) {
			a.isNotNull(this.editPanel) || (this.editPanel = new a.control.EditPanel({
					width: this.width,
					target_layer: b
				}), this.editPanel.addSelectTool(), this.editPanel.addNewPolygonTool(), this.editPanel.addVoidPolygonTool(), this.editPanel.addNewLineTool(), this.editPanel.addNewPointTool(), b = {
					title: "Edition Tools",
					altaIcon: a.control.DrawerPanel.ALTA_ICON_TOOLS,
					panelDiv: this.editPanel.getEditPanelDiv(),
					mode: a.control.DrawerPanel.TEXT_AND_ICON,
					type: "edit_panel"
				}, this.addTab(b))
		},
		removeEditPanel: function () {
			a.isNotNull(this.editPanel) && (this.editPanel = null)
		},
		getEditPanel: function () {
			return this.editPanel
		}
	});
	a.control.Drawer.MINIMUM_WIDTH = 200;
	a.control.Drawer.MINIMUM_HEIGHT = 300;
	a.control.Drawer.TAB_SIZE = 120;
	a.control.Drawer.PANEL_SHOWN = "panelShown";
	a.control.Drawer.PANEL_TOGGLE = "panelToggle";
	a.control.Drawer.PANEL_HIDEN = "panelHide";
	a.control.Drawer.LEFT = 1;
	a.control.Drawer.RIGHT = 2;
	a.control.EditPanel = a.Class.extend({
		mixin: a.event.EventSource,
		initialize: function (b) {
			this.rndID = (new Date).getTime();
			this.prefixID = "omv2_editpanel_";
			!b || a.isNull(b) ? (b = {}, b.width = a.control.EditPanel.MINIMUM_WIDTH) : b.width || (b.width =
					a.control.EditPanel.MINIMUM_WIDTH);
			this.tool = null;
			this.snapLayer = new a.layer.VectorLayer("snap_layer", {
				def: {
					type: a.layer.VectorLayer.TYPE_LOCAL
				}
			});
			this.snaplineStyle = new a.style.Marker({
				width: 12,
				height: 12,
				vectorDef: [{
						shape: {
							type: "rectangle",
							x: 0,
							y: 0,
							width: 10,
							height: 10
						},
						style: {
							fill: "#ffffff",
							stroke: "#ff0000",
							strokeThickness: 1
						}
					}
				]
			});
			this.snapLayer.setRenderingStyle(this.snaplineStyle);
			this.snapFeature = null;
			this.newFeatCounter = 0;
			this.toolMap = {};
			this.width = Math.max(b.width, a.control.EditPanel.MINIMUM_WIDTH);
			this.targetLayer = b.target_layer ? b.target_layer : null;
			this.isEnabled = !1;
			this.targetLayer.isFeatureEditable() && (this.isEnabled = !0);
			this.targetLayer.parentMap.addLayer(this.snapLayer);
			this.editPanel_div = a.$("\x3cdiv\x3e\x3c/div\x3e");
			this.editPanel_div.id = this.prefixID + "main_div" + this.rndID;
			this.editPanel_div.addClass("omv2_edit_panel_container")
		},
		setTargetLayer: function (a) {
			this.targetLayer = a;
			this.refreshEditPanel()
		},
		getEditPanelDiv: function () {
			return this.editPanel_div
		},
		addNewEditTool: function (b, c) {
			var wa =
				this.targetLayer.isFeatureEditable() ? " enabled" : " disabled",
			Aa = {};
			Aa.container = a.$("\x3cdiv\x3e\x3c/div\x3e");
			Aa.container.id = this.prefixID + b + "Tool" + this.rndID;
			Aa.container.addClass("omv2_edit_panel_tool_container");
			Aa.container.appendTo(this.editPanel_div);
			Aa.icon = a.$("\x3cdiv\x3e\x3c/div\x3e");
			Aa.icon.id = this.prefixID + b + "Tool_icon" + this.rndID;
			Aa.icon.addClass("omv2_edit_panel_tool_icon " + b + " " + wa);
			Aa.icon.appendTo(Aa.container);
			Aa.title_container = a.$("\x3cdiv\x3e\x3c/div\x3e");
			Aa.title_container.id =
				this.prefixID + b + "Tool_title_container" + this.rndID;
			Aa.title_container.addClass("omv2_edit_panel_tool_title_container");
			Aa.title_container.appendTo(Aa.container);
			Aa.title_text = a.$("\x3cspan\x3e\x3c/span\x3e");
			Aa.title_text.id = this.prefixID + b + "Tool_title_text" + this.rndID;
			Aa.title_text.addClass("omv2_edit_panel_tool_title_text");
			Aa.title_text.appendTo(Aa.title_container);
			Aa.title_text.text(c);
			return Aa
		},
		refresh: function () {
			var a = this.targetLayer.isFeatureEditable() ? " enabled" : " disabled",
			b;
			for (b in this.toolMap)
				this.toolMap[b] &&
				null !== this.toolMap[b] && (this.toolMap[b].icon.removeClass("enabled disabled"), this.toolMap[b].icon.addClass("omv2_edit_panel_tool_icon " + b + " " + a))
		},
		addSelectTool: function () {
			this.toolMap[a.control.EditPanel.SELECT_TOOL] && null !== this.toolMap[a.control.EditPanel.SELECT_TOOL] || (this.toolMap[a.control.EditPanel.SELECT_TOOL] = this.addNewEditTool(a.control.EditPanel.SELECT_TOOL, "Select"), this.goToSelectState())
		},
		addNewPolygonTool: function () {
			if (!this.toolMap[a.control.EditPanel.NEW_POLYGON_TOOL] || null === this.toolMap[a.control.EditPanel.NEW_POLYGON_TOOL]) {
				var b =
					this;
				this.toolMap[a.control.EditPanel.NEW_POLYGON_TOOL] = this.addNewEditTool(a.control.EditPanel.NEW_POLYGON_TOOL, "New Polygon");
				this.toolMap[a.control.EditPanel.NEW_POLYGON_TOOL].icon.click(function () {
					b.newPolygon()
				})
			}
		},
		addVoidPolygonTool: function () {
			if (!this.toolMap[a.control.EditPanel.VOID_POLYGON_TOOL] || null === this.toolMap[a.control.EditPanel.VOID_POLYGON_TOOL]) {
				var b = this;
				this.toolMap[a.control.EditPanel.VOID_POLYGON_TOOL] = this.addNewEditTool(a.control.EditPanel.VOID_POLYGON_TOOL, "Void Polygon");
				this.toolMap[a.control.EditPanel.VOID_POLYGON_TOOL].icon.click(function () {
					b.newVoidPolygon()
				})
			}
		},
		addNewLineTool: function () {
			if (!this.toolMap[a.control.EditPanel.NEW_LINE_TOOL] || null === this.toolMap[a.control.EditPanel.NEW_LINE_TOOL]) {
				var b = this;
				this.toolMap[a.control.EditPanel.NEW_LINE_TOOL] = this.addNewEditTool(a.control.EditPanel.NEW_LINE_TOOL, "New Line");
				this.toolMap[a.control.EditPanel.NEW_LINE_TOOL].icon.click(function () {
					b.newLine()
				})
			}
		},
		addNewPointTool: function () {
			if (!this.toolMap[a.control.EditPanel.NEW_POINT_TOOL] ||
				null === this.toolMap[a.control.EditPanel.NEW_POINT_TOOL]) {
				var b = this;
				this.toolMap[a.control.EditPanel.NEW_POINT_TOOL] = this.addNewEditTool(a.control.EditPanel.NEW_POINT_TOOL, "New Point");
				this.toolMap[a.control.EditPanel.NEW_POINT_TOOL].icon.click(function () {
					b.newPoint()
				})
			}
		},
		addNewRectangleTool: function () {
			if (!this.toolMap[a.control.EditPanel.NEW_RECTANGLE_TOOL] || null === this.toolMap[a.control.EditPanel.NEW_RECTANGLE_TOOL]) {
				var b = this;
				this.toolMap[a.control.EditPanel.NEW_RECTANGLE_TOOL] = this.addNewEditTool(a.control.EditPanel.NEW_RECTANGLE_TOOL,
						"New Rectangle");
				this.toolMap[a.control.EditPanel.NEW_RECTANGLE_TOOL].icon.click(function () {
					b.newRectangle()
				})
			}
		},
		goToSelectState: function () {
			$(".omv2_edit_panel_tool_title_text").css("text-decoration", "none");
			this.toolMap[a.control.EditPanel.SELECT_TOOL].title_text.css("text-decoration", "underline")
		},
		newPolygon: function () {
			this.targetLayer.isFeatureEditable() && ($(".omv2_edit_panel_tool_title_text").css("text-decoration", "none"), this.toolMap[a.control.EditPanel.NEW_POLYGON_TOOL].title_text.css("text-decoration",
					"underline"), this.newFeature(3))
		},
		newVoidPolygon: function () {
			this.targetLayer.isFeatureEditable() && ($(".omv2_edit_panel_tool_title_text").css("text-decoration", "none"), this.toolMap[a.control.EditPanel.VOID_POLYGON_TOOL].title_text.css("text-decoration", "underline"), this.createVoidPolygon())
		},
		newLine: function () {
			this.targetLayer.isFeatureEditable() && ($(".omv2_edit_panel_tool_title_text").css("text-decoration", "none"), this.toolMap[a.control.EditPanel.NEW_LINE_TOOL].title_text.css("text-decoration", "underline"),
				this.newFeature(2))
		},
		newPoint: function () {
			this.targetLayer.isFeatureEditable() && ($(".omv2_edit_panel_tool_title_text").css("text-decoration", "none"), this.toolMap[a.control.EditPanel.NEW_POINT_TOOL].title_text.css("text-decoration", "underline"), this.newFeature(1))
		},
		newRectangle: function () {
			this.targetLayer.isFeatureEditable() && ($(".omv2_edit_panel_tool_title_text").css("text-decoration", "none"), this.toolMap[a.control.EditPanel.NEW_RECTANGLE_TOOL].title_text.css("text-decoration", "underline"))
		},
		newFeature: function (b) {
			var c =
				this.targetLayer.parentMap,
			wa = this;
			!this.tool || this.tool instanceof a.tool.RedlineTool && b === this.tool.getGeometryType() || this.removeTool();
			this.tool || (a.isNull(b) || b === a.tool.RedlineTool.TYPE_POLYGON ? this.tool = new a.tool.RedlineTool(c, a.tool.RedlineTool.TYPE_POLYGON) : this.tool = b === a.tool.RedlineTool.TYPE_LINESTRING ? new a.tool.RedlineTool(c, a.tool.RedlineTool.TYPE_LINESTRING) : new a.tool.RedlineTool(c, a.tool.RedlineTool.TYPE_POINT), this.tool.addListener(a.event.ToolEvent.SNAP_POINT, function () {
					a.notNull(wa.snapFeature) &&
					(wa.snapLayer.removeFeature(wa.snapFeature), wa.snapLayer.redraw(), wa.snapFeature = null);
					wa.tool.snapPoint = null;
					var b = c.getScreenPointLocation(c.mLocX, c.mLocY);
					if (a.notNull(b)) {
						var na = c.getScreenPointLocation(c.mLocX - 3, c.mLocY - 3),
						Ha = b.coordinates[0] - na.coordinates[0],
						na = na.coordinates[1] - b.coordinates[1],
						Ha = a.edit.GeometrySegmentUtil.getLayerSnapPoint(wa.targetLayer, [b.coordinates[0], b.coordinates[1]], Math.sqrt(Ha * Ha + na * na), !1, !1, !1, !1);
						a.notNull(Ha) && (Ha = Ha.getPoint(), b = new a.geometry.Point(Ha[0],
									Ha[1], b.getSRID()), Ha = c.getScreenLocation(b), wa.tool.snapPoint = [], wa.tool.snapPoint.push(Ha.x), wa.tool.snapPoint.push(Ha.y), wa.snapFeature = new a.Feature("SnapPoint", b, {
									renderingStyle: wa.snaplineStyle
								}), wa.snapLayer.addFeature(wa.snapFeature), wa.snapLayer.redraw())
					}
				}), this.tool.addListener(a.event.ToolEvent.TOOL_END, function () {
					if (!a.isNull(wa.tool.getGeometry())) {
						var b = wa.tool.getGeometry();
						if (wa.tool.getGeometryType() === a.tool.RedlineTool.TYPE_POLYGON) {
							var c = b.getOrdinates()[0];
							a.util.GeomUtil.isClockwise(c[0]) &&
							(c = a.util.GeomUtil.reverseCoordinates(c), b.coordinates[0] = c)
						}
						b = new a.Feature("newfeat_" + wa.rndID + "_" + wa.newFeatCounter++, b);
						b = wa.targetLayer.changeManager.addFeature(b.id, b);
						a.notNull(b) && wa.targetLayer.getUndoManager().addEdit({
							changeManager: wa.targetLayer.changeManager,
							editChangeEvent: b,
							canUndo: function () {
								return !0
							},
							canRedo: function () {
								return !0
							},
							getPresentationName: function () {
								return "feature added"
							},
							undo: function () {
								this.changeManager.undo(this.editChangeEvent)
							},
							redo: function () {
								this.changeManager.redo(this.editChangeEvent)
							}
						});
						a.notNull(wa.snapFeature) && (wa.snapLayer.removeFeature(wa.snapFeature), wa.snapLayer.redraw(), wa.snapFeature = null);
						wa.tool.snapPoint = null;
						wa.tool.clear();
						wa.tool = null;
						wa.goToSelectState()
					}
				}), this.tool.start())
		},
		createVoidPolygon: function () {
			var b = this,
			c = this.targetLayer.parentMap,
			wa = this.targetLayer.getSelectedFeatures();
			a.isNull(wa) || 1 !== wa.length ? this.goToSelectState() : (!this.tool || this.tool instanceof a.tool.VoidPolygonTool || this.removeTool(), this.tool || (this.tool = new a.tool.VoidPolygonTool(c, wa[0]),
					this.tool.addListener(a.event.ToolEvent.TOOL_END, function () {
						b.removeTool();
						b.goToSelectState()
					}), a.isNull(this.tool.polygonFeature) ? (this.goToSelectState(), this.removeTool()) : this.tool.start()))
		},
		removeTool: function () {
			this.tool && (this.tool.clear(), this.tool = null)
		}
	});
	a.control.EditPanel.MINIMUM_WIDTH = 200;
	a.control.EditPanel.MINIMUM_HEIGHT = 200;
	a.control.EditPanel.SELECT_TOOL = "select";
	a.control.EditPanel.NEW_POLYGON_TOOL = "new_polygon";
	a.control.EditPanel.VOID_POLYGON_TOOL = "void_polygon";
	a.control.EditPanel.NEW_LINE_TOOL =
		"new_line";
	a.control.EditPanel.NEW_POINT_TOOL = "new_point";
	a.control.EditPanel.NEW_RECTANGLE_TOOL = "new_ractangle";
	a.control.ScaleBar = a.control.MapDecoration.extend({
		initialize: function sa(b) {
			sa.base.call(this, "MapDeco_ScaleBar");
			this.anchored = this.isInternal = !0;
			this.anchorPosition = a.control.MapDecoration.POSITION_LOWER_LEFT;
			this.format = "BOTH";
			this.maxLength = 100;
			this.transformToGeodetic = !1;
			this.fontSize = 12;
			this.fontColor = "#000000";
			this.fontWeight = "bold";
			this.scaleBarColor = "#000000";
			this.textShadow =
				this.barShadow = this.boxColor = this.boxShadow = "";
			this.barThickness = 3;
			this.fontFamily = "arial,bold";
			this.barColummn = this.textColumn = this.flexContainer = this.botBarText = this.topBarText = this.botBarDiv = this.topBarDiv = this.botTextDiv = this.topTextDiv = null;
			this.topScaleBarHost = {};
			this.bottomScaleBarHost = {};
			this.type = "ScaleBar";
			this.isHtml = !0;
			this.style = {};
			b && (this.format = b.format ? b.format : "BOTH", this.anchorPosition = b.anchorPosition ? b.anchorPosition : a.control.MapDecoration.POSITION_LOWER_LEFT, a.isNotNull(b.style) &&
				this.setStyle(b.style))
		},
		updateScale: function () {
			if (this.map) {
				var a = this;
				this.decideScale(this.map, this.maxLength, function (b) {
					var c = b.fpsLength,
					h = b.metricLength,
					Ha = b.fpsText;
					b = b.metricText;
					"METRIC" === a.format ? (a.topScaleBarHost.length = h, a.topScaleBarHost.text = b, a.renderDivLength(a.topBarDiv), a.renderTextElement(a.topBarText, a.topScaleBarHost.text)) : "IMPERIAL" === a.format ? (a.topScaleBarHost.length = c, a.topScaleBarHost.text = Ha, a.renderDivLength(a.topBarDiv), a.renderTextElement(a.topBarText, a.topScaleBarHost.text)) :
					(a.topScaleBarHost.length = c, a.topScaleBarHost.text = Ha, a.bottomScaleBarHost.length = h, a.bottomScaleBarHost.text = b, a.renderDivLength(a.topBarDiv, a.botBarDiv), a.renderTextElement(a.topBarText, a.topScaleBarHost.text), a.renderTextElement(a.botBarText, a.bottomScaleBarHost.text))
				})
			}
		},
		setStyle: function (b) {
			a.isNull(b) || (b.fontSize && (this.fontSize = "string" === typeof b.fontSize ? parseInt(b.fontSize, 10) : b.fontSize), b.fontColor && (this.fontColor = b.fontColor), b.scaleBarColor && (this.scaleBarColor = b.scaleBarColor), b.fontWeight &&
				(this.fontWeight = b.fontWeight), b.boxShadow && (this.boxShadow = b.boxShadow), b.textShadow && (this.textShadow = b.textShadow), b.scaleBarShadow && (this.barShadow = b.scaleBarShadow), b.maxLength && (this.maxLength = b.maxLength), b.barThickness && (this.barThickness = b.barThickness), b.fontFamily && (this.fontFamily = b.fontFamily), b.boxColor && (this.boxColor = b.boxColor), this.style = b, this.updateScaleBarGroup())
		},
		setFormat: function (b) {
			a.isNull(b) || (this.format = b, a.notNull(this.map) && this.updateScaleBarGroup())
		},
		display: function wa(b,
			c) {
			wa.base.call(this, b, c);
			this.pageDirection = a.util.DomUtil.getPageDirection(this.map);
			this.updateScaleBarGroup()
		},
		updateScaleBarGroup: function () {
			var b = this,
			c = this.map;
			!a.isNull(c) && c.displayed && (c.ScaleBar = this, b.shadowFilter = null, this.decideScale(c, this.maxLength, function (h) {
					var Ha = h.fpsLength,
					tb = h.metricLength,
					yb = h.fpsText;
					h = h.metricText;
					"METRIC" === b.format ? (b.topScaleBarHost.length = tb, b.topScaleBarHost.text = h) : "IMPERIAL" === b.format ? (b.topScaleBarHost.length = Ha, b.topScaleBarHost.text = yb) : (b.topScaleBarHost.length =
							Ha, b.topScaleBarHost.text = yb, b.bottomScaleBarHost.length = tb, b.bottomScaleBarHost.text = h);
					b.createScaleBar();
					Ha = a.event.MapEvent;
					b.anchorPosition && (b.setAnchorPosition(), c.on(Ha.MAP_RESIZED, b.setAnchorPosition, b));
					c.on(Ha.I_MAP_CENTER_ZOOM, b.updateScale, b);
					c.on(Ha.MAP_RECENTERED, b.updateScale, b)
				}))
		},
		prepareTopPortion: function () {
			this.topTextDiv = a.$("\x3cdiv\x3e\x3c/div\x3e");
			this.topTextDiv.css({
				display: "inline-flex",
				"padding-right": "10px"
			});
			this.topBarText = a.$("\x3cspan class\x3d'omv2_scaleText'\x3e\x3c/span\x3e");
			this.renderTextElement(this.topBarText, this.topScaleBarHost.text);
			this.topTextDiv.append(this.topBarText);
			this.topBarDiv = a.$("\x3cdiv\x3e\x3c/div\x3e");
			this.topBarDiv.css({
				display: "inline-flex"
			})
		},
		prepareBottomPortion: function () {
			this.botTextDiv = a.$("\x3cdiv\x3e\x3c/div\x3e");
			this.botTextDiv.css({
				display: "inline-flex",
				"padding-right": "10px"
			});
			this.botBarText = a.$("\x3cspan class\x3d'omv2_scaleText'\x3e\x3c/span\x3e");
			this.renderTextElement(this.botBarText, this.bottomScaleBarHost.text);
			this.botTextDiv.append(this.botBarText);
			this.botBarDiv = a.$("\x3cdiv\x3e\x3c/div\x3e");
			this.botBarDiv.css({
				display: "inline-flex"
			})
		},
		createScaleBar: function () {
			if (!a.isNull(this.$DecorationDiv)) {
				this.$DecorationDiv.empty();
				this.$DecorationDiv.css({
					display: "inline-flex"
				});
				this.flexContainer = a.$("\x3cdiv id\x3d'flexContainer'\x3e\x3c/div\x3e");
				this.flexContainer.css({
					display: "inline-flex",
					"flex-direction": "row"
				});
				this.flexContainer.css({
					"box-shadow": this.boxShadow,
					"background-color": this.boxColor
				});
				this.$DecorationDiv.append(this.flexContainer);
				var b = a.$("\x3cdiv id\x3d'fRow'\x3e\x3c/div\x3e");
				this.textColumn = b;
				var c = a.$("\x3cdiv id\x3d'sRow'\x3e\x3c/div\x3e");
				this.barColumn = c;
				b.css({
					display: "inline-flex",
					"flex-direction": "column",
					"align-items": "baseline",
					"justify-content": "space-around"
				});
				c.css({
					display: "inline-flex",
					"flex-direction": "column",
					"justify-content": "space-around"
				});
				"BOTH" === this.format ? (this.prepareTopPortion(), this.prepareBottomPortion(), this.renderDivLength(this.topBarDiv, this.botBarDiv), b.append(this.topTextDiv, this.botTextDiv),
					c.append(this.topBarDiv, this.botBarDiv)) : (this.prepareTopPortion(), this.renderDivLength(this.topBarDiv), b.append(this.topTextDiv), c.append(this.topBarDiv));
				this.flexContainer.append(b, c);
				if (this.map._decoration[this.type]) {
					this.map._decoration[this.type].$DecorationDiv.find("table").remove();
					this.map._decoration[this.type].contentStyle ? this.map._decoration[this.type].$DecorationDiv.css(this.map._decoration[this.type].contentStyle) : this.map._decoration[this.type].$DecorationDiv.css({
						background: "white"
					});
					var h = this,
					Ha = h.map._decoration[this.type].$DecorationDiv.height();
					setTimeout(function () {
						h.$DecorationDiv.css({
							position: "absolute",
							top: Ha - h.height
						})
					}, 100);
					this.map._decoration[this.type].$DecorationDiv.append(this.$DecorationDiv);
					this.$DecorationDiv.css({
						"z-index": "9999999999"
					})
				}
			}
		},
		renderDivLength: function (b, c) {
			if (!a.isNull(b)) {
				b.empty();
				var h = a.$("\x3cspan\x3e\x3c/span\x3e");
				h.css({
					display: "inline-block",
					"white-space": "nowrap",
					width: "100%"
				});
				var Ha = a.$("\x3cdiv class\x3d'omv2_scaleBar'\x3e\x3c/div\x3e");
				Ha.append(h);
				Ha.css({
					"background-color": this.scaleBarColor,
					"box-shadow": this.barShadow,
					height: this.barThickness,
					width: this.topScaleBarHost.length
				});
				b.append(Ha);
				a.isNull(c) || (c.empty(), h = a.$("\x3cspan\x3e\x3c/span\x3e"), h.css({
						display: "inline-block",
						"white-space": "nowrap",
						width: "100%"
					}), Ha = a.$("\x3cdiv class\x3d'omv2_scaleBar'\x3e\x3c/div\x3e"), Ha.append(h), Ha.css({
						"background-color": this.scaleBarColor,
						"box-shadow": this.barShadow,
						height: this.barThickness,
						width: this.bottomScaleBarHost.length
					}), c.append(Ha))
			}
		},
		renderText: function () {
			this.$topScaleText.css({
				"font-size": this.fontSize,
				color: this.fontColor,
				"font-weight": this.fontWeight
			});
			this.$bottomScaleText.css({
				"font-size": this.fontSize,
				color: this.fontColor,
				"font-weight": this.fontWeight
			});
			this.pageDirection ? (this.$topScaleText.text(this.topScaleBarHost.text), this.$bottomScaleText.text(this.bottomScaleBarHost.text)) : (this.$topScaleText.text(this.topScaleBarHost.text.split(" ").reverse().join(" ")), this.$bottomScaleText.text(this.bottomScaleBarHost.text.split(" ").reverse().join(" ")))
		},
		renderTextElement: function (a, b) {
			this.pageDirection ? a.text(b) : a.text(b.split(" ").reverse().join(" "));
			a.css({
				"font-size": this.fontSize,
				color: this.fontColor,
				"font-weight": this.fontWeight,
				"text-shadow": this.textShadow,
				"font-family": this.fontFamily
			})
		},
		round125: function (a) {
			if (1 < a) {
				for (var b = 0; 10 <= a; )
					a /= 10, b += 1;
				for (a = 5 <= a ? 5 : 2 <= a ? 2 : 1; 0 < b; )
					a *= 10, --b
			}
			return a
		},
		decideScale: function (b, c, h) {
			var Ha,
			tb,
			yb,
			Ib,
			Pa = this,
			xb = c / 2;
			c = b.getScreenPointLocation(b.getMapContext().getDeviceWidth() / 2 - xb, b.getMapContext().getDeviceHeight() /
					2);
			xb = b.getScreenPointLocation(b.getMapContext().getDeviceWidth() / 2 + xb, b.getMapContext().getDeviceHeight() / 2);
			c = new a.geometry.LineString([c.getX(), c.getY(), xb.getX(), xb.getY()], c.srid);
			c.srid === a.util.BaiduUtil.SRID && (c = a.util.BaiduUtil.transformGeom({
					geom: c,
					toSrid: 8307,
					map: b
				}));
			Ha = a.util.GeomUtil.getLength(c, function (b) {
				Ha = b;
				tb = Pa.round125(Ha);
				1E3 <= tb ? (b = Pa.round125(Ha / 1E3), Ib = Math.round(Pa.maxLength * b / (Ha / 1E3)), yb = b + " " + a.gv.getLabel("MAPVIEWER_SB_KILOMETERS")) : (Ib = Math.round(Pa.maxLength * tb / Ha),
					yb = tb + " " + a.gv.getLabel("MAPVIEWER_SB_METERS"));
				b = Ha / 1609.344;
				var c = 3.28084 * Ha;
				if (1 <= b)
					c = Pa.round125(b), b = Math.round(Pa.maxLength * c / b), c = c + " " + a.gv.getLabel("MAPVIEWER_SB_MILES");
				else {
					var Ta = Pa.round125(c);
					b = Math.round(Pa.maxLength * Ta / c);
					c = Ta + " " + a.gv.getLabel("MAPVIEWER_SB_FEET")
				}
				Ta = {};
				Ta.fpsLength = b;
				Ta.metricLength = Ib;
				Ta.fpsText = c;
				Ta.metricText = yb;
				h(Ta)
			}, {
				unit: "METER",
				transformToGeodetic: !0
			})
		},
		remove: function Aa() {
			Aa.base.call(this);
			var b = this.map,
			c = a.event.MapEvent;
			this.anchored && b.deleteListener(c.MAP_RESIZED,
				this.setAnchorPosition, this);
			b.deleteListener(c.I_MAP_CENTER_ZOOM, this.updateScale, this);
			b.deleteListener(c.MAP_RECENTERED, this.updateScale, this);
			this.map.ScaleBar = null;
			a.notNull(a.util.DomUtil.$div) && (a.util.DomUtil.$div = null)
		},
		getTopScaleValue: function () {
			return this.topScaleBarHost.text.split(" ")[0]
		},
		getBottomScaleValue: function () {
			return "BOTH" === this.format ? this.bottomScaleBarHost.text.split(" ")[0] : ""
		},
		getTopScaleUnit: function () {
			return this.topScaleBarHost.text.split(" ")[1]
		},
		getBottomScaleUnit: function () {
			return "BOTH" ===
			this.format ? this.bottomScaleBarHost.text.split(" ")[1] : ""
		},
		getTopScaleBar: function () {
			return this.$topScaleBar.css({
				position: "relative",
				top: "0px",
				left: ""
			})
		},
		getBottomScaleBar: function () {
			if ("BOTH" === this.format)
				return this.$bottomScaleBar.css({
					position: "relative",
					top: this.padding,
					left: ""
				})
		}
	});
	a.control.OverviewMap = a.control.MapDecoration.extend({
		initialize: function (b) {
			this.isInternal = !0;
			this.type = "OverviewMap";
			this.visible = this.isHtml = !0;
			this.overFeatureLayer = this.rectangleFeature = this.layer = this.submap =
				this.mainmap = null;
			this.cursorStyleDefault = this.cursorStyleDragging = a.CursorTypes.POINTER;
			this.scaleRatio = null;
			this.enableAnimation = !1;
			this.rectangleStyle = b.rectStyle || new a.style.Color({
				strokeThickness: 1,
				stroke: "#f0ff00",
				fill: "#ff0000",
				fillOpacity: .3
			});
			this.actionOnSubMap = this.actionOnMainMap = !1;
			this.collapsible = !0;
			this.minimized = !1;
			this.anchorPosition = b.anchorPosition ? parseInt(b.anchorPosition) : 6
		},
		display: function Oa(b, c) {
			this.minimized = !1;
			Oa.base.call(this, b, c);
			a.$(this.overviewMapDIV).mousewheel(function (a) {
				a.stopPropagation()
			});
			this.mainmap = this.map;
			this.submap = new a.Map(this.overviewMapDIV, {
				mapviewerURL: this.mainmap.mapviewerURL,
				over: !0,
				wraparound: !1
			});
			this.setOverviewMapSize();
			this.submap.enableMapZoom(this.mainmap.zoomEnabled);
			this.mainmap.displayed && (this.map.changeOverView(), this.doinit(), this.anchorPosition && this.setAnchorPosition(this.anchorPosition))
		},
		doinit: function () {
			a.notNull(this.mainmap.overviewLayer) && (this.layer = this.mainmap.overviewLayer.clone("over_" + this.mainmap.overviewLayer.name, !0));
			if (this.layer) {
				if (this.submap.getLayerByName(this.layer.name))
					return;
				this.submap.addLayer(this.layer)
			}
			this.overFeatureLayer = this.submap.getDefaultFeatureLayer();
			var b = this.mainmap.getMapContext();
			this.submap.getMapContextToken().universe = b.getUniverse().clone();
			this.submap.setMapCenter(b.getCenterPoint().clone());
			this.submap.setMapZoomLevel(b.getZoomLevel() - this.calMapZoomDiff());
			this.submap.enableMapDrag(!1);
			this.submap.enableMapAction.click = !1;
			this.submap.enableMapAction.dbclick = !1;
			this.submap.enableMapAction.mousewheel = !1;
			var c = this,
			h = function () {
				var b = c.mainmap.getMapWindowBoundingBox();
				a.isNull(c.rectangleFeature) && (c.rectangleFeature = new a.layer.EditableFeature("overview_rectangle", b, {
						renderingStyle: c.rectangleStyle
					}));
				var h = a.event.LayerEvent;
				c.overFeatureLayer.addFeature(c.rectangleFeature);
				c.rectangleFeature.on(h.FEATURE_MOVED, c.endDragRect, c);
				c.rectangleFeature.on(h.FEATURE_MOVING, c.draggingRect, c);
				c.overFeatureLayer.on(h.FEATURES_DISPLAYED, function () {
					this.rectangleFeature.shape.applyStyle({
						cursor: this.cursorStyleDefault
					})
				}, c);
				b.getWidth() >= c.submap.getMapWindowBoundingBox().getWidth() &&
				c.rectangleFeature.setVisible(!1)
			};
			this.submap.on(a.event.MapEvent.MAP_INITIALIZED, h);
			this.submap.init();
			this.on(a.event.MapDecorationEvent.AFTER_RESTORE, function () {
				c.layer && c.layer.layerType === a.LayerTypes.EXTERNAL ? (c.setCenterAndZoomlevel(), c.submap.refreshMap()) : c.setCenterAndZoomlevel();
				h()
			});
			this.mainmap.on(a.event.MapEvent.MAP_RESIZED, function () {
				this.resize();
				this.setAnchorPosition(this.anchorPosition);
				this.setRectangleFeature();
				this.endDragRect()
			}, this);
			this.collapse()
		},
		clean: function () {},
		collapse: function () {
			this.overviewMapDIV.css({
				width: "0px",
				height: "0px",
				overflow: "hidden",
				"border-width": "0px"
			});
			this.inAnimation = !1;
			this.minimized = !0;
			var a = this.$DecorationBtnDiv.children("img");
			a.attr("src") === this.getMinimizeIcon() ? a.attr("src", this.getRestoreIcon()) : a.attr("src") === this.getRestoreIcon() && a.attr("src", this.getMinimizeIcon())
		},
		restore: function () {
			this.setOverviewMapSize();
			this.minimized = this.inAnimation = !1;
			if (a.notNull(this.$DecorationBtnDiv)) {
				this.overviewMapDIV.css({
					"border-width": "1px"
				});
				var b = this.$DecorationBtnDiv.children("img");
				b.attr("src") === this.getRestoreIcon() ? b.attr("src", this.getMinimizeIcon()) : b.attr("src") === this.getMinimizeIcon() && b.attr("src", this.getRestoreIcon())
			}
		},
		setAnchorPosition: function (a) {
			this.decideButtonAndMapLayout(a);
			var b = this.container.find("div[id^\x3domv2_anchorBox]");
			$(b[a - 1]).append(this.$DecorationDiv)
		},
		decideButtonAndMapLayout: function (a) {
			var b = this.$DecorationBtnDiv,
			c = this.overviewMapDIV;
			switch (a) {
			case 1:
			case 2:
			case 3:
				this.$DecorationDiv.css({
					top: "0px",
					bottom: ""
				});
				break;
			case 4:
			case 5:
			case 6:
				this.$DecorationDiv.css({
					bottom: "0px",
					top: ""
				})
			}
			switch (a) {
			case 1:
				this.$DecorationDiv.css({
					left: "0px",
					right: "",
					"flex-direction": "row",
					"align-items": "flex-end"
				});
				this.$DecorationDiv.append(c, b);
				break;
			case 4:
				this.$DecorationDiv.css({
					left: "0px",
					right: "",
					"flex-direction": "row",
					"align-items": "flex-end"
				});
				this.$DecorationDiv.append(c, b);
				break;
			case 2:
				this.$DecorationDiv.css({
					left: "",
					right: "",
					"flex-direction": "column",
					"align-items": "center"
				});
				this.$DecorationDiv.append(c,
					b);
				break;
			case 5:
				this.$DecorationDiv.css({
					left: "",
					right: "",
					"flex-direction": "column",
					"align-items": "center"
				});
				this.$DecorationDiv.append(b, c);
				break;
			case 3:
				this.$DecorationDiv.css({
					left: "",
					right: "0px",
					"flex-direction": "row",
					"align-items": "flex-end"
				});
				this.$DecorationDiv.append(b, c);
				break;
			case 6:
				this.$DecorationDiv.css({
					left: "",
					right: "0px",
					"flex-direction": "row",
					"align-items": "flex-end"
				}),
				this.$DecorationDiv.append(b, c)
			}
		},
		resize: function Ha() {
			this.setOverviewMapSize();
			Ha.base.call(this)
		},
		setOverviewMapSize: function () {
			var b =
				this.mainmap.getMapContext().getDeviceWindow(),
			c = Math.round(.3 * b.w),
			b = Math.round(.3 * b.h);
			if (a.notNull(this.submap)) {
				var h = this.submap.getMapContextToken();
				h.deviceWindow.w = c;
				h.deviceWindow.h = b
			}
			a.notNull(this.overviewMapDIV) && (this.overviewMapDIV.width(c), this.overviewMapDIV.height(b))
		},
		draggingRect: function () {
			this.cursorStyleDragging && this.rectangleFeature.shape.applyStyle({
				cursor: this.cursorStyleDragging
			})
		},
		endDragRect: function () {
			var a = this.rectangleFeature.geo.getCenter(),
			b = this.mainmap.getMapContext().getZoomLevel();
			this.mainmap.setMapCenterAndZoomLevel(a, b);
			this.setRectangleFeature();
			this.rectangleFeature.shape.applyStyle({
				cursor: this.cursorStyleDefault
			})
		},
		remove: function tb() {
			tb.base.call(this);
			this.layer = this.overFeatureLayer = this.rectangleFeature = null;
			this.submap && this.submap.destroyMap();
			this.layerDel = this.layerAdd = this.styleChange = this.setRectangleFeature = this.endDragRect = this.refreshMainMap = this.resize = this._display = this.map = this.submap = this.mainmap = this.overviewMapDIV = this.rectangleStyle = null
		},
		setRectangleFeature: function () {
			var b =
				this.mainmap.getMapWindowBoundingBox();
			a.isNull(b) || a.isNull(this.submap.getMapWindowBoundingBox()) || (b.getWidth() >= this.submap.getMapWindowBoundingBox().getWidth() && !this.mainmap.wraparound ? this.rectangleFeature.setVisible(!1) : (b.getWidth() >= this.submap.getMapWindowBoundingBox().getWidth() && this.mainmap.wraparound || this.rectangleFeature.setGeometry(b), this.rectangleFeature.setVisible(!0), 3 > this.mainmap.getMapZoomLevel() && this.mainmap.wraparound && this.rectangleFeature.setVisible(!1)))
		},
		styleChange: function (a) {
			var b =
				a.affectLayer;
			this.layer && "over_" + b.name === this.layer.name && b.layerType == this.layer.layerType && ((b = a.newStyle) && "HeatMap" === b.styleType && b.containerVectorLayer && (b = b.clone(), b.containerVectorLayer = b.containerVectorLayer.clone("over_" + b.containerVectorLayer.name, !0, !0)), this.layer.setRenderingStyle(b, a.attributes))
		},
		nsdpMapped: function (a) {
			a = a.affectLayer;
			if (this.layer && "over_" + a.name === this.layer.name && a.layerType == this.layer.layerType) {
				this.layer.clearFeatureShapes();
				this.layer.featureArray = [];
				for (var b =
						a.featureArray.length, c = 0; c < b; c++) {
					var h = a.featureArray[c].clone();
					this.layer.featureArray.push(h)
				}
				this.layer.redraw()
			}
		},
		layerAdd: function () {},
		layerDel: function (b) {
			(b = b.affectedLayer) && this.layer && this.layer.name === "over_" + b.name && b.layerType == this.layer.layerType && (this.layer.copyFeatures && this.mainmap.overviewLayer.deleteListener(a.event.LayerEvent.FEATURES_LOADED, this.layer.copyFeatures), this.submap.removeLayer(this.layer), this.layer = this.mainmap.overviewLayer = null)
		},
		setCenterAndZoomlevel: function () {
			if (!this.minimized) {
				var a =
					this.mainmap.getMapContext();
				this.submap.setMapCenterAndZoomLevel(a.getCenterPoint(), a.getZoomLevel() - this.calMapZoomDiff());
				this.setRectangleFeature()
			}
		},
		calMapZoomDiff: function () {
			for (var a = null, b = this.mainmap.getMapContext(), c = b.getUniverse(), a = 1 < this.scaleRatio ? c.getZoomLevels()[b.getZoomLevel()].resolution * this.scaleRatio : this.mainmap.getMapWindowBoundingBox().getWidth() / (Math.round(.3 * b.getDeviceWidth()) / 2), h = 0; h < b.getZoomLevel(); h++)
				if (c.getZoomLevels()[h + 1].resolution <= a && c.getZoomLevels()[h].resolution >=
					a)
					return b.getZoomLevel() - h;
			if (c.getZoomLevels()[0].resolution < a)
				return b.getZoomLevel()
		},
		setOverviewMapOptions: function (b) {
			if (b.scaleRatio && 1 < b.scaleRatio) {
				if (this.scaleRatio === b.scaleRatio)
					return;
				this.scaleRatio = b.scaleRatio;
				this.submap && this.submap.displayed && this.mainmap && this.submap.setMapZoomLevel(this.mainmap.getMapContext().getZoomLevel() - this.calMapZoomDiff())
			}
			b.overviewLayer && (this.mainmap.overviewLayer = b.overviewLayer, this.submap && this.submap.displayed && (this.submap.removeLayer(this.layer),
					this.layer = b.overviewLayer.clone("over_" + b.overviewLayer.name, !0), this.submap.addLayer(this.layer)));
			if (b.panelOptions) {
				var c = b.panelOptions;
				c.style && (this.rectangleStyle = c.style, this.submap.displayed && this.rectangleFeature.setRenderingStyle(this.rectangleStyle));
				a.notNull(c.draggingCursorStyle) && (this.cursorStyleDragging = c.draggingCursorStyle);
				a.notNull(c.defaultCursorStyle) && (this.cursorStyleDefault = c.defaultCursorStyle, this.rectangleFeature && this.rectangleFeature.shape && this.rectangleFeature.shape.applyStyle({
						cursor: this.cursorStyleDefault
					}));
				a.notNull(c.enableAnimation) && (this.enableAnimation = c.enableAnimation)
			}
			a.notNull(b.anchorPosition) && (this.anchorPosition = b.anchorPosition, this.setAnchorPosition(this.anchorPosition));
			a.notNull(b.display) && this.setVisible(b.display);
			a.notNull(b.collapse) && (b.collapse ? this.collapse() : this.restore())
		},
		refreshMainMap: function () {
			if (!this.actionOnMainMap) {
				this.actionOnSubMap = !0;
				var a = this.submap.getMapContext();
				this.mainmap.setMapCenterAndZoomLevel(a.getCenterPoint(), a.getZoomLevel() + this.calMapZoomDiff());
				this.actionOnSubMap = !1
			}
			this.setRectangleFeature()
		},
		getMapConfig: function () {
			if (this.overviewTileLayer.config)
				return this.overviewTileLayer.config;
			a.util.Logger.warning("MAPVIEWER_9001", "MVOverviewMap.getMapConfig")
		},
		getZoomLevel: function () {
			return this.submap.getZoomLevel()
		},
		errLoadLayer: function () {
			var a = this.mainmap.overviewLayer;
			this.layer = a.clone("over_" + a.name, !0);
			this.submap.inited = !1;
			this.submap.displayed || (this.submap.addLayer(this.layer), this.submap.init())
		},
		enableOverViewMapZoom: function (a) {
			this.submap &&
			this.submap.enableMapZoom(a)
		}
	});
	a.control.ToolButton = a.Class.extend({
		mixin: a.event.EventSource,
		initialize: function (b, c, h) {
			this.btID = b;
			this.btType = c;
			this.btName = h && h.buttonName;
			this.btIcon = h && h.buttonIcon;
			this.btSelectedIcon = h && h.buttonSelectedIcon;
			this.btState = a.control.ToolButton.UP;
			this.tip = h && h.tooltip;
			this.parentToolBar = null;
			this.btDiv = document.createElement("div");
			this.btDiv.id = this.btID;
			this.btImg = document.createElement("img");
			this.tipDiv = document.createElement("div");
			this.width = h && h.width;
			this.height = h && h.height;
			this.positionPending = !1;
			var Pa = this;
			Pa.initButton();
			var xb = function (b) {
				var c = a.event.ToolbarEvent,
				h = new a.event.ToolbarEvent(c.BUTTON_STATE_CHANGE, Pa);
				h.btID = Pa.btID;
				Pa.fire(h.type, h);
				b.stopPropagation();
				Pa.btType == a.control.ToolButton.COMMAND ? (Pa.btImg.setAttribute("src", Pa.btSelectedIcon), Pa.btState = a.control.ToolButton.DOWN, b = new a.event.ToolbarEvent(c.BUTTON_DOWN, Pa), b.btID = Pa.btID, Pa.fire(b.type, b)) : Pa.btType == a.control.ToolButton.TOGGLE && (Pa.btState == a.control.ToolButton.UP ?
					(Pa.btImg.setAttribute("src", Pa.btSelectedIcon), Pa.btState = a.control.ToolButton.DOWN, b = new a.event.ToolbarEvent(c.BUTTON_DOWN, Pa)) : (Pa.btImg.setAttribute("src", Pa.btIcon), Pa.btState = a.control.ToolButton.UP, (a.notNull(Pa.parentToolBar) && a.notNull(Pa.parentToolBar.builtInBts) ? Pa.parentToolBar.builtInBts : []).forEach(function (b) {
							if (b.btID === Pa.btID) {
								var c = new a.event.ToolbarEvent(a.event.ToolbarEvent.BUTTON_STATE_CHANGE, Pa);
								c.button = 0;
								c.btID = b.btID;
								b.tool.finish(c)
							}
						}), b = new a.event.ToolbarEvent(c.BUTTON_UP,
								Pa)), b.btID = Pa.btID, Pa.fire(b.type, b))
			},
			Nb = function (b) {
				Pa.btType == a.control.ToolButton.COMMAND && Pa.btState == a.control.ToolButton.DOWN && Pa.reset();
				b.stopPropagation()
			};
			a.$(this.btImg).mouseover(function () {
				if (Pa.btType != a.control.ToolButton.SEPARATOR) {
					if (a.$(Pa.parentToolBar.toolBarDecorationDiv).css("cursor", "pointer"), Pa.tip) {
						Pa.parentToolBar.toolBarDecorationDiv.appendChild(Pa.tipDiv);
						Pa.tipDiv.innerHTML = Pa.tip;
						a.$(Pa.tipDiv).addClass("tip_toolbar");
						var b = {
							display: "inline",
							left: Pa.btDiv.parentNode.offsetLeft +
							5,
							top: Pa.btDiv.parentNode.offsetTop + 30,
							"white-space": "nowrap"
						};
						a.$(Pa.tipDiv).css(b);
						setTimeout(function () {
							a.$(Pa.tipDiv).css({
								display: "none"
							})
						}, 4E3)
					}
				} else
					a.$(Pa.parentToolBar.toolBarDecorationDiv).css("cursor", "default")
			}).mouseout(function (b) {
				Pa.tip && a.$(Pa.tipDiv).css({
					display: "none"
				});
				Pa.btType == a.control.ToolButton.COMMAND && Pa.btState == a.control.ToolButton.DOWN && Pa.reset();
				b.stopPropagation()
			}).mousedown(xb).mouseup(Nb);
			a.$(this.btImg).keydown(function (a) {
				13 === a.keyCode && xb(a)
			});
			a.browser.touchSupported &&
			(a.$(this.btImg).bind("touchstart", function (a) {
					a.preventDefault();
					a.stopPropagation();
					xb(a)
				}), a.$(this.btImg).bind("touchend", function (a) {
					a.preventDefault();
					a.stopPropagation();
					Nb(a)
				}))
		},
		initButton: function () {
			this.btDiv.appendChild(this.btImg);
			a.$(this.tipDiv).css({
				display: "none"
			});
			a.$(this.btDiv).addClass("btDiv_toolbar");
			"clear" != this.btID.substring(this.btID.lastIndexOf("bt_") + 3) || a.control.ToolBar.ENABLECLEAR || a.$(this.btDiv).css({
				display: "none"
			});
			this.btType != a.control.ToolButton.SEPARATOR &&
			(this.btImg.setAttribute("src", this.btIcon), this.width && this.btImg.setAttribute("width", this.width), this.height && this.btImg.setAttribute("height", this.height), a.notNull(this.tip) && this.btImg.setAttribute("aria-label", this.tip), this.btImg.setAttribute("tabindex", "0"))
		},
		destroy: function () {
			a.$(this.btDiv).empty();
			this.tipDiv = this.btImg = this.btDiv = null
		},
		setToolTip: function (a) {
			this.tip = a
		},
		reset: function (b) {
			this.tool && b && this.tool.clear();
			this.btState == a.control.ToolButton.DOWN && (this.btImg.setAttribute("src",
					this.btIcon), this.btState = a.control.ToolButton.UP, this.tool && this.tool.getStatus() == a.tool.Tool.STARTED && this.tool.clear(), b = new a.event.ToolbarEvent(a.event.ToolbarEvent.BUTTON_UP, this), b.btID = this.btID, this.fire(b.type, b))
		}
	});
	a.control.ToolButton.COMMAND = 0;
	a.control.ToolButton.TOGGLE = 1;
	a.control.ToolButton.SEPARATOR = 2;
	a.control.ToolButton.UP = 0;
	a.control.ToolButton.DOWN = 1;
	a.control.ButtonGroup = a.Class.extend({
		initialize: function () {
			this.toolButtons = [];
			this.toolBar = null;
			var b = this;
			this.onToolButtonStateChange =
			function (c) {
				c = c.btID;
				var h = !1;
				"clear" == c.substring(c.lastIndexOf("bt_") + 3) && (h = !0);
				if (b.toolButtons)
					for (var Pa in b.toolButtons)
						c != Pa && b.toolButtons[Pa]instanceof a.control.ToolButton && b.toolButtons[Pa].reset(h)
			}
		},
		add: function (b) {
			this.toolButtons[b.btID] = b;
			b.group = this;
			b.on(a.event.ToolbarEvent.BUTTON_STATE_CHANGE, this.onToolButtonStateChange);
			this.toolBar && this.toolBar.addButton(b)
		}
	});
	a.control.ToolBar = a.control.MapDecoration.extend({
		initialize: function (b, c) {
			c && a.notNull(c.orientation) && c.orientation ==
			a.control.ToolBar.VERTICAL ? this.direction = c.orientation : this.direction = a.control.ToolBar.HORIZONTAL;
			c && a.notNull(c.enableClear) ? a.control.ToolBar.ENABLECLEAR = c.enableClear : a.control.ToolBar.ENABLECLEAR = !0;
			this.innerID = b = (new Date).getTime();
			this.toolBarTB = this.toolBarDecorationDiv = this.toolBarDecoration = this.map = null;
			this.left = .35;
			this.top = .05;
			var h = this,
			Pa = a.gv.toolButtonW,
			xb = a.gv.toolButtonH;
			a.browser.touchSupported && (Pa *= 1.5, xb *= 1.5);
			this.addedBuiltInbts = c.builtInButtons;
			this.enableBuiltInBts =
				[!1, !1, !1, !1, !1, !1];
			this.builtInBts = [];
			this.allToolBts = [];
			this.toBeAddedBts = [];
			this.builtInButtonGroup = new a.control.ButtonGroup;
			this.buttonGroups = [this.builtInButtonGroup];
			this.toolBarDecoration = new a.control.MapDecoration('\x3cdiv id\x3d"div_' + h.innerID + '" style\x3d"background: white;"\x3e\x3c/div\x3e', {
				offsetX: this.left,
				offsetY: this.top,
				draggable: !0,
				contentStyle: {
					"border-style": "solid",
					"border-color": "#ffffff",
					"border-width": "2px",
					backgroundColor: "#ffffff",
					filter: "alpha(Opacity\x3d80)",
					"-moz-opacity": "0.8",
					opacity: "1"
				}
			});
			this.toolBarDecoration.type = "ToolBar";
			this.toolBarDecoration.clean = function () {};
			this.builtInBtSelected = function (c) {
				c = c.btID;
				var Qa = h.map;
				if (c == b + "_bt_clear") {
					a.notNull(Qa) && Qa.setMaskOutInfoWindow(!1);
					for (var Ta in h.allToolBts)
						h.allToolBts[Ta].tool && (c = h.allToolBts[Ta].btID, c != b + "_bt_redline" && c != b + "_bt_distance" && c != b + "_bt_circle" && c != b + "_bt_rectangle" || h.allToolBts[Ta].tool.clear())
				} else if (a.notNull(Qa) && Qa.setMaskOutInfoWindow(!0), c == b + "_bt_redline" || c == b + "_bt_distance" || c == b +
					"_bt_circle" || c == b + "_bt_rectangle" || c == b + "_bt_zoom")
					for (Ta = 0; Ta < h.builtInBts.length; Ta++)
						if (h.builtInBts[Ta].btID == c) {
							h.builtInBts[Ta].tool.start();
							break
						}
			};
			this.builtInBtUnSelected = function (b) {
				var c = null;
				if (b.btID)
					c = h.allToolBts[b.btID];
				else if (b.target.bt)
					c = b.target.bt;
				else
					return;
				a.notNull(h.map) && h.map.setMaskOutInfoWindow(!1);
				c.reset()
			};
			this.clearTools = function () {
				for (var a = 0; a < h.builtInBts.length; a++)
					h.builtInBts[a].reset()
			};
			(function () {
				h.toolBarTB = document.createElement("Table");
				h.toolBarTB.id =
					"tb_" + h.innerID;
				h.toolBarTB.style.backgroundColor = "rgb(242, 237, 242)";
				h.toolBarTB.cellSpacing = 1;
				h.toolBarTB.cellPadding = 0;
				h.toolBarTB.style.border = "0px solid #7F9DB9";
				h.toolBarTB.style.width = "100%";
				h.builtInBts.push(new a.control.ToolButton(b + "_bt_clear", a.control.ToolButton.COMMAND, {
						buttonIcon: a.gv.resourcePath() + "tbicons/clear.gif",
						buttonSelectedIcon: a.gv.resourcePath() + "tbicons/p_clear.gif",
						width: Pa,
						height: xb,
						tooltip: a.gv.getLabel("MAPVIEWER_TB_TIP_CLEAR")
					}));
				h.builtInBts.push(new a.control.ToolButton(b +
						"_bt_circle", a.control.ToolButton.TOGGLE, {
						buttonIcon: a.gv.resourcePath() + "tbicons/func_circleselect_16_ena.png",
						buttonSelectedIcon: a.gv.resourcePath() + "tbicons/func_circleselect_16_act.png",
						width: Pa,
						height: xb,
						tooltip: a.gv.getLabel("MAPVIEWER_TB_TIP_CIRCLE"),
						buttonName: a.control.ToolBar.BUILTIN_CIRCLE
					}));
				h.builtInBts.push(new a.control.ToolButton(b + "_bt_rectangle", a.control.ToolButton.TOGGLE, {
						buttonIcon: a.gv.resourcePath() + "tbicons/func_rectangleselect_16_ena.png",
						buttonSelectedIcon: a.gv.resourcePath() +
						"tbicons/func_rectangleselect_16_act.png",
						width: Pa,
						height: xb,
						tooltip: a.gv.getLabel("MAPVIEWER_TB_TIP_RECTANGLE"),
						buttonName: a.control.ToolBar.BUILTIN_RECTANGLE
					}));
				h.builtInBts.push(new a.control.ToolButton(b + "_bt_redline", a.control.ToolButton.TOGGLE, {
						buttonIcon: a.gv.resourcePath() + "tbicons/func_polyselect_16_ena.png",
						buttonSelectedIcon: a.gv.resourcePath() + "tbicons/func_polyselect_16_act.png",
						width: Pa,
						height: xb,
						tooltip: a.gv.getLabel("MAPVIEWER_TB_TIP_REDLINE"),
						buttonName: a.control.ToolBar.BUILTIN_REDLINE
					}));
				h.builtInBts.push(new a.control.ToolButton(b + "_bt_distance", a.control.ToolButton.TOGGLE, {
						buttonIcon: a.gv.resourcePath() + "tbicons/func_distance_11_ena.png",
						buttonSelectedIcon: a.gv.resourcePath() + "tbicons/func_distance_11_act.png",
						width: Pa,
						height: xb,
						tooltip: a.gv.getLabel("MAPVIEWER_TB_TIP_DISTANCE"),
						buttonName: a.control.ToolBar.BUILTIN_DISTANCE
					}));
				h.builtInBts.push(new a.control.ToolButton(b + "_bt_zoom", a.control.ToolButton.TOGGLE, {
						buttonIcon: a.gv.resourcePath() + "tbicons/zoom.gif",
						buttonSelectedIcon: a.gv.resourcePath() +
						"tbicons/p_zoom.gif",
						width: Pa,
						height: xb,
						tooltip: a.gv.getLabel("MAPVIEWER_TB_TIP_ZOOM"),
						buttonName: a.control.ToolBar.BUILTIN_MARQUEE_ZOOM
					}));
				for (var c = 0; c < h.builtInBts.length; c++)
					h.builtInBts[c].on(a.event.ToolbarEvent.BUTTON_DOWN, h.builtInBtSelected), h.builtInButtonGroup.add(h.builtInBts[c])
			})()
		},
		setPosition: function (b, c) {
			this.left = a.notNull(b) ? b : this.left;
			this.top = a.notNull(c) ? c : this.top;
			this.positionPending = !1;
			0 < this.left && 1 > this.left && (a.notNull(this.toolBarDecoration.map) ? this.left *= this.toolBarDecoration.map.getMapContext().getDeviceWidth() :
				this.positionPending = !0);
			0 < this.top && 1 > this.top && (a.notNull(this.toolBarDecoration.map) ? this.top *= this.toolBarDecoration.map.getMapContext().getDeviceHeight() : this.positionPending = !0);
			this.toolBarDecoration.left = this.left;
			this.toolBarDecoration.top = this.top;
			a.notNull(this.toolBarDecoration.$DecorationDiv) ? this.toolBarDecoration.$DecorationDiv.css({
				left: this.left,
				top: this.top,
				right: "",
				bottom: ""
			}) : this.positionPending = !0
		},
		display: function yb(a, b) {
			yb.base.call(this, a, b);
			!0 === this.positionPending && this.setPosition()
		},
		setVisible: function (a) {
			this.toolBarDecoration && this.toolBarDecoration.setVisible(a)
		},
		setDraggable: function (a) {
			this.toolBarDecoration && this.toolBarDecoration.setDraggable(a)
		},
		isVisible: function () {
			if (this.toolBarDecoration)
				return this.toolBarDecoration.isVisible()
		},
		initBuiltInTools: function () {
			var b = a.control.ToolBar,
			c = a.event.ToolEvent;
			this.toolBarDecorationDiv = document.getElementById("div_" + this.innerID);
			this.toolBarDecorationDiv.appendChild(this.toolBarTB);
			this.builtInBts[b.BUILTIN_CIRCLE].tool = new a.tool.CircleTool(this.map);
			this.builtInBts[b.BUILTIN_CIRCLE].tool.bt = this.builtInBts[b.BUILTIN_CIRCLE];
			this.builtInBts[b.BUILTIN_CIRCLE].tool.on(c.TOOL_END, this.builtInBtUnSelected);
			this.builtInBts[b.BUILTIN_RECTANGLE].tool = new a.tool.RectangleTool(this.map);
			this.builtInBts[b.BUILTIN_RECTANGLE].tool.bt = this.builtInBts[b.BUILTIN_RECTANGLE];
			this.builtInBts[b.BUILTIN_RECTANGLE].tool.on(c.TOOL_END, this.builtInBtUnSelected);
			this.builtInBts[b.BUILTIN_REDLINE].tool = new a.tool.RedlineTool(this.map);
			this.builtInBts[b.BUILTIN_REDLINE].tool.bt =
				this.builtInBts[b.BUILTIN_REDLINE];
			this.builtInBts[b.BUILTIN_REDLINE].tool.on(c.TOOL_END, this.builtInBtUnSelected);
			this.builtInBts[b.BUILTIN_DISTANCE].tool = new a.tool.DistanceTool(this.map);
			this.builtInBts[b.BUILTIN_DISTANCE].tool.bt = this.builtInBts[b.BUILTIN_DISTANCE];
			this.builtInBts[b.BUILTIN_DISTANCE].tool.on(c.TOOL_END, this.builtInBtUnSelected);
			this.builtInBts[b.BUILTIN_MARQUEE_ZOOM].tool = new a.tool.MarqueeZoomTool(this.map, a.tool.MarqueeZoomTool.ONE_TIME);
			this.builtInBts[b.BUILTIN_MARQUEE_ZOOM].tool.bt =
				this.builtInBts[b.BUILTIN_MARQUEE_ZOOM];
			this.builtInBts[b.BUILTIN_MARQUEE_ZOOM].tool.on(c.TOOL_END, this.builtInBtUnSelected);
			this.enableBuiltInButton(this.addedBuiltInbts);
			var h = this,
			b = function () {
				for (var a = 0; a < h.builtInBts.length; a++)
					h.getBuiltInToolButton(a).reset()
			};
			this.toolBarDecoration.$DecorationDiv.mousedown(b);
			if (a.browser.touchSupported)
				this.toolBarDecoration.$DecorationDiv.on("touchend", b)
		},
		enableBuiltInButton: function (b) {
			for (var c = 0; c < b.length; c++)
				if (b[c] == a.control.ToolBar.BUILTIN_ALL) {
					for (b =
							0; b < this.enableBuiltInBts.length; b++)
						this.enableBuiltInBts[b] || (this.enableBuiltInBts[b] = !0);
					break
				} else
					b[c] < this.enableBuiltInBts.length && 0 <= b[c] && (this.enableBuiltInBts[0] = !0, this.enableBuiltInBts[b[c]] = !0);
			for (b = 0; b < this.builtInBts.length; b++)
				this.enableBuiltInBts[b] && this.addButton(this.builtInBts[b])
		},
		removeButton: function (b) {
			if (b) {
				for (var c = this.toBeAddedBts.length - 1; 0 <= c; c--)
					this.toBeAddedBts[c] == b && this.toBeAddedBts.splice(c, 1);
				if (this.map)
					if (delete this.allToolBts[b.btID], b.group && (delete b.group.toolButtons[b.btID],
							b.group = null), this.direction == a.control.ToolBar.HORIZONTAL) {
						var h = this.toolBarTB.firstChild.firstChild;
						if (0 !== h.childNodes.length)
							for (var c = h.childNodes, xb = 0; xb < c.length; xb++)
								c[xb].id == "_td_" + b.btID && h.deleteCell(xb)
					} else if (0 !== this.toolBarTB.firstChild.childNodes.length)
						for (c = this.toolBarTB.firstChild.childNodes, h = 0; h < c.length; h++)
							c[h].id == "_tr_" + b.btID && this.toolBarTB.firstChild.deleteRow(h)
			}
		},
		addButton: function (b) {
			if (this.map) {
				b.btType == a.control.ToolButton.SEPARATOR && (this.direction == a.control.ToolBar.HORIZONTAL ?
					b.btImg.setAttribute("src", a.gv.resourcePath() + "tbicons/bk_v.png") : b.btImg.setAttribute("src", a.gv.resourcePath() + "tbicons/bk_h.png"));
				var c = null,
				c = null;
				this.direction == a.control.ToolBar.HORIZONTAL ? (c = 0 === this.toolBarTB.childNodes.length ? this.toolBarTB.insertRow(0) : this.toolBarTB.firstChild.firstChild, c = c.insertCell(c.childNodes.length), c.id = "_td_" + b.btID) : (c = 0 === this.toolBarTB.childNodes.length ? this.toolBarTB.insertRow(0) : this.toolBarTB.insertRow(this.toolBarTB.firstChild.childNodes.length), c.id =
						"_tr_" + b.btID, c = c.insertCell(0));
				b.parentToolBar = this;
				c.appendChild(b.btDiv);
				this.allToolBts[b.btID] = b
			} else
				this.toBeAddedBts.push(b)
		},
		initCustomBts: function () {
			for (var a = 0; a < this.toBeAddedBts.length; a++)
				this.addButton(this.toBeAddedBts[a])
		},
		getBuiltInTool: function (a) {
			return this.builtInBts[a] ? this.builtInBts[a].tool : null
		},
		getBuiltInToolButton: function (a) {
			return this.builtInBts[a] ? this.builtInBts[a] : null
		},
		addSeparator: function (b) {
			b = new a.control.ToolButton(b, a.control.ToolButton.SEPARATOR);
			this.addButton(b)
		},
		removeSeparator: function (a) {
			for (var b = this.toBeAddedBts.length - 1; 0 <= b; b--)
				if (this.toBeAddedBts[b].btID == a) {
					this.removeButton(this.toBeAddedBts[b]);
					break
				}
		},
		destroy: function () {
			this.allToolBts = this.toolBarDecorationDiv = this.toolBarDecoration = this.map = null;
			for (var a = 0; a < this.builtInBts && this.builtInBts.length; a++)
				this.builtInBts[a].destroy(), this.builtInBts[a] = null;
			this.buttonsToAdd = this.buttonGroups = this.DrawingButtonGroup = this.builtInBts = null
		}
	});
	a.control.ToolBar.VERTICAL = 0;
	a.control.ToolBar.HORIZONTAL =
		1;
	a.control.ToolBar.ENABLECLEAR = !0;
	a.control.ToolBar.BUILTIN_CLEAR = 0;
	a.control.ToolBar.BUILTIN_CIRCLE = 1;
	a.control.ToolBar.BUILTIN_RECTANGLE = 2;
	a.control.ToolBar.BUILTIN_REDLINE = 3;
	a.control.ToolBar.BUILTIN_DISTANCE = 4;
	a.control.ToolBar.BUILTIN_MARQUEE_ZOOM = 5;
	a.control.ToolBar.BUILTIN_ALL = 6;
	a.control.Magnifier = a.control.MapDecoration.extend({
		initialize: function Ib(a) {
			Ib.base.call(this);
			this.collapsible = this.draggable = this.isInternal = !0;
			this.innerID = null;
			this.width = a.width ? a.width : 150;
			this.height = a.height ?
				a.height : 150;
			this.zoomIncrement = a.zoomIncrement ? a.zoomIncrement : 1;
			this.anchorPosition = a.anchorPosition ? a.anchorPosition : 1;
			!1 === a.collapsible && (this.collapsible = !1);
			!1 === a.draggable && (this.draggable = !1);
			this.left = a.offsetX ? a.offsetX : 20;
			this.top = a.offsetY ? a.offsetY : 20;
			this.type = "Magnifier";
			this.isHtml = !0;
			this.scaleRatio = this.cursorStyleDefault = this.cursorStyleDragging = this.overFeatureLayer = this.layer = this.submap = this.mainmap = null;
			this.actionOnSubMap = this.actionOnMainMap = !1;
			this.zommLevel = this.mapHeight =
				this.mapWidth = 0
		},
		display: function Pa(a, b) {
			Pa.base.call(this, a, b);
			this.MagnifierMapDIV = this.$Content;
			this.mainmap = this.map;
			this.doinit()
		},
		centerAndZoomlevel: function (a) {
			this.actionOnSubMap || (this.actionOnMainMap = !0, this.setCenterAndZoomlevel(a), this.actionOnMainMap = !1)
		},
		resize: function () {
			this.submap.getMapContextToken().transform = null;
			this.submap.getMapContext().getTransform();
			this.submap.graphics.setLeftTop(this.submap.draggableGroup, 0, 0);
			this.refreshSubMap();
			this.mapWidth = this.mainmap.getMapContext().getDeviceWidth();
			this.mapHeight = this.mainmap.getMapContext().getDeviceHeight()
		},
		refreshSubMap: function () {
			var b = this.mainmap.getMapContext(),
			c = b.getDeviceWidth() / 2 - this.moveX - this.width / 2,
			h = b.getDeviceHeight() / 2 - this.moveY - this.height / 2,
			Qa = b.getZoomLevel(),
			Ta = b.getUniverse().getZoomLevels()[Qa],
			c = c * Ta.resolution,
			h = h * Ta.resolution * Ta.stretchRatio,
			Ta = b.getCenterPoint(),
			Ta = new a.geometry.Point(Ta.getX() - c, Ta.getY() + h, Ta.getSRID()),
			b = b.getUniverse().getZoomLevelNumber();
			Qa + this.zoomIncrement >= b ? this.submap.setMapCenterAndZoomLevel(Ta,
				b - 1) : this.submap.setMapCenterAndZoomLevel(Ta, Qa + this.zoomIncrement);
			this.X = -c;
			this.Y = h
		},
		remove: function () {
			this.layer = this.overFeatureLayer = null;
			this.submap && this.submap.destroyMap();
			this.refreshSubMap = this.resize = this.centerAndZoomlevel = this.display = this.map = this.submap = this.mainmap = this.MagnifierMapDIV = null
		},
		doinit: function () {
			this.mainmap.on(a.event.MapEvent.MAP_RESIZED, this.resize, this);
			this.setAnchorPosition(this.anchorPosition);
			this.submap = new a.Map(this.MagnifierMapDIV, {
				mapviewerURL: this.mainmap.mapviewerURL,
				magnifier: !0
			});
			this.mapWidth = this.mainmap.getMapContext().getDeviceWidth();
			this.mapHeight = this.mainmap.getMapContext().getDeviceHeight();
			this.zoomLevel = this.mainmap.getMapContext().getZoomLevel();
			for (var b = 0; b < this.mainmap.divLayers.length; b++) {
				var c = this.mainmap.divLayers[b],
				c = c.clone("clone_" + c.name);
				this.submap.addLayer(c)
			}
			for (b = 2; b < this.mainmap.svgLayers.length; b++) {
				var c = this.mainmap.svgLayers[b],
				h = c.name;
				"ii_oracle_maps_internal_editing" !== h && "ii_oracle_maps_internal_others" !== h && (c = c.clone("clone_" +
							h), this.submap.addLayer(c))
			}
			this.overFeatureLayer = this.submap.getDefaultFeatureLayer();
			var h = this.mapWidth / 2 - this.X - this.width / 2,
			c = this.mapHeight / 2 - this.Y - this.height / 2,
			b = this.mainmap.getMapContext(),
			Qa = b.getZoomLevel(),
			Qa = b.getUniverse().getZoomLevels()[Qa],
			h = h * Qa.resolution,
			c = c * Qa.resolution * Qa.stretchRatio,
			b = b.getCenterPoint(),
			b = new a.geometry.Point(b.getX() - h, b.getY() + c, b.getSRID());
			this.mainmap.getMapContext().getZoomLevel() + this.zoomIncrement >= this.mainmap.getMapContext().getUniverse().getZoomLevelNumber() ?
			this.submap.setMapCenterAndZoomLevel(b, this.mainmap.getMapContext().getUniverse().getZoomLevelNumber() - 1) : this.submap.setMapCenterAndZoomLevel(b, this.mainmap.getMapContext().getZoomLevel() + this.zoomIncrement);
			this.submap.enableMapAction.mouse = !1;
			var Ta = this;
			this.flag = !1;
			this.submap.init();
			this.mapdown = !1;
			a.browser.touchSupported || (this.map.$oracleMapDiv.mousedown(function () {
					Ta.mapdown = !0
				}), this.map.$oracleMapDiv.mouseup(function () {
					Ta.mapdown = !1
				}), this.map.$oracleMapDiv.mousemove(function (a) {
					Ta.mapdown &&
					Ta.refreshSubMap(a)
				}), this.$DecorationDiv.mousedown(function () {
					a.$(this).css("cursor", "default");
					Ta.draggable && a.$(this).css("cursor", "move");
					Ta.flag = !0;
					Ta.map.$oracleMapDiv.mousemove(function () {
						if (Ta.flag) {
							var b = Ta.mapWidth / 2 - Ta.moveX - Ta.width / 2,
							c = Ta.mapHeight / 2 - Ta.moveY - Ta.height / 2,
							Qa = Ta.mainmap.getMapContext(),
							h = Qa.getZoomLevel(),
							Pa = Qa.getUniverse().getZoomLevels()[h],
							b = b * Pa.resolution,
							c = c * Pa.resolution * Pa.stretchRatio,
							Pa = Qa.getCenterPoint(),
							Pa = new a.geometry.Point(Pa.getX() - b, Pa.getY() + c, Pa.getSRID()),
							Qa = Qa.getUniverse().getZoomLevelNumber();
							h + Ta.zoomIncrement >= Qa ? Ta.submap.setMapCenterAndZoomLevel(Pa, Qa - 1) : Ta.submap.setMapCenterAndZoomLevel(Pa, h + Ta.zoomIncrement);
							Ta.X = -b;
							Ta.Y = c
						}
					})
				}).mouseup(function () {
					a.$(this).css("cursor", "default")
				}), Ta.submap.$oracleMapDiv.mouseup(function () {
					Ta.flag = !1
				}));
			a.browser.touchSupported && (this.$DecorationDiv.bind("touchstart", function (a) {
					Ta.touchStart(a)
				}), this.map.$oracleMapDiv.bind("touchmove", function (a) {
					Ta.touchMove(a)
				}), this.$DecorationDiv.bind("touchend", function (a) {
					Ta.touchEnd(a)
				}));
			b = a.event.MapEvent;
			this.mainmap.on(b.I_MAP_CENTER_ZOOM, this.refreshSubMap, this);
			this.mainmap.on(b.MAP_RECENTERED, this.refreshSubMap, this);
			a.browser.touchSupported && (this.map.$oracleMapDiv.bind("touchstart", function () {
					Ta.mapdown = !0
				}), this.map.$oracleMapDiv.bind("touchmove", function (a) {
					Ta.mapdown && Ta.refreshSubMap(a)
				}), this.map.$oracleMapDiv.bind("touchend", function () {
					Ta.mapdown = !1
				}))
		},
		touchStart: function () {
			this.flag = !0
		},
		touchMove: function () {
			if (this.flag) {
				var b = this.mapWidth / 2 - this.touchMoveX - this.width /
					2,
				c = this.mapHeight / 2 - this.touchMoveY - this.height / 2;
				this.submap.$oracleMapDiv.css("cursor", "pointer");
				var h = this.mainmap.getMapContext(),
				Qa = h.getZoomLevel(),
				Qa = h.getUniverse().getZoomLevels()[Qa],
				b = b * Qa.resolution,
				c = c * Qa.resolution * Qa.stretchRatio,
				h = h.getCenterPoint(),
				h = new a.geometry.Point(h.getX() - b, h.getY() + c, h.getSRID());
				this.mainmap.getMapContext().getZoomLevel() + this.zoomIncrement >= this.mainmap.getMapContext().getUniverse().getZoomLevelNumber() ? this.submap.setMapCenterAndZoomLevel(h, this.mainmap.getMapContext().getUniverse().getZoomLevelNumber() -
					1) : this.submap.setMapCenterAndZoomLevel(h, this.mainmap.getMapContext().getZoomLevel() + this.zoomIncrement);
				this.X = -b;
				this.Y = c
			}
		},
		touchEnd: function () {
			this.flag = !1
		},
		setCenterAndZoomlevel: function () {
			this.minimized || (this.submap.setMapCenterAndZoomLevel(this.mainmap.getMapContext().getCenterPoint(), this.mainmap.getMapContext().getZoomLevel() + 1), this.setRectangleFeature())
		}
	});
	a.control.LayerControl = a.control.MapDecoration.extend({
		initialize: function xb(a) {
			xb.base.call(this, "MapDeco_LayerControl");
			this.collapsible =
				this.draggable = this.isInternal = !0;
			a = a ? a : {};
			a.position = a.position ? a.position : {};
			this.left = a.offsetX ? a.offsetX : 20;
			this.top = a.offsetY ? a.offsetY : 20;
			a.contentStyle = a.contentStyle ? a.contentStyle : {};
			this.minWidth = this.width = parseInt(a.contentStyle.minWidth) ? parseInt(a.contentStyle.minWidth) : 150;
			this.maxHeight = parseInt(a.contentStyle.maxHeight) ? parseInt(a.contentStyle.maxHeight) : 500;
			a.titleStyle = a.titleStyle ? a.titleStyle : {};
			this.title_font_size = a.titleStyle.font_size ? a.titleStyle.font_size : 11;
			this.title_font_family =
				a.titleStyle.font_family ? a.titleStyle.font_family : "Tahoma";
			this.content_font_size = a.contentStyle.font_size ? a.contentStyle.font_size : 11;
			this.content_font_family = a.contentStyle.font_family ? a.contentStyle.font_family : "Tahoma";
			this.anchorPosition = a.anchorPosition ? a.anchorPosition : 1;
			this.layerDeleteEnable = a.layerDeleteEnable ? a.layerDeleteEnable : !1;
			!1 === a.collapsible && (this.collapsible = !1);
			!1 === a.draggable && (this.draggable = !1);
			this.type = "LayerControl";
			this.isHtml = !0;
			this.layer = this.mainmap = null
		},
		display: function Nb(a,
			b) {
			Nb.base.call(this, a, b);
			this.panelDIV = this.$Content;
			this.mainmap = this.map;
			this.doinit()
		},
		remove: function Qa() {
			Qa.base.call(this);
			this.map && (this.map.$oracleMapDiv.unbind("mousemove", this.mapDiv_mousemove), this.map.$oracleMapDiv.unbind("mouseup", this.mapDiv_mouseup));
			this.resize = this._display = this.map = null;
			this.document_mousemove && a.$(document).unbind("mousemove", this.document_mousemove);
			this.document_mouseup && a.$(document).unbind("mouseup", this.document_mouseup);
			this.document_msup && a.$(document).unbind("mouseup",
				this.document_msup)
		},
		resize: function () {
			this.setAnchorPosition(this.anchorPosition)
		},
		doinit: function () {
			this.el = null;
			this.aY = this.pY = this.moveY = this.scrollTop = 0;
			this.preStyleId = this.aftStyleId = this.preClass = this.aftClass = this.preId = this.aftId = "";
			var b = this;
			this.ck4 = this.ck3 = this.ck2 = this.ck1 = !1;
			this.chkAll = !0;
			var c = 0;
			this.flag = !1;
			this._width = b.width;
			this.v_isDrag = !1;
			this.offsetX = 0;
			this.array = [];
			this._currentWidth = this.width;
			var Ua = {};
			b.currentWidth = this._currentWidth;
			this.setAnchorPosition(this.anchorPosition,
				5, 5);
			this.mapWidth = this.map.getMapContext().getDeviceWidth();
			this.mapHeight = this.map.getMapContext().getDeviceHeight();
			this.map.on(a.event.MapEvent.MAP_RESIZED, this.resize, this);
			var La = this.mainmap.typeArray.slice(3);
			0 === this.mainmap.divLayers.length && (La = this.mainmap.typeArray.slice(2));
			for (var bb = La.length, cb = bb - 1; 1 <= cb; cb--)
				La[cb - 1] == La[cb] && La.splice(cb, 1);
			for (var jb = [], cb = 0, bb = La.length; cb < bb; cb++)
				!RegExp(La[cb], "g").test(jb.join(",")) && jb.push(La[cb]);
			La = jb;
			this.$Dom = a.$("\x3cdiv id\x3d'content' class\x3d'outDom_layerctrl'\x3e\x3c/div\x3e");
			this.panelDIV.append(this.$Dom);
			this.touchscroll("content");
			this.list = {};
			this.dataSource = {};
			for (cb = 0; cb < this.mainmap.svgLayers.length; cb++)
				bb = this.mainmap.svgLayers[cb].name, jb = this.mainmap.getLayerByName(bb).themeName, this.list[bb] = jb, this.dataSource[bb] = this.mainmap.getLayerByName(bb).getDataSouce();
			for (cb = 0; cb < La.length; cb++)
				if (0 !== this.mainmap.nameArray[La[cb]].length) {
					var Jb;
					if ("undefined" === La[cb])
						for (Jb = !0, bb = this.mainmap.nameArray[La[cb]].length - 1; 0 <= bb; bb--)
							this.mainmap.getLayerByName(this.mainmap.nameArray[La[cb]][bb]) &&
							"ii_oracle_maps_internal_others" !== this.mainmap.getLayerByName(this.mainmap.nameArray[La[cb]][bb]).name && "ii_oracle_maps_internal_editing" !== this.mainmap.getLayerByName(this.mainmap.nameArray[La[cb]][bb]).name && this.mainmap.getLayerByName(this.mainmap.nameArray[La[cb]][bb]).layerType == a.LayerTypes.VECTOR && (Jb = !1);
					if (!Jb) {
						c++;
						jb = document.createElement("div");
						jb.id = "dom" + cb;
						jb.setAttribute("style", "position:absolute");
						jb.setAttribute("style", "padding-top:10px;padding-left:9px;height:20px;width:" + (this.width -
								9 + 2) + "px;background:#F5F5F9;border: 0px solid #C6CAD5");
						var zb = document.createElement("img");
						zb.setAttribute("name", La[cb]);
						zb.setAttribute("type", "checkbox");
						zb.setAttribute("value", La[cb]);
						zb.setAttribute("checked", "true");
						zb.src = a.gv.resourcePath() + "checkMark_readonly.png";
						zb.setAttribute("style", "padding-left:6px;display:'';");
						bb = document.createElement("img");
						bb.src = a.gv.resourcePath() + "zoomout.gif";
						bb.alt = La[cb];
						a.browser.touchSupported || this.typeCheckBoxEvent(zb, "click");
						a.browser.touchSupported &&
						this.typeCheckBoxEvent(zb, "touchstart");
						var sb = document.createElement("text");
						sb.id = "typeText" + c;
						a.$(sb).addClass("typeText_layerctrl");
						a.$(sb).css({
							"font-size": this.content_font_size,
							"font-family": this.content_font_family
						});
						var vb;
						vb = "undefined" == La[cb] ? document.createTextNode("vector layers") : document.createTextNode(La[cb]);
						sb.appendChild(vb);
						a.browser.touchSupported || (Ua[bb.alt] = 1, a.$(bb).click(function () {
								1 == Ua[a.$(this)[0].alt] ? (a.$("img[name \x3d " + this.alt + "]")[0].setAttribute("style", "display:none"),
									a.$("." + this.alt).css({
										display: "none"
									}), a.$(".style_" + this.alt).css({
										display: "none"
									}), b.adjustSize(), this.src = a.gv.resourcePath() + "zoomin.gif", Ua[a.$(this)[0].alt] = 0) : (a.$("img[name \x3d " + this.alt + "]")[0].setAttribute("style", "padding-left:3px;display:inline;"), a.$("." + this.alt).css({
										display: ""
									}), b.adjustSize(), this.src = a.gv.resourcePath() + "zoomout.gif", Ua[a.$(this)[0].alt] = 1)
							}));
						jb.appendChild(bb);
						jb.appendChild(zb);
						jb.appendChild(sb);
						b.$Dom.append(jb);
						a.$(jb).height(a.$(sb).height() + 7);
						for (jb =
								this.mainmap.nameArray[La[cb]].length - 1; 0 <= jb; jb--)
							if (this.mainmap.getLayerByName(this.mainmap.nameArray[La[cb]][jb]) && !this.mainmap.getLayerByName(this.mainmap.nameArray[La[cb]][jb]).ignoreLayerControl && "ii_oracle_maps_internal_editing" != this.mainmap.getLayerByName(this.mainmap.nameArray[La[cb]][jb]).name && "ii_oracle_maps_internal_others" != this.mainmap.getLayerByName(this.mainmap.nameArray[La[cb]][jb]).name && this.mainmap.getLayerByName(this.mainmap.nameArray[La[cb]][jb]).layerType == a.LayerTypes.VECTOR) {
								zb =
									document.createElement("div");
								zb.id = "item" + c + jb;
								zb.className = "item " + La[cb];
								zb.setAttribute("style", "display:'';padding-left:20px;height:20px;width:" + (this.width - 20 + 2) + "px;background:#F5F5F9;border-top:0px solid white");
								zb.setAttribute("draggable", "false");
								zb.setAttribute("z-index", "999999");
								this.layerDeleteEnable && (sb = document.createElement("img"), sb.setAttribute("style", "display:none;margin-left:-10px;padding-top:6px;width:12px;height:12px"), sb.src = a.gv.resourcePath() + "cross.png", sb.setAttribute("value",
										this.mainmap.nameArray[La[cb]][jb]), sb.setAttribute("name", "deletebutton_layercontrol"), a.$(sb).bind("click touchstart", function () {
										b.mainmap.removeLayer(b.mainmap.getLayerByName(a.$(this).attr("value")))
									}), a.$(sb).bind("mouseover", function (c) {
										c.stopPropagation();
										a.$(this)[0].src = a.gv.resourcePath() + "delete_ena.png";
										b.layerDeleteEnable && a.$(this).css({
											display: ""
										});
										a.$(this).css({
											cursor: "pointer"
										})
									}), a.$(sb).bind("mouseout", function () {
										a.$(this)[0].src = a.gv.resourcePath() + "cross.png"
									}), zb.appendChild(sb));
								vb = document.createElement("img");
								vb.setAttribute("name", "item_" + La[cb]);
								vb.setAttribute("type", "checkbox");
								vb.setAttribute("value", this.mainmap.nameArray[La[cb]][jb]);
								vb.className = this.mainmap.nameArray[La[cb]][jb];
								vb.setAttribute("checked", "true");
								vb.setAttribute("style", "padding-left:6px;padding-top:6px");
								vb.src = a.gv.resourcePath() + "checkMark_readonly.png";
								a.$(vb).mouseover(function (c) {
									b.layerDeleteEnable && a.$(this).prev().css({
										display: ""
									});
									c.stopPropagation()
								}).mousedown(function (a) {
									a.stopPropagation()
								});
								a.browser.touchSupported || (this.itemCheckBoxEvent(vb, "click"), this.mainmap.getLayerByName(this.mainmap.nameArray[La[cb]][jb]).visible || a.$(vb).click());
								a.browser.touchSupported && (this.itemCheckBoxEvent(vb, "touchstart"), this.mainmap.getLayerByName(this.mainmap.nameArray[La[cb]][jb]).visible || a.$(vb).trigger("touchstart"));
								sb = document.createElement("text");
								sb.id = "itemText" + c + jb;
								a.$(sb).addClass("itemText_layerctrl");
								a.$(sb).css({
									"font-size": this.content_font_size,
									"font-family": this.content_font_family
								});
								var Gb = document.createTextNode(this.mainmap.nameArray[La[cb]][jb]);
								sb.appendChild(Gb);
								zb.appendChild(vb);
								zb.appendChild(sb);
								a.browser.touchSupported || a.$(sb).mouseover(function (c) {
									a.$(this).css({
										cursor: "pointer",
										"font-weight": "600"
									});
									b.layerDeleteEnable && a.$(this).prev().prev().css({
										display: ""
									});
									c.stopPropagation()
								}).bind("mouseout", function (c) {
									a.$(this).css({
										cursor: "default",
										"font-weight": "normal"
									});
									b.layerDeleteEnable && a.$(this).prev().prev().css({
										display: "none"
									});
									c.stopPropagation()
								}).bind("mousedown",
									function (a) {
									a.stopPropagation()
								});
								a.browser.touchSupported && (a.$(sb).bind("touchend", function (c) {
										a.$(this).css({
											cursor: "default",
											"font-weight": "normal"
										});
										b.layerDeleteEnable && a.$(this).prev().prev().css({
											display: "none"
										});
										c.stopPropagation()
									}), a.$(sb).bind("touchstart", function (a) {
										a.stopPropagation()
									}));
								if (!a.browser.touchSupported) {
									var Kb = 1,
									mb;
									a.$(sb).click(function () {
										1 == Kb ? ("none" == a.$("#style" + a.$(this).attr("id")).css("display") ? (a.$("#style" + a.$(this).attr("id")).css({
													display: ""
												}), mb = this, b.getThemeStyle(mb)) :
											a.$("#style" + a.$(this).attr("id")).css({
												display: "none"
											}), b.adjustSize(), Kb = 0) : ("block" == a.$("#style" + a.$(this).attr("id")).css("display") || "" === a.$("#style" + a.$(this).attr("id")).css("display") ? a.$("#style" + a.$(this).attr("id")).css({
												display: "none"
											}) : (a.$("#style" + a.$(this).attr("id")).css({
													display: ""
												}), mb = this, b.getThemeStyle(mb)), b.adjustSize(), Kb = 1)
									})
								}
								a.browser.touchSupported && b.touchEvent(bb, sb);
								vb = document.createElement("div");
								vb.id = "styleitemText" + c + jb;
								vb.setAttribute("style", "display:none;padding-left:40px;height:20;width:" +
									(this.width - 40 + 2) + "px;background:#ECF9FF;border-top:0px solid white;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;");
								vb.className = "style style_" + La[cb] + " style_" + this.mainmap.nameArray[La[cb]][jb];
								Gb = document.createElement("text");
								Gb.id = "styleTextitemText" + c + jb;
								a.$(Gb).addClass("styleText_layerctrl");
								a.$(Gb).css({
									"font-size": this.content_font_size,
									"font-family": this.content_font_family
								});
								var Eb = document.createTextNode(""),
								bb = document.createElement("img");
								bb.id = "imgitemText" + c + jb;
								bb.setAttribute("style",
									"width:18px;height:18px;");
								bb.setAttribute("value", this.mainmap.nameArray[La[cb]][jb]);
								vb.appendChild(bb);
								Gb.appendChild(Eb);
								vb.appendChild(Gb);
								b.$Dom.append(zb);
								b.$Dom.append(vb);
								a.$(zb).height(a.$(sb).height() + 10);
								a.$(vb).mouseover(function () {
									a.$(this).css({
										cursor: "default"
									})
								})
							}
						a.browser.touchSupported || a.$("#dom" + cb).mouseover(function () {
							a.$(this).css({
								cursor: "default"
							});
							b.flag && a.$(this).css({
								background: "#B8DFFD",
								"border-bottom": "2px solid black",
								opacity: "1",
								cursor: "n-resize"
							})
						}).mouseout(function () {
							a.$(this).css({
								background: "#ECF9FF",
								"border-bottom": "0px solid black",
								"border-top": "0px solid black",
								opacity: "1"
							})
						}).bind("mouseup", function (c) {
							b.flag && 0 < a.$(this).find("img[alt]").attr("src").indexOf("zoomin") && a.$(this).find("img[alt]").click();
							b.touchFlag && 0 < a.$(this).find("img[alt]").attr("src").indexOf("zoomin") && a.$(this).find("img[alt]").trigger("touchstart");
							b.itemMoveEventOnTypeDiv(c, this);
							a.browser.touchSupported && (b.flag = !1, b.touchFlag = !1, b.ff = !1)
						});
						a.browser.touchSupported && a.$("#dom" + cb).bind("touchstart", function (c) {
							b.flag &&
							0 < a.$(this).find("img[alt]").attr("src").indexOf("zoomin") && a.$(this).find("img[alt]").click();
							b.touchFlag && 0 < a.$(this).find("img[alt]").attr("src").indexOf("zoomin") && a.$(this).find("img[alt]").trigger("touchstart");
							b.itemMoveEventOnTypeDiv(c, this);
							a.browser.touchSupported && (b.flag = !1, b.touchFlag = !1, b.ff = !1)
						});
						a.browser.touchSupported || a.$("div[id^\x3d'item']").each(function () {
							a.$(this)[0].onmousedown = function (c) {
								2 === c.button ? alert("right click event!") : (a.$("div[id^\x3d'item']").each(function () {
										a.$(this).css({
											background: "#ECF9FF"
										})
									}),
									a.$(this).css({
										background: "gray"
									}), b.scrollTop = a.$(b.$Dom)[0].scrollTop, b.flag = !0, b.preId = this.id, b.preStyleId = "styleitemText" + this.id.substring(4), b.preClass = a.$(this).attr("class"), b.pY = (c || h.event).clientY, b.cloneDiv(c))
							}
						});
						b.touchFlag = !1;
						b.ff = !1;
						a.$("div[id^\x3d'item']").bind("touchstart", function () {
							if (!b.touchFlag) {
								var c = [],
								h = a.util.DomUtil.getTouchesPosition(event);
								c.push(h);
								b.flag = !0;
								b.preId = this.id;
								b.preStyleId = "styleitemText" + this.id.substring(4);
								b.preClass = a.$(this).attr("class");
								b.pY = c[0].y;
								b.pX = c[0].x;
								b.touchFlag = !0;
								a.$(this).css({
									background: "#B8DFFD"
								})
							}
						}).bind("touchend", function () {
							b.ff = b.touchFlag ? !0 : !1;
							a.$("div[id^\x3d'item']").css({
								background: "#ECF9FF"
							})
						});
						a.browser.touchSupported || a.$("div[id^\x3d'item']").click(function () {
							a.$(this).css({
								background: "#B8DFFD",
								cursor: "n-resize"
							})
						}).mouseover(function () {
							b.layerDeleteEnable && a.$(a.$(this).find("img")[0]).css({
								display: ""
							});
							a.$(this).css({
								background: "#B8DFFD"
							});
							b.flag && a.$(this).css({
								"border-bottom": "2px solid black",
								opacity: "1"
							});
							a.$(this).css({
								cursor: "n-resize"
							})
						}).mouseout(function () {
							b.layerDeleteEnable &&
							a.$(a.$(this).find("img")[0]).css({
								display: "none"
							});
							a.$(this).css({
								background: "#ECF9FF",
								"border-top": "0px solid white",
								"border-bottom": "0px solid white"
							});
							b.flag ? a.$("#" + b.preId).css({
								background: "gray"
							}) : (a.$(this)[0].id == b.preId && (b.preId = ""), a.$("div[id^\x3d'item']").each(function () {
									a.$(this).css({
										background: "#ECF9FF"
									})
								}))
						}).bind("mouseup", function (a) {
							b.itemMoveEventOnItemDiv(a, this)
						})
					}
				}
			a.browser.touchSupported && a.$("div[id^\x3d'item']").bind("touchstart", function (a) {
				b.itemMoveEventOnItemDiv(a,
					this)
			});
			this.$Dom.height() > this.maxHeight && this.$Dom.height(this.maxHeight);
			c = document.createElement("div");
			c.id = "v_drag";
			a.browser.touchSupported ? c.setAttribute("style", "cursor: e-resize;z-index:5000000;position:absolute;top:0px;left:" + (parseInt(this.width) - 10) + "px;height:" + this.$title.height() + "px;width:12px;background:#E0E0E0;border:0px solid gray") : c.setAttribute("style", "cursor: e-resize;z-index:5000000;position:absolute;top:0px;left:" + this.width + "px;height:" + this.$title.height() + "px;width:2px;background:#E0E0E0;border:0px solid gray");
			this.panelDIV[0].appendChild(c);
			this.mouseEvent();
			a.$("img[class][type\x3d'checkbox'][checked\x3d'true']").each(function () {
				b.array.push(a.$(this).attr("value"))
			});
			b.array = [];
			this.height = this.$Dom.height();
			this.setAnchorPosition(this.anchorPosition, 5, 5);
			this.panelDIV.height(this.$Dom.height())
		},
		typeCheckBoxEvent: function (b, c) {
			var h = this,
			La = !0;
			a.$(b).mouseover(function () {
				a.$(this).css({
					cursor: "default"
				})
			});
			a.$(b).bind(c, function () {
				"false" == a.$(this)[0].getAttribute("checked") && (La = !1);
				La ? (h.chkAll =
						!1, a.$(this)[0].setAttribute("checked", "false"), a.$(this)[0].src = a.gv.resourcePath() + "checkMark_NS_readonly.png", a.$("img[name \x3d item_" + this.name + "]").attr("src", a.gv.resourcePath() + "checkMark_NS_readonly.png"), a.$("img[name \x3d item_" + this.name + "]").each(function () {
						a.$(this)[0].setAttribute("checked", "false");
						h.map.getLayerByName(a.$(this).attr("value")).setVisible(!1)
					}), La = !1) : (h.chkAll = !0, a.$(this)[0].setAttribute("checked", "true"), a.$(this)[0].src = a.gv.resourcePath() + "checkMark_readonly.png",
					a.$("img[name \x3d item_" + this.name + "]").attr("src", a.gv.resourcePath() + "checkMark_readonly.png"), a.$("img[name \x3d item_" + this.name + "]").each(function () {
						a.$(this)[0].setAttribute("checked", "true");
						h.map.getLayerByName(a.$(this).attr("value")).setVisible(!0)
					}), La = !0)
			})
		},
		itemCheckBoxEvent: function (b, c) {
			var h = this,
			La = !0;
			a.$(b).mouseover(function () {
				a.$(this).css({
					cursor: "default"
				})
			});
			a.$(b).bind(c, function (b) {
				b.stopPropagation();
				La = "true" == a.$(this)[0].getAttribute("checked") ? !0 : !1;
				var c = 0;
				La ? (a.$("img[name \x3d " +
						this.name + "]").each(function () {
						"true" == a.$(this)[0].getAttribute("checked") && (c += 1)
					}), a.$(this)[0].setAttribute("checked", "false"), b = this.name.substr(5), a.$(this)[0].src = a.gv.resourcePath() + "checkMark_NS_readonly.png", 2 > c && (a.$("img[name \x3d " + b + "]")[0].src = a.gv.resourcePath() + "checkMark_NS_readonly.png"), h.map.getLayerByName(a.$(this).attr("value")).setVisible(!1)) : (a.$(this)[0].setAttribute("checked", "true"), b = this.name.substr(5), a.$(this)[0].src = a.gv.resourcePath() + "checkMark_readonly.png", a.$("img[name \x3d " +
						b + "]")[0].src = a.gv.resourcePath() + "checkMark_readonly.png", h.map.getLayerByName(a.$(this).attr("value")).setVisible(!0))
			})
		},
		typeDivEvent: function () {},
		itemDivEvent: function () {},
		mouseEvent: function () {
			var b = this;
			a.$("#v_drag").mousedown(function (a) {
				b.v_isDrag = !0;
				b.offsetX = a.clientX
			}).mouseup(function () {
				b.v_isDrag = !1;
				b._currentWidth = b._width;
				b.currentWidth = b._currentWidth
			});
			this.panelDIV.mouseup(function () {
				b.v_isDrag = !1;
				b._currentWidth = b._width;
				b.currentWidth = b._currentWidth
			});
			this.document_mouseup = function () {
				b.v_isDrag =
					!1;
				b._currentWidth = b._width;
				b.currentWidth = b._currentWidth
			};
			a.$(document).mouseup(this.document_mouseup);
			a.$("#v_drag").mouseout(function () {
				b.$title.removeClass("titleStyleDwn_layerctrl");
				b.$title.removeClass("titleStyleOvr_layerctrl");
				b.$title.addClass("titleStyleEna_layerctrl")
			});
			b.mapDiv_mousemove = function (c) {
				b.v_isDrag && (c = h.event ? h.event : c, b._width = c.clientX - b.offsetX + b._currentWidth, b._width >= b.minWidth ? (a.$("#content div").width(b._width - 9 + 2), a.$(".item").width(b._width - 20 + 2), a.$(".style").width(b._width -
							49 + 11), b.panelDIV.width(b._width), a.$("#v_drag")[0].style.left = b._width + "px", b.$title.width(b._width - 6)) : b._width = b.minWidth)
			};
			b.mapDiv_mouseup = function () {
				b.v_isDrag = !1;
				b._currentWidth = b._width;
				b.currentWidth = b._currentWidth
			};
			this.map.$oracleMapDiv.mousemove(b.mapDiv_mousemove);
			this.map.$oracleMapDiv.mouseup(b.mapDiv_mouseup);
			this.$title.mouseup(function (c) {
				c.stopPropagation();
				b.v_isDrag = !1;
				b._currentWidth = b._width;
				b.currentWidth = b._currentWidth;
				a.$(this).removeClass("titleStyleEna_layerctrl");
				a.$(this).removeClass("titleStyleDwn_layerctrl");
				a.$(this).addClass("titleStyleOvr_layerctrl");
				b.flag = !1;
				a.$("div[id^\x3d'item']").each(function () {
					a.$(this).css({
						background: "#ECF9FF"
					})
				});
				b.el && (b.container[0].removeChild(b.el), b.el = null)
			}).mouseover(function () {
				b.draggable || a.$(this).css({
					cursor: "default"
				});
				b.dragging ? (a.$(this).removeClass("titleStyleEna_layerctrl"), a.$(this).removeClass("titleStyleOvr_layerctrl"), a.$(this).addClass("titleStyleDwn_layerctrl")) : (a.$(this).removeClass("titleStyleEna_layerctrl"), a.$(this).removeClass("titleStyleDwn_layerctrl"),
					a.$(this).addClass("titleStyleOvr_layerctrl"))
			}).mousedown(function () {
				a.$(this).removeClass("titleStyleEna_layerctrl");
				a.$(this).removeClass("titleStyleOvr_layerctrl");
				a.$(this).addClass("titleStyleDwn_layerctrl")
			}).mouseout(function () {
				b.dragging ? (a.$(this).removeClass("titleStyleEna_layerctrl"), a.$(this).removeClass("titleStyleOvr_layerctrl"), a.$(this).addClass("titleStyleDwn_layerctrl")) : (a.$(this).removeClass("titleStyleDwn_layerctrl"), a.$(this).removeClass("titleStyleOvr_layerctrl"), a.$(this).addClass("titleStyleEna_layerctrl"))
			});
			a.browser.touchSupported && (a.$("#v_drag").bind("touchstart", function (c) {
					b.v_isDrag = !0;
					var h = [];
					c = a.util.DomUtil.getTouchesPosition(c);
					h.push(c);
					b.offsetX = h[0].x
				}), a.$("#v_drag").bind("touchend", function () {
					b.v_isDrag = !1;
					b._currentWidth = b._width;
					b.currentWidth = b._currentWidth
				}), a.$("#v_drag").bind("touchmove", function (c) {
					if (b.v_isDrag) {
						var h = [];
						c = a.util.DomUtil.getTouchesPosition(c);
						h.push(c);
						b._width = h[0].x - b.offsetX + b._currentWidth;
						b._width > b.minWidth ? (a.$("#content div").width(b._width - 9 + 2), a.$(".item").width(b._width -
								20 + 2), a.$(".style").width(b._width - 49 + 11), b.panelDIV.width(b._width), a.$("#v_drag")[0].style.left = b._width - 10 + "px", b.$title.width(b._width - 6)) : b._width = b.width
					}
				}), this.$title.bind("touchend", function (c) {
					c.stopPropagation();
					b.v_isDrag = !1;
					b._currentWidth = b._width;
					b.currentWidth = b._currentWidth;
					a.$(this).removeClass("titleStyleDwn_layerctrl");
					a.$(this).removeClass("titleStyleOvr_layerctrl");
					a.$(this).addClass("titleStyleEna_layerctrl")
				}).bind("touchstart", function () {
					a.$(this).removeClass("titleStyleEna_layerctrl");
					a.$(this).removeClass("titleStyleOvr_layerctrl");
					a.$(this).addClass("titleStyleDwn_layerctrl")
				}))
		},
		itemMoveEventOnTypeDiv: function (b, c) {
			var h = this;
			a.$("div[id^\x3d'item']").css({
				background: "#ECF9FF"
			});
			a.$(c).css({
				cursor: "default",
				background: "#ECF9FF",
				"border-bottom": "0px solid black",
				"border-top": "0px solid black",
				opacity: "1"
			});
			if (h.flag) {
				h.el && (h.container[0].removeChild(h.el), h.el = null);
				h.aftId = c.id;
				h.aftClass = "item " + a.$(c).find("img[name]").attr("name");
				h.aftStyleId = "styleitemText" + c.id.substring(4);
				c.$preDiv = a.$("#" + h.preId);
				c.$aftDiv = a.$("#" + h.aftId);
				c.$preStyleDiv = a.$("#" + h.preStyleId);
				c.$aftStyleDiv = a.$("#" + h.aftStyleId);
				c.$temp = c.$aftDiv.next();
				var La = c.$preDiv.attr("class"),
				La = La.substring(5),
				bb = a.$(".item." + La).length;
				if (1 == bb && La == a.$(c).find("img[name]").attr("name"))
					h.flag = !1;
				else {
					1 == bb ? a.$("img[name\x3d" + La + "]").parent().find("img").css("display", "none") : a.$("img[name\x3d" + La + "]").parent().find("img").css({
						display: "inline"
					});
					0 === a.$(".item." + a.$(c).find("img[name]").attr("name")).length &&
					a.$("img[name\x3d" + a.$(c).find("img[name]").attr("name") + "]").parent().find("img").css({
						display: "inline"
					});
					c.$preDiv.insertAfter(c.$aftDiv);
					c.$preStyleDiv.insertAfter(c.$preDiv);
					c.$preDiv.attr("class", h.aftClass);
					La = c.$preStyleDiv.attr("class").split(" ");
					La[1] = "style_" + a.$(c).find("img[name]").attr("name");
					c.$preStyleDiv.attr("class", La[0] + " " + La[1] + " " + La[2]);
					h.aftClass = h.aftClass.replace(" ", "_");
					h.layerDeleteEnable ? a.$("#" + h.preId).children().eq(1).attr("name", h.aftClass) : a.$("#" + h.preId).children().eq(0).attr("name",
						h.aftClass);
					h.flag = !1;
					a.$("img[class][type\x3d'checkbox']").each(function () {
						h.array.push(a.$(this).attr("value"))
					});
					La = h.array.length;
					for (bb = h.array.length - 1; 0 <= bb; bb--)
						h.map.getLayerByName(h.array[bb]).setZIndex(La + 1 - bb);
					a.$("img[class][type\x3d'checkbox']").each(function () {
						"false" == a.$(this)[0].getAttribute("checked") && h.map.getLayerByName(a.$(this).attr("value")).setVisible(!1)
					});
					h.array = [];
					var cb = h.aftClass.substring(5),
					jb = h.preClass.substring(5);
					a.$("img[name \x3d item_" + cb + "]").each(function () {
						"false" ==
						a.$(this)[0].getAttribute("checked") && (h.ck2 = !0);
						a.$("img[name \x3d " + cb + "]")[0].src = a.gv.resourcePath() + "checkMark_readonly.png"
					});
					h.ck2 && (a.$("img[name \x3d " + cb + "]")[0].src = a.gv.resourcePath() + "checkMark_NS_readonly.png", h.ck2 = !1);
					h.ck4 = !1;
					a.$("img[name \x3d item_" + jb + "]").each(function () {
						"false" == a.$(this)[0].getAttribute("checked") && (h.ck4 = !0);
						a.$("img[name \x3d" + jb + "]")[0].src = a.gv.resourcePath() + "checkMark_NS_readonly.png"
					});
					h.ck4 || (a.$("img[name \x3d" + jb + "]")[0].src = a.gv.resourcePath() + "checkMark_readonly.png",
						h.ck4 = !1)
				}
			}
		},
		itemMoveEventOnItemDiv: function (b, c) {
			var Ua = this;
			a.browser.touchSupported || (Ua.ff = !0);
			if (Ua.ff) {
				a.$("div[id^\x3d'item']").css({
					background: "#ECF9FF"
				});
				a.$(c).css({
					background: "#B8DFFD",
					cursor: "n-resize"
				});
				if (Ua.flag) {
					a.$(c).css({
						"border-top": "0px solid white",
						"border-bottom": "0px solid white"
					});
					Ua.el && (Ua.container[0].removeChild(Ua.el), Ua.el = null);
					Ua.aftId = c.id;
					Ua.aftClass = a.$(c).attr("class");
					Ua.aftStyleId = "styleitemText" + c.id.substring(4);
					var La;
					a.browser.touchSupported || (La = b || h.event);
					c.$preDiv = a.$("#" + Ua.preId);
					c.$aftDiv = a.$("#" + Ua.aftId);
					var bb = c.$preDiv.attr("class"),
					bb = bb.substring(5);
					1 == a.$(".item." + bb).length ? a.$("img[name\x3d" + bb + "]").parent().find("img").css("display", "none") : a.$("img[name\x3d" + bb + "]").parent().find("img").css({
						display: "inline"
					});
					0 !== a.$(".item." + Ua.aftClass.substring(5)).length && a.$("img[name\x3d" + Ua.aftClass.substring(5) + "]").parent().find("img").css({
						display: "inline"
					});
					c.$preStyleDiv = a.$("#" + Ua.preStyleId);
					c.$aftStyleDiv = a.$("#" + Ua.aftStyleId);
					if (c.$preDiv[0] !=
						c.$aftDiv[0]) {
						a.browser.touchSupported ? (La = [], bb = a.util.DomUtil.getTouchesPosition(event), La.push(bb), Ua.aY = La[0].y) : Ua.aY = La.clientY;
						Ua.moveY = Ua.aY - Ua.pY;
						c.$temp = c.$aftDiv.next();
						c.$temp1 = c.$preDiv.next();
						Ua.preId != Ua.aftId && (0 < Ua.moveY && (c.$aftDiv[0].nextSibling || c.$aftDiv[0].previousSibling == c.$preDiv[0] ? (c.$preDiv.next().next(), c.$preDiv.insertAfter(c.$aftDiv)) : (c.$tt = a.$(c.$aftDiv[0].previousSibling), c.$aftDiv.insertBefore(c.$preDiv), c.$preDiv.insertAfter(c.$tt)), c.$preStyleDiv.insertAfter(c.$preDiv),
								c.$aftStyleDiv.insertAfter(c.$aftDiv), Ua.changeClassName(c), c.$preDiv.attr("class", Ua.aftClass), Ua.aftClass = Ua.aftClass.replace(" ", "_"), Ua.layerDeleteEnable ? a.$("#" + Ua.preId).children().eq(1).attr("name", Ua.aftClass) : a.$("#" + Ua.preId).children().eq(0).attr("name", Ua.aftClass)), 0 > Ua.moveY && (c.$aftDiv[0].previousSibling || c.$aftDiv[0].nextSibling == c.$preDiv[0] ? c.$preDiv.insertAfter(c.$aftDiv) : (c.$qq = a.$(c.$aftDiv[0].nextSibling), c.$aftDiv.insertBefore(c.$preDiv), c.$preDiv.insertBefore(c.$qq)), c.$preStyleDiv.insertAfter(c.$preDiv),
								c.$aftStyleDiv.insertAfter(c.$aftDiv), Ua.changeClassName(c), c.$preDiv.attr("class", Ua.aftClass), Ua.aftClass = Ua.aftClass.replace(" ", "_"), Ua.layerDeleteEnable ? a.$("#" + Ua.preId).children().eq(1).attr("name", Ua.aftClass) : a.$("#" + Ua.preId).children().eq(0).attr("name", Ua.aftClass)));
						a.$("img[class][type\x3d'checkbox']").each(function () {
							Ua.array.push(a.$(this).attr("value"))
						});
						La = Ua.array.length;
						for (bb = Ua.array.length - 1; 0 <= bb; bb--)
							Ua.map.getLayerByName(Ua.array[bb]).setZIndex(La + 1 - bb);
						a.$("img[class][type\x3d'checkbox']").each(function () {
							"false" ==
							a.$(this)[0].getAttribute("checked") && Ua.map.getLayerByName(a.$(this).attr("value")).setVisible(!1)
						});
						Ua.array = [];
						var cb = a.$(c).attr("class").substring(5),
						jb = Ua.preClass.substring(5);
						a.$("img[name \x3d item_" + cb + "]").each(function () {
							"false" == a.$(this)[0].getAttribute("checked") && (Ua.ck3 = !0);
							a.$("img[name \x3d" + cb + "]")[0].src = a.gv.resourcePath() + "checkMark_readonly.png"
						});
						Ua.ck3 && (a.$("img[name \x3d" + cb + "]")[0].src = a.gv.resourcePath() + "checkMark_NS_readonly.png", Ua.ck3 = !1);
						Ua.ck4 = !1;
						a.$("img[name \x3d item_" +
							jb + "]").each(function () {
							"false" == a.$(this)[0].getAttribute("checked") && (Ua.ck4 = !0);
							a.$("img[name \x3d" + jb + "]")[0].src = a.gv.resourcePath() + "checkMark_NS_readonly.png"
						});
						Ua.ck4 || (a.$("img[name \x3d" + jb + "]")[0].src = a.gv.resourcePath() + "checkMark_readonly.png", Ua.ck4 = !1)
					}
				}
				Ua.flag = !1;
				Ua.touchFlag = !1;
				a.browser.android && a.$(c).css({
					background: "#ECF9FF"
				})
			}
		},
		changeClassName: function (b) {
			var c = b.$preStyleDiv.attr("class").split(" ");
			c[1] = this.layerDeleteEnable ? "style_" + a.$(a.$(b).find("img[name]")[1]).attr("name").slice(5) :
				"style_" + a.$(b).find("img[name]").attr("name").slice(5);
			b.$preStyleDiv.attr("class", c[0] + " " + c[1] + " " + c[2])
		},
		touchEvent: function (b, c) {
			var h = this,
			La = !0;
			a.$(b).bind("touchstart", function () {
				La ? (a.$("img[name \x3d " + this.alt + "]")[0].setAttribute("style", "display:none"), a.$("." + this.alt).css({
						display: "none"
					}), a.$(".style_" + this.alt).css({
						display: "none"
					}), h.adjustSize(), this.src = a.gv.resourcePath() + "zoomin.gif", La = !1) : (a.$("img[name \x3d " + this.alt + "]")[0].setAttribute("style", "padding-left:3px;display:inline;"),
					a.$("." + this.alt).css({
						display: ""
					}), h.adjustSize(), this.src = a.gv.resourcePath() + "zoomout.gif", La = !0)
			});
			var bb = !0;
			a.$(c).bind("touchstart", function (b) {
				b.stopPropagation();
				bb ? (a.$("#style" + a.$(this).attr("id")).css({
						display: ""
					}), h.getThemeStyle(this), h.adjustSize(), bb = !1) : (a.$("#style" + a.$(this).attr("id")).css({
						display: "none"
					}), h.adjustSize(), bb = !0);
				a.browser.android && h.panelDIV.height(h.$Dom.height())
			})
		},
		getThemeStyle: function (b) {
			var c = this;
			a.util.HttpRequest.send("/mapviewer/omserver", {
				xml_request: '\x3cnon_map_request\x3e\x3cget_theme_info data_source\x3d"' +
				c.dataSource[a.$(b).text()] + '" theme\x3d"' + c.list[a.$(b).text()] + '"/\x3e\x3c/non_map_request\x3e'
			}, function (h) {
				a.$("#img" + a.$(b).attr("id"))[0] && (h = a.$(h).find("theme_style[label\x3d'false']").attr("name"), a.$("#styleText" + a.$(b).attr("id")).text(h), a.$("#img" + a.$(b).attr("id"))[0].src = "/mapviewer/omserver?sty\x3d" + h + "\x26ds\x3d" + c.dataSource[a.$(b).text()], c.map && c.map.getLayerByName(a.$("#img" + a.$(b).attr("id")).attr("value")).customImg && (a.$("#img" + a.$(b).attr("id"))[0].src = c.map.getLayerByName(a.$("#img" +
									a.$(b).attr("id")).attr("value")).customImg), c.map && c.map.getLayerByName(a.$("#img" + a.$(b).attr("id")).attr("value")).getRenderingStyle() && (a.$("#img" + a.$(b).attr("id"))[0].src = c.map.getLayerByName(a.$("#img" + a.$(b).attr("id")).attr("value")).getRenderingStyle().src))
			}, "xml")
		},
		cloneDiv: function (b) {
			for (var c = this, Ua = a.$("div[id^\x3d'item']"), La = 0; La < Ua.length; La++)
				Ua[La].pos = c.getElementPos(Ua[La]), Ua[La].size = c.getElementSize(Ua[La]);
			b = b || h.event;
			b = b.target || b.srcElement;
			"deletebutton_layercontrol" !=
			a.$(b).attr("name") && (c.el = b.cloneNode(!0), c.el.style.position = "absolute", c.el.style.left = b.pos.x - 7 + "px", c.el.style.display = "none", c.el.style.width = b.size.width - 20 + "px", c.el.style.height = b.size.height + "px", c.el.style.border = "1px solid #d4d4d4", c.el.style.background = "lightgray", c.el.style.opacity = "1", c.el.style.color = "red", this.container[0].appendChild(c.el), this.document_mousemove = function (b) {
				if (c.flag) {
					b = b || h.event;
					var Qa = c.getMousePos(b);
					c.el.style.display = "";
					c.el.style.left = c.left;
					c.el.style.top =
						parseInt(Qa.y) - parseInt(c.map.$oracleMapDiv.parent()[0].offsetTop) - 10 + "px";
					parseInt(c.el.style.top) < c.top + c.$title.height() && (c.el.style.top = c.top + c.$title.height() + "px");
					parseInt(c.el.style.top) > c.top + c.$Dom.height() - 10 && (c.el.style.top = c.top + c.$Dom.height() - 10 + "px");
					c.aY = b.clientY;
					a.$(c.$Dom)[0].scrollTop = c.scrollTop + (c.aY - c.pY) * (a.$(c.$Dom)[0].scrollHeight / a.$(c.$Dom).height())
				}
			}, this.document_msup = function () {
				c.flag = !1;
				a.$("div[id^\x3d'item']").each(function () {
					a.$(this).css({
						background: "#ECF9FF"
					})
				});
				c.el && (c.container[0].removeChild(c.el), c.el = null)
			}, a.$(document).mousemove(this.document_mousemove), a.$(document).mouseup(this.document_msup), a.$(c.$Dom).mouseup(function () {
					c.flag = !1;
					c.el && (c.container[0].removeChild(c.el), c.el = null)
				}).mouseout(function () {
					c.map.$oracleMapDiv.css({
						cursor: "default"
					})
				}))
		},
		adjustSize: function () {
			this.$Dom.height() > this.maxHeight + 1 && this.$Dom.height(this.maxHeight);
			this.panelDIV.height(this.$Dom.height());
			a.$("#v_drag").height(this.$title.height())
		},
		getMousePos: function (a) {
			return {
				x: a.pageX ||
				a.clientX + document.body.scrollLeft,
				y: a.pageY || a.clientY + document.body.scrollTop
			}
		},
		getElementPos: function (a) {
			return {
				x: a.offsetParent ? a.offsetLeft + arguments.callee(a.offsetParent).x : a.offsetLeft,
				y: a.offsetParent ? a.offsetTop + arguments.callee(a.offsetParent).y : a.offsetTop
			}
		},
		getElementSize: function (a) {
			return {
				width: a.offsetWidth,
				height: a.offsetHeight
			}
		}
	});
	a.control.MapTypeControl = a.control.MapDecoration.extend({
		initialize: function (b, c, h) {
			this.map = b;
			this.tileLayer = c;
			this.enableTypes = h ? h.enableTypes : null;
			this.type = h ? h.type : null;
			var La = this;
			this.addListener = function () {
				a.$("#div_type").bind("click touchend", function (b) {
					b = b.target;
					b.style.backgroundImage = "url('" + a.gv.resourcePath() + "button_bg_dwn.png')";
					b.style.color = "#000000";
					b.style.borderColor = "#e0e3e8 #606974 #606974 #e0e3e8";
					if (La.tileLayer) {
						La.tileLayer.setMapType(La.enableTypes[b.id]);
						var c = document.getElementById(La.type);
						La.type !== b.id && (c.style.backgroundImage = "url('" + a.gv.resourcePath() + "button_bg_ena.png')", c.style.color = "#003d5b", c.style.borderColor =
								"#e0e3e8 #606974 #606974 #e0e3e8");
						La.type = b.id
					}
				}).mouseover(function (b) {
					b = b.target;
					b.id !== La.type && (b.style.backgroundImage = "url('" + a.gv.resourcePath() + "button_bg_ovr.png')", b.style.color = "#000000")
				}).mouseout(function (b) {
					b = b.target;
					b.id !== La.type && (b.style.backgroundImage = "url('" + a.gv.resourcePath() + "button_bg_ena.png')", b.style.color = "#003d5b")
				})
			};
			if (this.tileLayer.mapTypeVisible && !this.infoDecoration) {
				b = "";
				c = 0;
				for (var bb in this.enableTypes)
					this.enableTypes[bb] && (b = bb === this.type ? b + "\x3ctd\x3e\x3ca class\x3d'selectedLinkStyle_mapTypeCtrl' id\x3d\"" +
							bb + '" href\x3d"javascript:void(0);"\x3e ' + bb + "\x3c/a\x3e\x3c/td\x3e" : b + "\x3ctd\x3e\x3ca class\x3d'linkStyle_mapTypeCtrl' id\x3d\"" + bb + '" href\x3d"javascript:void(0);"\x3e ' + bb + "\x3c/a\x3e\x3c/td\x3e", c += 60);
				0 < c && (this.infoDecoration = new a.control.MapDecoration('\x3cdiv id\x3d"div_type" style\x3d"background: white;"\x3e\x3ctable width\x3d100% cellspacing\x3d0 cellpadding\x3d0\x3e\x3ctr\x3e' + b + "\x3c/tr\x3e\x3c/table\x3e\x3c/div\x3e", {
						mapType: "mapTypeControl",
						offsetX: 10,
						offsetY: 10,
						draggable: !1,
						height: 20,
						contentStyle: {
							"border-style": "solid",
							"border-color": "#ffffff",
							border: "0px",
							backgroundColor: "#ffffff",
							filter: "alpha(Opacity\x3d80)",
							"-moz-opacity": "0.8"
						}
					}), this.infoDecoration.setAnchorPosition(2), this.map.addMapDecoration(this.infoDecoration), this.addListener(), this.infoDecoration.$DecorationDiv.css({
						"z-index": 5
					}))
			}
		},
		destroy: function () {
			this.infoDecoration && this.map.removeMapDecoration(this.infoDecoration)
		}
	});
	a.filter.Filter = a.Class.extend({
		initialize: function () {
			this.filterMode = a.filter.Filter.CLIENT_SIDE;
			this.sql = null
		},
		setFilterMode: function () {
			this.filterMode = a.filter.Filter.CLIENT_SIDE
		},
		evaluate: function (a) {
			return this.invokeClient(a)
		},
		invokeClient: function () {
			return !1
		}
	});
	a.filter.Filter.CLIENT_SIDE = "client_side";
	a.filter.Equals = a.filter.Filter.extend({
		initialize: function Ta(a, b) {
			Ta.base.call(this);
			this.filterType = "equalsFilter";
			this.filterAttribute = a ? a.toUpperCase() : "";
			this.filterValue = b
		},
		invokeClient: function (a) {
			return a.attributes && a.attributes[this.filterAttribute] ? (a = a.attributes[this.filterAttribute],
				isNaN(a) || isNaN(this.filterValue) ? a === this.filterValue : parseFloat(a) === parseFloat(this.filterValue)) : !1
		}
	});
	a.filter.NotEquals = a.filter.Filter.extend({
		initialize: function Ua(b, c) {
			Ua.base.call(this);
			this.filterType = "notEqualsFilter";
			this.equalsFilter = new a.filter.Equals(b, c)
		},
		invokeClient: function (a) {
			return !this.equalsFilter.evaluate(a)
		}
	});
	a.filter.Greater = a.filter.Filter.extend({
		initialize: function La(a, b) {
			La.base.call(this);
			this.filterType = "greaterFilter";
			this.filterAttribute = a ? a.toUpperCase() : "";
			this.filterValue = b
		},
		invokeClient: function (a) {
			return a.attributes && a.attributes[this.filterAttribute] && a.attributes[this.filterAttribute] > this.filterValue ? !0 : !1
		}
	});
	a.filter.GreaterEquals = a.filter.Filter.extend({
		initialize: function bb(a, b) {
			bb.base.call(this);
			this.filterType = "greaterEqualsFilter";
			this.filterAttribute = a ? a.toUpperCase() : "";
			this.filterValue = b
		},
		invokeClient: function (a) {
			return a.attributes && a.attributes[this.filterAttribute] && a.attributes[this.filterAttribute] >= this.filterValue ? !0 : !1
		}
	});
	a.filter.Less = a.filter.Filter.extend({
		initialize: function cb(a, b) {
			cb.base.call(this);
			this.filterType = "lessFilter";
			this.filterAttribute = a ? a.toUpperCase() : "";
			this.filterValue = b
		},
		invokeClient: function (a) {
			return a.attributes && a.attributes[this.filterAttribute] && a.attributes[this.filterAttribute] < this.filterValue ? !0 : !1
		}
	});
	a.filter.LessEquals = a.filter.Filter.extend({
		initialize: function jb(a, b) {
			jb.base.call(this);
			this.filterType = "lessEqualsFilter";
			this.filterAttribute = a ? a.toUpperCase() : "";
			this.filterValue =
				b
		},
		invokeClient: function (a) {
			return a.attributes && a.attributes[this.filterAttribute] && a.attributes[this.filterAttribute] <= this.filterValue ? !0 : !1
		}
	});
	a.filter.Between = a.filter.Filter.extend({
		initialize: function Jb(a, b, c) {
			Jb.base.call(this);
			this.filterType = "betweenFilter";
			this.filterAttribute = a ? a.toUpperCase() : "";
			this.lowValue = parseFloat(b);
			this.highValue = parseFloat(c)
		},
		invokeClient: function (a) {
			return a.attributes && a.attributes[this.filterAttribute] && parseFloat(a.attributes[this.filterAttribute]) >= this.lowValue &&
			parseFloat(a.attributes[this.filterAttribute]) <= this.highValue ? !0 : !1
		}
	});
	a.filter.Like = a.filter.Filter.extend({
		initialize: function zb(a, b) {
			zb.base.call(this);
			this.filterType = "likeFilter";
			this.filterAttribute = a ? a.toUpperCase() : "";
			this.filterValue = b
		},
		invokeClient: function (a) {
			return a.attributes && a.attributes[this.filterAttribute] ? this.executeLikeReg(this.filterValue, a.attributes[this.filterAttribute]) : !1
		},
		executeLikeReg: function (b, c) {
			if (b === c)
				return !0;
			var h = "" + b;
			Gb = "" + c;
			-1 !== h.indexOf("_") && (h = h.replace(/\_/g,
						"."));
			-1 !== h.indexOf("%") && (h = h.replace(/\%/g, "[a-zA-Z0-9.@!#$^\x26*() \\s]*"));
			h = new RegExp(h);
			return a.notNull(Gb.match(h)) && 0 < Gb.match(h).length ? Gb.match(h).index >= 0 : !1
		}
	});
	a.filter.InsidePolygon = a.filter.Filter.extend({
		initialize: function sb(a) {
			sb.base.call(this);
			this.filterType = "InsidePolygonFilter";
			this.filterGeom = a;
			this.filterMBR = this.filterGeom.getMBR()
		},
		invokeClient: function (a) {
			var b;
			if (a.geo)
				if (a.geo.srid !== this.filterGeom.srid) {
					var c = this;
					this.filterGeom.transform(a.geo.srid, function (b) {
						c.filterGeom =
							b;
						c.evaluate(a)
					})
				} else {
					var h = this.filterGeom.type;
					b = a.getGeometry().getMBR();
					if ("Rectangle" === h) {
						if (b.getMinX() >= this.filterGeom.getMinX() && b.getMaxX() <= this.filterGeom.getMaxX() && b.getMinY() >= this.filterGeom.getMinY() && b.getMaxY() <= this.filterGeom.getMaxY())
							return !0
					} else if ("Polygon" === h) {
						if (b.getMinX() >= this.filterMBR.getMinX() && b.getMaxX() <= this.filterMBR.getMaxX() && b.getMinY() >= this.filterMBR.getMinY() && b.getMaxY() <= this.filterMBR.getMaxY() && (this._MBRInPolygon(b, this.filterGeom) || this.geomInPolygon(a.geo,
									this.filterGeom)))
							return !0
					} else if ("MultiPolygon" === h && b.getMinX() >= this.filterMBR.getMinX() && b.getMaxX() <= this.filterMBR.getMaxX() && b.getMinY() >= this.filterMBR.getMinY() && b.getMaxY() <= this.filterMBR.getMaxY() && (this._MBRInPolygon(b, this.filterGeom) || this.geomInPolygon(a.geo, this.filterGeom)))
						return !0;
					return !1
				}
			else
				return !1
		},
		pointInsidePolygonRing: function (a, b, c) {
			for (var h = [], mb = [], Eb = c[0].length / 2, Db = 0; Db < Eb; Db++)
				h[Db] = parseFloat(c[0][2 * Db]), mb[Db] = parseFloat(c[0][2 * Db + 1]);
			var Lb = 0;
			c = 0;
			for (Db = Eb -
					1; c < Eb; Db = c++)
				mb[c] > b !== mb[Db] > b && a < (h[Db] - h[c]) * (b - mb[c]) / (mb[Db] - mb[c]) + h[c] && (Lb = !Lb);
			return Lb
		},
		pointInsideCircle: function (a, b, c) {
			var h = c.centerX,
			mb = c.centerY,
			Eb = 0;
			(h - a) * (h - a) + (mb - b) * (mb - b) < c.radius * c.radius && (Eb = !Eb);
			return Eb
		},
		pointInPolygon: function (a, b, c) {
			var h = c.getType(),
			mb = 0;
			if ("Polygon" === h)
				mb = c.circlePolygon ? this.pointInsideCircle(a, b, c) : this.pointInsidePolygonRing(a, b, c.coordinates);
			else if ("MultiPolygon" === h) {
				c = c.coordinates;
				for (var h = c.length, Eb = 0; Eb < h; Eb++) {
					var Db = this.pointInsidePolygonRing(a,
							b, c[Eb]);
					if (Db) {
						mb = Db;
						break
					}
				}
			}
			return mb
		},
		geomInPolygon: function (a, b) {
			var c,
			h,
			mb;
			if ("Point" === a.type || "OrientedPoint" === a.type) {
				if (c = a.coordinates, this.pointInPolygon(c[0], c[1], this.filterGeom))
					return !0
			} else {
				if ("MultiPoint" === a.type || "OrientedMultiPoint" === a.type) {
					h = a.coordinates;
					for (mb = 0; mb < h.length; mb++)
						if (c = h[mb], !this.pointInPolygon(c[0], c[1], b))
							return !1;
					return !0
				}
				if ("Rectangle" === a.type)
					return c = a.coordinates, c.push(c[0], c[3], c[2], c[1]), this._geomInPolygon(c, b) ? !0 : !1;
				if ("LineString" === a.type)
					return c =
						a.coordinates, this._geomInPolygon(c, b) ? !0 : !1;
				if ("MultiLineString" === a.type) {
					h = a.coordinates;
					for (mb = 0; mb < h.length; mb++)
						if (c = h[mb], !this._geomInPolygon(c, b))
							return !1;
					return !0
				}
				if ("Polygon" === a.type)
					return c = a.coordinates[0], this._geomInPolygon(c, b) ? !0 : !1;
				if ("MultiPolygon" === a.type) {
					h = a.coordinates;
					for (mb = 0; mb < h.length; mb++)
						if (c = h[mb][0], !this._geomInPolygon(c, b))
							return !1;
					return !0
				}
			}
			return !1
		},
		_geomInPolygon: function (a, b) {
			var c = a.length / 2;
			if (b.circlePolygon)
				return this._geomInPolygonCircle(a, b);
			for (var h =
					0, mb = c - 1; h < c; h++)
				if (!this.pointInPolygon(a[2 * h], a[2 * h + 1], b) || this.segmentCrossPolygon({
						coordinates: [a[2 * h], a[2 * h + 1], a[2 * mb], a[2 * mb + 1]]
					}, b))
					return !1;
			return !0
		},
		_geomInPolygonCircle: function (a, b) {
			for (var c = a.length / 2, h = 0; h < c; h++)
				if (!this.pointInPolygon(a[2 * h], a[2 * h + 1], b))
					return !1;
			return !0
		},
		_MBRInPolygon: function (a, b) {
			return this.geomInPolygon(a, b)
		},
		segmentCrossPolygon: function (b, c) {
			this.proxy || (this.proxy = new a.filter.AnyInteract(this.filterGeom));
			return this.proxy.segmentCrossPolygon(b, c)
		}
	});
	a.filter.All =
		a.filter.Filter.extend({
			initialize: function vb(a) {
				vb.base.call(this);
				this.filterType = "allFilter";
				this.filterArray = a
			},
			invokeClient: function (a) {
				for (var b = 0; b < this.filterArray.length; b++)
					if (!1 === this.filterArray[b].evaluate(a))
						return !1;
				return !0
			}
		});
	a.filter.And = a.filter.Filter.extend({
		initialize: function Gb(a, b) {
			Gb.base.call(this);
			this.filterType = "andFilter";
			this.filter1 = a;
			this.filter2 = b
		},
		invokeClient: function (a) {
			var b = this.filter1.evaluate(a);
			a = this.filter2.evaluate(a);
			return !!(b & a)
		}
	});
	a.filter.Any =
		a.filter.Filter.extend({
			initialize: function Kb(a) {
				Kb.base.call(this);
				this.filterType = "anyFilter";
				this.filterArray = a
			},
			invokeClient: function (a) {
				for (var b = 0; b < this.filterArray.length; b++)
					if (!0 === this.filterArray[b].evaluate(a))
						return !0;
				return !1
			}
		});
	a.filter.In = a.filter.Any.extend({
		initialize: function mb(b, c) {
			var h = [];
			"[object Array]" !== Object.prototype.toString.call(c) && (c = [c]);
			for (var Mb = 0; Mb < c.length; Mb++)
				h.push(new a.filter.Equals(b, c[Mb]));
			mb.base.call(this, h);
			this.filterType = "inFilter"
		}
	});
	a.filter.IsNotNull =
		a.filter.Filter.extend({
			initialize: function Eb(a) {
				Eb.base.call(this);
				this.filterType = "isNotNullFilter";
				this.filterAttribute = a ? a.toUpperCase() : ""
			},
			invokeClient: function (b) {
				return a.notNull(b.attributes) && a.notNull(b.attributes[this.filterAttribute]) ? !0 : !1
			}
		});
	a.filter.IsNull = a.filter.Filter.extend({
		initialize: function Db(a) {
			Db.base.call(this);
			this.filterType = "isNullFilter";
			this.filterAttribute = a ? a.toUpperCase() : ""
		},
		invokeClient: function (b) {
			return a.isNull(b.attributes) || a.isNull(b.attributes[this.filterAttribute]) ?
			!0 : !1
		}
	});
	a.filter.Not = a.filter.Filter.extend({
		initialize: function Lb(a) {
			Lb.base.call(this);
			this.filterType = "notFilter";
			this.negateFilter = a
		},
		invokeClient: function (a) {
			return !this.negateFilter.evaluate(a)
		}
	});
	a.filter.Or = a.filter.Filter.extend({
		initialize: function Mb(a, b) {
			Mb.base.call(this);
			this.filterType = "orFilter";
			this.filter1 = a;
			this.filter2 = b
		},
		invokeClient: function (a) {
			var b = this.filter1.evaluate(a);
			a = this.filter2.evaluate(a);
			return b || a
		}
	});
	a.filter.Xor = a.filter.Filter.extend({
		initialize: function Qb(a,
			b) {
			Qb.base.call(this);
			this.filterType = "xorFilter";
			this.filter1 = a;
			this.filter2 = b
		},
		invokeClient: function (a) {
			var b = this.filter1.evaluate(a);
			a = this.filter2.evaluate(a);
			return !!(b ^ a)
		}
	});
	a.filter.AnyInteract = a.filter.Filter.extend({
		initialize: function Rb(a) {
			Rb.base.call(this);
			this.filterType = "AnyInteractFilter";
			this.filterGeom = a;
			this.filterMBR = this.filterGeom.getMBR();
			this.sqlStr = null
		},
		invokeClient: function (b) {
			if (b.geo)
				if (b.geo.srid !== this.filterGeom.srid) {
					var c = this;
					this.filterGeom.transform(b.geo.srid,
						function (a) {
						var za = a.getMBR();
						c.filterGeom = a;
						c.filterMBR = c.filterGeom.getMBR();
						a = b.getGeometry().getMBR();
						a.getMinX() > za.getMinX() && a.getMaxX() < za.getMaxX() && a.getMinY() > za.getMinY() && a.getMaxY() < za.getMaxY() && this._AnyInteractWithPolygon(b.geo, this.filterGeom);
						return !1
					})
				} else {
					var za = b.getGeometry(),
					T = za.getMBR(),
					J = za.type,
					F = this.filterGeom.type;
					return a.isNull(T) ? !1 : T.getMaxX() < this.filterMBR.getMinX() || T.getMinX() > this.filterMBR.getMaxX() || T.getMaxY() < this.filterMBR.getMinY() || T.getMinY() > this.filterMBR.getMaxY() ?
					!1 : "Polygon" === F || "Rectangle" === F || "MultiPolygon" === F ? this._AnyInteractWithPolygon(za, this.filterGeom) : "Polygon" === J || "Rectangle" === J || "MultiPolygon" === J ? this._AnyInteractWithPolygon(this.filterGeom, za) : "LineString" !== F && "MultiLineString" !== F || "LineString" !== J && "MultiLineString" !== J ? "LineString" === F || "MultiLineString" === F ? this.isPointOnLine(za, this.filterGeom) : "LineString" === J || "MultiLineString" === J ? this.isPointOnLine(this.filterGeom, za) : this.isSamePoints(this.filterGeom, za) : this.isInteractLine(za,
						this.filterGeom)
				}
			else
				return !1
		},
		_AnyInteractWithPolygon: function (b, c) {
			var za = b.getMBR(),
			T = c.getMBR();
			if (("Polygon" === b.type || "MultiPolygon" === b.type) && za.getMinX() < T.getMinX() && za.getMaxX() > T.getMaxX() && za.getMinY() < T.getMinY() && za.getMaxY() > T.getMaxY()) {
				var J = b;
				b = c;
				c = J;
				za = b.getMBR();
				T = c.getMBR()
			}
			var J = a.util.GeomUtil.isWithinBBox,
			F = za.getMinX(),
			Z = za.getMinY(),
			h = za.getMaxX(),
			za = za.getMaxY(),
			ha = T.getMinX(),
			ra = T.getMinY(),
			Ba = T.getMaxX(),
			T = T.getMaxY();
			if (J(F, Z, ha, ra, Ba, T) && J(F, za, ha, ra, Ba, T) && J(h, za,
					ha, ra, Ba, T) && J(h, Z, ha, ra, Ba, T)) {
				if (this.hasPointsInPolygon(b, c) || this.intersectWithPolygon(b, c))
					return !0
			} else if (this.intersectWithPolygon(b, c) || this.hasPointsInPolygon(b, c))
				return !0;
			return !1
		},
		simplifyCirlce: function (b) {
			if (a.isNull(b))
				return null;
			for (var c = b.coordinates[0], za = c.length, T = a.isNull(b.dim) ? 2 : b.dim, J = Math.max(Math.floor(za / 120), 1), F = [], Z = 0; Z < za - T; Z += T * J)
				F.push(c[Z]), F.push(c[Z + 1]);
			F.push(c[za - T]);
			F.push(c[za - T + 1]);
			b.circlePolygon.coordinates[0] = F;
			b.coordinates[0] = F;
			return b
		},
		intersectWithPolygon: function (b,
			c) {
			var za = b.type,
			T;
			a.notNull(c.circlePolygon) && (T = c.coordinates[0], c = this.simplifyCirlce(c));
			try {
				var J = c.getMBR(),
				F,
				Z,
				h,
				ha,
				ra,
				Ba,
				Ia;
				if ("Point" === za || "OrientedPoint" === za)
					return this.pointInPolygon(b.getX(), b.getY(), c);
				if ("MultiPoint" === za || "OrientedMultiPoint" === za)
					for (F = b.coordinates, ha = 0, Z = F.length; ha < Z; ha++) {
						if (this.pointInPolygon(F[ha][0], F[ha][1], c))
							return !0
					}
				else if ("LineString" === za)
					for (F = b.coordinates, ha = 0, Z = F.length / 2; ha < Z - 1; ha++) {
						if (h = {
								coordinates: [F[2 * ha], F[2 * ha + 1], F[2 * (ha + 1)], F[2 * (ha + 1) +
										1]]
							}, this.segmentCrossPolygon(h, c))
							return !0
					}
				else if ("MultiLineString" === za)
					for (Ba = b.coordinates, Ia = Ba.length, J = 0; J < Ia; J++)
						for (F = Ba[J], ha = 0, Z = F.length / 2; ha < Z - 1; ha++) {
							if (h = {
									coordinates: [F[2 * ha], F[2 * ha + 1], F[2 * (ha + 1)], F[2 * (ha + 1) + 1]]
								}, this.segmentCrossPolygon(h, c))
								return !0
						}
				else if ("Rectangle" === za)
					for (F = b.coordinates, F.push(F[0], F[3], F[2], F[1]), Z = F.length / 2, ha = 0, ra = Z - 1; ha < Z; ra = ha++) {
						if (h = {
								coordinates: [F[2 * ha], F[2 * ha + 1], F[2 * ra], F[2 * ra + 1]]
							}, this.segmentCrossPolygon(h, c))
							return !0
					}
				else if ("Polygon" === za)
					for (F =
							b.coordinates[0], Z = F.length / 2, ha = 0, ra = Z - 1; ha < Z; ra = ha++) {
						if (!(F[2 * ha] < J[0] && F[2 * ra] < J[0] || F[2 * ha] > J[2] && F[2 * ra] > J[2] || F[2 * ha + 1] < J[1] && F[2 * ra + 1] < J[1] || F[2 * ha + 1] > J[3] && F[2 * ra + 1] > J[3]) && (h = {
									coordinates: [F[2 * ha], F[2 * ha + 1], F[2 * ra], F[2 * ra + 1]]
								}, this.segmentCrossPolygon(h, c)))
							return !0
					}
				else if ("MultiPolygon" === za)
					for (Ba = b.coordinates, Ia = Ba.length, Z = 0; Z < Ia; Z++) {
						F = Ba[Z][0];
						var Va = F.length / 2;
						ha = 0;
						for (ra = Va - 1; ha < Va; ra = ha++)
							if (!(F[2 * ha] < J[0] && F[2 * ra] < J[0] || F[2 * ha] > J[2] && F[2 * ra] > J[2] || F[2 * ha + 1] < J[1] && F[2 * ra + 1] < J[1] ||
									F[2 * ha + 1] > J[3] && F[2 * ra + 1] > J[3]) && (h = {
										coordinates: [F[2 * ha], F[2 * ha + 1], F[2 * ra], F[2 * ra + 1]]
									}, this.segmentCrossPolygon(h, c)))
								return !0
					}
				return !1
			} finally {
				a.notNull(c.circlePolygon) && a.notNull(T) && (c.circlePolygon.coordinates[0] = T, c.coordinates[0] = T)
			}
		},
		segmentCrossPolygon: function (a, b) {
			var c = b.coordinates;
			if ("Rectangle" == b.type) {
				var T = b.coordinates,
				c = T[0],
				J = T[1],
				F = T[2],
				T = T[3],
				Z = a.coordinates;
				if (Z[0] >= c && Z[0] <= F && Z[1] >= J && Z[1] <= T || Z[2] >= c && Z[2] <= F && Z[3] >= J && Z[3] <= T)
					return !0;
				c = [[[c, J, F, J, F, T, c, T, c, J]]]
			}
			"Polygon" ===
			b.type && (c = [c]);
			J = 0;
			for (F = c.length; J < F; J++)
				for (var T = c[J][0], Z = T.length / 2, h = 0, ha = Z - 1; h < Z; ha = h++)
					if (this.segmentsStraddle(a, {
							coordinates: [T[2 * h], T[2 * h + 1], T[2 * ha], T[2 * ha + 1]]
						}))
						return !0;
			return !1
		},
		segmentsStraddle: function (a, b) {
			if (!this.rectangleScopeOverlap(a, b))
				return !1;
			var c = {
				x: a.coordinates[2] - b.coordinates[0],
				y: a.coordinates[3] - b.coordinates[1]
			},
			T = {
				x: b.coordinates[2] - b.coordinates[0],
				y: b.coordinates[3] - b.coordinates[1]
			},
			J = {
				x: b.coordinates[0] - a.coordinates[0],
				y: b.coordinates[1] - a.coordinates[1]
			},
			F = {
				x: b.coordinates[2] - a.coordinates[0],
				y: b.coordinates[3] - a.coordinates[1]
			},
			Z = {
				x: a.coordinates[2] - a.coordinates[0],
				y: a.coordinates[3] - a.coordinates[1]
			},
			c = this.crossProduct({
				x: a.coordinates[0] - b.coordinates[0],
				y: a.coordinates[1] - b.coordinates[1]
			}, T) * this.crossProduct(T, c),
			J = this.crossProduct(J, Z) * this.crossProduct(Z, F);
			return 0 <= c && 0 <= J ? !0 : !1
		},
		crossProduct: function (a, b) {
			return Math.round(1E5 * (a.x * b.y - a.y * b.x)) / 1E5
		},
		rectangleScopeOverlap: function (a, b) {
			var c = function (a, b) {
				var c = {};
				a >= b ? (c.max = a, c.min =
						b) : (c.max = b, c.min = a);
				return c
			},
			T = c(a.coordinates[0], a.coordinates[2]),
			J = c(a.coordinates[1], a.coordinates[3]),
			F = c(b.coordinates[0], b.coordinates[2]),
			c = c(b.coordinates[1], b.coordinates[3]);
			return T.max < F.min || T.min > F.max || J.max < c.min || J.min > c.max ? !1 : !0
		},
		hasPointsInPolygon: function (a, b) {
			var c = a.type,
			T,
			J,
			F,
			Z;
			if ("Point" === c || "OrientedPoint" === c)
				return this.pointInPolygon(a.getX(), a.getY(), b);
			if ("MultiPoint" === c || "OrientedMultiPoint" === c) {
				c = 0;
				for (J = a.coordinates.length / 2; c < J; c++)
					if (this.pointInPolygon(a.coordinates[2 *
								c], a.coordinates[2 * c + 1], b))
						return !0;
				return !1
			}
			if ("LineString" === a.type) {
				c = 0;
				for (T = a.coordinates.length / 2; c < T; c++)
					if (this.pointInPolygon(a.coordinates[2 * c], a.coordinates[2 * c + 1], b))
						return !0;
				return !1
			}
			if ("MultiLineString" === a.type) {
				J = 0;
				for (F = a.coordinates.length; J < F; J++)
					for (Z = a.coordinates[J], c = 0, T = Z.length / 2; c < T; c++)
						if (this.pointInPolygon(Z[2 * c], Z[2 * c + 1], b))
							return !0;
				return !1
			}
			if ("Rectangle" === a.type)
				return c = a.coordinates, this.pointInPolygon(c[0], c[1], b) || this.pointInPolygon(c[2], c[3], b) || this.pointInPolygon(c[0],
					c[3], b) || this.pointInPolygon(c[2], c[1], b) ? !0 : !1;
			if ("Polygon" === a.type) {
				c = 0;
				for (T = a.coordinates[0].length / 2; c < T; c++)
					if (this.pointInPolygon(a.coordinates[0][2 * c], a.coordinates[0][2 * c + 1], b))
						return !0;
				return !1
			}
			if ("MultiPolygon" === a.type) {
				J = 0;
				for (F = a.coordinates.length; J < F; J++)
					for (Z = a.coordinates[J][0], c = 0, T = Z.length / 2; c < T; c++)
						if (this.pointInPolygon(Z[2 * c], Z[2 * c + 1], b))
							return !0;
				return !1
			}
		},
		pointInPolygon: function (a, b, c) {
			var T;
			if ("Polygon" === c.type)
				T = c.coordinates[0], T = this._pointInPolygon(a, b, T);
			else if ("Rectangle" ==
				c.type)
				T = [c.getMinX(), c.getMinY(), c.getMaxX(), c.getMinY(), c.getMaxX(), c.getMaxY(), c.getMinX(), c.getMaxY(), c.getMinX(), c.getMinY()], T = this._pointInPolygon(a, b, T);
			else if ("MultiPolygon" === c.type)
				for (var J = c.coordinates, F = 0; F < J.length; F++)
					if (T = J[F][0], T = this._pointInPolygon(a, b, T))
						return !0;
			return T ? !0 : this.isPointOnLine({
				coordinates: [a, b],
				type: "Point"
			}, c)
		},
		_pointInPolygon: function (a, b, c) {
			for (var T = [], J = [], F = c.length / 2, Z = 0; Z < F; Z++)
				T[Z] = parseFloat(c[2 * Z]), J[Z] = parseFloat(c[2 * Z + 1]);
			var h = 0;
			c = 0;
			for (Z = F -
					1; c < F; Z = c++)
				J[c] > b !== J[Z] > b && a < (T[Z] - T[c]) * (b - J[c]) / (J[Z] - J[c]) + T[c] && (h = !h);
			return h
		},
		isInteractLine: function (a, b) {
			for (var c = this.getSegments(a), T = this.getSegments(b), J = 0, F = c.length; J < F; J++)
				for (var Z = 0, h = T.length; Z < h; Z++)
					if (this.segmentsStraddle(c[J], T[Z]))
						return !0;
			return !1
		},
		getSegments: function (a) {
			var b = a.type;
			a = a.coordinates;
			var c = [],
			T,
			J,
			F,
			Z;
			if ("LineString" === b)
				for (b = 0, T = a.length / 2; b < T - 1; b++)
					c.push({
						coordinates: [a[2 * b], a[2 * b + 1], a[2 * (b + 1)], a[2 * (b + 1) + 1]]
					});
			else if ("MultiLineString" === b)
				for (J = 0, F =
						a.length; J < F; J++)
					for (Z = a[J], b = 0, T = Z.length / 2; b < T - 1; b++)
						c.push({
							coordinates: [Z[2 * b], Z[2 * b + 1], Z[2 * (b + 1)], Z[2 * (b + 1) + 1]]
						});
			else if ("Polygon" === b)
				for (a = a[0], b = 0, T = a.length / 2; b < T - 1; b++)
					c.push({
						coordinates: [a[2 * b], a[2 * b + 1], a[2 * (b + 1)], a[2 * (b + 1) + 1]]
					});
			else if ("MultiPolygon" === b)
				for (J = 0, F = a.length; J < F; J++)
					for (Z = a[J][0], b = 0, T = Z.length / 2; b < T - 1; b++)
						c.push({
							coordinates: [Z[2 * b], Z[2 * b + 1], Z[2 * (b + 1)], Z[2 * (b + 1) + 1]]
						});
			else
				"Rectangle" === b && (c.push({
						coordinates: [a[0], a[1], a[2], a[1]]
					}), c.push({
						coordinates: [a[2], a[1], a[2],
							a[3]]
					}), c.push({
						coordinates: [a[2], a[3], a[0], a[3]]
					}), c.push({
						coordinates: [a[0], a[3], a[0], a[1]]
					}));
			return c
		},
		isPointOnLine: function (a, b) {
			var c = this.getSegments(b),
			T = a.coordinates;
			if ("Point" === a.type || "OrientedPoint" === a.type)
				T = [T];
			for (var J = 0, F = T.length; J < F; J++)
				for (var Z = 0, h = c.length; Z < h; Z++)
					if (this.isPointOnSegment(T[J][0], T[J][1], c[Z]))
						return !0;
			return !1
		},
		isPointOnSegment: function (a, b, c) {
			c = c.coordinates;
			return 0 !== this.crossProduct({
				x: a - c[0],
				y: b - c[1]
			}, {
				x: c[2] - c[0],
				y: c[3] - c[1]
			}) ? !1 : Math.min(c[0], c[2]) <=
			a && a <= Math.max(c[0], c[2]) && Math.min(c[1], c[3]) <= b && b <= Math.max(c[1], c[3]) ? !0 : !1
		},
		isSamePoints: function (a, b) {
			var c = a.coordinates,
			T = b.coordinates;
			if ("Point" === a.type || "OrientedPoint" === a.type)
				c = [c];
			if ("Point" === b.type || "OrientedPoint" === b.type)
				T = [T];
			for (var J = 0, F = c.length; J < F; J++)
				for (var Z = 0, h = T.length; Z < h; Z++) {
					var ha = c[J],
					ra = T[Z];
					if (ha[0] === ra[0] && ha[1] === ra[1])
						return !0
				}
			return !1
		}
	});
	a.template.TemplateConfig = a.Class.extend({
		initialize: function (b, c) {
			this.baseFolder = this.url = "";
			var za = {};
			c ? this.config =
				c : (b && -1 !== b.indexOf("config.json", b.length - 11) && (this.url = b, this.baseFolder = b.substring(0, b.lastIndexOf("/") + 1), a.$.ajax({
							url: b,
							async: !1,
							dataType: "json",
							success: function (a) {
								za = a
							}
						})), this.config = za)
		},
		vectorLayerList: function () {
			var a = this.config,
			b = [];
			if (a.vectorLayers)
				for (var c = 0; c < a.vectorLayers.length; c++)
					b.push(a.vectorLayers[c].dn);
			return b
		},
		initVectorLayerList: function () {},
		tileLayerList: function () {
			var a = this.config,
			b = [];
			if (a.tileLayers)
				for (var c = 0; c < a.tileLayers.length; c++)
					b.push(a.tileLayers[c].dn);
			return b
		},
		styleList: function () {
			var a = this.config,
			b = [];
			if (a.styles)
				for (var c = 0; c < a.styles.length; c++)
					b.push(a.styles[c].dn);
			return b
		},
		getTileLayer: function (b) {
			if (!this.config.vectorLayers)
				return null;
			var c = this.getTileLayerConfig(b);
			if (a.isNull(c))
				return null;
			var za = null,
			T = c.vendor;
			if ("google" === T)
				za = new a.layer.GoogleTileLayer(b);
			else if ("oracle" === T)
				za = new a.layer.ElocationTileLayer(b);
			else if ("nokia" === T) {
				var za = c.key,
				T = c.secondary_key,
				J = null;
				if (c.mapTypes)
					for (var c = c.mapTypes.split(","), J = "", F =
							0; F < c.length; F++)
						0 < F && (J += ";"), J += "OM.layer.NokiaTileLayer.TYPE_" + c[F].toUpperCase();
				za = new a.layer.NokiaTileLayer(b, {
					key: za,
					appID: T,
					mapTyleList: J
				})
			} else
				"bing" === T && (za = new a.layer.BingTileLayer(b, {
						key: c.key
					}));
			return za
		},
		getVectorLayer: function (b, c) {
			if (!this.config.vectorLayers)
				return null;
			var za = this.getVectorLayerConfig(c);
			if (a.isNull(za))
				return null;
			var T = za.uri;
			this.baseFolder && 0 > za.uri.indexOf("http") && (T = this.baseFolder + za.uri);
			T = new a.layer.VectorLayer(b, {
				def: {
					type: a.layer.VectorLayer.TYPE_DATAPACK,
					url: T
				}
			});
			if (za.styles) {
				var J = za.styles;
				J.normal && T.setRenderingStyle(this.getStyle(J.normal));
				J.selected && T.setSelectStyle(this.getStyle(J.selected));
				J.mouseOver && (T.enableFeatureHover(!0), T.setHoverStyle(this.getStyle(J.mouseOver)))
			}
			za.nsdp && T.setNSDP(za.nsdp);
			return T
		},
		getStyle: function (b) {
			var c = this.config;
			if (!c.styles)
				return null;
			for (var c = c.styles, za = null, T = 0; T < c.length; T++)
				if (c[T].dn === b) {
					switch (c[T].type) {
					case "color":
						za = new a.style.Color(c[T].def);
						break;
					case "marker":
						za = new a.style.Marker(c[T].def);
						break;
					case "linear-gradient":
						za = new a.style.LinearGradient(c[T].def);
						break;
					case "pulse_animation":
						za = new a.style.PulseAnimation(c[T].def);
						break;
					case "color_animation":
						b = {};
						c[T].beginColor && (b.beginColor = this.getStyle(c[T].beginColor));
						c[T].endColor && (b.endColor = this.getStyle(c[T].endColor));
						c[T].duration && (b.duration = c[T].duration);
						c[T].movingDashLine && (b.enableMovingDashLine = c[T].movingDashLine);
						za = new a.style.AnimationColor(b);
						break;
					case "line":
						za = new a.style.Line(c[T].def);
						break;
					case "text":
						za =
							new a.style.Text(c[T].def);
						break;
					case "heat_map":
						b = c[T].container;
						b = this.getVectorLayer(c[T].dn + " " + b, b);
						c = c[T].def;
						c.containerVectorLayer = b;
						za = new a.style.HeatMap(c);
						break;
					case "bar_chart":
						var J = c[T].barArr,
						F = J.length,
						za = [];
						for (b = 0; b < F; b++)
							za.push(new a.style.Bar(J[b].name, J[b].color));
						c = c[T].def;
						c.bars = za;
						za = new a.style.BarChart(c);
						break;
					case "pie_chart":
						J = c[T].pieArr;
						F = J.length;
						za = [];
						for (b = 0; b < F; b++)
							za.push(new a.style.PieSlice(J[b].name, J[b].color));
						c = c[T].def;
						c.pieSlices = za;
						za = new a.style.PieChart(c)
					}
					break
				}
			return za
		},
		getConfig: function () {
			return this.config
		},
		setConfig: function (a) {
			this.config = a
		},
		initMap: function (b) {
			var c = this.config;
			if (c.init) {
				c = c.init;
				if (c.tileLayer)
					b.addLayer(this.getTileLayer(c.tileLayer));
				else if (c.customUniverse) {
					var za = c.customUniverse,
					T = za.bounds,
					za = new a.universe.Universe({
						srid: za.srid,
						bounds: new a.geometry.Rectangle(T[0], T[1], T[2], T[3], T[4]),
						numberOfZoomLevels: za.numberOfZoomLevels
					});
					b.getMapContextToken().universe = za
				} else
					return;
				if (c.layers)
					for (b.removeAllFeatureLayers(), za = c.layers, T =
							0; T < za.length; T++)
						b.addLayer(this.getVectorLayer(za[T], za[T]));
				if (c.center) {
					var za = c.center[0],
					T = c.center[1],
					J = b.getMapContext().getUniverse().srid,
					za = new a.geometry.Point(za, T, J);
					b.setMapCenter(za)
				}
				c.zoomLevel && b.setMapZoomLevel(c.zoomLevel);
				c.copyright && b.addMapDecoration(new a.control.CopyRight(c.copyright));
				c.navigation && b.addMapDecoration(new a.control.NavigationPanelBar(c.navigation))
			}
		},
		getVectorLayerConfig: function (a) {
			a = this.indexOfVectorLayer(a);
			return -1 === a ? null : this.config.vectorLayers[a]
		},
		getTileLayerConfig: function (a) {
			a = this.tileLayerList().indexOf(a);
			return -1 === a ? null : this.config.tileLayers[a]
		},
		indexOfVectorLayer: function (a) {
			var b = this.vectorLayerList().indexOf(a);
			if (-1 === b)
				for (var c = this.config.vectorLayers, T = 0; T < c.length; T++) {
					var J = c[T];
					if (J.cn && (b = J.cn.indexOf(a), -1 !== b)) {
						b = T;
						break
					}
				}
			return b
		}
	});
	a.template.Template = a.Class.extend({
		initialize: function (b) {
			this.name = "default";
			this.containerMap = null;
			b && b.name && (this.name = b.name);
			this.config = null;
			b.url ? this.config = new a.template.TemplateConfig(b.url) :
				b.data && (this.config = new a.template.TemplateConfig(null, b.data))
		},
		getConfig: function () {
			return this.config
		},
		setConfig: function (b) {
			var c = new a.template.TemplateConfig(null);
			c.setConfig(b);
			this.config = c
		},
		getVectorLayer: function (b, c, za) {
			if (!this.config)
				return null;
			var T = this.config.getVectorLayer(b, c);
			if (a.isNull(T))
				return null;
			if (!(za && za instanceof Array && 0 < za.length))
				return T;
			c = this.config.getVectorLayerConfig(c).uri;
			var J = null;
			a.$.ajax({
				url: c,
				async: !1,
				dataType: "json",
				success: function (a) {
					J = a
				}
			});
			if (a.isNull(J))
				return null;
			c = J.features;
			for (var T = c.length, F = J.attr_names, Z = J.srs, h = [], ha = 0; ha < T; ha++) {
				var ra = c[ha],
				Ba = 0;
				a: for (; Ba < za.length; Ba++)
					for (var Ia = za[Ba].toUpperCase(), Va = 0; Va < F.length; Va++) {
						var Ra = F[Va].toUpperCase();
						if (ra.properties[Ra].toUpperCase() === Ia) {
							Ia = ra.geometry;
							Ia.srid = Z;
							Ba = a.notNull(ra._id) ? ra._id : ha;
							Ia = a.geometry.Geometry.createGeometry(Ia, Z);
							Ba = new a.Feature(Ba, Ia, {
								attributes: ra.properties
							});
							Ba.srid = Z;
							Ba.label_box = ra.label_box;
							h.push(Ba);
							break a
						}
					}
			}
			return new a.layer.VectorLayer(b, {
				def: {
					type: a.layer.VectorLayer.TYPE_LOCAL,
					features: h
				}
			})
		},
		getTileLayer: function (a) {
			return this.config ? this.config.getTileLayer(a) : null
		},
		getStyle: function (a) {
			return this.config ? this.config.getStyle(a) : null
		},
		setupMapControls: function (a) {
			try {
				this.config.initMap(a),
				a.template = this,
				this.containerMap = a
			} catch (b) {}
		},
		getVectorLayerNames: function () {
			return this.config.vectorLayerList()
		},
		getTileLayerNames: function () {
			return this.config.tileLayerList()
		},
		getStyleNames: function () {
			return this.config.styleList()
		},
		getChildLayerNames: function (a) {
			if (!this.config)
				return null;
			var b = [];
			a = this.config.getVectorLayerConfig(a);
			null !== a && a.cl && (b = a.cl);
			return b
		},
		getParentLayerNames: function (a) {
			if (!this.config)
				return null;
			var b = [];
			a = this.config.getVectorLayerConfig(a);
			null !== a && a.pl && (b = a.pl);
			return b
		},
		getChildLayer: function (b, c, za, T) {
			if (!this.config)
				return null;
			c = this.config.getVectorLayerConfig(c);
			if (a.isNull(c) || !c.cl)
				return null;
			c = c.cl;
			if ("string" === typeof za)
				if (-1 === c.indexOf(za)) {
					var J = this.config.indexOfVectorLayer(za);
					if (-1 === J)
						return null;
					for (var F = !1, Z = 0; Z < c.length; Z++) {
						var h =
							this.config.indexOfVectorLayer(c[Z]);
						if (J === h) {
							F = !0;
							break
						}
					}
					if (F)
						return this.getVectorLayer(b, za, T)
				} else
					return this.getVectorLayer(b, za, T);
			else if ("number" === typeof za && !(0 > za || za >= c.length))
				return this.getVectorLayer(b, c[za], T);
			return null
		},
		switchTileLayer: function (b) {
			if (this.getTileLayerNames() && b) {
				var c = this.containerMap.getLayerByName(b);
				if (!c) {
					var za = this.getTileLayer(b);
					za ? (c && this.containerMap.removeLayer(c), this.containerMap.addLayer(za)) : a.util.Logger.warning("MAPVIEWER_9031", "OM.template.Template",
						b)
				}
			}
		},
		destroy: function () {
			this.containerMap = null
		}
	});
	(function (a) {
		a.lbs.OutputAddress = a.Class.extend({
			initialize: function (a) {
				this.id = a;
				this.edgeId = this.percent = this.side = this.postalAddonCode = this.postalCode = this.country = this.region = this.municipality = this.settlement = this.street = this.houseNumber = this.name = null
			}
		})
	})(a);
	(function (a) {
		a.lbs.Match = a.Class.extend({
			initialize: function (a, b) {
				this.id = a;
				this.sequence = b;
				this.outputAddress = this.srid = this.matchVector = this.errorMessage = this.matchCode = this.latitude =
					this.longitude = null
			},
			getErrorMessage: function () {
				return this.errorMessage
			},
			setErrorMessage: function (a) {
				this.errorMessage = a
			},
			getId: function () {
				return this.id
			},
			setId: function (a) {
				this.id = a
			},
			getLatitude: function () {
				return this.latitude
			},
			setLatitude: function (a) {
				this.latitude = a
			},
			getLongitude: function () {
				return this.longitude
			},
			setLongitude: function (a) {
				this.longitude = a
			},
			getMatchCode: function () {
				return this.matchCode
			},
			setMatchCode: function (a) {
				this.matchCode = a
			},
			getMatchVector: function () {
				return this.matchVector
			},
			setMatchVector: function (a) {
				this.matchVector = a
			},
			getSequence: function () {
				return this.sequence
			},
			setSequence: function (a) {
				this.sequence = a
			},
			getOutputAddress: function () {
				return this.outputAddress
			},
			setOutputAddress: function (a) {
				this.outputAddress = a
			},
			getSrid: function () {
				return this.srid
			},
			setSrid: function (a) {
				this.srid = a
			}
		})
	})(a);
	(function (a) {
		a.lbs.GCResult = a.Class.extend({
			initialize: function () {
				this.MATCH_CODE1 = 1;
				this.MATCH_CODE2 = 2;
				this.MATCH_CODE3 = 3;
				this.MATCH_CODE4 = 4;
				this.MATCH_CODE10 = 10;
				this.MATCH_CODE11 = 11
			},
			getId: function () {},
			succeeded: function () {},
			getMatches: function () {}
		})
	})(a);
	(function (a) {
		a.lbs.DefaultGCResult = a.lbs.GCResult.extend({
			initialize: function za(b, c) {
				za.base.call(this);
				this.id = b;
				this.rawResponse = c;
				this.matchCount = 0;
				this.matches = null;
				a.gv.proxyEnabled ? this.parseResult() : this.parseJsonResult()
			},
			getId: function () {
				return this.id
			},
			succeeded: function () {
				return 0 < this.matchCount
			},
			getMatches: function () {
				return this.matches
			},
			parseJsonResult: function () {
				this.matchCount = 0;
				this.matches = null;
				var b = this.rawResponse;
				if (!(a.isNull(b) || (this.matchCount = b.length, 0 >= this.matchCount))) {
					this.matches = [];
					for (var c = 0; c < this.matchCount; c++) {
						var J = {};
						J.longitude = b[c].x;
						J.latitude = b[c].y;
						J.matchCode = b[c].matchCode;
						J.matchVector = b[c].matchVector;
						J.errorMessage = b[c].errorMessage;
						a.notNull(b[c].language) && (J.language = b[c].language);
						var F = {
							name: ""
						};
						F.houseNumber = b[c].houseNumber;
						F.street = b[c].street;
						F.country = b[c].country;
						F.postalCode = b[c].postalCode;
						F.region = b[c].region;
						F.settlement = b[c].settlement;
						F.municipality = b[c].municipality;
						F.side = b[c].side;
						F.percent = b[c].percent;
						F.edgeId = b[c].edgeId;
						J.outputAddress = F;
						a.isNotNull(J) && "not geocoded" != J.errorMessage && this.matches.push(J)
					}
				}
			},
			parseResult: function () {
				this.matchCount = 0;
				this.matches = null;
				var b = this.rawResponse;
				if (!(a.isNull(b) || 7 > b.length)) {
					this.id || (this.id = a.lbs.MetaData.DefaultAddressId);
					var c = '\x3cgeocode id\x3d"' + this.id + '"',
					c = b.indexOf(c),
					J = b.indexOf("\x3c/geocode\x3e", c + 7),
					b = b.substring(c, J);
					if (0 > c)
						return null;
					this.matchCount = this.getAttribute(b, "match_count", 0);
					if (!(0 >=
							this.matchCount))
						for (this.matches = [], c = 0; c < this.matchCount; c++)
							J = this.parseMatch(this.id, c, b), a.isNotNull(J) && this.matches.push(J)
				}
			},
			getAttribute: function (a, b, c) {
				b += '\x3d"';
				c = a.indexOf(b, c);
				var F = a.indexOf('"', c + b.length);
				return a.substring(c + b.length, F)
			},
			parseMatch: function (b, c, J) {
				var F = J.indexOf('\x3cmatch sequence\x3d"' + c + '"');
				if (0 > F)
					return null;
				var Z = J.indexOf("\x3c/match\x3e", F + 7);
				J = J.substring(F, Z);
				c = new a.lbs.Match(b, c);
				F = Number(this.getAttribute(J, "longitude", 0));
				Z = Number(this.getAttribute(J,
							"latitude", 0));
				c.setLongitude(F);
				c.setLatitude(Z);
				c.setErrorMessage(this.getAttribute(J, "error_message", 0));
				c.setMatchVector(this.getAttribute(J, "match_vector", 0));
				c.setSrid(this.getAttribute(J, "srid", 0));
				F = this.getAttribute(J, "match_code", 0);
				c.setMatchCode(F);
				b = this.parseOutputAddress(b, J);
				c.setOutputAddress(b);
				return c
			},
			parseOutputAddress: function (b, c) {
				var J = c.indexOf("\x3coutput_address");
				if (0 > J)
					return null;
				var F = c.indexOf("/\x3e", J + 1);
				c = c.substring(J, F);
				J = new a.lbs.OutputAddress(b);
				J.name = this.getAttribute(c,
						"name", 0);
				J.houseNumber = this.getAttribute(c, "house_number", 0);
				J.street = this.getAttribute(c, "street", 0);
				J.settlement = this.getAttribute(c, "settlement", 0);
				J.region = this.getAttribute(c, "region", 0);
				J.municipality = this.getAttribute(c, "municipality", 0);
				J.country = this.getAttribute(c, "country", 0);
				J.postalCode = this.getAttribute(c, "postal_code", 0);
				J.postalAddonCode = this.getAttribute(c, "postal_addon_code", 0);
				J.side = this.getAttribute(c, "side", 0);
				J.percent = this.getAttribute(c, "percent", 0);
				J.edgeId = this.getAttribute(c,
						"edge_id", 0);
				return J
			}
		})
	})(a);
	(function (a) {
		a.lbs.MetaData = a.Class.extend({
			initialize: function (a) {
				a ? ("/" == a.substr(a.length - 1, 1) && (a = a.substr(0, a.length - 1)), this.baseURL = a) : this.baseURL = "https://elocation.oracle.com";
				this.mappingUrl = this.baseURL + "/mapviewer";
				this.geocoderUrl = this.baseURL + "/geocoder/gcserver";
				this.elocationLbsUrl = this.baseURL + "/elocation/lbs"
			},
			getElocationLbsUrl: function () {
				return this.elocationLbsUrl
			},
			setElocationLbsUrl: function (a) {
				this.elocationLbsUrl = a
			},
			getGeocoderUrl: function () {
				return this.geocoderUrl
			},
			setGeocoderUrl: function (a) {
				this.geocoderUrl = a
			},
			getMappingUrl: function () {
				return this.mappingUrl
			},
			setMappingUrl: function (a) {
				this.mappingUrl = a
			},
			getRoutingUrl: function () {
				return this.routingUrl
			},
			setRoutingUrl: function (a) {
				this.routingUrl = a
			}
		});
		a.lbs.MetaData.DefaultAddressId = "0"
	})(a);
	(function (a) {
		a.lbs.Geocoder = a.Class.extend({
			initialize: function (b) {
				(this.metaData = b) && b.getGeocoderUrl() && a.gv.proxyEnabled && (this.geocoderUrl = b.getGeocoderUrl());
				b && b.getGeocoderUrl() && !a.gv.proxyEnabled && (this.elocationLbsUrl =
						b.getElocationLbsUrl())
			},
			geocode: function (a, b) {
				var c = this.wrapAddress2Xml(a);
				this.send_geocode(a.id, c, b)
			},
			parseJson: function (b) {
				return a.notNull(b) && a.notNull(b.replace) ? (b = b.replace(/([{,])(?:\s*)([^:"{},]+)(?:\s*):/g, '$1"$2":'), a.$.parseJSON(b)) : null
			},
			batchGeoCode: function (b, c) {
				for (var T = "", J = 0; J < b.length; J++)
					T += this.wrapAddress2Xml(b[J]);
				var F = this.wrapRequests(T);
				a.util.Logger.fine("", "OM.Geocoder.batchGeoCode", "gc batch request\x3d" + F);
				var T = function (F) {
					for (var Z = a.lbs.Geocoder.STATUS_FAILED,
						J = [], Z = 0; Z < b.length; Z++) {
						var T = new a.lbs.DefaultGCResult(b[Z].id, F);
						J.push(T)
					}
					Z = a.lbs.Geocoder.STATUS_OK;
					a.util.Logger.fine("", "OM.Geocoder.batchGeoCode", "gc batch response\x3d" + F);
					a.notNull(c) && c(J, Z)
				},
				Z = this;
				MVXMLHttpRequest = {
					callBack: function (F, J) {
						J = Z.parseJson(J);
						for (var T = a.lbs.Geocoder.STATUS_FAILED, h = [], ma = 0; ma < J.length; ma++)
							1 < J.length && a.notNull(J[ma][0].x) && (T = new a.lbs.DefaultGCResult(b[ma].id, J[ma]), h.push(T));
						T = a.lbs.Geocoder.STATUS_OK;
						a.util.Logger.fine("", "OM.Geocoder.batchGeoCode",
							"gc batch response\x3d" + J);
						for (var ha = document.getElementsByClassName("OMV_XHR_"), ma = 0; ma < ha.length; ma++)
							ha[ma].remove();
						MVXMLHttpRequest.callBack = null;
						a.notNull(c) && (c(h, T), c = null)
					}
				};
				var J = function (b, c, F) {
					"abort" !== F && (c = "URL: " + ha, F && (c += "\nError: " + F), b && b.responseText && (c += "\nResponse : " + b.responseText), a.util.Logger.warning("MAPVIEWER_9014", "OM.lbs.Geocoder.geocode", c))
				},
				h = a.util.HttpRequest,
				F = {
					xml_request: F,
					format: "xml"
				},
				ha;
				a.gv.proxyEnabled ? (ha = this.geocoderUrl, h.send(ha, F, T, "text", J, !0, !0)) :
				(F.format = "JSON", ha = this.elocationLbsUrl, a.util.HttpRequest.sendAsScripts(ha, F, MVXMLHttpRequest.callBack, "JSON", !0))
			},
			batchGeoCodePromise: function (b) {
				var c = this;
				return new Promise(function (T, J) {
					if (a.isNull(b) || !Array.isArray(b))
						return J("Address list is not a valid array.");
					if (0 === b.length)
						return J("Address list is emptry.");
					try {
						for (var F = "", Z = 0; Z < b.length; Z++)
							F += c.wrapAddress2Xml(b[Z]);
						var h = c.wrapRequests(F);
						a.util.Logger.fine("", "OM.Geocoder.batchGeoCode", "gc batch request\x3d" + h);
						F = function (c) {
							for (var F =
									[], za = 0; za < b.length; za++) {
								var Z = new a.lbs.DefaultGCResult(b[za].id, c);
								F.push(Z)
							}
							a.util.Logger.fine("", "OM.Geocoder.batchGeoCode", "gc batch response\x3d" + c);
							a.notNull(F) && 0 < F.length ? T(F) : J("No valid data returned from the geocode server.")
						};
						MVXMLHttpRequest = {
							callBack: function (F, Z) {
								Z = c.parseJson(Z);
								for (var h = [], ma = 0; ma < Z.length; ma++)
									if (1 < Z.length && a.notNull(Z[ma][0].x)) {
										var ha = new a.lbs.DefaultGCResult(b[ma].id, Z[ma]);
										h.push(ha)
									}
								a.util.Logger.fine("", "OM.Geocoder.batchGeoCode", "gc batch response\x3d" +
									Z);
								ha = document.getElementsByClassName("OMV_XHR_");
								for (ma = 0; ma < ha.length; ma++)
									ha[ma].remove();
								MVXMLHttpRequest.callBack = null;
								a.notNull(h) && 0 < h.length ? T(h) : J("No valid data returned from the geocode server.")
							}
						};
						var Z = function (b, c, F) {
							"abort" !== F && (c = "URL: " + ra, F && (c += "\nError: " + F), b && b.responseText && (c += "\nResponse : " + b.responseText), a.util.Logger.warning("MAPVIEWER_9014", "OM.lbs.Geocoder.geocode", c), J(c))
						},
						ha = a.util.HttpRequest,
						h = {
							xml_request: h,
							format: "xml"
						},
						ra;
						a.gv.proxyEnabled ? (ra = c.geocoderUrl,
							ha.send(ra, h, F, "text", Z, !0, !0)) : (h.format = "JSON", ra = c.elocationLbsUrl, a.util.HttpRequest.sendAsScripts(ra, h, MVXMLHttpRequest.callBack, "JSON", !0))
					} catch (Ba) {
						J(Ba)
					}
				})
			},
			reverseGeocode: function (b, c, T) {
				b = this.wrapLatLon2Xml(b, c);
				this.send_geocode(a.lbs.MetaData.DefaultAddressId, b, T)
			},
			reverseGeocodePoint: function (b, c) {
				if (!a.isNull(b)) {
					var T = this,
					J = b.getSRID();
					8307 === J || 4326 === J ? this.reverseGeocode(b.getX(), b.getY(), c) : b.transform(8307, function (a) {
						T.reverseGeocode(a.getX(), a.getY(), c)
					})
				}
			},
			send_geocode: function (b,
				c, T) {
				var J = this.wrapRequests(c);
				c = function (c) {
					var F = a.lbs.Geocoder.STATUS_FAILED;
					c = new a.lbs.DefaultGCResult(b, c);
					F = a.lbs.Geocoder.STATUS_OK;
					a.notNull(T) && T(c, F)
				};
				var F = this;
				MVXMLHttpRequest = {
					callBack: function (b, c) {
						c = F.parseJson(c);
						var za = a.lbs.Geocoder.STATUS_FAILED,
						Z = new a.lbs.DefaultGCResult(b, c),
						za = a.lbs.Geocoder.STATUS_OK;
						a.notNull(T) && T(Z, za)
					}
				};
				var Z = function (b, c, F) {
					"abort" !== F && (c = "URL: " + ha, F && (c += "\nError: " + F), b && b.responseText && (c += "\nResponse : " + b.responseText), a.util.Logger.warning("MAPVIEWER_9014",
							"OM.lbs.Geocoder.geocode", c))
				},
				h = a.util.HttpRequest,
				J = {
					xml_request: J,
					format: "xml"
				},
				ha;
				a.gv.proxyEnabled ? (ha = this.geocoderUrl, h.send(ha, J, c, "text", Z, !0, !0)) : (J.format = "JSON", ha = this.elocationLbsUrl, a.util.HttpRequest.sendAsScripts(ha, J, MVXMLHttpRequest.callBack, "JSON", !0))
			},
			wrapAddress2Xml: function (b) {
				return b instanceof a.lbs.Address ? b.toXmlString() : (new a.lbs.Address(b)).toXmlString()
			},
			wrapLatLon2Xml: function (a, b) {
				var c;
				c = "\x3cinput_location " + ('longitude\x3d"' + a + '" ') + ('latitude\x3d"' + b + '"');
				return c +=
				"/\x3e"
			},
			wrapRequests: function (a) {
				var b;
				b = '\x3c?xml version\x3d"1.0" standalone\x3d"yes"?\x3e\n\x3cgeocode_request vendor\x3d"oracle"\x3e\n\x3caddress_list\x3e\n';
				b += a;
				b += "\x3c/address_list\x3e\n";
				return b += "\x3c/geocode_request\x3e"
			}
		});
		a.lbs.Geocoder.MATCH_MODE_EXACT = "EXACT";
		a.lbs.Geocoder.MATCH_MODE_RELAX_STREET_TYPE = "RELAX_STREET_TYPE";
		a.lbs.Geocoder.MATCH_MODE_RELAX_POI_NAME = "RELAX_POI_NAME";
		a.lbs.Geocoder.MATCH_MODE_RELAX_HOUSE_NUMBER = "RELAX_HOUSE_NUMBER";
		a.lbs.Geocoder.MATCH_MODE_RELAX_BASE_NAME =
			"RELAX_BASE_NAME";
		a.lbs.Geocoder.MATCH_MODE_RELAX_POSTAL_CODE = "RELAX_POSTAL_CODE";
		a.lbs.Geocoder.MATCH_MODE_RELAX_BUILTUP_AREA = "RELAX_BUILTUP_AREA";
		a.lbs.Geocoder.MATCH_MODE_RELAX_ALL = "RELAX_ALL";
		a.lbs.Geocoder.MATCH_MODE_DEFAULT = "RELAX_POSTAL_CODE";
		a.lbs.Geocoder.STATUS_FAILED = 0;
		a.lbs.Geocoder.STATUS_OK = 1
	})(a);
	(function (a) {
		a.lbs.Address = a.Class.extend({
			initialize: function (b) {
				this.id = a.lbs.MetaData.DefaultAddressId;
				this.address = "";
				this.country = "US";
				this.matchMode = a.lbs.Geocoder.MATCH_MODE_DEFAULT;
				b && (b.id && (this.id = b.id), b.address && (this.address = b.address), b.country && (this.country = b.country), b.matchMode && (this.matchMode = b.matchMode))
			},
			toXmlString: function () {
				for (var a = "", b = this.address.split(","), a = a + ('\x3cinput_location id\x3d"' + this.id + '"\x3e\x3cinput_address match_mode\x3d"' + this.matchMode + '"\x3e\x3cunformatted country\x3d"' + this.country + '"\x3e'), c = 0; c < b.length; c++)
					a += '\x3caddress_line value \x3d"' + b[c] + '"/\x3e';
				return a + "\x3c/unformatted\x3e\x3c/input_address\x3e\x3c/input_location\x3e"
			},
			getStreetLine: function (b) {
				if (!b.houseNumber)
					return b.street ? b.street : null;
				var c = b.country;
				return a.isNull(c) || "US" == c || "AD" == c || "AU" == c || "CA" == c || "FR" == c || "GB" == c || "IE" == c || "LU" == c || "MC" == c || "NZ" == c || "PR" == c ? b.houseNumber + " " + b.street : b.street + " " + b.houseNumber
			},
			getLocalityLine: function (b) {
				var c = b.country,
				h = !1;
				!a.notNull(c) || "AT" != c && "BE" != c && "DK" != c && "FI" != c && "FR" != c && "DE" != c && "IT" != c && "LI" != c && "LU" != c && "MC" != c && "NL" != c && "NO" != c && "PT" != c && "SM" != c && "ES" != c && "SE" != c && "CH" != c || (h = !0);
				var J = !1;
				if (a.isNull(c) ||
					"US" == c || "AU" == c || "CA" == c)
					J = !0;
				c = "";
				b.settlement && (c += b.settlement);
				b.municipality && b.municipality != b.settlement && (c += (0 < c.length ? ", " : "") + b.municipality);
				J && b.region && (c += (0 < c.length ? ", " : "") + b.region);
				a.notNull(b.postalCode) && (c = h ? b.postalCode + " " + c : c + " " + b.postalCode);
				return "" === c ? null : c
			}
		})
	})(a);
	(function (a) {
		a.lbs.GdfFormAddress = a.lbs.Address.extend({
			initialize: function za(a) {
				za.base.call(this, a);
				this.postalAddonCode = this.postalCode = this.order1Area = this.order2Area = this.order8Area = this.builtupArea =
					this.intersectingStreet = this.street = this.name = "";
				this.country = "US";
				a && (this.name = a.name, this.street = a.street, this.intersectingStreet = a.intersectingStreet, this.builtupArea = a.builtupArea, this.order8Area = a.order8Area, this.order2Area = a.order2Area, this.order1Area = a.order1Area, this.postalCode = a.postalCode, this.postalAddonCode = a.postalAddonCode, a.country && (this.country = a.country))
			},
			toXmlString: function () {
				var a;
				a = "" + ('\x3cinput_location id\x3d"' + this.id + '"\x3e\x3cinput_address match_mode\x3d"' + this.matchMode +
						'"\x3e\x3cgdf_form ');
				this.name && (a += 'name \x3d"' + this.name + '" ');
				this.street && (a += 'street \x3d"' + this.street + '" ');
				this.intersectingStreet && (a += 'intersecting_street \x3d"' + this.intersectingStreet + '" ');
				this.builtupArea && (a += 'builtup_area \x3d"' + this.builtupArea + '" ');
				this.order8Area && (a += 'order8_area \x3d"' + this.order8Area + '" ');
				this.order2Area && (a += 'order2_area \x3d"' + this.order2Area + '" ');
				this.order1Area && (a += 'order1_area \x3d"' + this.order1Area + '" ');
				this.country && (a += 'country \x3d"' + this.country +
					'" ');
				this.postalCode && (a += 'postal_code \x3d"' + this.postalCode + '" ');
				this.postalAddonCode && (a += 'postal_addon_code \x3d"' + this.postalAddonCode + '" ');
				return a + "/\x3e\x3c/input_address\x3e\x3c/input_location\x3e"
			}
		})
	})(a);
	(function (a) {
		a.lbs.GenFormAddress = a.lbs.Address.extend({
			initialize: function za(a) {
				za.base.call(this, a);
				this.postalAddonCode = this.postalCode = this.region = this.city = this.subArea = this.intersectingStreet = this.street = this.name = "";
				this.country = "US";
				a && (this.name = a.name, this.street = a.street,
					this.intersectingStreet = a.intersectingStreet, this.subArea = a.subArea, this.city = a.city, this.region = a.region, this.postalCode = a.postalCode, this.postalAddonCode = a.postalAddonCode, a.country && (this.country = a.country))
			},
			toXmlString: function () {
				var a;
				a = "" + ('\x3cinput_location id\x3d"' + this.id + '"\x3e\x3cinput_address match_mode\x3d"' + this.matchMode + '"\x3e\x3cgen_form ');
				this.name && (a += 'name \x3d"' + this.name + '" ');
				this.street && (a += 'street \x3d"' + this.street + '" ');
				this.intersectingStreet && (a += 'intersecting_street \x3d"' +
					this.intersectingStreet + '" ');
				this.subArea && (a += 'sub_area \x3d"' + this.subArea + '" ');
				this.city && (a += 'city \x3d"' + this.city + '" ');
				this.region && (a += 'region \x3d"' + this.region + '" ');
				this.country && (a += 'country \x3d"' + this.country + '" ');
				this.postalCode && (a += 'postal_code \x3d"' + this.postalCode + '" ');
				this.postalAddonCode && (a += 'postal_addon_code \x3d"' + this.postalAddonCode + '" ');
				return a + "/\x3e\x3c/input_address\x3e\x3c/input_location\x3e"
			}
		})
	})(a);
	(function (a) {
		a.lbs.USForm1Address = a.lbs.Address.extend({
			initialize: function za(a) {
				za.base.call(this,
					a);
				this.lastline = this.intersectingStreet = this.street = this.name = "";
				a && (this.name = a.name, this.street = a.street, this.intersectingStreet = a.intersectingStreet, this.lastline = a.lastline)
			},
			toXmlString: function () {
				var a;
				a = "" + ('\x3cinput_location id\x3d"' + this.id + '"\x3e\x3cinput_address match_mode\x3d"' + this.matchMode + '"\x3e\x3cus_form1 ');
				this.name && (a += 'name \x3d"' + this.name + '" ');
				this.street && (a += 'street \x3d"' + this.street + '" ');
				this.intersectingStreet && (a += 'intersecting_street \x3d"' + this.intersectingStreet +
					'" ');
				this.lastline && (a += 'lastline \x3d"' + this.lastline + '" ');
				return a + "/\x3e\x3c/input_address\x3e\x3c/input_location\x3e"
			}
		})
	})(a);
	(function (a) {
		a.lbs.USForm2Address = a.lbs.Address.extend({
			initialize: function za(a) {
				za.base.call(this, a);
				this.zipCode = this.state = this.city = this.intersectingStreet = this.street = this.name = "";
				a && (this.name = a.name, this.street = a.street, this.intersectingStreet = a.intersectingStreet, this.city = a.city, this.state = a.state, this.zipCode = a.zipCode)
			},
			toXmlString: function () {
				var a;
				a = "" + ('\x3cinput_location id\x3d"' +
						this.id + '"\x3e\x3cinput_address match_mode\x3d"' + this.matchMode + '"\x3e\x3cus_form2 ');
				this.name && (a += 'name \x3d"' + this.name + '" ');
				this.street && (a += 'street \x3d"' + this.street + '" ');
				this.intersectingStreet && (a += 'intersecting_street \x3d"' + this.intersectingStreet + '" ');
				this.city && (a += 'city \x3d"' + this.city + '" ');
				this.state && (a += 'state \x3d"' + this.state + '" ');
				this.zipCode && (a += 'zip_code \x3d"' + this.zipCode + '" ');
				return a + "/\x3e\x3c/input_address\x3e\x3c/input_location\x3e"
			}
		})
	})(a);
	(function (a) {
		a.lbs.UnformatedAddress =
			a.lbs.Address.extend({
				initialize: function (b) {
					this.id = a.lbs.MetaData.DefaultAddressId;
					this.address = "";
					this.country = "US";
					this.matchMode = "relax_street_type";
					b && (b.id && (this.id = b.id), b.address && (this.address = b.address), b.country && (this.country = b.country), b.matchMode && (this.matchMode = b.matchMode))
				},
				toXmlString: function () {
					for (var a = "", b = this.address.split(","), a = a + ('\x3cinput_location id\x3d"' + this.id + '"\x3e\x3cinput_address match_mode\x3d"' + this.matchMode + '"\x3e\x3cunformatted country\x3d"' + this.country +
								'"\x3e'), c = 0; c < b.length; c++)
						a += '\x3caddress_line value \x3d"' + b[c] + '"/\x3e';
					return a + "\x3c/unformatted\x3e\x3c/input_address\x3e\x3c/input_location\x3e"
				}
			})
	})(a);
	a.edit.EditChangeEvent = a.Class.extend({
		initialize: function (b) {
			var c = a.edit.EditChangeEvent;
			this.eventType = c.NO_EVENT;
			this.updateType = c.NO_UPDATE;
			this.oldChange = this.currentChange = this.feature = this.key = null;
			this.isModifiedFeature = this.isNewFeature = !1;
			a.notNull(b) && (a.notNull(b.eventType) && (this.eventType = b.eventType), a.notNull(b.updateType) &&
				(this.updateType = b.updateType), a.notNull(b.key) && (this.key = b.key), a.notNull(b.feature) && (this.feature = b.feature), a.notNull(b.currentChange) && (this.currentChange = b.currentChange), a.notNull(b.oldChange) && (this.oldChange = b.oldChange), a.notNull(b.isNewFeature) && (this.isNewFeature = b.isNewFeature), a.notNull(b.isModifiedFeature) && (this.isModifiedFeature = b.isModifiedFeature))
		},
		getEventType: function () {
			return this.eventType
		},
		getUpdateType: function () {
			return this.updateType
		},
		getKey: function () {
			return this.key
		},
		getFeature: function () {
			return this.feature
		},
		getCurrentChange: function () {
			return this.currentChange
		},
		getOldChange: function () {
			return this.oldChange
		},
		isNewFeature: function () {
			return this.isNewFeature
		},
		isModifiedFeature: function () {
			return this.isModifiedFeature
		}
	});
	a.edit.EditChangeEvent.NO_EVENT = 0;
	a.edit.EditChangeEvent.NEW_EVENT = 1;
	a.edit.EditChangeEvent.UPDATE_EVENT = 2;
	a.edit.EditChangeEvent.REMOVE_EVENT = 3;
	a.edit.EditChangeEvent.NO_UPDATE = 0;
	a.edit.EditChangeEvent.SPATIAL_UPDATE = 1;
	a.edit.EditChangeEvent.ATTRIBUTE_UPDATE =
		2;
	a.edit.EditChangeManager = a.Class.extend({
		initialize: function (b) {
			this.layer = a.notNull(b) ? b.layer : null;
			this.newFeatures = {};
			this.removedFeatures = {};
			this.modifiedFeatures = {};
			this.updateChanges = {}
		},
		addFeature: function (b, c) {
			if (a.isNull(this.layer) || a.isNull(b) || a.isNull(c))
				return null;
			this.layer.addFeature(c);
			this.newFeatures[b] = c;
			var h = a.edit.EditChangeEvent;
			return new a.edit.EditChangeEvent({
				eventType: h.NEW_EVENT,
				updateType: h.NO_UPDATE,
				key: b,
				feature: c,
				currentChange: c,
				oldChange: null,
				isNewFeature: !0,
				isModifiedFeature: !1
			})
		},
		removeFeature: function (b, c) {
			if (a.isNull(this.layer) || a.isNull(b) || a.isNull(c))
				return null;
			this.layer.removeFeature(c);
			var h = !1,
			T = !1;
			a.notNull(this.newFeatures[b]) ? (h = !0, delete this.newFeatures[b]) : (this.removedFeatures[b] = c, a.notNull(this.modifiedFeatures[b]) && (delete this.modifiedFeatures[b], T = !0));
			var J = a.edit.EditChangeEvent;
			return new a.edit.EditChangeEvent({
				eventType: J.REMOVE_EVENT,
				updateType: J.NO_UPDATE,
				key: b,
				feature: c,
				currentChange: null,
				oldChange: c,
				isNewFeature: h,
				isModifiedFeature: T
			})
		},
		updateFeature: function (b, c, h, T) {
			if (a.isNull(this.layer) || a.isNull(b))
				return null;
			var J = null,
			F = a.edit.EditChangeEvent;
			if (T === F.SPATIAL_UPDATE)
				J = c.geo, c.geo = h;
			else if (T === F.ATTRIBUTE_UPDATE) {
				if (J = {}, a.notNull(h))
					for (var Z in h)
						h.hasOwnProperty(Z) && (J[Z] = c.getAttributeValue(Z), a.isNull(c.attributes) && (c.attributes = {}), c.attributes[Z] = h[Z])
			} else
				return null;
			var ma = !1;
			Z = !1;
			a.isNull(this.newFeatures[b]) ? (a.notNull(this.modifiedFeatures[b]) && (Z = !0), this.modifiedFeatures[b] = c) : (ma = !0, this.newFeatures[b] =
					c);
			Z = new a.edit.EditChangeEvent({
				eventType: F.UPDATE_EVENT,
				updateType: T,
				key: b,
				feature: c,
				currentChange: h,
				oldChange: J,
				isNewFeature: ma,
				isModifiedFeature: Z
			});
			!1 === ma && (ma = this.updateChanges[b], a.isNull(ma) && (ma = [], this.updateChanges[b] = ma), ma.push(Z));
			a.notNull(this.layer.rtree) && T === F.SPATIAL_UPDATE && (a.notNull(J) && (b = J.getMBR(), a.notNull(b) && (this.layer.removeFromRtree(c), delete this.layer.segmentRtree[c.id])), a.notNull(h) && (h = h.getMBR(), a.notNull(h) && this.layer.addToRtree(c)));
			return Z
		},
		getNewFeatures: function () {
			var a =
				[],
			b;
			for (b in this.newFeatures)
				this.newFeatures.hasOwnProperty(b) && a.push(this.newFeatures[b]);
			return a
		},
		getRemovedFeatures: function () {
			var a = [],
			b;
			for (b in this.removedFeatures)
				this.removedFeatures.hasOwnProperty(b) && a.push(this.removedFeatures[b]);
			return a
		},
		getModifiedFeatures: function () {
			var a = [],
			b;
			for (b in this.modifiedFeatures)
				this.modifiedFeatures.hasOwnProperty(b) && a.push(this.modifiedFeatures[b]);
			return a
		},
		hasChanges: function () {
			for (var a in this.newFeatures)
				if (this.newFeatures.hasOwnProperty(a))
					return !0;
			for (a in this.removedFeatures)
				if (this.removedFeatures.hasOwnProperty(a))
					return !0;
			for (a in this.modifiedFeatures)
				if (this.modifiedFeatures.hasOwnProperty(a))
					return !0;
			return !1
		},
		hasSpatialAttributeChanged: function (b) {
			if (a.isNull(b) || a.isNull(this.modifiedFeatures[b]))
				return !1;
			b = this.updateChanges[b];
			if (a.isNull(b))
				return !1;
			for (var c = a.edit.EditChangeEvent, h = b.length, T = 0; T < h; T++)
				if (b[T].getUpdateType() === c.SPATIAL_UPDATE)
					return !0;
			return !1
		},
		getChangedAttributesOfModifiedFeature: function (b) {
			if (a.isNull(b))
				return null;
			if (a.isNull(this.modifiedFeatures[b]))
				return !1;
			b = this.updateChanges[b];
			if (a.isNull(b))
				return !1;
			for (var c = [], h = a.edit.EditChangeEvent, T = b.length, J = 0; J < T; J++)
				if (b[J].getUpdateType() === h.ATTRIBUTE_UPDATE) {
					var F = b[J].getCurrentChange();
					if (!a.isNull(F))
						for (var Z in F)
							if (F.hasOwnProperty(Z)) {
								for (var ma = !1, ha = 0; ha < c.length; ha++)
									if (c[ha] == Z) {
										ma = !0;
										break
									}
								!1 === ma && c.push(Z)
							}
				}
			return c
		},
		undo: function (b) {
			if (!a.isNull(b)) {
				var c = b.key,
				h = b.eventType,
				T = a.edit.EditChangeEvent;
				if (h === T.NEW_EVENT)
					this.layer.removeFeature(b.currentChange),
					delete this.newFeatures[c], a.notNull(this.layer.rtree) && a.notNull(b.currentChange.geo) && (c = b.currentChange.geo.getMBR(), a.notNull(c) && (this.layer.removeFromRtree(b.currentChange), delete this.layer.segmentRtree[b.currentChange.id]));
				else if (h === T.UPDATE_EVENT) {
					h = b.updateType;
					if (h === T.SPATIAL_UPDATE) {
						if (a.isNull(b.feature))
							return;
						b.feature.setGeometry(b.oldChange)
					} else if (h === T.ATTRIBUTE_UPDATE && a.notNull(b.oldChange))
						for (var J in b.oldChange)
							b.oldChange.hasOwnProperty(J) && (b.feature.attributes[J] =
									b.oldChange[J]);
					!1 === b.isNewFeature && (J = this.updateChanges[c], a.notNull(J) && 0 < J.length && (J.pop(), 0 === J.length && delete this.updateChanges[c]), !1 === b.isModifiedFeature && delete this.modifiedFeatures[c]);
					a.notNull(this.layer.rtree) && h === T.SPATIAL_UPDATE && (a.notNull(b.currentChange) && (c = b.currentChange.getMBR(), a.notNull(c) && (this.layer.removeFromRtree(b.feature), delete this.layer.segmentRtree[b.feature.id])), a.notNull(b.oldChange) && (c = b.oldChange.getMBR(), a.notNull(c) && this.layer.addToRtree(b.feature)))
				} else
					h ===
					T.REMOVE_EVENT && (this.layer.addFeature(b.oldChange), !1 === b.isNewFeature ? (delete this.removedFeatures[c], !0 === b.isModifiedFeature && (this.modifiedFeatures[c] = b.oldChange)) : this.newFeatures[c] = b.oldChange, a.notNull(this.layer.rtree) && a.notNull(b.oldChange.geo) && (c = b.oldChange.geo.getMBR(), a.notNull(c) && this.layer.addToRtree(b.oldChange)))
			}
		},
		redo: function (b) {
			if (!a.isNull(b)) {
				var c = b.key,
				h = b.eventType,
				T = a.edit.EditChangeEvent;
				if (h === T.NEW_EVENT)
					this.layer.addFeature(b.currentChange), this.newFeatures[c] =
						b.currentChange, a.notNull(this.layer.rtree) && a.notNull(b.currentChange.geo) && (c = b.currentChange.geo.getMBR(), a.notNull(c) && this.layer.addToRtree(b.currentChange));
				else if (h === T.UPDATE_EVENT) {
					h = b.updateType;
					if (h === T.SPATIAL_UPDATE) {
						if (a.isNull(b.feature))
							return;
						b.feature.setGeometry(b.currentChange)
					} else if (h === T.ATTRIBUTE_UPDATE && a.notNull(b.currentChange))
						for (var J in b.currentChange)
							b.currentChange.hasOwnProperty(J) && (b.feature.attributes[J] = b.currentChange[J]);
					!1 === b.isNewFeature && (J = this.updateChanges[c],
						a.isNull(J) && (J = [], this.updateChanges[c] = J), J.push(b), !1 === b.isModifiedFeature && (this.modifiedFeatures[c] = b.feature));
					a.notNull(this.layer.rtree) && h === T.SPATIAL_UPDATE && (a.notNull(b.oldChange) && (c = b.oldChange.getMBR(), a.notNull(c) && (this.layer.removeFromRtree(b.feature), delete this.layer.segmentRtree[b.feature.id])), a.notNull(b.currentChange) && (c = b.currentChange.getMBR(), a.notNull(c) && this.layer.addToRtree(b.feature)))
				} else
					h === T.REMOVE_EVENT && (this.layer.removeFeature(b.oldChange), !1 === b.isNewFeature ?
						(this.removedFeatures[c] = b.oldChange, !0 === b.isModifiedFeature && delete this.modifiedFeatures[c]) : delete this.newFeatures[c], a.notNull(this.layer.rtree) && a.notNull(b.oldChange.geo) && (c = b.oldChange.geo.getMBR(), a.notNull(c) && (this.layer.removeFromRtree(b.oldChange), delete this.layer.segmentRtree[b.oldChange.id])))
			}
		},
		clearChanges: function () {
			this.newFeatures = {};
			this.removedFeatures = {};
			this.modifiedFeatures = {};
			this.updateChanges = {}
		},
		isNewFeature: function (b) {
			return a.isNotNull(this.newFeatures[b]) ? !0 : !1
		},
		isRemovedFeature: function (b) {
			return a.isNotNull(this.removedFeatures[b]) ? !0 : !1
		},
		isModifiedFeature: function (b) {
			return a.isNotNull(this.modifiedFeatures[b]) ? !0 : !1
		}
	});
	a.edit.GeometrySegment = a.Class.extend({
		initialize: function (b) {
			var c = a.edit.GeometrySegment;
			this.subElemIndex = this.elemIndex = this.segIndex = -1;
			this.segType = c.UNDEFINED_TYPE;
			a.notNull(b) && (a.notNull(b.segIndex) && (this.segIndex = b.segIndex), a.notNull(b.elemIndex) && (this.elemIndex = b.elemIndex), a.notNull(b.subElemIndex) && (this.subElemIndex = b.subElemIndex),
				a.notNull(b.segType) && (this.segType = b.segType))
		},
		getSegmentIndex: function () {
			return this.segIndex
		},
		setSegmentIndex: function (a) {
			this.segIndex = a
		},
		getElementIndex: function () {
			return this.elemIndex
		},
		setElementIndex: function (a) {
			this.elemIndex = a
		},
		getSubElementIndex: function () {
			return this.subElemIndex
		},
		setSubElementIndex: function (a) {
			this.subElemIndex = a
		},
		getSegmentType: function () {
			return this.segType
		},
		setSegmentType: function (a) {
			this.segType = a
		}
	});
	a.edit.GeometrySegment.UNDEFINED_TYPE = 0;
	a.edit.GeometrySegment.POINT_TYPE =
		1;
	a.edit.GeometrySegment.LINE_TYPE = 2;
	a.edit.GeometrySegment.RECTANGLE_TYPE = 3;
	a.edit.GeometrySegment.ARC_TYPE = 4;
	a.edit.GeometrySegment.CIRCLE_TYPE = 5;
	a.edit.GeometrySegmentPoint = a.Class.extend({
		initialize: function (b) {
			var c = a.edit.GeometrySegmentPoint;
			this.point = this.segment = this.feature = null;
			this.pointLocation = c.UNDEFSEG_POINT;
			a.notNull(b) && (a.notNull(b.feature) && (this.feature = b.feature), a.notNull(b.segment) && (this.segment = b.segment), a.notNull(b.point) && (this.point = b.point), a.notNull(b.pointLocation) &&
				(this.pointLocation = b.pointLocation))
		},
		getFeature: function () {
			return this.feature
		},
		setFeature: function (a) {
			this.feature = a
		},
		getGeometrySegment: function () {
			return this.segment
		},
		setGeometrySegment: function (a) {
			this.segment = a
		},
		getPoint: function () {
			return this.point
		},
		setPoint: function (a) {
			this.point = a
		},
		getPointLocation: function () {
			return this.pointLocation
		},
		setPointLocation: function (a) {
			this.pointLocation = a
		}
	});
	a.edit.GeometrySegmentPoint.UNDEFSEG_POINT = -1;
	a.edit.GeometrySegmentPoint.STARTSEG_POINT = 0;
	a.edit.GeometrySegmentPoint.ENDSEG_POINT =
		1;
	a.edit.GeometrySegmentPoint.MIDSEG_POINT = 2;
	a.edit.GeometrySegmentUtil = a.edit.GeometrySegmentUtil || {};
	a.edit.GeometrySegmentUtil.buildSegmentTree = function (b) {
		if (a.isNull(b))
			return null;
		var c = b.getGeometry();
		if (a.isNull(c))
			return null;
		b = new a.RTree(10);
		var h = c.getType(),
		T = a.edit.GeometrySegment,
		J = c.getMBR();
		if (a.isNull(J))
			return null;
		var F = {
			x: J.minX,
			y: J.minY,
			w: J.maxX - J.minX,
			h: J.maxY - J.minY
		},
		J = c.getDimension();
		switch (h) {
		case "Point":
		case "OrientedPoint":
		case "Rectangle":
			c = new a.edit.GeometrySegment;
			c.setElementIndex(0);
			c.setSegmentIndex(0);
			c.setSubElementIndex(0);
			"Point" === h || "OrientedPoint" === h ? c.setSegmentType(T.POINT_TYPE) : c.setSegmentType(T.RECTANGLE_TYPE);
			b.insert(F, c);
			break;
		case "MultiPoint":
		case "OrientedMultiPoint":
			for (var F = c.coordinates.length, Z = 0; Z < F; Z++) {
				var ma = {
					minX: Number.POSITIVE_INFINITY,
					minY: Number.POSITIVE_INFINITY,
					maxX: Number.NEGATIVE_INFINITY,
					maxY: Number.NEGATIVE_INFINITY
				},
				ma = "MultiPoint" === h ? a.geometry.Geometry.getCoordsMBR(c.coordinates[Z], J, ma) : a.geometry.Geometry.getCoordsMBR([c.coordinates[Z][0],
							c.coordinates[Z][1]], J, ma),
				ha = new a.edit.GeometrySegment;
				ha.setElementIndex(Z);
				ha.setSegmentIndex(0);
				ha.setSubElementIndex(0);
				ha.setSegmentType(T.POINT_TYPE);
				b.insert({
					x: ma.minX,
					y: ma.minY,
					w: ma.maxX - ma.minX,
					h: ma.maxY - ma.minY
				}, ha)
			}
			break;
		case "LineString":
			h = c.coordinates.length;
			for (Z = F = 0; Z < h - J; Z += J) {
				var ha = ma = Number.POSITIVE_INFINITY,
				ra = Number.NEGATIVE_INFINITY,
				Ba = Number.NEGATIVE_INFINITY,
				Ia = new a.edit.GeometrySegment;
				Ia.setElementIndex(0);
				Ia.setSegmentIndex(F++);
				Ia.setSubElementIndex(0);
				Ia.setSegmentType(T.LINE_TYPE);
				ma = Math.min(c.coordinates[Z], c.coordinates[Z + J]);
				ra = Math.max(c.coordinates[Z], c.coordinates[Z + J]);
				ha = Math.min(c.coordinates[Z + 1], c.coordinates[Z + 1 + J]);
				Ba = Math.max(c.coordinates[Z + 1], c.coordinates[Z + 1 + J]);
				b.insert({
					x: ma,
					y: ha,
					w: ra - ma,
					h: Ba - ha
				}, Ia)
			}
			break;
		case "MultiLineString":
			h = c.coordinates.length;
			for (F = 0; F < h; F++)
				for (Z = c.coordinates[F].length, ha = ma = 0; ha < Z - J; ha += J) {
					var Ba = ra = Number.POSITIVE_INFINITY,
					Va = Ia = Number.NEGATIVE_INFINITY,
					Ra = new a.edit.GeometrySegment;
					Ra.setElementIndex(F);
					Ra.setSegmentIndex(ma++);
					Ra.setSubElementIndex(0);
					Ra.setSegmentType(T.LINE_TYPE);
					ra = Math.min(c.coordinates[F][ha], c.coordinates[F][ha + J]);
					Ia = Math.max(c.coordinates[F][ha], c.coordinates[F][ha + J]);
					Ba = Math.min(c.coordinates[F][ha + 1], c.coordinates[F][ha + 1 + J]);
					Va = Math.max(c.coordinates[F][ha + 1], c.coordinates[F][ha + 1 + J]);
					b.insert({
						x: ra,
						y: Ba,
						w: Ia - ra,
						h: Va - Ba
					}, Ra)
				}
			break;
		case "Polygon":
			h = c.coordinates.length;
			for (F = 0; F < h; F++)
				for (Z = c.coordinates[F].length, ha = ma = 0; ha < Z - J; ha += J)
					Ba = ra = Number.POSITIVE_INFINITY, Va = Ia = Number.NEGATIVE_INFINITY,
					Ra = new a.edit.GeometrySegment, Ra.setElementIndex(0), Ra.setSegmentIndex(ma++), Ra.setSubElementIndex(F), Ra.setSegmentType(T.LINE_TYPE), ra = Math.min(c.coordinates[F][ha], c.coordinates[F][ha + J]), Ia = Math.max(c.coordinates[F][ha], c.coordinates[F][ha + J]), Ba = Math.min(c.coordinates[F][ha + 1], c.coordinates[F][ha + 1 + J]), Va = Math.max(c.coordinates[F][ha + 1], c.coordinates[F][ha + 1 + J]), b.insert({
						x: ra,
						y: Ba,
						w: Ia - ra,
						h: Va - Ba
					}, Ra);
			break;
		case "MultiPolygon":
			for (h = c.coordinates.length, F = 0; F < h; F++)
				for (Z = c.coordinates[F].length,
					ma = 0; ma < Z; ma++)
					for (ha = c.coordinates[F][ma].length, Ba = ra = 0; Ba < ha - J; Ba += J) {
						var Va = Ia = Number.POSITIVE_INFINITY,
						db = Ra = Number.NEGATIVE_INFINITY,
						fb = new a.edit.GeometrySegment;
						fb.setElementIndex(F);
						fb.setSegmentIndex(ra++);
						fb.setSubElementIndex(ma);
						fb.setSegmentType(T.LINE_TYPE);
						Ia = Math.min(c.coordinates[F][ma][Ba], c.coordinates[F][ma][Ba + J]);
						Ra = Math.max(c.coordinates[F][ma][Ba], c.coordinates[F][ma][Ba + J]);
						Va = Math.min(c.coordinates[F][ma][Ba + 1], c.coordinates[F][ma][Ba + 1 + J]);
						db = Math.max(c.coordinates[F][ma][Ba +
									1], c.coordinates[F][ma][Ba + 1 + J]);
						b.insert({
							x: Ia,
							y: Va,
							w: Ra - Ia,
							h: db - Va
						}, fb)
					}
		}
		return b
	};
	a.edit.GeometrySegmentUtil.getFeatureSnapPoint = function (b, c, h) {
		if (a.isNull(b) || a.isNull(b.getGeometry()))
			return null;
		var T = null,
		T = a.isNull(c) ? a.edit.GeometrySegmentUtil.buildSegmentTree(b) : c;
		if (a.isNull(T))
			return null;
		c = b.parentLayer;
		if (!a.isNull(c)) {
			c = c.parentMap;
			c = c.getSnapTolerance().value * c.getPixelResolution();
			T = T.search({
				x: h[0] - c,
				y: h[1] - c,
				w: 2 * c,
				h: 2 * c
			});
			if (a.isNull(T) || 0 === T.length)
				return null;
			for (var J = a.edit.GeometrySegment,
				F = a.edit.GeometrySegmentPoint, Z = null, ma = null, ha = null, ra, Ba, Ia, Va = Number.MAX_VALUE, Ra = b.getGeometry(), db = Ra.getDimension(), fb = 0; fb < T.length; fb++) {
				var kb = T[fb];
				if (kb.getSegmentType() === J.POINT_TYPE)
					ra = Ra.getX() - h[0], Ba = Ra.getY() - h[1], Ia = Math.sqrt(ra * ra + Ba * Ba), Ia <= c && Ia < Va && (Va = Ia, Z = kb, ma = [Ra.getX(), Ra.getY()], ha = F.STARTSEG_POINT);
				else if (kb.getSegmentType() === J.LINE_TYPE) {
					ra = kb.getElementIndex();
					Ba = kb.getSegmentIndex();
					var Ab = kb.getSubElementIndex(),
					Ya = Ia = 0,
					hb = 0,
					nb = 0;
					if ("Polygon" === Ra.getType())
						Ia =
							Ra.coordinates[Ab][Ba * db], Ya = Ra.coordinates[Ab][Ba * db + 1], hb = Ra.coordinates[Ab][Ba * db + db], nb = Ra.coordinates[Ab][Ba * db + db + 1];
					else if ("MultiPolygon" === Ra.getType())
						Ia = Ra.coordinates[ra][Ab][Ba * db], Ya = Ra.coordinates[ra][Ab][Ba * db + 1], hb = Ra.coordinates[ra][Ab][Ba * db + db], nb = Ra.coordinates[ra][Ab][Ba * db + db + 1];
					else if ("LineString" === Ra.getType())
						Ia = Ra.coordinates[Ba * db], Ya = Ra.coordinates[Ba * db + 1], hb = Ra.coordinates[Ba * db + db], nb = Ra.coordinates[Ba * db + db + 1];
					else if ("MultiLineString" === Ra.getType())
						Ia = Ra.coordinates[ra][Ba *
								db], Ya = Ra.coordinates[ra][Ba * db + 1], hb = Ra.coordinates[ra][Ba * db + db], nb = Ra.coordinates[ra][Ba * db + db + 1];
					else
						continue;
					ra = a.util.GeomUtil.distanceToSegment(h[0], h[1], Ia, Ya, hb, nb);
					a.notNull(ra) && ra[0] <= c && (Va = ra[0], Z = kb, ha = Math.floor(ra[1]), 0 === ha ? ma = [Ia, Ya] : 1 === ha ? ma = [hb, nb] : (ma = a.util.GeomUtil.getSegmentPoint(h[0], h[1], Ia, Ya, hb, nb), ha = F.MIDSEG_POINT, a.notNull(ma) && (ra = ma[0] - Ia, Ba = ma[1] - Ya, Math.sqrt(ra * ra + Ba * Ba) <= c ? (ma = [Ia, Ya], ha = F.STARTSEG_POINT) : (ra = ma[0] - hb, Ba = ma[1] - nb, Math.sqrt(ra * ra + Ba * Ba) <= c && (ma =
											[hb, nb], ha = F.ENDSEG_POINT)))))
				}
			}
			return a.isNull(Z) ? null : new a.edit.GeometrySegmentPoint({
				feature: b,
				segment: Z,
				point: ma,
				pointLocation: ha
			})
		}
	};
	a.edit.GeometrySegmentUtil.getLayerSharedPoints = function (b, c) {
		var h = b.parentLayer;
		if (a.isNull(h) || a.isNull(c) || 0 === h.size())
			return null;
		var T = a.edit.GeometrySegmentUtil.getLayerNearestFeatures(h, c);
		if (a.isNull(T))
			return null;
		for (var J = 0, F = T.length; J < F; J++)
			if (b.id === T[J].id) {
				T.splice(J, 1);
				break
			}
		return a.isNull(T) ? null : a.edit.GeometrySegmentUtil.findSharedPoints(h,
			T, c)
	};
	a.edit.GeometrySegmentUtil.getLayerSnapPoint = function (b, c, h) {
		if (a.isNull(b) || a.isNull(c) || 0 === b.size())
			return null;
		var T = a.edit.GeometrySegmentUtil.getLayerNearestFeatures(b, c);
		if (a.isNull(T))
			return null;
		if (h && h.excludeFeature) {
			h = h.excludeFeature;
			for (var J = 0, F = T.length; J < F; J++)
				if (h.id === T[J].id) {
					T.splice(J, 1);
					break
				}
		}
		return a.isNull(T) ? null : a.edit.GeometrySegmentUtil.findSnapPoint(b, T, c)
	};
	a.edit.GeometrySegmentUtil.getLayerNearestFeatures = function (b, c) {
		if (a.isNull(b) || a.isNull(c) || 0 === b.size())
			return null;
		var h = b.parentMap;
		if (a.isNull(h))
			return null;
		var T = h.getSnapTolerance().value,
		h = h.getPixelResolution(),
		T = T * h;
		return b.searchFeatures({
			x: c[0] - T,
			y: c[1] - T,
			w: 2 * T,
			h: 2 * T
		})
	};
	a.edit.GeometrySegmentUtil.findSnapPoint = function (b, c, h) {
		if (a.isNull(b) || a.isNull(c) || a.isNull(h) || 0 === b.size())
			return null;
		var T = b.parentMap;
		if (a.isNull(T))
			return null;
		if (b.featureArray[0].geo && "Point" === b.featureArray[0].geo.type)
			for (b = 0; b < c.length; b += 1) {
				if (!c[b].selected)
					return c = c[b], b = c.getGeometry(), new a.edit.GeometrySegmentPoint({
						feature: c,
						segment: null,
						point: [b.getX(), b.getY()],
						pointLocation: 0
					})
			}
		else {
			for (var J = T.getSnapTolerance().value, T = T.getPixelResolution(), J = J * T, T = null, F = 0; F < c.length; F++) {
				var Z = b.segmentRtree[c[F].id];
				if (a.isNull(Z))
					if (Z = a.edit.GeometrySegmentUtil.buildSegmentTree(c[F]), a.isNull(Z))
						continue;
					else
						b.segmentRtree[c[F].id] = Z;
				Z = a.edit.GeometrySegmentUtil.getFeatureSnapPoint(c[F], Z, h);
				if (!a.isNull(Z)) {
					var ma = Z.getPoint();
					if (null !== ma) {
						var ha = h[0] - ma[0],
						ma = h[1] - ma[1],
						ha = Math.sqrt(ha * ha + ma * ma);
						ha < J && (J = ha, T = Z)
					}
				}
			}
			return T
		}
	};
	a.edit.GeometrySegmentUtil.findSharedPoints = function (b, c, h) {
		if (a.isNull(b) || a.isNull(c) || a.isNull(h) || 0 === b.size())
			return null;
		var T = b.parentMap;
		if (a.isNull(T) || b.featureArray[0].geo && ("Point" === b.featureArray[0].geo.type || "LineString" === b.featureArray[0].geo.type))
			return null;
		for (var J = [], F = T.getSnapTolerance().value, T = T.getPixelResolution(), F = F * T, T = 0; T < c.length; T++) {
			var Z = b.segmentRtree[c[T].id];
			if (a.isNull(Z))
				if (Z = a.edit.GeometrySegmentUtil.buildSegmentTree(c[T]), a.isNull(Z))
					continue;
				else
					b.segmentRtree[c[T].id] =
						Z;
			Z = a.edit.GeometrySegmentUtil.getFeatureSnapPoint(c[T], Z, h);
			if (!a.isNull(Z)) {
				var ma = Z.getPoint();
				if (null !== ma) {
					var ha = h[0] - ma[0],
					ma = h[1] - ma[1];
					Math.sqrt(ha * ha + ma * ma) <= F && J.push(Z)
				}
			}
		}
		return J
	};
	a.edit.GeometrySegmentUtil.getFeatureSnapPointsWithinBox = function (b, c, h) {
		if (a.isNull(b) || a.isNull(h) || a.isNull(b.getGeometry()))
			return null;
		var T = null,
		T = a.isNull(c) ? a.edit.GeometrySegmentUtil.buildSegmentTree(b) : c;
		if (a.isNull(T))
			return null;
		c = T.search(h);
		if (a.isNull(c) || 0 === c.length)
			return null;
		for (var T = a.edit.GeometrySegment,
			J = a.edit.GeometrySegmentPoint, F = b.getGeometry(), Z = F.getDimension(), ma = [], ha = {}, ra = null, Ba = 0; Ba < c.length; Ba++) {
			var Ia = c[Ba],
			Va = Ia.getElementIndex(),
			Ra = Ia.getSegmentIndex(),
			db = Ia.getSubElementIndex();
			if (Ia.getSegmentType() === T.LINE_TYPE) {
				var fb = 0,
				kb = 0,
				Ab = 0,
				Ya = 0;
				if ("Polygon" === F.getType())
					fb = F.coordinates[db][Ra * Z], kb = F.coordinates[db][Ra * Z + 1], Ab = F.coordinates[db][Ra * Z + Z], Ya = F.coordinates[db][Ra * Z + Z + 1];
				else if ("MultiPolygon" === F.getType())
					fb = F.coordinates[Va][db][Ra * Z], kb = F.coordinates[Va][db][Ra * Z +
							1], Ab = F.coordinates[Va][db][Ra * Z + Z], Ya = F.coordinates[Va][db][Ra * Z + Z + 1];
				else if ("LineString" === F.getType())
					fb = F.coordinates[Ra * Z], kb = F.coordinates[Ra * Z + 1], Ab = F.coordinates[Ra * Z + Z], Ya = F.coordinates[Ra * Z + Z + 1];
				else if ("MultiLineString" === F.getType())
					fb = F.coordinates[Va][Ra * Z], kb = F.coordinates[Va][Ra * Z + 1], Ab = F.coordinates[Va][Ra * Z + Z], Ya = F.coordinates[Va][Ra * Z + Z + 1];
				else
					continue;
				ra = "" + Va + ":" + (Ra - 1) + ":" + db + ":" + J.ENDSEG_POINT;
				a.util.GeomUtil.pointInRect(fb, kb, h.x, h.y, h.x + h.w, h.y + h.h) && a.isNull(ha[ra]) && (ra =
						new a.edit.GeometrySegmentPoint, ra.feature = b, ra.segment = Ia, ra.point = [fb, kb], ra.pointLocation = J.STARTSEG_POINT, ma.push(ra), ha["" + Va + ":" + Ra + ":" + db + ":" + J.STARTSEG_POINT] = "*");
				ra = "" + Va + ":" + (Ra + 1) + ":" + db + ":" + J.STARTSEG_POINT;
				a.util.GeomUtil.pointInRect(Ab, Ya, h.x, h.y, h.x + h.w, h.y + h.h) && a.isNull(ha[ra]) && (fb = new a.edit.GeometrySegmentPoint, fb.feature = b, fb.segment = Ia, fb.point = [Ab, Ya], fb.pointLocation = J.ENDSEG_POINT, ma.push(fb), ha["" + Va + ":" + Ra + ":" + db + ":" + J.ENDSEG_POINT] = "*")
			}
		}
		return 0 === ma.length ? null : ma
	};
	a.edit.GeometrySegmentUtil.getLayerSnapPointsWithinBox = function (b, c) {
		if (a.isNull(b) || a.isNull(c))
			return null;
		var h = b.searchFeatures(c);
		if (a.isNull(h) || 0 === h.length)
			return null;
		for (var T = {}, J = 0; J < h.length; J++) {
			var F = [],
			Z = b.segmentRtree[h[J].id];
			if (a.isNull(Z))
				if (Z = a.edit.GeometrySegmentUtil.buildSegmentTree(h[J]), a.isNull(Z))
					continue;
				else
					b.segmentRtree[h[J].id] = Z;
			Z = a.edit.GeometrySegmentUtil.getFeatureSnapPointsWithinBox(h[J], Z, c);
			if (!a.isNull(Z)) {
				for (var ma = 0; ma < Z.length; ma++)
					F.push(Z[ma]);
				T[h[J].id] =
					F
			}
		}
		var h = !1,
		ha;
		for (ha in T)
			if (T.hasOwnProperty(ha)) {
				h = !0;
				break
			}
		return h ? T : null
	};
	a.edit.GeometrySegmentUtil.removeVertexFromGeometry = function (b, c) {
		if (a.isNull(b) || a.isNull(c))
			return !1;
		var h = b.getType();
		if ("Point" === h || "MultiPoint" === h || "OrientedPoint" === h)
			return !1;
		var T = b.getOrdinates();
		if (a.isNull(T))
			return !1;
		var J = c.getGeometrySegment(),
		F = c.getPoint(),
		Z = c.getPointLocation();
		if (a.isNull(J) || a.isNull(F))
			return !1;
		var F = a.edit.GeometrySegment,
		ma = a.edit.GeometrySegmentPoint;
		if (J.getSegmentType() !== F.LINE_TYPE ||
			Z === ma.MIDSEG_POINT)
			return !1;
		var F = J.getElementIndex(),
		ha = J.getSegmentIndex(),
		J = J.getSubElementIndex(),
		ma = b.getDimension(),
		Z = ha * ma + Z * ma,
		ha = 0;
		switch (h) {
		case "LineString":
			ha = T.length / ma;
			if (3 > ha)
				return !1;
			T.splice(Z, ma);
			break;
		case "MultiLineString":
			ha = T[F].length / ma;
			if (3 > ha)
				return !1;
			T[F].splice(Z, ma);
			break;
		case "Polygon":
			ha = T[J].length / ma;
			if (5 > ha)
				return !1;
			T[J].splice(Z, ma);
			break;
		case "MultiPolygon":
			ha = T[F][J].length / ma;
			if (5 > ha)
				return !1;
			T[F][J].splice(Z, ma);
			break;
		default:
			return !1
		}
		b.mbr = null;
		b.getMBR();
		return !0
	};
	a.edit.GeometrySegmentUtil.addVertexToGeometry = function (b, c) {
		if (a.isNull(b) || a.isNull(c))
			return !1;
		var h = b.getType();
		if ("Point" === h || "MultiPoint" === h || "OrientedPoint" === h)
			return !1;
		var T = b.getOrdinates();
		if (a.isNull(T))
			return !1;
		var J = c.getGeometrySegment(),
		F = c.getPoint(),
		Z = c.getPointLocation();
		if (a.isNull(J) || a.isNull(F))
			return !1;
		var ma = a.edit.GeometrySegment,
		ha = a.edit.GeometrySegmentPoint;
		if (J.getSegmentType() !== ma.LINE_TYPE || Z !== ha.MIDSEG_POINT)
			return !1;
		Z = J.getElementIndex();
		ma = J.getSegmentIndex();
		ha = J.getSubElementIndex();
		J = b.getDimension();
		ma *= J;
		switch (h) {
		case "LineString":
			for (h = 0; h < J; h++)
				2 > h ? T.splice(ma + h + J, 0, F[h]) : T.splice(ma + h + J, 0, 0);
			break;
		case "MultiLineString":
			for (h = 0; h < J; h++)
				2 > h ? T[Z].splice(ma + h + J, 0, F[h]) : T[Z].splice(ma + h + J, 0, 0);
			break;
		case "Polygon":
			for (h = 0; h < J; h++)
				2 > h ? T[ha].splice(ma + h + J, 0, F[h]) : T[ha].splice(ma + h + J, 0, 0);
			break;
		case "MultiPolygon":
			for (h = 0; h < J; h++)
				2 > h ? T[Z][ha].splice(ma + h + J, 0, F[h]) : T[Z][ha].splice(ma + h + J, 0, 0);
			break;
		default:
			return !1
		}
		b.mbr = null;
		b.getMBR();
		return !0
	};
	a.edit.GeometrySegmentUtil.moveGeometryVertex =
	function (b, c, h) {
		if (a.isNull(b) || a.isNull(c) || a.isNull(h))
			return !1;
		var T = b.getType();
		if ("Point" === T || "MultiPoint" === T || "OrientedPoint" === T)
			return !1;
		var J = b.getOrdinates();
		if (a.isNull(J))
			return !1;
		var F = c.getGeometrySegment(),
		Z = c.getPoint();
		c = c.getPointLocation();
		if (a.isNull(F) || a.isNull(Z))
			return !1;
		var Z = a.edit.GeometrySegment,
		ma = a.edit.GeometrySegmentPoint;
		if (F.getSegmentType() !== Z.LINE_TYPE || c === ma.MIDSEG_POINT)
			return !1;
		var Z = F.getElementIndex(),
		ma = F.getSegmentIndex(),
		F = F.getSubElementIndex(),
		ha =
			b.getDimension();
		c = ma * ha + c * ha;
		ma = 0;
		switch (T) {
		case "LineString":
			J[c] = h[0];
			J[c + 1] = h[1];
			break;
		case "MultiLineString":
			J[Z][c] = h[0];
			J[Z][c + 1] = h[1];
			break;
		case "Polygon":
			J[F][c] = h[0];
			J[F][c + 1] = h[1];
			0 === c ? (ma = J[F].length, J[F][ma - 2] = h[0], J[F][ma - 1] = h[1]) : c === J[F].length - 2 && (J[F][0] = h[0], J[F][1] = h[1]);
			break;
		case "MultiPolygon":
			J[Z][F][c] = h[0];
			J[Z][F][c + 1] = h[1];
			0 === c ? (ma = J[Z][F].length, J[Z][F][ma - 2] = h[0], J[Z][F][ma - 1] = h[1]) : c === J[Z][F].length - 2 && (J[Z][F][0] = h[0], J[Z][F][1] = h[1]);
			break;
		default:
			return !1
		}
		b.mbr =
			null;
		b.getMBR();
		return !0
	};
	a.edit.GeometrySegmentUtil.removeVertexesFromGeometry = function (b, c) {
		if (a.isNull(b) || a.isNull(c))
			return !1;
		var h = b.getType();
		if ("Point" === h || "MultiPoint" === h || "OrientedPoint" === h)
			return !1;
		var T = b.getOrdinates();
		if (a.isNull(T))
			return !1;
		for (var J = b.getDimension(), F = !1, Z = {}, ma = 0; ma < c.length; ma++) {
			var ha = c[ma].getGeometrySegment(),
			ra = c[ma].getPoint(),
			Ba = c[ma].getPointLocation();
			if (!a.isNull(ha) && !a.isNull(ra)) {
				var ra = a.edit.GeometrySegment,
				Ia = a.edit.GeometrySegmentPoint;
				if (ha.getSegmentType() ===
					ra.LINE_TYPE && Ba !== Ia.MIDSEG_POINT) {
					var ra = ha.getElementIndex(),
					Ia = ha.getSegmentIndex(),
					ha = ha.getSubElementIndex(),
					Ba = Ia * J + Ba * J,
					Va = Ia = 0;
					switch (h) {
					case "LineString":
						Ia = T.length / J;
						if (2 > Ia - c.length)
							break;
						for (; Va != J; )
							T[Ba + Va] = Number.NaN, Va++;
						F = !0;
						break;
					case "MultiLineString":
						for (; Va != J; )
							T[ra][Ba + Va] = Number.NaN, Va++, Z["" + ra] = !0;
						F = !0;
						break;
					case "Polygon":
						for (; Va != J; )
							T[ha][Ba + Va] = Number.NaN, Va++, Z["" + ha] = !0;
						F = !0;
						break;
					case "MultiPolygon":
						for (; Va != J; )
							T[ra][ha][Ba + Va] = Number.NaN, Va++, Z["" + ra + ":" + ha] = !0;
						F =
							!0;
						break;
					default:
						return !1
					}
				}
			}
		}
		if (!F)
			return !1;
		switch (h) {
		case "LineString":
			Z = [];
			for (h = 0; h < T.length; h++)
				isNaN(T[h]) || Z.push(T[h]);
			b.coordinates = Z;
			break;
		case "MultiLineString":
			for (h = 0; h < T.length; h++)
				if (!a.isNull(Z["" + h])) {
					J = [];
					for (F = 0; F < T[h].length; F++)
						isNaN(T[h][F]) || J.push(T[h][F]);
					T[h] = J
				}
			for (Z = 0; Z < T.length; Z++)
				2 > T[Z].length && (T.splice(Z, 1), Z--);
			break;
		case "Polygon":
			for (h = 0; h < T.length; h++)
				if (!a.isNull(Z["" + h])) {
					J = [];
					for (F = 0; F < T[h].length; F++)
						isNaN(T[h][F]) || J.push(T[h][F]);
					T[h] = J
				}
			for (Z = 0; Z < T.length; Z++)
				if (4 >
					T[Z].length) {
					if (0 === Z)
						return !1;
					T.splice(Z, 1);
					Z--
				}
			break;
		case "MultiPolygon":
			for (h = 0; h < T.length; h++)
				for (J = 0; J < T[h].length; J++)
					if (!a.isNull(Z["" + h + ":" + J])) {
						F = [];
						for (ma = 0; ma < T[h][J].length; ma++)
							isNaN(T[h][J][ma]) || F.push(T[h][J][ma]);
						T[h][J] = F
					}
			for (Z = 0; Z < T.length; Z++)
				for (h = 0; h < T[Z].length; h++)
					if (4 > T[Z][h].length)
						if (0 === h) {
							T.splice(Z, 1);
							Z--;
							break
						} else
							T[Z].splice(h, 1), h--
		}
		b.mbr = null;
		b.getMBR();
		return !0
	};
	a.edit.GeometrySegmentUtil.breakLineGeometry = function (b, c) {
		if (a.isNull(b) || a.isNull(c))
			return !1;
		var h =
			b.getType();
		if ("LineString" !== h && "MultiLineString" !== h)
			return !1;
		var T = b.getOrdinates();
		if (a.isNull(T))
			return !1;
		var J = c.getGeometrySegment(),
		F = c.getPoint(),
		Z = c.getPointLocation();
		if (a.isNull(J) || a.isNull(F))
			return !1;
		var ma = a.edit.GeometrySegment,
		ha = a.edit.GeometrySegmentPoint;
		if (J.getSegmentType() !== ma.LINE_TYPE)
			return !1;
		var ra = J.getElementIndex(),
		J = J.getSegmentIndex(),
		Ba = b.getDimension(),
		Ia = -1;
		if (Z !== ha.MIDSEG_POINT)
			if (Ia = J * Ba + Z * Ba, "LineString" === h) {
				if (0 === Ia || Ia === T.length - Ba)
					return !1
			} else {
				if (0 ===
					Ia || Ia === T[ra].length - Ba)
					return !1
			}
		else
			Ia = J * Ba + Ba;
		var J = [],
		ma = [],
		Va = [],
		Ra = null;
		if ("LineString" === h)
			Ra = T;
		else
			for (Ra = T[ra], h = 0; h < T.length; h++)
				h !== ra && J.push(T[h]);
		for (T = 0; T < Ia; T++)
			ma.push(Ra[T]);
		if (Z !== ha.MIDSEG_POINT)
			for (F = 0; F < Ba; F++)
				ma.push(Ra[Ia + F]);
		else
			for (Z = 0; Z < Ba; Z++)
				2 > Z ? (ma.push(F[Z]), Va.push(F[Z])) : (ma.push(0), Va.push(0));
		for (F = Ia; F < Ra.length; F++)
			Va.push(Ra[F]);
		J.push(ma);
		J.push(Va);
		b.type = "MultiLineString";
		b.coordinates = J;
		return !0
	};
	a.edit.GeometrySegmentUtil.splitPolygonGeometry = function (b,
		c, h) {
		if (a.isNull(b) || a.isNull(c) || a.isNull(h))
			return !1;
		var T = b.getType();
		if ("Polygon" !== T && "MultiPolygon" !== T)
			return !1;
		var J = c.length;
		if (0 === J || 0 !== J % 2 || c[0].getGeometrySegment().getElementIndex() !== c[J - 1].getGeometrySegment().getElementIndex())
			return !1;
		var F;
		if (2 < c.length)
			for (F = 1; F < J - 1; F += 2)
				if (c[F].getSubElementIndex() != c[F + 1].getSegment().getSubElementIndex())
					return !1;
		for (F = 0; F < h.length; F++) {
			var Z = h[F];
			if (a.isNull(Z) || 2 > Z.length / 2)
				return !1
		}
		var ma = b.getDimension(),
		Z = c[0].getGeometrySegment().getElementIndex();
		if (-1 === Z)
			return !1;
		var ha = null,
		ha = "Polygon" === T ? b.getOrdinates() : b.getOrdinates()[Z],
		ra = c[0].getPointLocation(),
		Ba = c[J - 1].getPointLocation(),
		Ia = c[0].getGeometrySegment().getSegmentIndex(),
		Va = c[J - 1].getGeometrySegment().getSegmentIndex(),
		Ra = ha[0].length - 1;
		if (c[0].getPoint()[0] === c[J - 1].getPoint()[0] && c[0].getPoint()[1] === c[J - 1].getPoint()[1])
			return !1;
		if (2 < c.length)
			for (F = 1; F < J - 2; F += 2)
				if (c[F].getPoint()[0] === c[F + 1].getPoint()[0] && c[F].getPoint()[1] == c[F + 1].getPoint()[1])
					return !1;
		var db = [],
		fb = a.edit.GeometrySegmentPoint;
		if (2 === c.length)
			db.push(h[0]), db.push(h[0]);
		else
			return !1;
		F = !1;
		var kb = NaN,
		Ab = NaN,
		Ya,
		hb,
		nb;
		Ia === Va && (F = !0, Ya = c[0].getPoint(), h = c[J - 1].getPoint(), hb = ha[Ia * ma], nb = ha[Ia * ma + 1], kb = Ya[0] - hb, Ya = Ya[1] - nb, kb = Math.sqrt(kb * kb + Ya * Ya), hb = h.getX() - hb, h = h.getY() - nb, Ab = Math.sqrt(hb * hb + h * h));
		h = [];
		nb = [];
		Ya = hb = -1;
		hb = 2;
		if (Ia < Va || F && kb < Ab) {
			ra === fb.STARTSEG_POINT ? hb = Ia * ma : ra === fb.ENDSEG_POINT ? hb = (Ia + 1) * ma : (hb = (Ia + 1) * ma, h.push(c[0].getPoint()[0]), h.push(c[0].getPoint()[1]));
			Ba === fb.STARTSEG_POINT || Ba === fb.MIDSEG_POINT ?
			Ya = Va * ma + ma : Ba === fb.ENDSEG_POINT && (Ya = (Va + 1) * ma + ma);
			F && ra === fb.MIDSEG_POINT && Ba === fb.MIDSEG_POINT && (Ya = hb);
			for (F = hb; F < Ya; F += ma)
				h.push(ha[0][F]), h.push(ha[0][F + 1]);
			Ba === fb.MIDSEG_POINT && (h.push(c[J - 1].getPoint()[0]), h.push(c[J - 1].getPoint()[1]));
			F = db[0];
			hb = 2;
			for (kb = F.length - ma; 0 < kb; kb -= hb)
				h.push(F[kb - hb]), h.push(F[kb - hb + 1]);
			Ba === fb.STARTSEG_POINT ? hb = Va * ma : Ba === fb.ENDSEG_POINT ? hb = (Va + 1) * ma : (hb = (Va + 1) * ma, nb.push(c[J - 1].getPoint()[0]), nb.push(c[J - 1].getPoint()[1]));
			Ya = Ra + 1;
			for (F = hb; F < Ya; F += ma)
				nb.push(ha[0][F]),
				nb.push(ha[0][F + 1]);
			ra === fb.STARTSEG_POINT || ra === fb.MIDSEG_POINT ? Ya = Ia * ma + ma : ra === fb.ENDSEG_POINT && (Ya = (Ia + 1) * ma + ma);
			for (F = ma; F < Ya; F += ma)
				nb.push(ha[0][F]), nb.push(ha[0][F + 1]);
			ra === fb.MIDSEG_POINT && (nb.push(c[0].getPoint()[0]), nb.push(c[0].getPoint()[1]));
			F = db[1];
			hb = 2;
			for (c = ma; c < F.length; c += hb)
				nb.push(F[c]), nb.push(F[c + 1])
		} else if (Ia > Va || F && kb > Ab) {
			Ba === fb.STARTSEG_POINT ? hb = Va * ma : Ba === fb.ENDSEG_POINT ? hb = (Va + 1) * ma : (hb = (Va + 1) * ma, h.push(c[J - 1].getPoint()[0]), h.push(c[J - 1].getPoint()[1]));
			ra === fb.STARTSEG_POINT ||
			ra === fb.MIDSEG_POINT ? Ya = Ia * ma + ma : ra === fb.ENDSEG_POINT && (Ya = (Ia + 1) * ma + ma);
			for (F = hb; F < Ya; F += ma)
				h.push(ha[0][F]), h.push(ha[0][F + 1]);
			ra === fb.MIDSEG_POINT && (h.push(c[0].getPoint()[0]), h.push(c[0].getPoint()[1]));
			F = db[0];
			hb = 2;
			for (kb = ma; kb < F.length; kb += hb)
				h.push(F[kb]), h.push(F[kb + 1]);
			ra === fb.STARTSEG_POINT ? hb = Ia * ma : ra === fb.ENDSEG_POINT ? hb = (Ia + 1) * ma : (hb = (Ia + 1) * ma, nb.push(c[0].getPoint()[0]), nb.push(c[0].getPoint()[1]));
			Ya = Ra + 1;
			for (F = hb; F < Ya; F += ma)
				nb.push(ha[0][F]), nb.push(ha[0][F + 1]);
			Ba === fb.STARTSEG_POINT ||
			Ba === fb.MIDSEG_POINT ? Ya = Va * ma + ma : Ba === fb.ENDSEG_POINT && (Ya = (Va + 1) * ma + ma);
			for (F = ma; F < Ya; F += ma)
				nb.push(ha[0][F]), nb.push(ha[0][F + 1]);
			Ba === fb.MIDSEG_POINT && (nb.push(c[J - 1].getPoint()[0]), nb.push(c[J - 1].getPoint()[1]));
			F = db[1];
			hb = 2;
			for (kb = F.length - ma; 0 < kb; kb -= hb)
				nb.push(F[kb - hb]), nb.push(F[kb - hb + 1])
		} else
			return !1;
		c = [];
		J = -1;
		"Polygon" === T ? (J = 1, c[0] = [], c[1] = []) : (J = b.getOrdinates().length, c = b.getOrdinates());
		c[Z] = [h];
		c[J] = [nb];
		b.coordinates = c;
		b.type = "MultiPolygon";
		b.mbr = null;
		b.getMBR();
		return !0
	};
	a.tool.BreakLineTool =
		a.tool.RedlineTool.extend({
			initialize: function Sb(b, c) {
				Sb.base.call(this, b, a.tool.RedlineTool.TYPE_POINT);
				var h = this;
				this.lineFeature = c;
				this.lineElement = -1;
				this.snapSegment = this.snapFeature = this.secondLine = this.firstLine = null;
				a.isNull(this.lineFeature) ? (a.util.Logger.warning("MAPVIEWER_9054", "OM.tool.BreakLineTool.initialize", ""), this.clear()) : (a.notNull(this.lineFeature) && a.notNull(this.lineFeature.getGeometry()) && ("LineString" === this.lineFeature.getGeometry().getType() || "MultiLineString" === this.lineFeature.getGeometry().getType()) ?
					this.lineFeature.editable = !1 : (a.util.Logger.warning("MAPVIEWER_9055", "OM.tool.BreakLineTool.initialize", ""), this.lineFeature = null, this.clear()), a.gv.featureDrag = !1, a.gv.allowFeaturePointsInteraction = !1, this.addListener(a.event.ToolEvent.TOOL_END, this.processPoint), this.snapLayer = new a.layer.VectorLayer("snap_layer_" + Math.random(), {
						def: {
							type: a.layer.VectorLayer.TYPE_LOCAL
						}
					}), this.snapLayerStyle = new a.style.Marker({
						width: 12,
						height: 12,
						vectorDef: [{
								shape: {
									type: "circle",
									x: 0,
									y: 0,
									width: 10,
									height: 10
								},
								style: {
									fill: "#ffffff",
									stroke: "#ff0000",
									strokeThickness: 1
								}
							}
						]
					}), this.snapLayer.setRenderingStyle(this.snapLayerStyle), this.snapLayer.setDisplayFeaturesTaskEnabled(!1), b.addLayer(this.snapLayer), this.addListener(a.event.ToolEvent.SNAP_POINT, function () {
						if (!a.isNull(h.lineFeature)) {
							a.notNull(h.snapFeature) && (h.snapLayer.removeFeature(h.snapFeature), h.snapLayer.redraw(), h.snapFeature = null);
							h.snapPoint = null;
							var b = h._map.getScreenPointLocation(h._map.mLocX, h._map.mLocY);
							if (a.notNull(b)) {
								var c = h._map.getScreenPointLocation(h._map.mLocX -
										3, h._map.mLocY - 3),
								T = b.coordinates[0] - c.coordinates[0],
								c = c.coordinates[1] - b.coordinates[1],
								T = Math.sqrt(T * T + c * c),
								c = [b.coordinates[0], b.coordinates[1]],
								ha = null;
								a.notNull(h.lineFeature.parentLayer) && (ha = h.lineFeature.parentLayer.segmentRtree[h.lineFeature.id], a.isNull(ha) && (ha = a.edit.GeometrySegmentUtil.buildSegmentTree(h.lineFeature), a.notNull(ha) && (h.lineFeature.parentLayer.segmentRtree[h.lineFeature.id] = ha)));
								T = a.edit.GeometrySegmentUtil.getFeatureSnapPoint(h.lineFeature, ha, c, T, !1, !1, !1, !1);
								h.snapSegment =
									null;
								if (a.notNull(T)) {
									var ra = T.getGeometrySegment(),
									c = T.getPointLocation(),
									ha = a.edit.GeometrySegmentPoint,
									Ba = ra.getElementIndex(),
									ra = ra.getSegmentIndex(),
									za = h.lineFeature.getGeometry().getDimension(),
									Va = h.lineFeature.getGeometry().getType(),
									Ra = h.lineFeature.getGeometry().getOrdinates(),
									db = -1;
									if (c !== ha.MIDSEG_POINT)
										if (db = ra * za + c * za, "LineString" === Va) {
											if (0 === db || db === Ra.length - za)
												return
										} else if (0 === db || db === Ra[Ba].length - za)
											return;
									h.snapSegment = T;
									T = T.getPoint();
									b = new a.geometry.Point(T[0], T[1], b.getSRID());
									T = h._map.getScreenLocation(b);
									h.snapPoint = [];
									h.snapPoint.push(T.x);
									h.snapPoint.push(T.y);
									h.snapFeature = new a.Feature("SnapPoint", b, {
										renderingStyle: h.snapLayerStyle
									});
									h.snapLayer.addFeature(h.snapFeature);
									h.snapLayer.redraw()
								}
							}
						}
					}))
			},
			clear: function () {
				a.gv.featureDrag = !0;
				a.gv.allowFeaturePointsInteraction = !0;
				a.notNull(this.snapFeature) && (this.snapLayer.removeFeature(this.snapFeature), this.snapLayer.redraw(), this.snapFeature = null);
				this.finish();
				this.clear_base()
			},
			processPoint: function () {
				this.lineElement =
					-1;
				this.secondLine = this.firstLine = null;
				if (!a.isNull(this.lineFeature)) {
					if (a.notNull(this._geometry) && a.notNull(this.snapSegment)) {
						var b = this.lineFeature.getGeometry().clone(!0);
						if (a.edit.GeometrySegmentUtil.breakLineGeometry(b, this.snapSegment)) {
							this.lineElement = this.snapSegment.getElementIndex;
							var c = b.getOrdinates().length;
							this.firstLine = b.getOrdinates()[c - 2];
							this.secondLine = b.getOrdinates()[c - 1];
							a.notNull(this.lineFeature.parentLayer.changeManager) && (c = this.lineFeature.parentLayer.changeManager.updateFeature(this.lineFeature.id,
										this.lineFeature, b, a.edit.EditChangeEvent.SPATIAL_UPDATE), a.notNull(c) && this.lineFeature.parentLayer.getUndoManager().addEdit({
									feature: this.lineFeature,
									changeManager: this.lineFeature.parentLayer.changeManager,
									editChangeEvent: c,
									canUndo: function () {
										return !0
									},
									canRedo: function () {
										return !0
									},
									getPresentationName: function () {
										return "break line"
									},
									undo: function () {
										this.changeManager.undo(this.editChangeEvent);
										this.feature.deleteEditingProperties();
										this.feature.selected && this.feature.addEditProperties()
									},
									redo: function () {
										this.changeManager.redo(this.editChangeEvent);
										this.feature.deleteEditingProperties();
										this.feature.selected && this.feature.addEditProperties()
									}
								}));
							this.lineFeature.editable = !0;
							this.lineFeature.deleteEditingProperties();
							this.lineFeature.addEditProperties();
							this.lineFeature.setGeometry(b);
							this.lineFeature.parentLayer.selectFeature(this.lineFeature)
						}
					}
					this._map.getToolFeatureLayer().removeFeature(this._points[0])
				}
				this.start()
			}
		});
	a.tool.RemoveVertexesTool = a.tool.RectangleTool.extend({
		initialize: function za(b, c) {
			za.base.call(this, b);
			this.selectedFeature =
				c;
			this.addListener(a.event.ToolEvent.TOOL_END, this.processRectangle);
			this.registerUpdate = function (b, c) {
				a.isNull(b) || a.isNull(c) || a.isNull(this.selectedFeature) || (c === this.selectedFeature ? this.selectedFeature.parentLayer.getUndoManager().addEdit({
						feature: this.selectedFeature,
						changeManager: this.selectedFeature.parentLayer.changeManager,
						editChangeEvent: b,
						canUndo: function () {
							return !0
						},
						canRedo: function () {
							return !0
						},
						getPresentationName: function () {
							return "feature vertexes remove"
						},
						undo: function () {
							this.changeManager.undo(this.editChangeEvent);
							this.feature.deleteEditingProperties();
							this.feature.selected && this.feature.addEditProperties()
						},
						redo: function () {
							this.changeManager.redo(this.editChangeEvent);
							this.feature.deleteEditingProperties();
							this.feature.selected && this.feature.addEditProperties()
						}
					}) : this.selectedFeature.parentLayer.getUndoManager().addEdit({
						feature: c,
						changeManager: this.selectedFeature.parentLayer.changeManager,
						editChangeEvent: b,
						canUndo: function () {
							return !0
						},
						canRedo: function () {
							return !0
						},
						getPresentationName: function () {
							return "feature vertexes remove"
						},
						undo: function () {
							this.changeManager.undo(this.editChangeEvent)
						},
						redo: function () {
							this.changeManager.redo(this.editChangeEvent)
						}
					}))
			}
		},
		processRectangle: function () {
			if (a.notNull(this._geometry)) {
				var b = [],
				c = {},
				h = {
					x: this._geometry.getMinX(),
					y: this._geometry.getMinY(),
					w: this._geometry.getWidth(),
					h: this._geometry.getHeight()
				},
				h = a.edit.GeometrySegmentUtil.getLayerSnapPointsWithinBox(this.selectedFeature.parentLayer, h);
				if (a.notNull(h) && a.notNull(h[this.selectedFeature.id]))
					for (var F in h)
						if (h.hasOwnProperty(F)) {
							var Z =
								h[F];
							if (a.notNull(Z) && 0 < Z.length && (F === this.selectedFeature.id || this.selectedFeature.parentLayer.hasSharedBoundary())) {
								var ma = Z[0].getFeature().getGeometry().clone(!0);
								a.edit.GeometrySegmentUtil.removeVertexesFromGeometry(ma, Z) && (b.push(Z[0].getFeature()), c[F] = ma)
							}
						}
				if (a.notNull(this.selectedFeature.parentLayer.changeManager)) {
					F = a.edit.EditChangeEvent;
					1 < b.length && this.selectedFeature.parentLayer.getUndoManager().startChangeBlock("feature vertexes remove");
					for (h = 0; h < b.length; h++)
						Z = b[h], a.isNull(c[Z.id]) ||
						(ma = this.selectedFeature.parentLayer.changeManager.updateFeature(Z.id, Z, c[Z.id], F.SPATIAL_UPDATE), a.notNull(ma) && this.registerUpdate(ma, Z));
					1 < b.length && this.selectedFeature.parentLayer.getUndoManager().endChangeBlock("feature vertexes remove")
				}
				for (F = 0; F < b.length; F++)
					h = b[F], h.setGeometry(c[h.id]);
				this.selectedFeature.deleteEditingProperties();
				this.selectedFeature.addEditProperties()
			}
			this._geometry = null
		}
	});
	a.tool.SplitPolygonTool = a.tool.RedlineTool.extend({
		initialize: function T(b, c) {
			T.base.call(this,
				b, a.tool.RedlineTool.TYPE_POINT);
			var h = this;
			this.splitLineStyle = new a.style.Line({
				stroke: "#FF0000",
				strokeThickness: 5,
				strokeOpacity: .5
			});
			this.splitLineStyle.fill = b.graphics.oui.NO_PAINT;
			this.snapSegmentPoint = this.snapFeature = null;
			this.splitPoints = [];
			this.splitLines = [];
			this.currentSplitLine = [];
			this.shapeGroup = [];
			this.ghostShape = null;
			this.lastSubElem = -1;
			this.hasSplitLines = this.islastActionMoveTo = this.hasSplitLines = this.isInAction = !1;
			this.lastPointWC = [];
			this.lastScreenPoint = [];
			a.isNull(c) ? (a.util.Logger.alert("MAPVIEWER_9054",
					"OM.tool.SplitPolygonTool.initialize", ""), this.clear()) : (this.polygonFeature = c, !a.notNull(this.polygonFeature) || "Polygon" !== this.polygonFeature.getGeometry().getType() && "MultiPolygon" !== this.polygonFeature.getGeometry().getType() ? (a.util.Logger.alert("MAPVIEWER_9038", "OM.tool.SplitPolygonTool.initialize", ""), this.polygonFeature = null, this.clear()) : this.polygonFeature.editable = !1, a.gv.featureDrag = !1, a.gv.allowFeaturePointsInteraction = !1, this.addListener(a.event.ToolEvent.REDLINE_POINT_CREATE, this.processPoint),
				this.snapLayer = new a.layer.VectorLayer("snap_layer_" + Math.random(), {
					def: {
						type: a.layer.VectorLayer.TYPE_LOCAL
					}
				}), this.snapLayerStyle = new a.style.Marker({
					width: 12,
					height: 12,
					vectorDef: [{
							shape: {
								type: "rectangle",
								x: 0,
								y: 0,
								width: 10,
								height: 10
							},
							style: {
								fill: "#ffffff",
								stroke: "#ff0000",
								strokeThickness: 1
							}
						}
					]
				}), this.snapLayer.setRenderingStyle(this.snapLayerStyle), b.addLayer(this.snapLayer), this.addListener(a.event.ToolEvent.SNAP_POINT, function () {
					if (!a.isNull(h.polygonFeature)) {
						a.notNull(h.snapFeature) && (h.snapLayer.removeFeature(h.snapFeature),
							h.snapLayer.redraw(), h.snapFeature = null);
						h.snapPoint = null;
						var b = h._map.getScreenPointLocation(h._map.mLocX, h._map.mLocY);
						if (a.notNull(b)) {
							var c = h._map.getScreenPointLocation(h._map.mLocX - 3, h._map.mLocY - 3),
							F = b.coordinates[0] - c.coordinates[0],
							c = c.coordinates[1] - b.coordinates[1],
							F = Math.sqrt(F * F + c * c),
							c = [b.coordinates[0], b.coordinates[1]],
							J = null;
							a.notNull(h.polygonFeature.parentLayer) && (J = h.polygonFeature.parentLayer.segmentRtree[h.polygonFeature.id], a.isNull(J) && (J = a.edit.GeometrySegmentUtil.buildSegmentTree(h.polygonFeature),
									a.notNull(J) && (h.polygonFeature.parentLayer.segmentRtree[h.polygonFeature.id] = J)));
							F = a.edit.GeometrySegmentUtil.getFeatureSnapPoint(h.polygonFeature, J, c, F, !1, !1, !1, !1);
							h.snapSegmentPoint = null;
							if (a.notNull(F)) {
								J = F.getGeometrySegment();
								c = J.getSubElementIndex();
								J = J.getSegmentIndex();
								if (0 === h.splitPoints.length) {
									if (0 !== c)
										return
								} else {
									if (1 === h.splitPoints.length && 1 === this.currentSplitLine.length && 0 === this.splitLines.length && h.splitPoints[0].getGeometrySegment().getSegmentIndex() === J)
										return;
									if (1 < h.splitPoints.length)
										if (J =
												h.splitPoints[h.splitPoints.length - 1].getGeometrySegment().getSubElementIndex(), 0 === h.splitPoints.length % 2) {
											if (J !== c)
												return
										} else if (J === c)
											return
								}
								h.snapSegmentPoint = F;
								F = F.getPoint();
								b = new a.geometry.Point(F[0], F[1], b.getSRID());
								F = h._map.getScreenLocation(b);
								h.snapPoint = [];
								h.snapPoint.push(F.x);
								h.snapPoint.push(F.y);
								h.snapFeature = new a.Feature("SnapPoint", b, {
									renderingStyle: h.snapLayerStyle
								});
								h.snapLayer.addFeature(h.snapFeature);
								h.snapLayer.redraw()
							}
						}
						a.notNull(h.ghostShape) && (a.notNull(h.snapPoint) ?
							h._graphic.setPath(h.ghostShape, [[h.lastScreenPoint[0], h.lastScreenPoint[1], h.snapPoint[0], h.snapPoint[1]]]) : h._graphic.setPath(h.ghostShape, [[h.lastScreenPoint[0], h.lastScreenPoint[1], h._map.mLocX, h._map.mLocY]]))
					}
				}))
		},
		reset: function () {
			a.notNull(this.snapFeature) && (this.snapLayer.removeFeature(this.snapFeature), this.snapLayer.redraw(), this.snapFeature = null);
			this.snapSegmentPoint = this.snapFeature = null;
			this.splitPoints = [];
			this.splitLines = [];
			this.currentSplitLine = [];
			this.lastSubElem = -1;
			this.hasSplitLines =
				this.islastActionMoveTo = this.hasSplitLines = this.isInAction = !1;
			this.lastPointWC = [];
			this.lastScreenPoint = [];
			if (0 < this.shapeGroup.length)
				for (var b = this.shapeGroup.length - 1; -1 < b; b--)
					this._graphic.remove(this.shapeGroup[b]);
			this.shapeGroup = [];
			a.notNull(this.ghostShape) && this._graphic.remove(this.ghostShape);
			this.ghostShape = null
		},
		clear: function () {
			a.gv.featureDrag = !0;
			a.gv.allowFeaturePointsInteraction = !0;
			this.polygonFeature.editable = !0;
			this.reset();
			this.finish();
			this.clear_base()
		},
		processPoint: function () {
			this.hasSplitLines =
				!1;
			if (0 !== this.splitPoints.length || !a.isNull(this.snapSegmentPoint)) {
				var b,
				c,
				h,
				Z = this._geometry;
				b = Z.getX();
				c = Z.getY();
				if (0 === this.splitPoints.length)
					b = this.snapSegmentPoint.getPoint()[0], c = this.snapSegmentPoint.getPoint()[1], this.islastActionMoveTo = this.isInAction = !0, this.currentSplitLine = [], this.currentSplitLine.push(b), this.currentSplitLine.push(c), this.splitPoints.push(this.snapSegmentPoint), this.lastPointWC = [b, c], h = new a.geometry.Point(b, c, Z.getSRID()), h = this._map.getScreenLocation(h), this.lastScreenPoint =
						[h.x, h.y], this.ghostShape = this._graphic.drawPath([[h.x, h.y, h.x, h.y]], this.splitLineStyle, {
							group: this._group
						}), this.ghostShape.setStrokeDashArray([6]);
				else {
					var ma = !0;
					1 < this.splitPoints.length && a.notNull(this.snapSegmentPoint) && 0 === this.splitPoints.length % 2 && this.splitPoints[this.splitPoints.length - 1].getGeometrySegment().getSubElementIndex() == this.snapSegmentPoint.getGeometrySegment().getSubElementIndex() && (ma = !1);
					a.notNull(this.snapSegmentPoint) && (b = this.snapSegmentPoint.getPoint()[0], c = this.snapSegmentPoint.getPoint()[1]);
					h = new a.geometry.Point(b, c, Z.getSRID());
					h = this._map.getScreenLocation(h);
					this.lastScreenPoint = [h.x, h.y];
					if (ma) {
						this.islastActionMoveTo = !1;
						this.currentSplitLine.push(b);
						this.currentSplitLine.push(c);
						for (var ma = [], ha = 0; ha < this.currentSplitLine.length; ha += 2)
							h = new a.geometry.Point(this.currentSplitLine[ha], this.currentSplitLine[ha + 1], Z.getSRID()), h = this._map.getScreenLocation(h), ma.push(h.x), ma.push(h.y), a.isNull(this.shapeGroup[this.splitLines.length]) ? (this.shapeGroup[this.splitLines.length] = this._graphic.drawPath([ma],
										this.splitLineStyle, {
										group: this._group
									}), this.shapeGroup[this.splitLines.length].setStrokeDashArray([6])) : this._graphic.setPath(this.shapeGroup[this.splitLines.length], [ma])
					} else
						this.islastActionMoveTo = !0, this.splitLines.push(this.currentSplitLine), this.currentSplitLine = [], this.currentSplitLine.push(b), this.currentSplitLine.push(c);
					a.notNull(this.snapSegmentPoint) && (this.splitPoints.push(this.snapSegmentPoint), 1 < this.splitPoints.length && this.snapSegmentPoint.getGeometrySegment().getSubElementIndex() ==
						this.splitPoints[0].getGeometrySegment().getSubElementIndex() && (this.hasSplitLines = !0, this.splitLines.push(this.currentSplitLine)));
					this.lastPointWC = [b, c];
					this.hasSplitLines && (b = this.polygonFeature.getGeometry().clone(!0), a.edit.GeometrySegmentUtil.splitPolygonGeometry(b, this.splitPoints, this.splitLines) && (a.notNull(this.polygonFeature.parentLayer.changeManager) && (c = this.polygonFeature.parentLayer.changeManager.updateFeature(this.polygonFeature.id, this.polygonFeature, b, a.edit.EditChangeEvent.SPATIAL_UPDATE),
								a.notNull(c) && this.polygonFeature.parentLayer.getUndoManager().addEdit({
									feature: this.polygonFeature,
									changeManager: this.polygonFeature.parentLayer.changeManager,
									editChangeEvent: c,
									canUndo: function () {
										return !0
									},
									canRedo: function () {
										return !0
									},
									getPresentationName: function () {
										return "split polygon"
									},
									undo: function () {
										this.changeManager.undo(this.editChangeEvent);
										this.feature.deleteEditingProperties();
										this.feature.addEditProperties()
									},
									redo: function () {
										this.changeManager.redo(this.editChangeEvent);
										this.feature.deleteEditingProperties();
										this.feature.addEditProperties()
									}
								})), this.polygonFeature.deleteEditingProperties(), this.polygonFeature.addEditProperties(), this.polygonFeature.setGeometry(b)), this.reset())
				}
				this._map.getToolFeatureLayer().removeFeature(this._points[0])
			}
		}
	});
	a.tool.VoidPolygonTool = a.tool.RedlineTool.extend({
		initialize: function J(b, c) {
			J.base.call(this, b, a.tool.RedlineTool.TYPE_POLYGON);
			a.isNull(c) ? (a.util.Logger.alert("MAPVIEWER_9054", "OM.tool.VoidPolygonTool.initialize", ""), this.clear()) : (this.polygonFeature = c, this.polygonElement =
					-1, !a.notNull(this.polygonFeature) || "Polygon" !== this.polygonFeature.getGeometry().getType() && "MultiPolygon" !== this.polygonFeature.getGeometry().getType() ? (a.util.Logger.alert("MAPVIEWER_9038", "OM.tool.VoidPolygonTool.initialize", ""), this.polygonFeature = null, this.clear()) : this.polygonFeature.editable = !1)
		},
		end: function () {
			this.polygonElement = -1;
			if (!a.isNull(this._geometry) && !a.isNull(this.polygonFeature)) {
				var b = this._geometry.getOrdinates()[0],
				c = b[0],
				h = b[1],
				ma = this.polygonFeature.getGeometry().getDimension();
				if ("Polygon" === this.polygonFeature.getGeometry().getType())
					this.polygonElement = 0;
				else
					for (var ha = this.polygonFeature.getGeometry(), ra = ha.getOrdinates().length, Ba = 0; Ba < ra; Ba++) {
						var Ia = new a.geometry.Polygon(ha.getOrdinates()[Ba][0], this.polygonFeature.getGeometry().getSRID(), ma);
						if (a.util.GeomUtil.poinInPolygonGeometry(Ia, c, h)) {
							this.polygonElement = Ba;
							break
						}
					}
				if (-1 !== this.polygonElement) {
					ha = a.util.GeomUtil.isClockwise(b);
					c = this.polygonFeature.getGeometry().clone(!0);
					h = null;
					h = "Polygon" === this.polygonFeature.getGeometry().getType() ?
						c.getOrdinates() : c.getOrdinates()[this.polygonElement];
					if ((ra = a.util.GeomUtil.isClockwise(h[0], ma)) && ha || !ra && !ha)
						b = a.util.GeomUtil.reverseCoordinates(b);
					ha = [];
					if (2 < ma) {
						for (ra = 0; ra < b.length; ra += 2)
							for (ha.push(b[ra]), ha.push(b[ra + 1]), Ba = 2; Ba < ma; Ba++)
								ha.push(0);
						b = ha
					}
					h[h.length] = b;
					a.notNull(this.polygonFeature.parentLayer.changeManager) && (b = this.polygonFeature.parentLayer.changeManager.updateFeature(this.polygonFeature.id, this.polygonFeature, c, a.edit.EditChangeEvent.SPATIAL_UPDATE), a.notNull(b) && this.polygonFeature.parentLayer.getUndoManager().addEdit({
							feature: this.polygonFeature,
							changeManager: this.polygonFeature.parentLayer.changeManager,
							editChangeEvent: b,
							canUndo: function () {
								return !0
							},
							canRedo: function () {
								return !0
							},
							getPresentationName: function () {
								return "add void polygon"
							},
							undo: function () {
								this.changeManager.undo(this.editChangeEvent);
								this.feature.deleteEditingProperties();
								this.feature.selected && this.feature.addEditProperties()
							},
							redo: function () {
								this.changeManager.redo(this.editChangeEvent);
								this.feature.deleteEditingProperties();
								this.feature.selected && this.feature.addEditProperties()
							}
						}));
					this.polygonFeature.editable = !0;
					this.polygonFeature.deleteEditingProperties();
					this.polygonFeature.addEditProperties();
					this.polygonFeature.setGeometry(c);
					this.polygonFeature.parentLayer.selectFeature(this.polygonFeature)
				}
			}
		}
	});
	a.tool.WhiteBoardTool = a.tool.Tool.extend({
		initialize: function F(b) {
			F.base.call(this, b);
			var c = b.mapInstanceId;
			if (!b.$dialog) {
				var h = a.tool.WhiteBoardTool,
				ra;
				if (a.browser.touchSupported || a.gv.isWin8Touch)
					ra = "\x3ctr\x3e\x3ctd\x3e" + a.gv.getLabel("MAPVIEWER_WB_TEXT") + "\x3c/td\x3e\x3ctd\x3e\x3cinput type\x3d'text' size\x3d'25' id\x3d'_wb_text" +
						c + "'\x3e\x3c/td\x3e\x3ctd\x3e" + h.genSizes() + "\x3c/td\x3e\x3c/tr\x3e", b.$dialog = a.$('\x3cdiv id\x3d"_wb_dialog' + b.mapInstanceId + '" title\x3d"' + a.gv.getLabel("MAPVIEWER_WB_TTILE") + '" style\x3d"overflow:visible"\x3e\x3ctable width\x3d100%\x3e' + ra + "\x3c/table\x3e\x3c/div\x3e");
				else {
					ra = "\x3ctr\x3e\x3ctd\x3e\x3ctable\x3e\x3ctr\x3e\x3ctd\x3e" + a.gv.getLabel("MAPVIEWER_WB_TEXT") + "\x3c/td\x3e\x3ctd\x3e\x3cinput type\x3d'text' style\x3d'width:400px'  id\x3d'_wb_text" + c + "'\x3e\x3c/td\x3e\x3c/tr\x3e\x3c/table\x3e\x3c/td\x3e\x3c/tr\x3e";
					var Ba = "\x3ctr\x3e\x3ctd\x3e\x3ctable\x3e\x3ctr\x3e\x3ctd\x3e" + a.gv.getLabel("MAPVIEWER_WB_X", !0) + "\x3c/td\x3e\x3ctd\x3e\x3cinput type\x3d'text' style\x3d'width:100px' value\x3d'1' id\x3d'_wb_orienx" + c + "'\x3e\x3c/td\x3e\x3ctd\x3e\x26nbsp;\x26nbsp;" + a.gv.getLabel("MAPVIEWER_WB_Y", !0) + "\x3c/td\x3e\x3ctd\x3e\x3cinput type\x3d'text' style\x3d'width:100px' value\x3d'0' id\x3d'_wb_orieny" + c + "'\x3e\x3c/td\x3e\x3c/tr\x3e\x3c/table\x3e\x3c/td\x3e\x3c/tr\x3e";
					b.weightBut = new a.tool.ImageButton("_wb_weight" +
							c, {
							toolTip: a.gv.getLabel("MAPVIEWER_WB_BOLD"),
							buttonEnableIcon: a.tool.WhiteBoardTool.img_bold_ena,
							buttonOverIcon: a.tool.WhiteBoardTool.img_bold_ovr,
							buttonDownIcon: a.tool.WhiteBoardTool.img_bold_dwn
						});
					b.styleBut = new a.tool.ImageButton("_wb_style" + c, {
						toolTip: a.gv.getLabel("MAPVIEWER_WB_ITALIC"),
						buttonEnableIcon: a.tool.WhiteBoardTool.img_italic_ena,
						buttonOverIcon: a.tool.WhiteBoardTool.img_italic_ovr,
						buttonDownIcon: a.tool.WhiteBoardTool.img_italic_dwn
					});
					b.hAlignGroup = new a.tool.ButtonGroup;
					var Ia = new a.tool.ImageButton("_wb_halign_left" +
							c, {
							toolTip: a.gv.getLabel("MAPVIEWER_WB_ALIGN_LEFT"),
							buttonEnableIcon: a.tool.WhiteBoardTool.img_leftalign_ena,
							buttonOverIcon: a.tool.WhiteBoardTool.img_leftalign_ovr,
							buttonDownIcon: a.tool.WhiteBoardTool.img_leftalign_dwn
						}),
					Va = new a.tool.ImageButton("_wb_halign_center" + c, {
						toolTip: a.gv.getLabel("MAPVIEWER_WB_ALIGN_CENTER"),
						buttonEnableIcon: a.tool.WhiteBoardTool.img_centeralign_ena,
						buttonOverIcon: a.tool.WhiteBoardTool.img_centeralign_ovr,
						buttonDownIcon: a.tool.WhiteBoardTool.img_centeralign_dwn,
						status: a.tool.ImageButton.STATUS_DOWN
					}),
					Ra = new a.tool.ImageButton("_wb_halign_right" + c, {
						toolTip: a.gv.getLabel("MAPVIEWER_WB_ALIGN_RIGHT"),
						buttonEnableIcon: a.tool.WhiteBoardTool.img_rightalign_ena,
						buttonOverIcon: a.tool.WhiteBoardTool.img_rightalign_ovr,
						buttonDownIcon: a.tool.WhiteBoardTool.img_rightalign_dwn
					});
					b.hAlignGroup.addButton(Ia);
					b.hAlignGroup.addButton(Va);
					b.hAlignGroup.addButton(Ra);
					b.vAlignGroup = new a.tool.ButtonGroup;
					Ia = new a.tool.ImageButton("_wb_valign_bottom" + c, {
						toolTip: a.gv.getLabel("MAPVIEWER_WB_VALIGN_BOTTOM"),
						buttonEnableIcon: a.tool.WhiteBoardTool.img_bottomalign_ena,
						buttonOverIcon: a.tool.WhiteBoardTool.img_bottomalign_ovr,
						buttonDownIcon: a.tool.WhiteBoardTool.img_bottomalign_dwn
					});
					Va = new a.tool.ImageButton("_wb_valign_center" + c, {
						toolTip: a.gv.getLabel("MAPVIEWER_WB_VALIGN_CENTER"),
						buttonEnableIcon: a.tool.WhiteBoardTool.img_centervalign_ena,
						buttonOverIcon: a.tool.WhiteBoardTool.img_centervalign_ovr,
						buttonDownIcon: a.tool.WhiteBoardTool.img_centervalign_dwn,
						status: a.tool.ImageButton.STATUS_DOWN
					});
					Ra = new a.tool.ImageButton("_wb_valign_top" + c, {
						toolTip: a.gv.getLabel("MAPVIEWER_WB_VALIGN_TOP"),
						buttonEnableIcon: a.tool.WhiteBoardTool.img_topalign_ena,
						buttonOverIcon: a.tool.WhiteBoardTool.img_topalign_ovr,
						buttonDownIcon: a.tool.WhiteBoardTool.img_topalign_dwn
					});
					b.vAlignGroup.addButton(Ra);
					b.vAlignGroup.addButton(Va);
					b.vAlignGroup.addButton(Ia);
					Ia = "\x3ctr\x3e\x3ctd\x3e\x3ctable\x3e\x3ctr\x3e\x3ctd\x3e" + h.genColor(c) + "\x3c/td\x3e\x3ctd\x3e";
					Ia += b.weightBut.createHTML() + "\x3c/td\x3e\x3ctd\x3e" + b.styleBut.createHTML();
					Ia += "\x3c/td\x3e\x3ctd\x3e" + b.hAlignGroup.createHTML() + "\x3c/td\x3e\x3ctd\x3e" +
					b.vAlignGroup.createHTML() + "\x3c/td\x3e\x3ctd\x3e";
					Ia += h.genFontFamily(c) + "\x3c/td\x3e\x3ctd\x3e" + h.genSizes() + "\x3c/td\x3e\x3c/tr\x3e\x3c/table\x3e\x3c/td\x3e\x3c/tr\x3e";
					b.$dialog = a.$('\x3cdiv id\x3d"_wb_dialog' + b.mapInstanceId + '" title\x3d"' + a.gv.getLabel("MAPVIEWER_WB_TTILE") + '" style\x3d"overflow:visible"\x3e\x3ctable width\x3d100% cellSpacing\x3d0 borderSpacing\x3d0 style\x3d\'font-size:13px\'\x3e' + ra + Ba + Ia + "\x3c/table\x3e\x3c/div\x3e")
				}
			}
			var db = null,
			fb = null,
			kb = null,
			Ab = null,
			Ya = this;
			this.allTextFeatures =
				[];
			this.downEventAction = function (b) {
				if (2 === b.button)
					Ya.finish();
				else if ("touchstart" === b.type) {
					var c = a.util.DomUtil;
					1 === c.getTouchCount(b) && (b = c.getTouchesPosition(b), db = b.x, kb = b.y)
				} else
					db = b.pageX, kb = b.pageY
			};
			this.newShapePoint = function (h) {
				var F = Ya._map.getToolFeatureLayer();
				if (!F.focusFeature && Ya.status !== a.tool.Tool.STOPPED && Ya._map.currentTool === Ya) {
					var ha = null,
					ra = null;
					if ("touchend" === h.type)
						if (ha = a.util.DomUtil, 1 === ha.getTouchCount(h))
							ra = ha.getChangedTouchesPosition(h), ha = ra[0].x, ra = ra[0].y;
						else
							return;
					else
						ha = h.pageX, ra = h.pageY;
					if (2 > Math.abs(ha - db) && ha != fb && 2 > Math.abs(ra - kb) && ra != Ab) {
						Ya._graphic.getLeftTop(Ya._map.draggableGroup);
						Ya._$container.offset();
						Ya._$container.offset();
						h = Ya._map.getCursorLocation();
						Ya.currentPoint = null;
						a.tool.WhiteBoardTool.showDialog(b, Ya);
						var Ba = 1,
						Ia = 0;
						a.browser.touchSupported || a.gv.isWin8Touch || (Ba = parseFloat(a.$("#_wb_orienx" + c).val()), Ia = parseFloat(a.$("#_wb_orieny" + c).val()), isNaN(Ba) && (Ba = 1), isNaN(Ia) && (Ia = 0));
						Ya.currentPoint = new a.geometry.Point(h.getX(),
								h.getY(), h.srid, Ba, Ia);
						Ya.toolFeature && F.removeFeature(Ya.toolFeature);
						Ya.textFeature && (h = Ya.textFeature, h.saved ? (h.editable ? h.parentLayer.deselectFeature(h) : h.old && (h.setText(h.old.text), h.setRenderingStyle(h.old.style)), h = null, Ya.textFeature = null) : F.removeFeature(h));
						Ya.toolFeature = new a.Feature("_wb_point_" + (new Date).getTime(), Ya.currentPoint, {
							renderingStyle: a.tool.WhiteBoardTool.pointStyle
						});
						a.browser.touchSupported || a.gv.isWin8Touch || (Ya.toolFeature.addListener(a.event.LayerEvent.FEATURE_ORIENTATION_CHANGING,
								function (b) {
								var h = b.angle;
								b = h <= Math.PI / 2 && h >= -Math.PI / 2 ? 1 : -1;
								h = Math.tan(h) * b;
								a.$("#_wb_orienx" + c).val(b);
								a.$("#_wb_orieny" + c).val(h)
							}), Ya.addEventLisenterButtons());
						F.addFeature(Ya.toolFeature);
						F.selectFeature(Ya.toolFeature);
						Ya.toolFeature.tool = Ya
					}
					fb = ha;
					Ab = ra
				}
			}
		},
		start: function () {
			var b = a.event.ToolEvent;
			this.clear();
			a.browser.touchSupported ? (this._$container.bind("touchstart", this.downEventAction), this._$container.bind("touchend", this.newShapePoint)) : (this._$container.bind("mousedown", this.downEventAction),
				this._$container.bind("click", this.newShapePoint));
			this.status = a.tool.Tool.STARTED;
			this._map.currentTool = this;
			b = new b(b.TOOL_START, this);
			this.fire(b.type, b);
			return this
		},
		clear: function () {
			this.clearAll()
		},
		finish: function () {
			this._$container.unbind("mousedown", this.downEventAction);
			this._$container.unbind("click", this.newShapePoint);
			this._$container.unbind("touchstart", this.downEventAction);
			this._$container.unbind("touchend", this.newShapePoint);
			var a = this._map.getToolFeatureLayer();
			this.toolFeature &&
			a.removeFeature(this.toolFeature);
			this.toolFeature = null;
			this._map.$dialog.dialog("isOpen") && this._map.$dialog.dialog("close");
			for (var a = this.allTextFeatures.length, b = 0; b < a; b++)
				this.allTextFeatures[b].enableEditing = null;
			return this
		},
		clearAll: function () {
			for (var a = this._map.getToolFeatureLayer(), b = this.allTextFeatures.length - 1; 0 <= b; b--) {
				var c = this.allTextFeatures.pop();
				a.removeFeature(c);
				a.refresh()
			}
		},
		getTextStyle: function () {
			var b;
			if (a.browser.touchSupported || a.gv.isWin8Touch)
				b = {
					fontSize: a.tool.WhiteBoardTool.currentSize
				};
			else {
				var c = this._map.mapInstanceId;
				b = a.$("#_wb_weight" + c)[0].down ? "BOLD" : "NORMAL";
				var h = a.$("#_wb_style" + c)[0].down ? "ITALIC" : "NORMAL",
				ha = a.$("#_wb_valign_bottom" + c)[0].down ? "BOTTOM" : a.$("#_wb_valign_top" + c)[0].down ? "TOP" : "CENTERV",
				c = a.$("#_wb_halign_left" + c)[0].down ? "LFET" : a.$("#_wb_halign_right" + c)[0].down ? "RIGHT" : "CENTER",
				ra = a.tool.WhiteBoardTool;
				b = {
					fontFamily: ra.currentFontFamily,
					fontSize: ra.currentSize,
					fill: ra.currentColor,
					fontWeight: b,
					fontStyle: h,
					vAlign: ha,
					hAlign: c
				}
			}
			return new a.style.Text(b)
		},
		addText: function (b) {
			var c = a.$("#_wb_text" + this._map.mapInstanceId).val(),
			h = this.getTextStyle(),
			ha = this._map.getToolFeatureLayer();
			this.textFeature !== this.toolFeature && ha.removeFeature(this.toolFeature);
			if (this.textFeature) {
				var ra = this.textFeature;
				ra.old || (ra.old = {
						text: this.textFeature.getText(),
						style: this.textFeature.getRenderingStyle(),
						point: this.textFeature.getGeometry()
					});
				ra.setText(c);
				ra.setRenderingStyle(h);
				ra.screenPoints = null;
				ra.setGeometry(b);
				ha.deselectFeature(ra)
			} else
				ra = "_wb_textfeature_" +
					(new Date).getTime(), this.toolFeature = new a.TextFeature(ra, b, c, h), this.toolFeature.tool = this, ha.addFeature(this.toolFeature)
		},
		addEventLisenterButtons: function () {
			this._map.hAlignGroup.attachEvents();
			this._map.vAlignGroup.attachEvents();
			this._map.weightBut.attachEvents();
			this._map.styleBut.attachEvents()
		},
		getAllTextFeatures: function () {
			return this.allTextFeatures
		},
		saveToLS: function (b) {
			if (!localStorage)
				a.util.Logger.alert("MAPVIEWER_9041", "OM.tool.WhiteBoardTool.saveToLS");
			else if (!a.isNull(b) && "" !==
				b) {
				var c = this.getAllTextFeatures(),
				h = c ? c.length : 0;
				if (0 !== h) {
					for (var ha = [], ra = 0; ra < h; ra++)
						ha.push(c[ra].toJSON());
					localStorage[b] = JSON.stringify(ha)
				}
			}
		}
	});
	a.tool.WhiteBoardTool.pointStyle = new a.style.Marker({
		width: 20,
		height: 20,
		vectorDef: [{
				shape: {
					type: "path",
					coords: [[0, 7, 0, 13, 10, 13, 10, 20, 20, 10, 10, 0, 10, 7, 0, 7]],
					width: 20,
					height: 20
				},
				style: {
					fill: "#ffffff",
					stroke: "#0000ff",
					strokeThickness: 1
				}
			}
		]
	});
	a.tool.WhiteBoardTool.textFeatureIdSeq = 0;
	a.tool.WhiteBoardTool.fontFamilyArray = "Arial;Bookman Old Style;Courier New;Garamond;Lucida Console;Symbol;Tahoma;Times New Roman;Verdana".split(";");
	a.tool.WhiteBoardTool.currentFontFamily = "Arial";
	a.tool.WhiteBoardTool.genFontFamily = function (b) {
		b = '\x3cselect id\x3d"_wb_fontfamily' + b + '" onchange\x3d"OM.tool.WhiteBoardTool.setFontFamily(' + b + ')"\x3e';
		for (var c = "", h = a.tool.WhiteBoardTool.fontFamilyArray.length, ha = 0; ha < h; ha++)
			c = a.tool.WhiteBoardTool.fontFamilyArray[ha] == a.tool.WhiteBoardTool.currentFontFamily ? "selected\x3dtrue" : "", b += "\x3coption " + c + ' value\x3d"' + a.tool.WhiteBoardTool.fontFamilyArray[ha] + '"\x3e' + a.tool.WhiteBoardTool.fontFamilyArray[ha] +
			"\x3c/option\x3e";
		return b + "\x3c/select\x3e"
	};
	a.tool.WhiteBoardTool.setFontFamily = function (b) {
		b = a.$("#_wb_fontfamily" + b).val();
		a.tool.WhiteBoardTool.currentFontFamily = b
	};
	a.tool.WhiteBoardTool.addFont = function (b) {
		for (var c = MVAnnotationTool.fontFamilyArray.length - 1, h = 0; h < c; h++) {
			if (a.tool.WhiteBoardTool.fontFamilyArray[h] == b)
				return;
			if (a.tool.WhiteBoardTool.fontFamilyArray[h] < b && a.tool.WhiteBoardTool.fontFamilyArray[h + 1] > b) {
				a.tool.WhiteBoardTool.fontFamilyArray.splice(h + 1, 0, b);
				return
			}
		}
		a.tool.WhiteBoardTool.fontFamilyArray.push(b)
	};
	a.tool.WhiteBoardTool.removeFont = function (b) {
		for (var c = a.tool.WhiteBoardTool.fontFamilyArray.length - 1, h = 0; h < c; h++)
			if (a.tool.WhiteBoardTool.fontFamilyArray[h] == b) {
				a.tool.WhiteBoardTool.fontFamilyArray.splice(h, 1);
				break
			}
	};
	a.tool.WhiteBoardTool.genSizes = function (b) {
		b = '\x3cselect id\x3d"_wb_fontsize' + b + '" onchange\x3d"OM.tool.WhiteBoardTool.setSize(' + b + ')"\x3e';
		for (var c = "", h = 5; 50 > h; h++)
			c = h == a.tool.WhiteBoardTool.currentSize ? "selected\x3dtrue" : "", b += "\x3coption " + c + ' value\x3d"' + h + 'px"\x3e' + h + "px\x3c/option\x3e";
		return b + "\x3c/select\x3e"
	};
	a.tool.WhiteBoardTool.setSize = function (b) {
		b = a.$("#_wb_fontsize" + b).val();
		a.tool.WhiteBoardTool.currentSize = parseInt(b, 10)
	};
	a.tool.WhiteBoardTool.genColor = function (b) {
		var c = a.tool.WhiteBoardTool;
		b = '\x3cdiv id\x3d"_wb_color' + b + '" style\x3d"background: url(\'' + c.color_picker_icon + "') ";
		return b = b + "repeat scroll center center transparent; height: 16px;left: 4px;top: 4px;width: 16px;background-color: " + (c.currentColor + '"\x3e\x3c/div\x3e')
	};
	a.tool.WhiteBoardTool.showDialog = function (b,
		c, h) {
		var ha = c._map.getToolFeatureLayer();
		h && (c.textFeature = h, h.addListener(a.event.LayerEvent.FEATURE_ORIENTATION_CHANGING, function (b) {
				var h = b.angle;
				b = h <= Math.PI / 2 && h >= -Math.PI / 2 ? 1 : -1;
				h = Math.tan(h) * b;
				a.$("#_wb_orienx" + c._map.mapInstanceId).val(b);
				a.$("#_wb_orieny" + c._map.mapInstanceId).val(h)
			}), c.currentPoint = h.getGeometry().clone(), c.textFeature !== c.toolFeature && ha.removeFeature(c.toolFeature));
		b.$dialog.dialog({
			position: {
				of: b.$oracleMapDiv,
				at: "center"
			},
			resizable: !1,
			width: a.browser.touchSupported ||
			a.gv.isWin8Touch ? 450 : 510,
			height: a.browser.touchSupported || a.gv.isWin8Touch ? 190 : 230,
			buttons: [{
					closeOnEscape: !0,
					text: a.gv.getLabel("MAPVIEWER_WB_OK"),
					click: function () {
						if (h) {
							var ra = a.$("#_wb_text" + b.mapInstanceId).val();
							h.setText(ra);
							ra = c.getTextStyle();
							h.setRenderingStyle(ra);
							h.screenPoints = null;
							h.setGeometry(c.currentPoint);
							ha.deselectFeature(h);
							h.old = null;
							c.toolFeature = null;
							c.textFeature = null
						} else
							c.addText(c.currentPoint), c.toolFeature.tool = c, c.toolFeature.saved = !0, c.allTextFeatures.push(c.toolFeature),
							c.toolFeature.old = null, c.toolFeature = null;
						a.$(this).dialog("close")
					}
				}, {
					text: a.gv.getLabel("MAPVIEWER_WB_PREVIEW"),
					click: function () {
						c.addText(c.currentPoint)
					}
				}
			],
			close: function (a, b) {
				c.currentEditingFeature = null;
				c.toolFeature && ha.removeFeature(c.toolFeature);
				h && (h.old && (h.setText(h.old.text), h.setRenderingStyle(h.old.style), h.setGeometry(h.old.point)), h.parentLayer && h.parentLayer.deselectFeature(h));
				c.toolFeature = null;
				c.textFeature = null
			}
		});
		a.browser.touchSupported || a.gv.isWin8Touch || (b.$dialog.parent().draggable("option",
				"containment", b.$oracleMapDiv), a.$("#_wb_color" + b.mapInstanceId).ColorPicker({
				color: "#000000",
				onShow: function (b) {
					a.$(b).fadeIn(500);
					return !1
				},
				onHide: function (b) {
					a.$(b).fadeOut(500);
					return !1
				},
				onChange: function (c, h, Z) {
					a.$("#_wb_color" + b.mapInstanceId).css("backgroundColor", "#" + h);
					a.tool.WhiteBoardTool.currentColor = "#" + h
				},
				onSubmit: function (b, c, h, F) {
					a.tool.WhiteBoardTool.currentColor = "#" + c;
					a.$(F).ColorPickerHide()
				}
			}));
		h ? a.$("#_wb_text" + b.mapInstanceId).val(h.getText()) : a.$("#_wb_text" + b.mapInstanceId).val("")
	};
	a.tool.WhiteBoardTool.currentSize = 15;
	a.tool.WhiteBoardTool.currentColor = "#000000";
	a.tool.WhiteBoardTool.setIconsPath = function () {
		var b = a.gv.resourcePath() + "txt/",
		c = a.tool.WhiteBoardTool;
		c.color_picker_icon = b + "func_text_color_16_ena.png";
		c.img_bold_ena = b + "func_bold_16_ena.png";
		c.img_bold_ovr = b + "func_bold_16_hov.png";
		c.img_bold_dwn = b + "func_bold_16_act.png";
		c.img_italic_ena = b + "func_italic_16_ena.png";
		c.img_italic_ovr = b + "func_italic_16_hov.png";
		c.img_italic_dwn = b + "func_italic_16_act.png";
		c.img_leftalign_ena =
			b + "func_leftalign_16_ena.png";
		c.img_leftalign_ovr = b + "func_leftalign_16_hov.png";
		c.img_leftalign_dwn = b + "func_leftalign_16_act.png";
		c.img_centeralign_ena = b + "func_centeralign_16_ena.png";
		c.img_centeralign_ovr = b + "func_centeralign_16_hov.png";
		c.img_centeralign_dwn = b + "func_centeralign_16_act.png";
		c.img_rightalign_ena = b + "func_rightalign_16_ena.png";
		c.img_rightalign_ovr = b + "func_rightalign_16_hov.png";
		c.img_rightalign_dwn = b + "func_rightalign_16_act.png";
		c.img_bottomalign_ena = b + "bottomalignment_ena.png";
		c.img_bottomalign_ovr =
			b + "bottomalignment_ovr.png";
		c.img_bottomalign_dwn = b + "bottomalignment_dwn.png";
		c.img_centervalign_ena = b + "centeralignment_ena.png";
		c.img_centervalign_ovr = b + "centeralignment_ovr.png";
		c.img_centervalign_dwn = b + "centeralignment_dwn.png";
		c.img_topalign_ena = b + "topalignment_ena.png";
		c.img_topalign_ovr = b + "topalignment_ovr.png";
		c.img_topalign_dwn = b + "topalignment_dwn.png"
	};
	a.tool.WhiteBoardTool.setIconsPath();
	a.tool.WhiteBoardTool.loadFromLS = function (b) {
		if (!localStorage)
			a.util.Logger.alert("MAPVIEWER_9041", "OM.tool.WhiteBoardTool.loadFromLS");
		else if (!a.isNull(b) && "" !== b && (b = localStorage[b], !a.isNull(b) && "" !== b && (b = a.$.parseJSON(b), b.length))) {
			for (var c = [], h = 0, ha = b.length; h < ha; h++) {
				var ra = b[h],
				Ba = a.geometry.Geometry.createGeometry(ra.geometry, ra.geometry.srid),
				Ia = new a.style.Text(ra.styleConfig),
				ra = new a.TextFeature(ra.id, Ba, b[h].text, Ia);
				c.push(ra)
			}
			return c
		}
	};
	a.tool.DuplicateTool = a.tool.Tool.extend({
		initialize: function Z(b, c) {
			Z.base.call(this, b);
			var h = this;
			this.feature = c;
			a.isNull(c) ? (a.util.Logger.alert("MAPVIEWER_9054", "OM.tool.DuplicateTool.initialize",
					""), this.clear()) : (this.mouseDown = function (a) {
				a.stopPropagation()
			}, this.mouseUp = function (c) {
				if (!(a.isNull(c) || h.status === a.tool.Tool.STOPPED || h.status === a.tool.Tool.FINISHED || a.isNull(h.feature) || a.isNull(h.feature.getGeometry()) || a.isNull(h.feature.parentLayer) || a.isNull(h.feature.parentLayer.changeManager))) {
					c = h.feature.getGeometry();
					var Z = c.getMBR();
					if (!a.isNull(Z)) {
						var ha = b.getScreenPointLocation(h._map.mLocX, h._map.mLocY),
						Ra = Z.getCenter(),
						Z = ha.coordinates[0] - Ra.coordinates[0],
						ha = ha.coordinates[1] -
							Ra.coordinates[1];
						c = c.clone(!0);
						a.util.GeomUtil.moveGeometry(c, Z, ha) && (Z = new a.Feature("dup_" + Math.floor(1E4 * Math.random() + 1).toString(), c), c = h.feature.parentLayer, Z = c.changeManager.addFeature(Z.id, Z), a.notNull(Z) && c.getUndoManager().addEdit({
								changeManager: c.changeManager,
								editChangeEvent: Z,
								canUndo: function () {
									return !0
								},
								canRedo: function () {
									return !0
								},
								getPresentationName: function () {
									return "feature added"
								},
								undo: function () {
									this.changeManager.undo(this.editChangeEvent)
								},
								redo: function () {
									this.changeManager.redo(this.editChangeEvent)
								}
							}));
						c = new a.event.ToolEvent(a.event.ToolEvent.TOOL_END, h);
						h.fire(c.type, c)
					}
				}
			}, this.touchStart = function (b) {
				var c = a.util.DomUtil,
				Z = c.getTouchCount(b);
				if (1 == Z)
					b.button = 0, c = c.getTouchesPosition(b), h.touchPos = c, b.pageX = c.x, b.pageY = c.y;
				else if (2 == Z)
					b.button = 2;
				else
					return;
				h.mouseDown(b)
			}, this.touchEnd = function (a) {
				h.touchPos && (a.pageX = h.touchPos.x, a.pageY = h.touchPos.y, h.mouseUp(a))
			}, this.finish = function () {
				h.status == a.tool.Tool.STARTED && (h._$container.unbind("mouseup", h.mouseUp), h._$container.unbind("mousedown",
						h.mouseDown), a.gv.isWin8Touch && (h._$container[0].removeEventListener("MSPointerUp", h.mouseUp), h._$container[0].removeEventListener("MSPointerDown", h.mouseDown)), a.browser.touchSupported && (h._$container.unbind("touchstart", h.touchStart), h._$container.unbind("touchend", h.touchEnd)), h.status = a.tool.Tool.FINISHED, h._map.enableMapAction.dbclick = !0, h._map.enableMapAction.mouse = !0, h._map.enableMapDrag(!0))
			})
		},
		start: function () {
			var b = a.event.ToolEvent;
			this.clear();
			this._map.enableMapAction.dbclick = !1;
			this._map.enableMapAction.mouse =
				!1;
			this._group || (this._group = this._graphic.createGroup(), this._graphic.addGroup(this._group, this._map.draggableGroup));
			this._map.on(a.event.MapEvent.MAP_BEFORE_ZOOM, this.zoomAction, this);
			this._$container.bind("mouseup", this.mouseUp);
			this._$container.bind("mousedown", this.mouseDown);
			a.gv.isWin8Touch && (this._$container[0].addEventListener("MSPointerUp", this.mouseUp), this._$container[0].addEventListener("MSPointerDown", this.mouseDown));
			a.browser.touchSupported && (this._$container.bind("touchstart", this.touchStart),
				this._$container.bind("touchend", this.touchEnd));
			this.status = a.tool.Tool.STARTED;
			this.fire(b.type, b);
			return this
		},
		end: function () {},
		clear: function () {
			this.finish();
			this.clear_base()
		}
	});
	h.OM = a
})(window);
